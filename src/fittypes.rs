use std::collections::HashMap;
use std::fmt;
use std::rc::Rc;

use fitparsers::{
    parse_byte_as_bytes, parse_enum, parse_uint16, parse_uint16_as_bytes, parse_uint32,
    parse_uint32_as_bytes, parse_uint32z, parse_uint8, parse_uint8_as_bytes, parse_uint8z,
};
use fitparsingstate::FitParsingState;
use FitBaseValue;
use FitDefinitionMessage;
use FitFieldDefinition;
use FitFieldDeveloperData;
use FitFieldParseable;
use FitGlobalMesgNum;
use FitMessageUnknownToSdk;
use FitParseConfig;
use FitRecord;
use FitRecordHeader;
use {FitFieldAdjustedValue, FitFieldBasicValue};

use fittypes_utils::{FitFieldDateTime, FitFieldLocalDateTime};
use {
    fmt_developer_fields, fmt_message_field, fmt_raw_bytes, fmt_unknown_fields,
    vec_fit_field_parseable,
};
use {
    FitBool, FitByte, FitFloat32, FitFloat64, FitSint16, FitSint32, FitSint8, FitString, FitUint16,
    FitUint16z, FitUint32, FitUint32z, FitUint8, FitUint8z,
};

use BasicValue;

use errors::{Error, Result};

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFile {
    // fit base type: enum
    Device = 1,           // Read only, single file. Must be in root directory.
    Settings = 2,         // Read/write, single file. Directory=Settings
    Sport = 3,            // Read/write, multiple files, file number = sport type. Directory=Sports
    Activity = 4,         // Read/erase, multiple files. Directory=Activities
    Workout = 5,          // Read/write/erase, multiple files. Directory=Workouts
    Course = 6,           // Read/write/erase, multiple files. Directory=Courses
    Schedules = 7,        // Read/write, single file. Directory=Schedules
    Weight = 9, // Read only, single file. Circular buffer. All message definitions at start of file. Directory=Weight
    Totals = 10, // Read only, single file. Directory=Totals
    Goals = 11, // Read/write, single file. Directory=Goals
    BloodPressure = 14, // Read only. Directory=Blood Pressure
    MonitoringA = 15, // Read only. Directory=Monitoring. File number=sub type.
    ActivitySummary = 20, // Read/erase, multiple files. Directory=Activities
    MonitoringDaily = 28,
    MonitoringB = 32,      // Read only. Directory=Monitoring. File number=identifier
    Segment = 34,          // Read/write/erase. Multiple Files.  Directory=Segments
    SegmentList = 35,      // Read/write/erase. Single File.  Directory=Segments
    ExdConfiguration = 40, // Read/write/erase. Single File. Directory=Settings
    MfgRangeMin = 247,     // 0xF7 - 0xFE reserved for manufacturer specific file types
    MfgRangeMax = 254,     // 0xF7 - 0xFE reserved for manufacturer specific file types
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFile::Device => write!(f, "{}", "Device"),
            FitFieldFile::Settings => write!(f, "{}", "Settings"),
            FitFieldFile::Sport => write!(f, "{}", "Sport"),
            FitFieldFile::Activity => write!(f, "{}", "Activity"),
            FitFieldFile::Workout => write!(f, "{}", "Workout"),
            FitFieldFile::Course => write!(f, "{}", "Course"),
            FitFieldFile::Schedules => write!(f, "{}", "Schedules"),
            FitFieldFile::Weight => write!(f, "{}", "Weight"),
            FitFieldFile::Totals => write!(f, "{}", "Totals"),
            FitFieldFile::Goals => write!(f, "{}", "Goals"),
            FitFieldFile::BloodPressure => write!(f, "{}", "BloodPressure"),
            FitFieldFile::MonitoringA => write!(f, "{}", "MonitoringA"),
            FitFieldFile::ActivitySummary => write!(f, "{}", "ActivitySummary"),
            FitFieldFile::MonitoringDaily => write!(f, "{}", "MonitoringDaily"),
            FitFieldFile::MonitoringB => write!(f, "{}", "MonitoringB"),
            FitFieldFile::Segment => write!(f, "{}", "Segment"),
            FitFieldFile::SegmentList => write!(f, "{}", "SegmentList"),
            FitFieldFile::ExdConfiguration => write!(f, "{}", "ExdConfiguration"),
            FitFieldFile::MfgRangeMin => write!(f, "{}", "MfgRangeMin"),
            FitFieldFile::MfgRangeMax => write!(f, "{}", "MfgRangeMax"),
            FitFieldFile::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFile::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFile {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFile> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldFile::from(v)),
            Err(_) => Ok(FitFieldFile::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldFile);

impl From<u8> for FitFieldFile {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldFile::Device,
            2 => FitFieldFile::Settings,
            3 => FitFieldFile::Sport,
            4 => FitFieldFile::Activity,
            5 => FitFieldFile::Workout,
            6 => FitFieldFile::Course,
            7 => FitFieldFile::Schedules,
            9 => FitFieldFile::Weight,
            10 => FitFieldFile::Totals,
            11 => FitFieldFile::Goals,
            14 => FitFieldFile::BloodPressure,
            15 => FitFieldFile::MonitoringA,
            20 => FitFieldFile::ActivitySummary,
            28 => FitFieldFile::MonitoringDaily,
            32 => FitFieldFile::MonitoringB,
            34 => FitFieldFile::Segment,
            35 => FitFieldFile::SegmentList,
            40 => FitFieldFile::ExdConfiguration,
            247 => FitFieldFile::MfgRangeMin,
            254 => FitFieldFile::MfgRangeMax,
            _ => FitFieldFile::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldMesgNum {
    // fit base type: uint16
    FileId,                      // 0
    Capabilities,                // 1
    DeviceSettings,              // 2
    UserProfile,                 // 3
    HrmProfile,                  // 4
    SdmProfile,                  // 5
    BikeProfile,                 // 6
    ZonesTarget,                 // 7
    HrZone,                      // 8
    PowerZone,                   // 9
    MetZone,                     // 10
    Sport,                       // 12
    Goal,                        // 15
    Session,                     // 18
    Lap,                         // 19
    Record,                      // 20
    Event,                       // 21
    DeviceInfo,                  // 23
    Workout,                     // 26
    WorkoutStep,                 // 27
    Schedule,                    // 28
    WeightScale,                 // 30
    Course,                      // 31
    CoursePoint,                 // 32
    Totals,                      // 33
    Activity,                    // 34
    Software,                    // 35
    FileCapabilities,            // 37
    MesgCapabilities,            // 38
    FieldCapabilities,           // 39
    FileCreator,                 // 49
    BloodPressure,               // 51
    SpeedZone,                   // 53
    Monitoring,                  // 55
    TrainingFile,                // 72
    Hrv,                         // 78
    AntRx,                       // 80
    AntTx,                       // 81
    AntChannelId,                // 82
    Length,                      // 101
    MonitoringInfo,              // 103
    SlaveDevice,                 // 106
    Connectivity,                // 127
    WeatherConditions,           // 128
    WeatherAlert,                // 129
    CadenceZone,                 // 131
    Hr,                          // 132
    SegmentLap,                  // 142
    MemoGlob,                    // 145
    SegmentId,                   // 148
    SegmentLeaderboardEntry,     // 149
    SegmentPoint,                // 150
    SegmentFile,                 // 151
    WorkoutSession,              // 158
    WatchfaceSettings,           // 159
    GpsMetadata,                 // 160
    CameraEvent,                 // 161
    TimestampCorrelation,        // 162
    GyroscopeData,               // 164
    AccelerometerData,           // 165
    ThreeDSensorCalibration,     // 167
    VideoFrame,                  // 169
    ObdiiData,                   // 174
    NmeaSentence,                // 177
    AviationAttitude,            // 178
    Video,                       // 184
    VideoTitle,                  // 185
    VideoDescription,            // 186
    VideoClip,                   // 187
    OhrSettings,                 // 188
    ExdScreenConfiguration,      // 200
    ExdDataFieldConfiguration,   // 201
    ExdDataConceptConfiguration, // 202
    FieldDescription,            // 206
    DeveloperDataId,             // 207
    MagnetometerData,            // 208
    BarometerData,               // 209
    OneDSensorCalibration,       // 210
    Set,                         // 225
    StressLevel,                 // 227
    DiveSettings,                // 258
    DiveGas,                     // 259
    DiveAlarm,                   // 262
    ExerciseTitle,               // 264
    DiveSummary,                 // 268
    MfgRangeMin, // 65280  0xFF00 - 0xFFFE reserved for manufacturer specific messages
    MfgRangeMax, // 65534  0xFF00 - 0xFFFE reserved for manufacturer specific messages
    MesgNum(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldMesgNum {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldMesgNum::FileId => write!(f, "{}", "FileId"),
            FitFieldMesgNum::Capabilities => write!(f, "{}", "Capabilities"),
            FitFieldMesgNum::DeviceSettings => write!(f, "{}", "DeviceSettings"),
            FitFieldMesgNum::UserProfile => write!(f, "{}", "UserProfile"),
            FitFieldMesgNum::HrmProfile => write!(f, "{}", "HrmProfile"),
            FitFieldMesgNum::SdmProfile => write!(f, "{}", "SdmProfile"),
            FitFieldMesgNum::BikeProfile => write!(f, "{}", "BikeProfile"),
            FitFieldMesgNum::ZonesTarget => write!(f, "{}", "ZonesTarget"),
            FitFieldMesgNum::HrZone => write!(f, "{}", "HrZone"),
            FitFieldMesgNum::PowerZone => write!(f, "{}", "PowerZone"),
            FitFieldMesgNum::MetZone => write!(f, "{}", "MetZone"),
            FitFieldMesgNum::Sport => write!(f, "{}", "Sport"),
            FitFieldMesgNum::Goal => write!(f, "{}", "Goal"),
            FitFieldMesgNum::Session => write!(f, "{}", "Session"),
            FitFieldMesgNum::Lap => write!(f, "{}", "Lap"),
            FitFieldMesgNum::Record => write!(f, "{}", "Record"),
            FitFieldMesgNum::Event => write!(f, "{}", "Event"),
            FitFieldMesgNum::DeviceInfo => write!(f, "{}", "DeviceInfo"),
            FitFieldMesgNum::Workout => write!(f, "{}", "Workout"),
            FitFieldMesgNum::WorkoutStep => write!(f, "{}", "WorkoutStep"),
            FitFieldMesgNum::Schedule => write!(f, "{}", "Schedule"),
            FitFieldMesgNum::WeightScale => write!(f, "{}", "WeightScale"),
            FitFieldMesgNum::Course => write!(f, "{}", "Course"),
            FitFieldMesgNum::CoursePoint => write!(f, "{}", "CoursePoint"),
            FitFieldMesgNum::Totals => write!(f, "{}", "Totals"),
            FitFieldMesgNum::Activity => write!(f, "{}", "Activity"),
            FitFieldMesgNum::Software => write!(f, "{}", "Software"),
            FitFieldMesgNum::FileCapabilities => write!(f, "{}", "FileCapabilities"),
            FitFieldMesgNum::MesgCapabilities => write!(f, "{}", "MesgCapabilities"),
            FitFieldMesgNum::FieldCapabilities => write!(f, "{}", "FieldCapabilities"),
            FitFieldMesgNum::FileCreator => write!(f, "{}", "FileCreator"),
            FitFieldMesgNum::BloodPressure => write!(f, "{}", "BloodPressure"),
            FitFieldMesgNum::SpeedZone => write!(f, "{}", "SpeedZone"),
            FitFieldMesgNum::Monitoring => write!(f, "{}", "Monitoring"),
            FitFieldMesgNum::TrainingFile => write!(f, "{}", "TrainingFile"),
            FitFieldMesgNum::Hrv => write!(f, "{}", "Hrv"),
            FitFieldMesgNum::AntRx => write!(f, "{}", "AntRx"),
            FitFieldMesgNum::AntTx => write!(f, "{}", "AntTx"),
            FitFieldMesgNum::AntChannelId => write!(f, "{}", "AntChannelId"),
            FitFieldMesgNum::Length => write!(f, "{}", "Length"),
            FitFieldMesgNum::MonitoringInfo => write!(f, "{}", "MonitoringInfo"),
            FitFieldMesgNum::SlaveDevice => write!(f, "{}", "SlaveDevice"),
            FitFieldMesgNum::Connectivity => write!(f, "{}", "Connectivity"),
            FitFieldMesgNum::WeatherConditions => write!(f, "{}", "WeatherConditions"),
            FitFieldMesgNum::WeatherAlert => write!(f, "{}", "WeatherAlert"),
            FitFieldMesgNum::CadenceZone => write!(f, "{}", "CadenceZone"),
            FitFieldMesgNum::Hr => write!(f, "{}", "Hr"),
            FitFieldMesgNum::SegmentLap => write!(f, "{}", "SegmentLap"),
            FitFieldMesgNum::MemoGlob => write!(f, "{}", "MemoGlob"),
            FitFieldMesgNum::SegmentId => write!(f, "{}", "SegmentId"),
            FitFieldMesgNum::SegmentLeaderboardEntry => write!(f, "{}", "SegmentLeaderboardEntry"),
            FitFieldMesgNum::SegmentPoint => write!(f, "{}", "SegmentPoint"),
            FitFieldMesgNum::SegmentFile => write!(f, "{}", "SegmentFile"),
            FitFieldMesgNum::WorkoutSession => write!(f, "{}", "WorkoutSession"),
            FitFieldMesgNum::WatchfaceSettings => write!(f, "{}", "WatchfaceSettings"),
            FitFieldMesgNum::GpsMetadata => write!(f, "{}", "GpsMetadata"),
            FitFieldMesgNum::CameraEvent => write!(f, "{}", "CameraEvent"),
            FitFieldMesgNum::TimestampCorrelation => write!(f, "{}", "TimestampCorrelation"),
            FitFieldMesgNum::GyroscopeData => write!(f, "{}", "GyroscopeData"),
            FitFieldMesgNum::AccelerometerData => write!(f, "{}", "AccelerometerData"),
            FitFieldMesgNum::ThreeDSensorCalibration => write!(f, "{}", "ThreeDSensorCalibration"),
            FitFieldMesgNum::VideoFrame => write!(f, "{}", "VideoFrame"),
            FitFieldMesgNum::ObdiiData => write!(f, "{}", "ObdiiData"),
            FitFieldMesgNum::NmeaSentence => write!(f, "{}", "NmeaSentence"),
            FitFieldMesgNum::AviationAttitude => write!(f, "{}", "AviationAttitude"),
            FitFieldMesgNum::Video => write!(f, "{}", "Video"),
            FitFieldMesgNum::VideoTitle => write!(f, "{}", "VideoTitle"),
            FitFieldMesgNum::VideoDescription => write!(f, "{}", "VideoDescription"),
            FitFieldMesgNum::VideoClip => write!(f, "{}", "VideoClip"),
            FitFieldMesgNum::OhrSettings => write!(f, "{}", "OhrSettings"),
            FitFieldMesgNum::ExdScreenConfiguration => write!(f, "{}", "ExdScreenConfiguration"),
            FitFieldMesgNum::ExdDataFieldConfiguration => {
                write!(f, "{}", "ExdDataFieldConfiguration")
            }
            FitFieldMesgNum::ExdDataConceptConfiguration => {
                write!(f, "{}", "ExdDataConceptConfiguration")
            }
            FitFieldMesgNum::FieldDescription => write!(f, "{}", "FieldDescription"),
            FitFieldMesgNum::DeveloperDataId => write!(f, "{}", "DeveloperDataId"),
            FitFieldMesgNum::MagnetometerData => write!(f, "{}", "MagnetometerData"),
            FitFieldMesgNum::BarometerData => write!(f, "{}", "BarometerData"),
            FitFieldMesgNum::OneDSensorCalibration => write!(f, "{}", "OneDSensorCalibration"),
            FitFieldMesgNum::Set => write!(f, "{}", "Set"),
            FitFieldMesgNum::StressLevel => write!(f, "{}", "StressLevel"),
            FitFieldMesgNum::DiveSettings => write!(f, "{}", "DiveSettings"),
            FitFieldMesgNum::DiveGas => write!(f, "{}", "DiveGas"),
            FitFieldMesgNum::DiveAlarm => write!(f, "{}", "DiveAlarm"),
            FitFieldMesgNum::ExerciseTitle => write!(f, "{}", "ExerciseTitle"),
            FitFieldMesgNum::DiveSummary => write!(f, "{}", "DiveSummary"),
            FitFieldMesgNum::MfgRangeMin => write!(f, "{}", "MfgRangeMin"),
            FitFieldMesgNum::MfgRangeMax => write!(f, "{}", "MfgRangeMax"),
            FitFieldMesgNum::MesgNum(x) => write!(f, "{}({})", "MesgNum", x),
            FitFieldMesgNum::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldMesgNum::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldMesgNum {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldMesgNum> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldMesgNum::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldMesgNum::from(v)),
                1 => Ok(FitFieldMesgNum::from(v)),
                2 => Ok(FitFieldMesgNum::from(v)),
                3 => Ok(FitFieldMesgNum::from(v)),
                4 => Ok(FitFieldMesgNum::from(v)),
                5 => Ok(FitFieldMesgNum::from(v)),
                6 => Ok(FitFieldMesgNum::from(v)),
                7 => Ok(FitFieldMesgNum::from(v)),
                8 => Ok(FitFieldMesgNum::from(v)),
                9 => Ok(FitFieldMesgNum::from(v)),
                10 => Ok(FitFieldMesgNum::from(v)),
                12 => Ok(FitFieldMesgNum::from(v)),
                15 => Ok(FitFieldMesgNum::from(v)),
                18 => Ok(FitFieldMesgNum::from(v)),
                19 => Ok(FitFieldMesgNum::from(v)),
                20 => Ok(FitFieldMesgNum::from(v)),
                21 => Ok(FitFieldMesgNum::from(v)),
                23 => Ok(FitFieldMesgNum::from(v)),
                26 => Ok(FitFieldMesgNum::from(v)),
                27 => Ok(FitFieldMesgNum::from(v)),
                28 => Ok(FitFieldMesgNum::from(v)),
                30 => Ok(FitFieldMesgNum::from(v)),
                31 => Ok(FitFieldMesgNum::from(v)),
                32 => Ok(FitFieldMesgNum::from(v)),
                33 => Ok(FitFieldMesgNum::from(v)),
                34 => Ok(FitFieldMesgNum::from(v)),
                35 => Ok(FitFieldMesgNum::from(v)),
                37 => Ok(FitFieldMesgNum::from(v)),
                38 => Ok(FitFieldMesgNum::from(v)),
                39 => Ok(FitFieldMesgNum::from(v)),
                49 => Ok(FitFieldMesgNum::from(v)),
                51 => Ok(FitFieldMesgNum::from(v)),
                53 => Ok(FitFieldMesgNum::from(v)),
                55 => Ok(FitFieldMesgNum::from(v)),
                72 => Ok(FitFieldMesgNum::from(v)),
                78 => Ok(FitFieldMesgNum::from(v)),
                80 => Ok(FitFieldMesgNum::from(v)),
                81 => Ok(FitFieldMesgNum::from(v)),
                82 => Ok(FitFieldMesgNum::from(v)),
                101 => Ok(FitFieldMesgNum::from(v)),
                103 => Ok(FitFieldMesgNum::from(v)),
                106 => Ok(FitFieldMesgNum::from(v)),
                127 => Ok(FitFieldMesgNum::from(v)),
                128 => Ok(FitFieldMesgNum::from(v)),
                129 => Ok(FitFieldMesgNum::from(v)),
                131 => Ok(FitFieldMesgNum::from(v)),
                132 => Ok(FitFieldMesgNum::from(v)),
                142 => Ok(FitFieldMesgNum::from(v)),
                145 => Ok(FitFieldMesgNum::from(v)),
                148 => Ok(FitFieldMesgNum::from(v)),
                149 => Ok(FitFieldMesgNum::from(v)),
                150 => Ok(FitFieldMesgNum::from(v)),
                151 => Ok(FitFieldMesgNum::from(v)),
                158 => Ok(FitFieldMesgNum::from(v)),
                159 => Ok(FitFieldMesgNum::from(v)),
                160 => Ok(FitFieldMesgNum::from(v)),
                161 => Ok(FitFieldMesgNum::from(v)),
                162 => Ok(FitFieldMesgNum::from(v)),
                164 => Ok(FitFieldMesgNum::from(v)),
                165 => Ok(FitFieldMesgNum::from(v)),
                167 => Ok(FitFieldMesgNum::from(v)),
                169 => Ok(FitFieldMesgNum::from(v)),
                174 => Ok(FitFieldMesgNum::from(v)),
                177 => Ok(FitFieldMesgNum::from(v)),
                178 => Ok(FitFieldMesgNum::from(v)),
                184 => Ok(FitFieldMesgNum::from(v)),
                185 => Ok(FitFieldMesgNum::from(v)),
                186 => Ok(FitFieldMesgNum::from(v)),
                187 => Ok(FitFieldMesgNum::from(v)),
                188 => Ok(FitFieldMesgNum::from(v)),
                200 => Ok(FitFieldMesgNum::from(v)),
                201 => Ok(FitFieldMesgNum::from(v)),
                202 => Ok(FitFieldMesgNum::from(v)),
                206 => Ok(FitFieldMesgNum::from(v)),
                207 => Ok(FitFieldMesgNum::from(v)),
                208 => Ok(FitFieldMesgNum::from(v)),
                209 => Ok(FitFieldMesgNum::from(v)),
                210 => Ok(FitFieldMesgNum::from(v)),
                225 => Ok(FitFieldMesgNum::from(v)),
                227 => Ok(FitFieldMesgNum::from(v)),
                258 => Ok(FitFieldMesgNum::from(v)),
                259 => Ok(FitFieldMesgNum::from(v)),
                262 => Ok(FitFieldMesgNum::from(v)),
                264 => Ok(FitFieldMesgNum::from(v)),
                268 => Ok(FitFieldMesgNum::from(v)),
                65280 => Ok(FitFieldMesgNum::from(v)),
                65534 => Ok(FitFieldMesgNum::from(v)),
                v => Ok(FitFieldMesgNum::MesgNum(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldMesgNum);

impl From<u16> for FitFieldMesgNum {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldMesgNum::FileId,
            1 => FitFieldMesgNum::Capabilities,
            2 => FitFieldMesgNum::DeviceSettings,
            3 => FitFieldMesgNum::UserProfile,
            4 => FitFieldMesgNum::HrmProfile,
            5 => FitFieldMesgNum::SdmProfile,
            6 => FitFieldMesgNum::BikeProfile,
            7 => FitFieldMesgNum::ZonesTarget,
            8 => FitFieldMesgNum::HrZone,
            9 => FitFieldMesgNum::PowerZone,
            10 => FitFieldMesgNum::MetZone,
            12 => FitFieldMesgNum::Sport,
            15 => FitFieldMesgNum::Goal,
            18 => FitFieldMesgNum::Session,
            19 => FitFieldMesgNum::Lap,
            20 => FitFieldMesgNum::Record,
            21 => FitFieldMesgNum::Event,
            23 => FitFieldMesgNum::DeviceInfo,
            26 => FitFieldMesgNum::Workout,
            27 => FitFieldMesgNum::WorkoutStep,
            28 => FitFieldMesgNum::Schedule,
            30 => FitFieldMesgNum::WeightScale,
            31 => FitFieldMesgNum::Course,
            32 => FitFieldMesgNum::CoursePoint,
            33 => FitFieldMesgNum::Totals,
            34 => FitFieldMesgNum::Activity,
            35 => FitFieldMesgNum::Software,
            37 => FitFieldMesgNum::FileCapabilities,
            38 => FitFieldMesgNum::MesgCapabilities,
            39 => FitFieldMesgNum::FieldCapabilities,
            49 => FitFieldMesgNum::FileCreator,
            51 => FitFieldMesgNum::BloodPressure,
            53 => FitFieldMesgNum::SpeedZone,
            55 => FitFieldMesgNum::Monitoring,
            72 => FitFieldMesgNum::TrainingFile,
            78 => FitFieldMesgNum::Hrv,
            80 => FitFieldMesgNum::AntRx,
            81 => FitFieldMesgNum::AntTx,
            82 => FitFieldMesgNum::AntChannelId,
            101 => FitFieldMesgNum::Length,
            103 => FitFieldMesgNum::MonitoringInfo,
            106 => FitFieldMesgNum::SlaveDevice,
            127 => FitFieldMesgNum::Connectivity,
            128 => FitFieldMesgNum::WeatherConditions,
            129 => FitFieldMesgNum::WeatherAlert,
            131 => FitFieldMesgNum::CadenceZone,
            132 => FitFieldMesgNum::Hr,
            142 => FitFieldMesgNum::SegmentLap,
            145 => FitFieldMesgNum::MemoGlob,
            148 => FitFieldMesgNum::SegmentId,
            149 => FitFieldMesgNum::SegmentLeaderboardEntry,
            150 => FitFieldMesgNum::SegmentPoint,
            151 => FitFieldMesgNum::SegmentFile,
            158 => FitFieldMesgNum::WorkoutSession,
            159 => FitFieldMesgNum::WatchfaceSettings,
            160 => FitFieldMesgNum::GpsMetadata,
            161 => FitFieldMesgNum::CameraEvent,
            162 => FitFieldMesgNum::TimestampCorrelation,
            164 => FitFieldMesgNum::GyroscopeData,
            165 => FitFieldMesgNum::AccelerometerData,
            167 => FitFieldMesgNum::ThreeDSensorCalibration,
            169 => FitFieldMesgNum::VideoFrame,
            174 => FitFieldMesgNum::ObdiiData,
            177 => FitFieldMesgNum::NmeaSentence,
            178 => FitFieldMesgNum::AviationAttitude,
            184 => FitFieldMesgNum::Video,
            185 => FitFieldMesgNum::VideoTitle,
            186 => FitFieldMesgNum::VideoDescription,
            187 => FitFieldMesgNum::VideoClip,
            188 => FitFieldMesgNum::OhrSettings,
            200 => FitFieldMesgNum::ExdScreenConfiguration,
            201 => FitFieldMesgNum::ExdDataFieldConfiguration,
            202 => FitFieldMesgNum::ExdDataConceptConfiguration,
            206 => FitFieldMesgNum::FieldDescription,
            207 => FitFieldMesgNum::DeveloperDataId,
            208 => FitFieldMesgNum::MagnetometerData,
            209 => FitFieldMesgNum::BarometerData,
            210 => FitFieldMesgNum::OneDSensorCalibration,
            225 => FitFieldMesgNum::Set,
            227 => FitFieldMesgNum::StressLevel,
            258 => FitFieldMesgNum::DiveSettings,
            259 => FitFieldMesgNum::DiveGas,
            262 => FitFieldMesgNum::DiveAlarm,
            264 => FitFieldMesgNum::ExerciseTitle,
            268 => FitFieldMesgNum::DiveSummary,
            65280 => FitFieldMesgNum::MfgRangeMin,
            65534 => FitFieldMesgNum::MfgRangeMax,
            _ => FitFieldMesgNum::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldChecksum {
    // fit base type: uint8
    Clear, // 0  Allows clear of checksum for flash memory where can only write 1 to 0 without erasing sector.
    Ok, // 1  Set to mark checksum as valid if computes to invalid values 0 or 0xFF.  Checksum can also be set to ok to save encoding computation time.
    Checksum(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldChecksum {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldChecksum::Clear => write!(f, "{}", "Clear"),
            FitFieldChecksum::Ok => write!(f, "{}", "Ok"),
            FitFieldChecksum::Checksum(x) => write!(f, "{}({})", "Checksum", x),
            FitFieldChecksum::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldChecksum::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldChecksum {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldChecksum> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldChecksum::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldChecksum::from(v)),
                1 => Ok(FitFieldChecksum::from(v)),
                v => Ok(FitFieldChecksum::Checksum(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldChecksum);

impl From<u8> for FitFieldChecksum {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldChecksum::Clear,
            1 => FitFieldChecksum::Ok,
            _ => FitFieldChecksum::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFileFlags {
    // fit base type: uint8z
    Read,  // 2
    Write, // 4
    Erase, // 8
    FileFlags(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldFileFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFileFlags::Read => write!(f, "{}", "Read"),
            FitFieldFileFlags::Write => write!(f, "{}", "Write"),
            FitFieldFileFlags::Erase => write!(f, "{}", "Erase"),
            FitFieldFileFlags::FileFlags(x) => write!(f, "{}({})", "FileFlags", x),
            FitFieldFileFlags::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFileFlags::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFileFlags {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFileFlags> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldFileFlags::InvalidFieldValue),
            Ok(v) => match v {
                2 => Ok(FitFieldFileFlags::from(v)),
                4 => Ok(FitFieldFileFlags::from(v)),
                8 => Ok(FitFieldFileFlags::from(v)),
                v => Ok(FitFieldFileFlags::FileFlags(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldFileFlags);

impl From<u8> for FitFieldFileFlags {
    fn from(code: u8) -> Self {
        match code {
            2 => FitFieldFileFlags::Read,
            4 => FitFieldFileFlags::Write,
            8 => FitFieldFileFlags::Erase,
            _ => FitFieldFileFlags::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldMesgCount {
    // fit base type: enum
    NumPerFile = 0,
    MaxPerFile = 1,
    MaxPerFileType = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldMesgCount {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldMesgCount::NumPerFile => write!(f, "{}", "NumPerFile"),
            FitFieldMesgCount::MaxPerFile => write!(f, "{}", "MaxPerFile"),
            FitFieldMesgCount::MaxPerFileType => write!(f, "{}", "MaxPerFileType"),
            FitFieldMesgCount::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldMesgCount::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldMesgCount {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldMesgCount> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldMesgCount::from(v)),
            Err(_) => Ok(FitFieldMesgCount::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldMesgCount);

impl From<u8> for FitFieldMesgCount {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldMesgCount::NumPerFile,
            1 => FitFieldMesgCount::MaxPerFile,
            2 => FitFieldMesgCount::MaxPerFileType,
            _ => FitFieldMesgCount::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldMessageIndex {
    // fit base type: uint16
    Selected, // 32768  message is selected if set
    Reserved, // 28672  reserved (default 0)
    Mask,     // 4095  index
    MessageIndex(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldMessageIndex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldMessageIndex::Selected => write!(f, "{}", "Selected"),
            FitFieldMessageIndex::Reserved => write!(f, "{}", "Reserved"),
            FitFieldMessageIndex::Mask => write!(f, "{}", "Mask"),
            FitFieldMessageIndex::MessageIndex(x) => write!(f, "{}({})", "MessageIndex", x),
            FitFieldMessageIndex::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldMessageIndex::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldMessageIndex {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldMessageIndex> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldMessageIndex::InvalidFieldValue),
            Ok(v) => match v {
                32768 => Ok(FitFieldMessageIndex::from(v)),
                28672 => Ok(FitFieldMessageIndex::from(v)),
                4095 => Ok(FitFieldMessageIndex::from(v)),
                v => Ok(FitFieldMessageIndex::MessageIndex(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldMessageIndex);

impl From<u16> for FitFieldMessageIndex {
    fn from(code: u16) -> Self {
        match code {
            32768 => FitFieldMessageIndex::Selected,
            28672 => FitFieldMessageIndex::Reserved,
            4095 => FitFieldMessageIndex::Mask,
            _ => FitFieldMessageIndex::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDeviceIndex {
    // fit base type: uint8
    Creator, // 0  Creator of the file is always device index 0.
    DeviceIndex(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldDeviceIndex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDeviceIndex::Creator => write!(f, "{}", "Creator"),
            FitFieldDeviceIndex::DeviceIndex(x) => write!(f, "{}({})", "DeviceIndex", x),
            FitFieldDeviceIndex::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDeviceIndex::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDeviceIndex {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDeviceIndex> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldDeviceIndex::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldDeviceIndex::from(v)),
                v => Ok(FitFieldDeviceIndex::DeviceIndex(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldDeviceIndex);

impl From<u8> for FitFieldDeviceIndex {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDeviceIndex::Creator,
            _ => FitFieldDeviceIndex::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldGender {
    // fit base type: enum
    Female = 0,
    Male = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldGender {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldGender::Female => write!(f, "{}", "Female"),
            FitFieldGender::Male => write!(f, "{}", "Male"),
            FitFieldGender::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldGender::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldGender {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldGender> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldGender::from(v)),
            Err(_) => Ok(FitFieldGender::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldGender);

impl From<u8> for FitFieldGender {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGender::Female,
            1 => FitFieldGender::Male,
            _ => FitFieldGender::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLanguage {
    // fit base type: enum
    English = 0,
    French = 1,
    Italian = 2,
    German = 3,
    Spanish = 4,
    Croatian = 5,
    Czech = 6,
    Danish = 7,
    Dutch = 8,
    Finnish = 9,
    Greek = 10,
    Hungarian = 11,
    Norwegian = 12,
    Polish = 13,
    Portuguese = 14,
    Slovakian = 15,
    Slovenian = 16,
    Swedish = 17,
    Russian = 18,
    Turkish = 19,
    Latvian = 20,
    Ukrainian = 21,
    Arabic = 22,
    Farsi = 23,
    Bulgarian = 24,
    Romanian = 25,
    Chinese = 26,
    Japanese = 27,
    Korean = 28,
    Taiwanese = 29,
    Thai = 30,
    Hebrew = 31,
    BrazilianPortuguese = 32,
    Indonesian = 33,
    Malaysian = 34,
    Vietnamese = 35,
    Burmese = 36,
    Mongolian = 37,
    Custom = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldLanguage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLanguage::English => write!(f, "{}", "English"),
            FitFieldLanguage::French => write!(f, "{}", "French"),
            FitFieldLanguage::Italian => write!(f, "{}", "Italian"),
            FitFieldLanguage::German => write!(f, "{}", "German"),
            FitFieldLanguage::Spanish => write!(f, "{}", "Spanish"),
            FitFieldLanguage::Croatian => write!(f, "{}", "Croatian"),
            FitFieldLanguage::Czech => write!(f, "{}", "Czech"),
            FitFieldLanguage::Danish => write!(f, "{}", "Danish"),
            FitFieldLanguage::Dutch => write!(f, "{}", "Dutch"),
            FitFieldLanguage::Finnish => write!(f, "{}", "Finnish"),
            FitFieldLanguage::Greek => write!(f, "{}", "Greek"),
            FitFieldLanguage::Hungarian => write!(f, "{}", "Hungarian"),
            FitFieldLanguage::Norwegian => write!(f, "{}", "Norwegian"),
            FitFieldLanguage::Polish => write!(f, "{}", "Polish"),
            FitFieldLanguage::Portuguese => write!(f, "{}", "Portuguese"),
            FitFieldLanguage::Slovakian => write!(f, "{}", "Slovakian"),
            FitFieldLanguage::Slovenian => write!(f, "{}", "Slovenian"),
            FitFieldLanguage::Swedish => write!(f, "{}", "Swedish"),
            FitFieldLanguage::Russian => write!(f, "{}", "Russian"),
            FitFieldLanguage::Turkish => write!(f, "{}", "Turkish"),
            FitFieldLanguage::Latvian => write!(f, "{}", "Latvian"),
            FitFieldLanguage::Ukrainian => write!(f, "{}", "Ukrainian"),
            FitFieldLanguage::Arabic => write!(f, "{}", "Arabic"),
            FitFieldLanguage::Farsi => write!(f, "{}", "Farsi"),
            FitFieldLanguage::Bulgarian => write!(f, "{}", "Bulgarian"),
            FitFieldLanguage::Romanian => write!(f, "{}", "Romanian"),
            FitFieldLanguage::Chinese => write!(f, "{}", "Chinese"),
            FitFieldLanguage::Japanese => write!(f, "{}", "Japanese"),
            FitFieldLanguage::Korean => write!(f, "{}", "Korean"),
            FitFieldLanguage::Taiwanese => write!(f, "{}", "Taiwanese"),
            FitFieldLanguage::Thai => write!(f, "{}", "Thai"),
            FitFieldLanguage::Hebrew => write!(f, "{}", "Hebrew"),
            FitFieldLanguage::BrazilianPortuguese => write!(f, "{}", "BrazilianPortuguese"),
            FitFieldLanguage::Indonesian => write!(f, "{}", "Indonesian"),
            FitFieldLanguage::Malaysian => write!(f, "{}", "Malaysian"),
            FitFieldLanguage::Vietnamese => write!(f, "{}", "Vietnamese"),
            FitFieldLanguage::Burmese => write!(f, "{}", "Burmese"),
            FitFieldLanguage::Mongolian => write!(f, "{}", "Mongolian"),
            FitFieldLanguage::Custom => write!(f, "{}", "Custom"),
            FitFieldLanguage::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLanguage::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLanguage {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLanguage> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldLanguage::from(v)),
            Err(_) => Ok(FitFieldLanguage::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldLanguage);

impl From<u8> for FitFieldLanguage {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldLanguage::English,
            1 => FitFieldLanguage::French,
            2 => FitFieldLanguage::Italian,
            3 => FitFieldLanguage::German,
            4 => FitFieldLanguage::Spanish,
            5 => FitFieldLanguage::Croatian,
            6 => FitFieldLanguage::Czech,
            7 => FitFieldLanguage::Danish,
            8 => FitFieldLanguage::Dutch,
            9 => FitFieldLanguage::Finnish,
            10 => FitFieldLanguage::Greek,
            11 => FitFieldLanguage::Hungarian,
            12 => FitFieldLanguage::Norwegian,
            13 => FitFieldLanguage::Polish,
            14 => FitFieldLanguage::Portuguese,
            15 => FitFieldLanguage::Slovakian,
            16 => FitFieldLanguage::Slovenian,
            17 => FitFieldLanguage::Swedish,
            18 => FitFieldLanguage::Russian,
            19 => FitFieldLanguage::Turkish,
            20 => FitFieldLanguage::Latvian,
            21 => FitFieldLanguage::Ukrainian,
            22 => FitFieldLanguage::Arabic,
            23 => FitFieldLanguage::Farsi,
            24 => FitFieldLanguage::Bulgarian,
            25 => FitFieldLanguage::Romanian,
            26 => FitFieldLanguage::Chinese,
            27 => FitFieldLanguage::Japanese,
            28 => FitFieldLanguage::Korean,
            29 => FitFieldLanguage::Taiwanese,
            30 => FitFieldLanguage::Thai,
            31 => FitFieldLanguage::Hebrew,
            32 => FitFieldLanguage::BrazilianPortuguese,
            33 => FitFieldLanguage::Indonesian,
            34 => FitFieldLanguage::Malaysian,
            35 => FitFieldLanguage::Vietnamese,
            36 => FitFieldLanguage::Burmese,
            37 => FitFieldLanguage::Mongolian,
            254 => FitFieldLanguage::Custom,
            _ => FitFieldLanguage::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLanguageBits0 {
    // fit base type: uint8z
    English,  // 1
    French,   // 2
    Italian,  // 4
    German,   // 8
    Spanish,  // 16
    Croatian, // 32
    Czech,    // 64
    Danish,   // 128
    LanguageBits0(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLanguageBits0 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLanguageBits0::English => write!(f, "{}", "English"),
            FitFieldLanguageBits0::French => write!(f, "{}", "French"),
            FitFieldLanguageBits0::Italian => write!(f, "{}", "Italian"),
            FitFieldLanguageBits0::German => write!(f, "{}", "German"),
            FitFieldLanguageBits0::Spanish => write!(f, "{}", "Spanish"),
            FitFieldLanguageBits0::Croatian => write!(f, "{}", "Croatian"),
            FitFieldLanguageBits0::Czech => write!(f, "{}", "Czech"),
            FitFieldLanguageBits0::Danish => write!(f, "{}", "Danish"),
            FitFieldLanguageBits0::LanguageBits0(x) => write!(f, "{}({})", "LanguageBits0", x),
            FitFieldLanguageBits0::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLanguageBits0::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLanguageBits0 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLanguageBits0> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLanguageBits0::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldLanguageBits0::from(v)),
                2 => Ok(FitFieldLanguageBits0::from(v)),
                4 => Ok(FitFieldLanguageBits0::from(v)),
                8 => Ok(FitFieldLanguageBits0::from(v)),
                16 => Ok(FitFieldLanguageBits0::from(v)),
                32 => Ok(FitFieldLanguageBits0::from(v)),
                64 => Ok(FitFieldLanguageBits0::from(v)),
                128 => Ok(FitFieldLanguageBits0::from(v)),
                v => Ok(FitFieldLanguageBits0::LanguageBits0(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLanguageBits0);

impl From<u8> for FitFieldLanguageBits0 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits0::English,
            2 => FitFieldLanguageBits0::French,
            4 => FitFieldLanguageBits0::Italian,
            8 => FitFieldLanguageBits0::German,
            16 => FitFieldLanguageBits0::Spanish,
            32 => FitFieldLanguageBits0::Croatian,
            64 => FitFieldLanguageBits0::Czech,
            128 => FitFieldLanguageBits0::Danish,
            _ => FitFieldLanguageBits0::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLanguageBits1 {
    // fit base type: uint8z
    Dutch,      // 1
    Finnish,    // 2
    Greek,      // 4
    Hungarian,  // 8
    Norwegian,  // 16
    Polish,     // 32
    Portuguese, // 64
    Slovakian,  // 128
    LanguageBits1(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLanguageBits1 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLanguageBits1::Dutch => write!(f, "{}", "Dutch"),
            FitFieldLanguageBits1::Finnish => write!(f, "{}", "Finnish"),
            FitFieldLanguageBits1::Greek => write!(f, "{}", "Greek"),
            FitFieldLanguageBits1::Hungarian => write!(f, "{}", "Hungarian"),
            FitFieldLanguageBits1::Norwegian => write!(f, "{}", "Norwegian"),
            FitFieldLanguageBits1::Polish => write!(f, "{}", "Polish"),
            FitFieldLanguageBits1::Portuguese => write!(f, "{}", "Portuguese"),
            FitFieldLanguageBits1::Slovakian => write!(f, "{}", "Slovakian"),
            FitFieldLanguageBits1::LanguageBits1(x) => write!(f, "{}({})", "LanguageBits1", x),
            FitFieldLanguageBits1::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLanguageBits1::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLanguageBits1 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLanguageBits1> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLanguageBits1::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldLanguageBits1::from(v)),
                2 => Ok(FitFieldLanguageBits1::from(v)),
                4 => Ok(FitFieldLanguageBits1::from(v)),
                8 => Ok(FitFieldLanguageBits1::from(v)),
                16 => Ok(FitFieldLanguageBits1::from(v)),
                32 => Ok(FitFieldLanguageBits1::from(v)),
                64 => Ok(FitFieldLanguageBits1::from(v)),
                128 => Ok(FitFieldLanguageBits1::from(v)),
                v => Ok(FitFieldLanguageBits1::LanguageBits1(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLanguageBits1);

impl From<u8> for FitFieldLanguageBits1 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits1::Dutch,
            2 => FitFieldLanguageBits1::Finnish,
            4 => FitFieldLanguageBits1::Greek,
            8 => FitFieldLanguageBits1::Hungarian,
            16 => FitFieldLanguageBits1::Norwegian,
            32 => FitFieldLanguageBits1::Polish,
            64 => FitFieldLanguageBits1::Portuguese,
            128 => FitFieldLanguageBits1::Slovakian,
            _ => FitFieldLanguageBits1::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLanguageBits2 {
    // fit base type: uint8z
    Slovenian, // 1
    Swedish,   // 2
    Russian,   // 4
    Turkish,   // 8
    Latvian,   // 16
    Ukrainian, // 32
    Arabic,    // 64
    Farsi,     // 128
    LanguageBits2(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLanguageBits2 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLanguageBits2::Slovenian => write!(f, "{}", "Slovenian"),
            FitFieldLanguageBits2::Swedish => write!(f, "{}", "Swedish"),
            FitFieldLanguageBits2::Russian => write!(f, "{}", "Russian"),
            FitFieldLanguageBits2::Turkish => write!(f, "{}", "Turkish"),
            FitFieldLanguageBits2::Latvian => write!(f, "{}", "Latvian"),
            FitFieldLanguageBits2::Ukrainian => write!(f, "{}", "Ukrainian"),
            FitFieldLanguageBits2::Arabic => write!(f, "{}", "Arabic"),
            FitFieldLanguageBits2::Farsi => write!(f, "{}", "Farsi"),
            FitFieldLanguageBits2::LanguageBits2(x) => write!(f, "{}({})", "LanguageBits2", x),
            FitFieldLanguageBits2::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLanguageBits2::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLanguageBits2 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLanguageBits2> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLanguageBits2::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldLanguageBits2::from(v)),
                2 => Ok(FitFieldLanguageBits2::from(v)),
                4 => Ok(FitFieldLanguageBits2::from(v)),
                8 => Ok(FitFieldLanguageBits2::from(v)),
                16 => Ok(FitFieldLanguageBits2::from(v)),
                32 => Ok(FitFieldLanguageBits2::from(v)),
                64 => Ok(FitFieldLanguageBits2::from(v)),
                128 => Ok(FitFieldLanguageBits2::from(v)),
                v => Ok(FitFieldLanguageBits2::LanguageBits2(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLanguageBits2);

impl From<u8> for FitFieldLanguageBits2 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits2::Slovenian,
            2 => FitFieldLanguageBits2::Swedish,
            4 => FitFieldLanguageBits2::Russian,
            8 => FitFieldLanguageBits2::Turkish,
            16 => FitFieldLanguageBits2::Latvian,
            32 => FitFieldLanguageBits2::Ukrainian,
            64 => FitFieldLanguageBits2::Arabic,
            128 => FitFieldLanguageBits2::Farsi,
            _ => FitFieldLanguageBits2::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLanguageBits3 {
    // fit base type: uint8z
    Bulgarian, // 1
    Romanian,  // 2
    Chinese,   // 4
    Japanese,  // 8
    Korean,    // 16
    Taiwanese, // 32
    Thai,      // 64
    Hebrew,    // 128
    LanguageBits3(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLanguageBits3 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLanguageBits3::Bulgarian => write!(f, "{}", "Bulgarian"),
            FitFieldLanguageBits3::Romanian => write!(f, "{}", "Romanian"),
            FitFieldLanguageBits3::Chinese => write!(f, "{}", "Chinese"),
            FitFieldLanguageBits3::Japanese => write!(f, "{}", "Japanese"),
            FitFieldLanguageBits3::Korean => write!(f, "{}", "Korean"),
            FitFieldLanguageBits3::Taiwanese => write!(f, "{}", "Taiwanese"),
            FitFieldLanguageBits3::Thai => write!(f, "{}", "Thai"),
            FitFieldLanguageBits3::Hebrew => write!(f, "{}", "Hebrew"),
            FitFieldLanguageBits3::LanguageBits3(x) => write!(f, "{}({})", "LanguageBits3", x),
            FitFieldLanguageBits3::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLanguageBits3::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLanguageBits3 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLanguageBits3> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLanguageBits3::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldLanguageBits3::from(v)),
                2 => Ok(FitFieldLanguageBits3::from(v)),
                4 => Ok(FitFieldLanguageBits3::from(v)),
                8 => Ok(FitFieldLanguageBits3::from(v)),
                16 => Ok(FitFieldLanguageBits3::from(v)),
                32 => Ok(FitFieldLanguageBits3::from(v)),
                64 => Ok(FitFieldLanguageBits3::from(v)),
                128 => Ok(FitFieldLanguageBits3::from(v)),
                v => Ok(FitFieldLanguageBits3::LanguageBits3(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLanguageBits3);

impl From<u8> for FitFieldLanguageBits3 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits3::Bulgarian,
            2 => FitFieldLanguageBits3::Romanian,
            4 => FitFieldLanguageBits3::Chinese,
            8 => FitFieldLanguageBits3::Japanese,
            16 => FitFieldLanguageBits3::Korean,
            32 => FitFieldLanguageBits3::Taiwanese,
            64 => FitFieldLanguageBits3::Thai,
            128 => FitFieldLanguageBits3::Hebrew,
            _ => FitFieldLanguageBits3::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLanguageBits4 {
    // fit base type: uint8z
    BrazilianPortuguese, // 1
    Indonesian,          // 2
    Malaysian,           // 4
    Vietnamese,          // 8
    Burmese,             // 16
    Mongolian,           // 32
    LanguageBits4(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLanguageBits4 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLanguageBits4::BrazilianPortuguese => write!(f, "{}", "BrazilianPortuguese"),
            FitFieldLanguageBits4::Indonesian => write!(f, "{}", "Indonesian"),
            FitFieldLanguageBits4::Malaysian => write!(f, "{}", "Malaysian"),
            FitFieldLanguageBits4::Vietnamese => write!(f, "{}", "Vietnamese"),
            FitFieldLanguageBits4::Burmese => write!(f, "{}", "Burmese"),
            FitFieldLanguageBits4::Mongolian => write!(f, "{}", "Mongolian"),
            FitFieldLanguageBits4::LanguageBits4(x) => write!(f, "{}({})", "LanguageBits4", x),
            FitFieldLanguageBits4::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLanguageBits4::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLanguageBits4 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLanguageBits4> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLanguageBits4::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldLanguageBits4::from(v)),
                2 => Ok(FitFieldLanguageBits4::from(v)),
                4 => Ok(FitFieldLanguageBits4::from(v)),
                8 => Ok(FitFieldLanguageBits4::from(v)),
                16 => Ok(FitFieldLanguageBits4::from(v)),
                32 => Ok(FitFieldLanguageBits4::from(v)),
                v => Ok(FitFieldLanguageBits4::LanguageBits4(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLanguageBits4);

impl From<u8> for FitFieldLanguageBits4 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits4::BrazilianPortuguese,
            2 => FitFieldLanguageBits4::Indonesian,
            4 => FitFieldLanguageBits4::Malaysian,
            8 => FitFieldLanguageBits4::Vietnamese,
            16 => FitFieldLanguageBits4::Burmese,
            32 => FitFieldLanguageBits4::Mongolian,
            _ => FitFieldLanguageBits4::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTimeZone {
    // fit base type: enum
    Almaty = 0,
    Bangkok = 1,
    Bombay = 2,
    Brasilia = 3,
    Cairo = 4,
    CapeVerdeIs = 5,
    Darwin = 6,
    Eniwetok = 7,
    Fiji = 8,
    HongKong = 9,
    Islamabad = 10,
    Kabul = 11,
    Magadan = 12,
    MidAtlantic = 13,
    Moscow = 14,
    Muscat = 15,
    Newfoundland = 16,
    Samoa = 17,
    Sydney = 18,
    Tehran = 19,
    Tokyo = 20,
    UsAlaska = 21,
    UsAtlantic = 22,
    UsCentral = 23,
    UsEastern = 24,
    UsHawaii = 25,
    UsMountain = 26,
    UsPacific = 27,
    Other = 28,
    Auckland = 29,
    Kathmandu = 30,
    EuropeWesternWet = 31,
    EuropeCentralCet = 32,
    EuropeEasternEet = 33,
    Jakarta = 34,
    Perth = 35,
    Adelaide = 36,
    Brisbane = 37,
    Tasmania = 38,
    Iceland = 39,
    Amsterdam = 40,
    Athens = 41,
    Barcelona = 42,
    Berlin = 43,
    Brussels = 44,
    Budapest = 45,
    Copenhagen = 46,
    Dublin = 47,
    Helsinki = 48,
    Lisbon = 49,
    London = 50,
    Madrid = 51,
    Munich = 52,
    Oslo = 53,
    Paris = 54,
    Prague = 55,
    Reykjavik = 56,
    Rome = 57,
    Stockholm = 58,
    Vienna = 59,
    Warsaw = 60,
    Zurich = 61,
    Quebec = 62,
    Ontario = 63,
    Manitoba = 64,
    Saskatchewan = 65,
    Alberta = 66,
    BritishColumbia = 67,
    Boise = 68,
    Boston = 69,
    Chicago = 70,
    Dallas = 71,
    Denver = 72,
    KansasCity = 73,
    LasVegas = 74,
    LosAngeles = 75,
    Miami = 76,
    Minneapolis = 77,
    NewYork = 78,
    NewOrleans = 79,
    Phoenix = 80,
    SantaFe = 81,
    Seattle = 82,
    WashingtonDc = 83,
    UsArizona = 84,
    Chita = 85,
    Ekaterinburg = 86,
    Irkutsk = 87,
    Kaliningrad = 88,
    Krasnoyarsk = 89,
    Novosibirsk = 90,
    PetropavlovskKamchatskiy = 91,
    Samara = 92,
    Vladivostok = 93,
    MexicoCentral = 94,
    MexicoMountain = 95,
    MexicoPacific = 96,
    CapeTown = 97,
    Winkhoek = 98,
    Lagos = 99,
    Riyahd = 100,
    Venezuela = 101,
    AustraliaLh = 102,
    Santiago = 103,
    Manual = 253,
    Automatic = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldTimeZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTimeZone::Almaty => write!(f, "{}", "Almaty"),
            FitFieldTimeZone::Bangkok => write!(f, "{}", "Bangkok"),
            FitFieldTimeZone::Bombay => write!(f, "{}", "Bombay"),
            FitFieldTimeZone::Brasilia => write!(f, "{}", "Brasilia"),
            FitFieldTimeZone::Cairo => write!(f, "{}", "Cairo"),
            FitFieldTimeZone::CapeVerdeIs => write!(f, "{}", "CapeVerdeIs"),
            FitFieldTimeZone::Darwin => write!(f, "{}", "Darwin"),
            FitFieldTimeZone::Eniwetok => write!(f, "{}", "Eniwetok"),
            FitFieldTimeZone::Fiji => write!(f, "{}", "Fiji"),
            FitFieldTimeZone::HongKong => write!(f, "{}", "HongKong"),
            FitFieldTimeZone::Islamabad => write!(f, "{}", "Islamabad"),
            FitFieldTimeZone::Kabul => write!(f, "{}", "Kabul"),
            FitFieldTimeZone::Magadan => write!(f, "{}", "Magadan"),
            FitFieldTimeZone::MidAtlantic => write!(f, "{}", "MidAtlantic"),
            FitFieldTimeZone::Moscow => write!(f, "{}", "Moscow"),
            FitFieldTimeZone::Muscat => write!(f, "{}", "Muscat"),
            FitFieldTimeZone::Newfoundland => write!(f, "{}", "Newfoundland"),
            FitFieldTimeZone::Samoa => write!(f, "{}", "Samoa"),
            FitFieldTimeZone::Sydney => write!(f, "{}", "Sydney"),
            FitFieldTimeZone::Tehran => write!(f, "{}", "Tehran"),
            FitFieldTimeZone::Tokyo => write!(f, "{}", "Tokyo"),
            FitFieldTimeZone::UsAlaska => write!(f, "{}", "UsAlaska"),
            FitFieldTimeZone::UsAtlantic => write!(f, "{}", "UsAtlantic"),
            FitFieldTimeZone::UsCentral => write!(f, "{}", "UsCentral"),
            FitFieldTimeZone::UsEastern => write!(f, "{}", "UsEastern"),
            FitFieldTimeZone::UsHawaii => write!(f, "{}", "UsHawaii"),
            FitFieldTimeZone::UsMountain => write!(f, "{}", "UsMountain"),
            FitFieldTimeZone::UsPacific => write!(f, "{}", "UsPacific"),
            FitFieldTimeZone::Other => write!(f, "{}", "Other"),
            FitFieldTimeZone::Auckland => write!(f, "{}", "Auckland"),
            FitFieldTimeZone::Kathmandu => write!(f, "{}", "Kathmandu"),
            FitFieldTimeZone::EuropeWesternWet => write!(f, "{}", "EuropeWesternWet"),
            FitFieldTimeZone::EuropeCentralCet => write!(f, "{}", "EuropeCentralCet"),
            FitFieldTimeZone::EuropeEasternEet => write!(f, "{}", "EuropeEasternEet"),
            FitFieldTimeZone::Jakarta => write!(f, "{}", "Jakarta"),
            FitFieldTimeZone::Perth => write!(f, "{}", "Perth"),
            FitFieldTimeZone::Adelaide => write!(f, "{}", "Adelaide"),
            FitFieldTimeZone::Brisbane => write!(f, "{}", "Brisbane"),
            FitFieldTimeZone::Tasmania => write!(f, "{}", "Tasmania"),
            FitFieldTimeZone::Iceland => write!(f, "{}", "Iceland"),
            FitFieldTimeZone::Amsterdam => write!(f, "{}", "Amsterdam"),
            FitFieldTimeZone::Athens => write!(f, "{}", "Athens"),
            FitFieldTimeZone::Barcelona => write!(f, "{}", "Barcelona"),
            FitFieldTimeZone::Berlin => write!(f, "{}", "Berlin"),
            FitFieldTimeZone::Brussels => write!(f, "{}", "Brussels"),
            FitFieldTimeZone::Budapest => write!(f, "{}", "Budapest"),
            FitFieldTimeZone::Copenhagen => write!(f, "{}", "Copenhagen"),
            FitFieldTimeZone::Dublin => write!(f, "{}", "Dublin"),
            FitFieldTimeZone::Helsinki => write!(f, "{}", "Helsinki"),
            FitFieldTimeZone::Lisbon => write!(f, "{}", "Lisbon"),
            FitFieldTimeZone::London => write!(f, "{}", "London"),
            FitFieldTimeZone::Madrid => write!(f, "{}", "Madrid"),
            FitFieldTimeZone::Munich => write!(f, "{}", "Munich"),
            FitFieldTimeZone::Oslo => write!(f, "{}", "Oslo"),
            FitFieldTimeZone::Paris => write!(f, "{}", "Paris"),
            FitFieldTimeZone::Prague => write!(f, "{}", "Prague"),
            FitFieldTimeZone::Reykjavik => write!(f, "{}", "Reykjavik"),
            FitFieldTimeZone::Rome => write!(f, "{}", "Rome"),
            FitFieldTimeZone::Stockholm => write!(f, "{}", "Stockholm"),
            FitFieldTimeZone::Vienna => write!(f, "{}", "Vienna"),
            FitFieldTimeZone::Warsaw => write!(f, "{}", "Warsaw"),
            FitFieldTimeZone::Zurich => write!(f, "{}", "Zurich"),
            FitFieldTimeZone::Quebec => write!(f, "{}", "Quebec"),
            FitFieldTimeZone::Ontario => write!(f, "{}", "Ontario"),
            FitFieldTimeZone::Manitoba => write!(f, "{}", "Manitoba"),
            FitFieldTimeZone::Saskatchewan => write!(f, "{}", "Saskatchewan"),
            FitFieldTimeZone::Alberta => write!(f, "{}", "Alberta"),
            FitFieldTimeZone::BritishColumbia => write!(f, "{}", "BritishColumbia"),
            FitFieldTimeZone::Boise => write!(f, "{}", "Boise"),
            FitFieldTimeZone::Boston => write!(f, "{}", "Boston"),
            FitFieldTimeZone::Chicago => write!(f, "{}", "Chicago"),
            FitFieldTimeZone::Dallas => write!(f, "{}", "Dallas"),
            FitFieldTimeZone::Denver => write!(f, "{}", "Denver"),
            FitFieldTimeZone::KansasCity => write!(f, "{}", "KansasCity"),
            FitFieldTimeZone::LasVegas => write!(f, "{}", "LasVegas"),
            FitFieldTimeZone::LosAngeles => write!(f, "{}", "LosAngeles"),
            FitFieldTimeZone::Miami => write!(f, "{}", "Miami"),
            FitFieldTimeZone::Minneapolis => write!(f, "{}", "Minneapolis"),
            FitFieldTimeZone::NewYork => write!(f, "{}", "NewYork"),
            FitFieldTimeZone::NewOrleans => write!(f, "{}", "NewOrleans"),
            FitFieldTimeZone::Phoenix => write!(f, "{}", "Phoenix"),
            FitFieldTimeZone::SantaFe => write!(f, "{}", "SantaFe"),
            FitFieldTimeZone::Seattle => write!(f, "{}", "Seattle"),
            FitFieldTimeZone::WashingtonDc => write!(f, "{}", "WashingtonDc"),
            FitFieldTimeZone::UsArizona => write!(f, "{}", "UsArizona"),
            FitFieldTimeZone::Chita => write!(f, "{}", "Chita"),
            FitFieldTimeZone::Ekaterinburg => write!(f, "{}", "Ekaterinburg"),
            FitFieldTimeZone::Irkutsk => write!(f, "{}", "Irkutsk"),
            FitFieldTimeZone::Kaliningrad => write!(f, "{}", "Kaliningrad"),
            FitFieldTimeZone::Krasnoyarsk => write!(f, "{}", "Krasnoyarsk"),
            FitFieldTimeZone::Novosibirsk => write!(f, "{}", "Novosibirsk"),
            FitFieldTimeZone::PetropavlovskKamchatskiy => {
                write!(f, "{}", "PetropavlovskKamchatskiy")
            }
            FitFieldTimeZone::Samara => write!(f, "{}", "Samara"),
            FitFieldTimeZone::Vladivostok => write!(f, "{}", "Vladivostok"),
            FitFieldTimeZone::MexicoCentral => write!(f, "{}", "MexicoCentral"),
            FitFieldTimeZone::MexicoMountain => write!(f, "{}", "MexicoMountain"),
            FitFieldTimeZone::MexicoPacific => write!(f, "{}", "MexicoPacific"),
            FitFieldTimeZone::CapeTown => write!(f, "{}", "CapeTown"),
            FitFieldTimeZone::Winkhoek => write!(f, "{}", "Winkhoek"),
            FitFieldTimeZone::Lagos => write!(f, "{}", "Lagos"),
            FitFieldTimeZone::Riyahd => write!(f, "{}", "Riyahd"),
            FitFieldTimeZone::Venezuela => write!(f, "{}", "Venezuela"),
            FitFieldTimeZone::AustraliaLh => write!(f, "{}", "AustraliaLh"),
            FitFieldTimeZone::Santiago => write!(f, "{}", "Santiago"),
            FitFieldTimeZone::Manual => write!(f, "{}", "Manual"),
            FitFieldTimeZone::Automatic => write!(f, "{}", "Automatic"),
            FitFieldTimeZone::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTimeZone::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTimeZone {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTimeZone> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldTimeZone::from(v)),
            Err(_) => Ok(FitFieldTimeZone::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldTimeZone);

impl From<u8> for FitFieldTimeZone {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTimeZone::Almaty,
            1 => FitFieldTimeZone::Bangkok,
            2 => FitFieldTimeZone::Bombay,
            3 => FitFieldTimeZone::Brasilia,
            4 => FitFieldTimeZone::Cairo,
            5 => FitFieldTimeZone::CapeVerdeIs,
            6 => FitFieldTimeZone::Darwin,
            7 => FitFieldTimeZone::Eniwetok,
            8 => FitFieldTimeZone::Fiji,
            9 => FitFieldTimeZone::HongKong,
            10 => FitFieldTimeZone::Islamabad,
            11 => FitFieldTimeZone::Kabul,
            12 => FitFieldTimeZone::Magadan,
            13 => FitFieldTimeZone::MidAtlantic,
            14 => FitFieldTimeZone::Moscow,
            15 => FitFieldTimeZone::Muscat,
            16 => FitFieldTimeZone::Newfoundland,
            17 => FitFieldTimeZone::Samoa,
            18 => FitFieldTimeZone::Sydney,
            19 => FitFieldTimeZone::Tehran,
            20 => FitFieldTimeZone::Tokyo,
            21 => FitFieldTimeZone::UsAlaska,
            22 => FitFieldTimeZone::UsAtlantic,
            23 => FitFieldTimeZone::UsCentral,
            24 => FitFieldTimeZone::UsEastern,
            25 => FitFieldTimeZone::UsHawaii,
            26 => FitFieldTimeZone::UsMountain,
            27 => FitFieldTimeZone::UsPacific,
            28 => FitFieldTimeZone::Other,
            29 => FitFieldTimeZone::Auckland,
            30 => FitFieldTimeZone::Kathmandu,
            31 => FitFieldTimeZone::EuropeWesternWet,
            32 => FitFieldTimeZone::EuropeCentralCet,
            33 => FitFieldTimeZone::EuropeEasternEet,
            34 => FitFieldTimeZone::Jakarta,
            35 => FitFieldTimeZone::Perth,
            36 => FitFieldTimeZone::Adelaide,
            37 => FitFieldTimeZone::Brisbane,
            38 => FitFieldTimeZone::Tasmania,
            39 => FitFieldTimeZone::Iceland,
            40 => FitFieldTimeZone::Amsterdam,
            41 => FitFieldTimeZone::Athens,
            42 => FitFieldTimeZone::Barcelona,
            43 => FitFieldTimeZone::Berlin,
            44 => FitFieldTimeZone::Brussels,
            45 => FitFieldTimeZone::Budapest,
            46 => FitFieldTimeZone::Copenhagen,
            47 => FitFieldTimeZone::Dublin,
            48 => FitFieldTimeZone::Helsinki,
            49 => FitFieldTimeZone::Lisbon,
            50 => FitFieldTimeZone::London,
            51 => FitFieldTimeZone::Madrid,
            52 => FitFieldTimeZone::Munich,
            53 => FitFieldTimeZone::Oslo,
            54 => FitFieldTimeZone::Paris,
            55 => FitFieldTimeZone::Prague,
            56 => FitFieldTimeZone::Reykjavik,
            57 => FitFieldTimeZone::Rome,
            58 => FitFieldTimeZone::Stockholm,
            59 => FitFieldTimeZone::Vienna,
            60 => FitFieldTimeZone::Warsaw,
            61 => FitFieldTimeZone::Zurich,
            62 => FitFieldTimeZone::Quebec,
            63 => FitFieldTimeZone::Ontario,
            64 => FitFieldTimeZone::Manitoba,
            65 => FitFieldTimeZone::Saskatchewan,
            66 => FitFieldTimeZone::Alberta,
            67 => FitFieldTimeZone::BritishColumbia,
            68 => FitFieldTimeZone::Boise,
            69 => FitFieldTimeZone::Boston,
            70 => FitFieldTimeZone::Chicago,
            71 => FitFieldTimeZone::Dallas,
            72 => FitFieldTimeZone::Denver,
            73 => FitFieldTimeZone::KansasCity,
            74 => FitFieldTimeZone::LasVegas,
            75 => FitFieldTimeZone::LosAngeles,
            76 => FitFieldTimeZone::Miami,
            77 => FitFieldTimeZone::Minneapolis,
            78 => FitFieldTimeZone::NewYork,
            79 => FitFieldTimeZone::NewOrleans,
            80 => FitFieldTimeZone::Phoenix,
            81 => FitFieldTimeZone::SantaFe,
            82 => FitFieldTimeZone::Seattle,
            83 => FitFieldTimeZone::WashingtonDc,
            84 => FitFieldTimeZone::UsArizona,
            85 => FitFieldTimeZone::Chita,
            86 => FitFieldTimeZone::Ekaterinburg,
            87 => FitFieldTimeZone::Irkutsk,
            88 => FitFieldTimeZone::Kaliningrad,
            89 => FitFieldTimeZone::Krasnoyarsk,
            90 => FitFieldTimeZone::Novosibirsk,
            91 => FitFieldTimeZone::PetropavlovskKamchatskiy,
            92 => FitFieldTimeZone::Samara,
            93 => FitFieldTimeZone::Vladivostok,
            94 => FitFieldTimeZone::MexicoCentral,
            95 => FitFieldTimeZone::MexicoMountain,
            96 => FitFieldTimeZone::MexicoPacific,
            97 => FitFieldTimeZone::CapeTown,
            98 => FitFieldTimeZone::Winkhoek,
            99 => FitFieldTimeZone::Lagos,
            100 => FitFieldTimeZone::Riyahd,
            101 => FitFieldTimeZone::Venezuela,
            102 => FitFieldTimeZone::AustraliaLh,
            103 => FitFieldTimeZone::Santiago,
            253 => FitFieldTimeZone::Manual,
            254 => FitFieldTimeZone::Automatic,
            _ => FitFieldTimeZone::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDisplayMeasure {
    // fit base type: enum
    Metric = 0,
    Statute = 1,
    Nautical = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDisplayMeasure {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDisplayMeasure::Metric => write!(f, "{}", "Metric"),
            FitFieldDisplayMeasure::Statute => write!(f, "{}", "Statute"),
            FitFieldDisplayMeasure::Nautical => write!(f, "{}", "Nautical"),
            FitFieldDisplayMeasure::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDisplayMeasure::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDisplayMeasure {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDisplayMeasure> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDisplayMeasure::from(v)),
            Err(_) => Ok(FitFieldDisplayMeasure::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDisplayMeasure);

impl From<u8> for FitFieldDisplayMeasure {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayMeasure::Metric,
            1 => FitFieldDisplayMeasure::Statute,
            2 => FitFieldDisplayMeasure::Nautical,
            _ => FitFieldDisplayMeasure::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDisplayHeart {
    // fit base type: enum
    Bpm = 0,
    Max = 1,
    Reserve = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDisplayHeart {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDisplayHeart::Bpm => write!(f, "{}", "Bpm"),
            FitFieldDisplayHeart::Max => write!(f, "{}", "Max"),
            FitFieldDisplayHeart::Reserve => write!(f, "{}", "Reserve"),
            FitFieldDisplayHeart::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDisplayHeart::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDisplayHeart {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDisplayHeart> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDisplayHeart::from(v)),
            Err(_) => Ok(FitFieldDisplayHeart::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDisplayHeart);

impl From<u8> for FitFieldDisplayHeart {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayHeart::Bpm,
            1 => FitFieldDisplayHeart::Max,
            2 => FitFieldDisplayHeart::Reserve,
            _ => FitFieldDisplayHeart::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDisplayPower {
    // fit base type: enum
    Watts = 0,
    PercentFtp = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDisplayPower {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDisplayPower::Watts => write!(f, "{}", "Watts"),
            FitFieldDisplayPower::PercentFtp => write!(f, "{}", "PercentFtp"),
            FitFieldDisplayPower::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDisplayPower::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDisplayPower {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDisplayPower> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDisplayPower::from(v)),
            Err(_) => Ok(FitFieldDisplayPower::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDisplayPower);

impl From<u8> for FitFieldDisplayPower {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayPower::Watts,
            1 => FitFieldDisplayPower::PercentFtp,
            _ => FitFieldDisplayPower::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDisplayPosition {
    // fit base type: enum
    Degree = 0,                // dd.dddddd
    DegreeMinute = 1,          // dddmm.mmm
    DegreeMinuteSecond = 2,    // dddmmss
    AustrianGrid = 3,          // Austrian Grid (BMN)
    BritishGrid = 4,           // British National Grid
    DutchGrid = 5,             // Dutch grid system
    HungarianGrid = 6,         // Hungarian grid system
    FinnishGrid = 7,           // Finnish grid system Zone3 KKJ27
    GermanGrid = 8,            // Gausss Krueger (German)
    IcelandicGrid = 9,         // Icelandic Grid
    IndonesianEquatorial = 10, // Indonesian Equatorial LCO
    IndonesianIrian = 11,      // Indonesian Irian LCO
    IndonesianSouthern = 12,   // Indonesian Southern LCO
    IndiaZone0 = 13,           // India zone 0
    IndiaZoneIA = 14,          // India zone IA
    IndiaZoneIB = 15,          // India zone IB
    IndiaZoneIIA = 16,         // India zone IIA
    IndiaZoneIIB = 17,         // India zone IIB
    IndiaZoneIIIA = 18,        // India zone IIIA
    IndiaZoneIIIB = 19,        // India zone IIIB
    IndiaZoneIVA = 20,         // India zone IVA
    IndiaZoneIVB = 21,         // India zone IVB
    IrishTransverse = 22,      // Irish Transverse Mercator
    IrishGrid = 23,            // Irish Grid
    Loran = 24,                // Loran TD
    MaidenheadGrid = 25,       // Maidenhead grid system
    MgrsGrid = 26,             // MGRS grid system
    NewZealandGrid = 27,       // New Zealand grid system
    NewZealandTransverse = 28, // New Zealand Transverse Mercator
    QatarGrid = 29,            // Qatar National Grid
    ModifiedSwedishGrid = 30,  // Modified RT-90 (Sweden)
    SwedishGrid = 31,          // RT-90 (Sweden)
    SouthAfricanGrid = 32,     // South African Grid
    SwissGrid = 33,            // Swiss CH-1903 grid
    TaiwanGrid = 34,           // Taiwan Grid
    UnitedStatesGrid = 35,     // United States National Grid
    UtmUpsGrid = 36,           // UTM/UPS grid system
    WestMalayan = 37,          // West Malayan RSO
    BorneoRso = 38,            // Borneo RSO
    EstonianGrid = 39,         // Estonian grid system
    LatvianGrid = 40,          // Latvian Transverse Mercator
    SwedishRef99Grid = 41,     // Reference Grid 99 TM (Swedish)
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDisplayPosition {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDisplayPosition::Degree => write!(f, "{}", "Degree"),
            FitFieldDisplayPosition::DegreeMinute => write!(f, "{}", "DegreeMinute"),
            FitFieldDisplayPosition::DegreeMinuteSecond => write!(f, "{}", "DegreeMinuteSecond"),
            FitFieldDisplayPosition::AustrianGrid => write!(f, "{}", "AustrianGrid"),
            FitFieldDisplayPosition::BritishGrid => write!(f, "{}", "BritishGrid"),
            FitFieldDisplayPosition::DutchGrid => write!(f, "{}", "DutchGrid"),
            FitFieldDisplayPosition::HungarianGrid => write!(f, "{}", "HungarianGrid"),
            FitFieldDisplayPosition::FinnishGrid => write!(f, "{}", "FinnishGrid"),
            FitFieldDisplayPosition::GermanGrid => write!(f, "{}", "GermanGrid"),
            FitFieldDisplayPosition::IcelandicGrid => write!(f, "{}", "IcelandicGrid"),
            FitFieldDisplayPosition::IndonesianEquatorial => {
                write!(f, "{}", "IndonesianEquatorial")
            }
            FitFieldDisplayPosition::IndonesianIrian => write!(f, "{}", "IndonesianIrian"),
            FitFieldDisplayPosition::IndonesianSouthern => write!(f, "{}", "IndonesianSouthern"),
            FitFieldDisplayPosition::IndiaZone0 => write!(f, "{}", "IndiaZone0"),
            FitFieldDisplayPosition::IndiaZoneIA => write!(f, "{}", "IndiaZoneIA"),
            FitFieldDisplayPosition::IndiaZoneIB => write!(f, "{}", "IndiaZoneIB"),
            FitFieldDisplayPosition::IndiaZoneIIA => write!(f, "{}", "IndiaZoneIIA"),
            FitFieldDisplayPosition::IndiaZoneIIB => write!(f, "{}", "IndiaZoneIIB"),
            FitFieldDisplayPosition::IndiaZoneIIIA => write!(f, "{}", "IndiaZoneIIIA"),
            FitFieldDisplayPosition::IndiaZoneIIIB => write!(f, "{}", "IndiaZoneIIIB"),
            FitFieldDisplayPosition::IndiaZoneIVA => write!(f, "{}", "IndiaZoneIVA"),
            FitFieldDisplayPosition::IndiaZoneIVB => write!(f, "{}", "IndiaZoneIVB"),
            FitFieldDisplayPosition::IrishTransverse => write!(f, "{}", "IrishTransverse"),
            FitFieldDisplayPosition::IrishGrid => write!(f, "{}", "IrishGrid"),
            FitFieldDisplayPosition::Loran => write!(f, "{}", "Loran"),
            FitFieldDisplayPosition::MaidenheadGrid => write!(f, "{}", "MaidenheadGrid"),
            FitFieldDisplayPosition::MgrsGrid => write!(f, "{}", "MgrsGrid"),
            FitFieldDisplayPosition::NewZealandGrid => write!(f, "{}", "NewZealandGrid"),
            FitFieldDisplayPosition::NewZealandTransverse => {
                write!(f, "{}", "NewZealandTransverse")
            }
            FitFieldDisplayPosition::QatarGrid => write!(f, "{}", "QatarGrid"),
            FitFieldDisplayPosition::ModifiedSwedishGrid => write!(f, "{}", "ModifiedSwedishGrid"),
            FitFieldDisplayPosition::SwedishGrid => write!(f, "{}", "SwedishGrid"),
            FitFieldDisplayPosition::SouthAfricanGrid => write!(f, "{}", "SouthAfricanGrid"),
            FitFieldDisplayPosition::SwissGrid => write!(f, "{}", "SwissGrid"),
            FitFieldDisplayPosition::TaiwanGrid => write!(f, "{}", "TaiwanGrid"),
            FitFieldDisplayPosition::UnitedStatesGrid => write!(f, "{}", "UnitedStatesGrid"),
            FitFieldDisplayPosition::UtmUpsGrid => write!(f, "{}", "UtmUpsGrid"),
            FitFieldDisplayPosition::WestMalayan => write!(f, "{}", "WestMalayan"),
            FitFieldDisplayPosition::BorneoRso => write!(f, "{}", "BorneoRso"),
            FitFieldDisplayPosition::EstonianGrid => write!(f, "{}", "EstonianGrid"),
            FitFieldDisplayPosition::LatvianGrid => write!(f, "{}", "LatvianGrid"),
            FitFieldDisplayPosition::SwedishRef99Grid => write!(f, "{}", "SwedishRef99Grid"),
            FitFieldDisplayPosition::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDisplayPosition::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDisplayPosition {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDisplayPosition> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDisplayPosition::from(v)),
            Err(_) => Ok(FitFieldDisplayPosition::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDisplayPosition);

impl From<u8> for FitFieldDisplayPosition {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayPosition::Degree,
            1 => FitFieldDisplayPosition::DegreeMinute,
            2 => FitFieldDisplayPosition::DegreeMinuteSecond,
            3 => FitFieldDisplayPosition::AustrianGrid,
            4 => FitFieldDisplayPosition::BritishGrid,
            5 => FitFieldDisplayPosition::DutchGrid,
            6 => FitFieldDisplayPosition::HungarianGrid,
            7 => FitFieldDisplayPosition::FinnishGrid,
            8 => FitFieldDisplayPosition::GermanGrid,
            9 => FitFieldDisplayPosition::IcelandicGrid,
            10 => FitFieldDisplayPosition::IndonesianEquatorial,
            11 => FitFieldDisplayPosition::IndonesianIrian,
            12 => FitFieldDisplayPosition::IndonesianSouthern,
            13 => FitFieldDisplayPosition::IndiaZone0,
            14 => FitFieldDisplayPosition::IndiaZoneIA,
            15 => FitFieldDisplayPosition::IndiaZoneIB,
            16 => FitFieldDisplayPosition::IndiaZoneIIA,
            17 => FitFieldDisplayPosition::IndiaZoneIIB,
            18 => FitFieldDisplayPosition::IndiaZoneIIIA,
            19 => FitFieldDisplayPosition::IndiaZoneIIIB,
            20 => FitFieldDisplayPosition::IndiaZoneIVA,
            21 => FitFieldDisplayPosition::IndiaZoneIVB,
            22 => FitFieldDisplayPosition::IrishTransverse,
            23 => FitFieldDisplayPosition::IrishGrid,
            24 => FitFieldDisplayPosition::Loran,
            25 => FitFieldDisplayPosition::MaidenheadGrid,
            26 => FitFieldDisplayPosition::MgrsGrid,
            27 => FitFieldDisplayPosition::NewZealandGrid,
            28 => FitFieldDisplayPosition::NewZealandTransverse,
            29 => FitFieldDisplayPosition::QatarGrid,
            30 => FitFieldDisplayPosition::ModifiedSwedishGrid,
            31 => FitFieldDisplayPosition::SwedishGrid,
            32 => FitFieldDisplayPosition::SouthAfricanGrid,
            33 => FitFieldDisplayPosition::SwissGrid,
            34 => FitFieldDisplayPosition::TaiwanGrid,
            35 => FitFieldDisplayPosition::UnitedStatesGrid,
            36 => FitFieldDisplayPosition::UtmUpsGrid,
            37 => FitFieldDisplayPosition::WestMalayan,
            38 => FitFieldDisplayPosition::BorneoRso,
            39 => FitFieldDisplayPosition::EstonianGrid,
            40 => FitFieldDisplayPosition::LatvianGrid,
            41 => FitFieldDisplayPosition::SwedishRef99Grid,
            _ => FitFieldDisplayPosition::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSwitch {
    // fit base type: enum
    Off = 0,
    On = 1,
    Auto = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSwitch {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSwitch::Off => write!(f, "{}", "Off"),
            FitFieldSwitch::On => write!(f, "{}", "On"),
            FitFieldSwitch::Auto => write!(f, "{}", "Auto"),
            FitFieldSwitch::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSwitch::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSwitch {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSwitch> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSwitch::from(v)),
            Err(_) => Ok(FitFieldSwitch::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSwitch);

impl From<u8> for FitFieldSwitch {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSwitch::Off,
            1 => FitFieldSwitch::On,
            2 => FitFieldSwitch::Auto,
            _ => FitFieldSwitch::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSport {
    // fit base type: enum
    Generic = 0,
    Running = 1,
    Cycling = 2,
    Transition = 3, // Mulitsport transition
    FitnessEquipment = 4,
    Swimming = 5,
    Basketball = 6,
    Soccer = 7,
    Tennis = 8,
    AmericanFootball = 9,
    Training = 10,
    Walking = 11,
    CrossCountrySkiing = 12,
    AlpineSkiing = 13,
    Snowboarding = 14,
    Rowing = 15,
    Mountaineering = 16,
    Hiking = 17,
    Multisport = 18,
    Paddling = 19,
    Flying = 20,
    EBiking = 21,
    Motorcycling = 22,
    Boating = 23,
    Driving = 24,
    Golf = 25,
    HangGliding = 26,
    HorsebackRiding = 27,
    Hunting = 28,
    Fishing = 29,
    InlineSkating = 30,
    RockClimbing = 31,
    Sailing = 32,
    IceSkating = 33,
    SkyDiving = 34,
    Snowshoeing = 35,
    Snowmobiling = 36,
    StandUpPaddleboarding = 37,
    Surfing = 38,
    Wakeboarding = 39,
    WaterSkiing = 40,
    Kayaking = 41,
    Rafting = 42,
    Windsurfing = 43,
    Kitesurfing = 44,
    Tactical = 45,
    Jumpmaster = 46,
    Boxing = 47,
    FloorClimbing = 48,
    All = 254, // All is for goals only to include all sports.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSport::Generic => write!(f, "{}", "Generic"),
            FitFieldSport::Running => write!(f, "{}", "Running"),
            FitFieldSport::Cycling => write!(f, "{}", "Cycling"),
            FitFieldSport::Transition => write!(f, "{}", "Transition"),
            FitFieldSport::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldSport::Swimming => write!(f, "{}", "Swimming"),
            FitFieldSport::Basketball => write!(f, "{}", "Basketball"),
            FitFieldSport::Soccer => write!(f, "{}", "Soccer"),
            FitFieldSport::Tennis => write!(f, "{}", "Tennis"),
            FitFieldSport::AmericanFootball => write!(f, "{}", "AmericanFootball"),
            FitFieldSport::Training => write!(f, "{}", "Training"),
            FitFieldSport::Walking => write!(f, "{}", "Walking"),
            FitFieldSport::CrossCountrySkiing => write!(f, "{}", "CrossCountrySkiing"),
            FitFieldSport::AlpineSkiing => write!(f, "{}", "AlpineSkiing"),
            FitFieldSport::Snowboarding => write!(f, "{}", "Snowboarding"),
            FitFieldSport::Rowing => write!(f, "{}", "Rowing"),
            FitFieldSport::Mountaineering => write!(f, "{}", "Mountaineering"),
            FitFieldSport::Hiking => write!(f, "{}", "Hiking"),
            FitFieldSport::Multisport => write!(f, "{}", "Multisport"),
            FitFieldSport::Paddling => write!(f, "{}", "Paddling"),
            FitFieldSport::Flying => write!(f, "{}", "Flying"),
            FitFieldSport::EBiking => write!(f, "{}", "EBiking"),
            FitFieldSport::Motorcycling => write!(f, "{}", "Motorcycling"),
            FitFieldSport::Boating => write!(f, "{}", "Boating"),
            FitFieldSport::Driving => write!(f, "{}", "Driving"),
            FitFieldSport::Golf => write!(f, "{}", "Golf"),
            FitFieldSport::HangGliding => write!(f, "{}", "HangGliding"),
            FitFieldSport::HorsebackRiding => write!(f, "{}", "HorsebackRiding"),
            FitFieldSport::Hunting => write!(f, "{}", "Hunting"),
            FitFieldSport::Fishing => write!(f, "{}", "Fishing"),
            FitFieldSport::InlineSkating => write!(f, "{}", "InlineSkating"),
            FitFieldSport::RockClimbing => write!(f, "{}", "RockClimbing"),
            FitFieldSport::Sailing => write!(f, "{}", "Sailing"),
            FitFieldSport::IceSkating => write!(f, "{}", "IceSkating"),
            FitFieldSport::SkyDiving => write!(f, "{}", "SkyDiving"),
            FitFieldSport::Snowshoeing => write!(f, "{}", "Snowshoeing"),
            FitFieldSport::Snowmobiling => write!(f, "{}", "Snowmobiling"),
            FitFieldSport::StandUpPaddleboarding => write!(f, "{}", "StandUpPaddleboarding"),
            FitFieldSport::Surfing => write!(f, "{}", "Surfing"),
            FitFieldSport::Wakeboarding => write!(f, "{}", "Wakeboarding"),
            FitFieldSport::WaterSkiing => write!(f, "{}", "WaterSkiing"),
            FitFieldSport::Kayaking => write!(f, "{}", "Kayaking"),
            FitFieldSport::Rafting => write!(f, "{}", "Rafting"),
            FitFieldSport::Windsurfing => write!(f, "{}", "Windsurfing"),
            FitFieldSport::Kitesurfing => write!(f, "{}", "Kitesurfing"),
            FitFieldSport::Tactical => write!(f, "{}", "Tactical"),
            FitFieldSport::Jumpmaster => write!(f, "{}", "Jumpmaster"),
            FitFieldSport::Boxing => write!(f, "{}", "Boxing"),
            FitFieldSport::FloorClimbing => write!(f, "{}", "FloorClimbing"),
            FitFieldSport::All => write!(f, "{}", "All"),
            FitFieldSport::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSport::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSport {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSport> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSport::from(v)),
            Err(_) => Ok(FitFieldSport::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSport);

impl From<u8> for FitFieldSport {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSport::Generic,
            1 => FitFieldSport::Running,
            2 => FitFieldSport::Cycling,
            3 => FitFieldSport::Transition,
            4 => FitFieldSport::FitnessEquipment,
            5 => FitFieldSport::Swimming,
            6 => FitFieldSport::Basketball,
            7 => FitFieldSport::Soccer,
            8 => FitFieldSport::Tennis,
            9 => FitFieldSport::AmericanFootball,
            10 => FitFieldSport::Training,
            11 => FitFieldSport::Walking,
            12 => FitFieldSport::CrossCountrySkiing,
            13 => FitFieldSport::AlpineSkiing,
            14 => FitFieldSport::Snowboarding,
            15 => FitFieldSport::Rowing,
            16 => FitFieldSport::Mountaineering,
            17 => FitFieldSport::Hiking,
            18 => FitFieldSport::Multisport,
            19 => FitFieldSport::Paddling,
            20 => FitFieldSport::Flying,
            21 => FitFieldSport::EBiking,
            22 => FitFieldSport::Motorcycling,
            23 => FitFieldSport::Boating,
            24 => FitFieldSport::Driving,
            25 => FitFieldSport::Golf,
            26 => FitFieldSport::HangGliding,
            27 => FitFieldSport::HorsebackRiding,
            28 => FitFieldSport::Hunting,
            29 => FitFieldSport::Fishing,
            30 => FitFieldSport::InlineSkating,
            31 => FitFieldSport::RockClimbing,
            32 => FitFieldSport::Sailing,
            33 => FitFieldSport::IceSkating,
            34 => FitFieldSport::SkyDiving,
            35 => FitFieldSport::Snowshoeing,
            36 => FitFieldSport::Snowmobiling,
            37 => FitFieldSport::StandUpPaddleboarding,
            38 => FitFieldSport::Surfing,
            39 => FitFieldSport::Wakeboarding,
            40 => FitFieldSport::WaterSkiing,
            41 => FitFieldSport::Kayaking,
            42 => FitFieldSport::Rafting,
            43 => FitFieldSport::Windsurfing,
            44 => FitFieldSport::Kitesurfing,
            45 => FitFieldSport::Tactical,
            46 => FitFieldSport::Jumpmaster,
            47 => FitFieldSport::Boxing,
            48 => FitFieldSport::FloorClimbing,
            254 => FitFieldSport::All,
            _ => FitFieldSport::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits0 {
    // fit base type: uint8z
    Generic,          // 1
    Running,          // 2
    Cycling,          // 4
    Transition,       // 8  Mulitsport transition
    FitnessEquipment, // 16
    Swimming,         // 32
    Basketball,       // 64
    Soccer,           // 128
    SportBits0(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits0 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits0::Generic => write!(f, "{}", "Generic"),
            FitFieldSportBits0::Running => write!(f, "{}", "Running"),
            FitFieldSportBits0::Cycling => write!(f, "{}", "Cycling"),
            FitFieldSportBits0::Transition => write!(f, "{}", "Transition"),
            FitFieldSportBits0::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldSportBits0::Swimming => write!(f, "{}", "Swimming"),
            FitFieldSportBits0::Basketball => write!(f, "{}", "Basketball"),
            FitFieldSportBits0::Soccer => write!(f, "{}", "Soccer"),
            FitFieldSportBits0::SportBits0(x) => write!(f, "{}({})", "SportBits0", x),
            FitFieldSportBits0::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits0::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits0 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits0> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits0::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits0::from(v)),
                2 => Ok(FitFieldSportBits0::from(v)),
                4 => Ok(FitFieldSportBits0::from(v)),
                8 => Ok(FitFieldSportBits0::from(v)),
                16 => Ok(FitFieldSportBits0::from(v)),
                32 => Ok(FitFieldSportBits0::from(v)),
                64 => Ok(FitFieldSportBits0::from(v)),
                128 => Ok(FitFieldSportBits0::from(v)),
                v => Ok(FitFieldSportBits0::SportBits0(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits0);

impl From<u8> for FitFieldSportBits0 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits0::Generic,
            2 => FitFieldSportBits0::Running,
            4 => FitFieldSportBits0::Cycling,
            8 => FitFieldSportBits0::Transition,
            16 => FitFieldSportBits0::FitnessEquipment,
            32 => FitFieldSportBits0::Swimming,
            64 => FitFieldSportBits0::Basketball,
            128 => FitFieldSportBits0::Soccer,
            _ => FitFieldSportBits0::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits1 {
    // fit base type: uint8z
    Tennis,             // 1
    AmericanFootball,   // 2
    Training,           // 4
    Walking,            // 8
    CrossCountrySkiing, // 16
    AlpineSkiing,       // 32
    Snowboarding,       // 64
    Rowing,             // 128
    SportBits1(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits1 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits1::Tennis => write!(f, "{}", "Tennis"),
            FitFieldSportBits1::AmericanFootball => write!(f, "{}", "AmericanFootball"),
            FitFieldSportBits1::Training => write!(f, "{}", "Training"),
            FitFieldSportBits1::Walking => write!(f, "{}", "Walking"),
            FitFieldSportBits1::CrossCountrySkiing => write!(f, "{}", "CrossCountrySkiing"),
            FitFieldSportBits1::AlpineSkiing => write!(f, "{}", "AlpineSkiing"),
            FitFieldSportBits1::Snowboarding => write!(f, "{}", "Snowboarding"),
            FitFieldSportBits1::Rowing => write!(f, "{}", "Rowing"),
            FitFieldSportBits1::SportBits1(x) => write!(f, "{}({})", "SportBits1", x),
            FitFieldSportBits1::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits1::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits1 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits1> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits1::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits1::from(v)),
                2 => Ok(FitFieldSportBits1::from(v)),
                4 => Ok(FitFieldSportBits1::from(v)),
                8 => Ok(FitFieldSportBits1::from(v)),
                16 => Ok(FitFieldSportBits1::from(v)),
                32 => Ok(FitFieldSportBits1::from(v)),
                64 => Ok(FitFieldSportBits1::from(v)),
                128 => Ok(FitFieldSportBits1::from(v)),
                v => Ok(FitFieldSportBits1::SportBits1(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits1);

impl From<u8> for FitFieldSportBits1 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits1::Tennis,
            2 => FitFieldSportBits1::AmericanFootball,
            4 => FitFieldSportBits1::Training,
            8 => FitFieldSportBits1::Walking,
            16 => FitFieldSportBits1::CrossCountrySkiing,
            32 => FitFieldSportBits1::AlpineSkiing,
            64 => FitFieldSportBits1::Snowboarding,
            128 => FitFieldSportBits1::Rowing,
            _ => FitFieldSportBits1::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits2 {
    // fit base type: uint8z
    Mountaineering, // 1
    Hiking,         // 2
    Multisport,     // 4
    Paddling,       // 8
    Flying,         // 16
    EBiking,        // 32
    Motorcycling,   // 64
    Boating,        // 128
    SportBits2(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits2 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits2::Mountaineering => write!(f, "{}", "Mountaineering"),
            FitFieldSportBits2::Hiking => write!(f, "{}", "Hiking"),
            FitFieldSportBits2::Multisport => write!(f, "{}", "Multisport"),
            FitFieldSportBits2::Paddling => write!(f, "{}", "Paddling"),
            FitFieldSportBits2::Flying => write!(f, "{}", "Flying"),
            FitFieldSportBits2::EBiking => write!(f, "{}", "EBiking"),
            FitFieldSportBits2::Motorcycling => write!(f, "{}", "Motorcycling"),
            FitFieldSportBits2::Boating => write!(f, "{}", "Boating"),
            FitFieldSportBits2::SportBits2(x) => write!(f, "{}({})", "SportBits2", x),
            FitFieldSportBits2::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits2::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits2 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits2> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits2::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits2::from(v)),
                2 => Ok(FitFieldSportBits2::from(v)),
                4 => Ok(FitFieldSportBits2::from(v)),
                8 => Ok(FitFieldSportBits2::from(v)),
                16 => Ok(FitFieldSportBits2::from(v)),
                32 => Ok(FitFieldSportBits2::from(v)),
                64 => Ok(FitFieldSportBits2::from(v)),
                128 => Ok(FitFieldSportBits2::from(v)),
                v => Ok(FitFieldSportBits2::SportBits2(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits2);

impl From<u8> for FitFieldSportBits2 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits2::Mountaineering,
            2 => FitFieldSportBits2::Hiking,
            4 => FitFieldSportBits2::Multisport,
            8 => FitFieldSportBits2::Paddling,
            16 => FitFieldSportBits2::Flying,
            32 => FitFieldSportBits2::EBiking,
            64 => FitFieldSportBits2::Motorcycling,
            128 => FitFieldSportBits2::Boating,
            _ => FitFieldSportBits2::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits3 {
    // fit base type: uint8z
    Driving,         // 1
    Golf,            // 2
    HangGliding,     // 4
    HorsebackRiding, // 8
    Hunting,         // 16
    Fishing,         // 32
    InlineSkating,   // 64
    RockClimbing,    // 128
    SportBits3(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits3 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits3::Driving => write!(f, "{}", "Driving"),
            FitFieldSportBits3::Golf => write!(f, "{}", "Golf"),
            FitFieldSportBits3::HangGliding => write!(f, "{}", "HangGliding"),
            FitFieldSportBits3::HorsebackRiding => write!(f, "{}", "HorsebackRiding"),
            FitFieldSportBits3::Hunting => write!(f, "{}", "Hunting"),
            FitFieldSportBits3::Fishing => write!(f, "{}", "Fishing"),
            FitFieldSportBits3::InlineSkating => write!(f, "{}", "InlineSkating"),
            FitFieldSportBits3::RockClimbing => write!(f, "{}", "RockClimbing"),
            FitFieldSportBits3::SportBits3(x) => write!(f, "{}({})", "SportBits3", x),
            FitFieldSportBits3::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits3::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits3 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits3> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits3::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits3::from(v)),
                2 => Ok(FitFieldSportBits3::from(v)),
                4 => Ok(FitFieldSportBits3::from(v)),
                8 => Ok(FitFieldSportBits3::from(v)),
                16 => Ok(FitFieldSportBits3::from(v)),
                32 => Ok(FitFieldSportBits3::from(v)),
                64 => Ok(FitFieldSportBits3::from(v)),
                128 => Ok(FitFieldSportBits3::from(v)),
                v => Ok(FitFieldSportBits3::SportBits3(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits3);

impl From<u8> for FitFieldSportBits3 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits3::Driving,
            2 => FitFieldSportBits3::Golf,
            4 => FitFieldSportBits3::HangGliding,
            8 => FitFieldSportBits3::HorsebackRiding,
            16 => FitFieldSportBits3::Hunting,
            32 => FitFieldSportBits3::Fishing,
            64 => FitFieldSportBits3::InlineSkating,
            128 => FitFieldSportBits3::RockClimbing,
            _ => FitFieldSportBits3::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits4 {
    // fit base type: uint8z
    Sailing,               // 1
    IceSkating,            // 2
    SkyDiving,             // 4
    Snowshoeing,           // 8
    Snowmobiling,          // 16
    StandUpPaddleboarding, // 32
    Surfing,               // 64
    Wakeboarding,          // 128
    SportBits4(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits4 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits4::Sailing => write!(f, "{}", "Sailing"),
            FitFieldSportBits4::IceSkating => write!(f, "{}", "IceSkating"),
            FitFieldSportBits4::SkyDiving => write!(f, "{}", "SkyDiving"),
            FitFieldSportBits4::Snowshoeing => write!(f, "{}", "Snowshoeing"),
            FitFieldSportBits4::Snowmobiling => write!(f, "{}", "Snowmobiling"),
            FitFieldSportBits4::StandUpPaddleboarding => write!(f, "{}", "StandUpPaddleboarding"),
            FitFieldSportBits4::Surfing => write!(f, "{}", "Surfing"),
            FitFieldSportBits4::Wakeboarding => write!(f, "{}", "Wakeboarding"),
            FitFieldSportBits4::SportBits4(x) => write!(f, "{}({})", "SportBits4", x),
            FitFieldSportBits4::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits4::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits4 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits4> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits4::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits4::from(v)),
                2 => Ok(FitFieldSportBits4::from(v)),
                4 => Ok(FitFieldSportBits4::from(v)),
                8 => Ok(FitFieldSportBits4::from(v)),
                16 => Ok(FitFieldSportBits4::from(v)),
                32 => Ok(FitFieldSportBits4::from(v)),
                64 => Ok(FitFieldSportBits4::from(v)),
                128 => Ok(FitFieldSportBits4::from(v)),
                v => Ok(FitFieldSportBits4::SportBits4(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits4);

impl From<u8> for FitFieldSportBits4 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits4::Sailing,
            2 => FitFieldSportBits4::IceSkating,
            4 => FitFieldSportBits4::SkyDiving,
            8 => FitFieldSportBits4::Snowshoeing,
            16 => FitFieldSportBits4::Snowmobiling,
            32 => FitFieldSportBits4::StandUpPaddleboarding,
            64 => FitFieldSportBits4::Surfing,
            128 => FitFieldSportBits4::Wakeboarding,
            _ => FitFieldSportBits4::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits5 {
    // fit base type: uint8z
    WaterSkiing, // 1
    Kayaking,    // 2
    Rafting,     // 4
    Windsurfing, // 8
    Kitesurfing, // 16
    Tactical,    // 32
    Jumpmaster,  // 64
    Boxing,      // 128
    SportBits5(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits5 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits5::WaterSkiing => write!(f, "{}", "WaterSkiing"),
            FitFieldSportBits5::Kayaking => write!(f, "{}", "Kayaking"),
            FitFieldSportBits5::Rafting => write!(f, "{}", "Rafting"),
            FitFieldSportBits5::Windsurfing => write!(f, "{}", "Windsurfing"),
            FitFieldSportBits5::Kitesurfing => write!(f, "{}", "Kitesurfing"),
            FitFieldSportBits5::Tactical => write!(f, "{}", "Tactical"),
            FitFieldSportBits5::Jumpmaster => write!(f, "{}", "Jumpmaster"),
            FitFieldSportBits5::Boxing => write!(f, "{}", "Boxing"),
            FitFieldSportBits5::SportBits5(x) => write!(f, "{}({})", "SportBits5", x),
            FitFieldSportBits5::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits5::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits5 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits5> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits5::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits5::from(v)),
                2 => Ok(FitFieldSportBits5::from(v)),
                4 => Ok(FitFieldSportBits5::from(v)),
                8 => Ok(FitFieldSportBits5::from(v)),
                16 => Ok(FitFieldSportBits5::from(v)),
                32 => Ok(FitFieldSportBits5::from(v)),
                64 => Ok(FitFieldSportBits5::from(v)),
                128 => Ok(FitFieldSportBits5::from(v)),
                v => Ok(FitFieldSportBits5::SportBits5(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits5);

impl From<u8> for FitFieldSportBits5 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits5::WaterSkiing,
            2 => FitFieldSportBits5::Kayaking,
            4 => FitFieldSportBits5::Rafting,
            8 => FitFieldSportBits5::Windsurfing,
            16 => FitFieldSportBits5::Kitesurfing,
            32 => FitFieldSportBits5::Tactical,
            64 => FitFieldSportBits5::Jumpmaster,
            128 => FitFieldSportBits5::Boxing,
            _ => FitFieldSportBits5::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportBits6 {
    // fit base type: uint8z
    FloorClimbing, // 1
    SportBits6(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSportBits6 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportBits6::FloorClimbing => write!(f, "{}", "FloorClimbing"),
            FitFieldSportBits6::SportBits6(x) => write!(f, "{}({})", "SportBits6", x),
            FitFieldSportBits6::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportBits6::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportBits6 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportBits6> {
        let val = parse_uint8z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSportBits6::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSportBits6::from(v)),
                v => Ok(FitFieldSportBits6::SportBits6(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSportBits6);

impl From<u8> for FitFieldSportBits6 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits6::FloorClimbing,
            _ => FitFieldSportBits6::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSubSport {
    // fit base type: enum
    Generic = 0,
    Treadmill = 1,            // Run/Fitness Equipment
    Street = 2,               // Run
    Trail = 3,                // Run
    Track = 4,                // Run
    Spin = 5,                 // Cycling
    IndoorCycling = 6,        // Cycling/Fitness Equipment
    Road = 7,                 // Cycling
    Mountain = 8,             // Cycling
    Downhill = 9,             // Cycling
    Recumbent = 10,           // Cycling
    Cyclocross = 11,          // Cycling
    HandCycling = 12,         // Cycling
    TrackCycling = 13,        // Cycling
    IndoorRowing = 14,        // Fitness Equipment
    Elliptical = 15,          // Fitness Equipment
    StairClimbing = 16,       // Fitness Equipment
    LapSwimming = 17,         // Swimming
    OpenWater = 18,           // Swimming
    FlexibilityTraining = 19, // Training
    StrengthTraining = 20,    // Training
    WarmUp = 21,              // Tennis
    Match = 22,               // Tennis
    Exercise = 23,            // Tennis
    Challenge = 24,
    IndoorSkiing = 25,         // Fitness Equipment
    CardioTraining = 26,       // Training
    IndoorWalking = 27,        // Walking/Fitness Equipment
    EBikeFitness = 28,         // E-Biking
    Bmx = 29,                  // Cycling
    CasualWalking = 30,        // Walking
    SpeedWalking = 31,         // Walking
    BikeToRunTransition = 32,  // Transition
    RunToBikeTransition = 33,  // Transition
    SwimToBikeTransition = 34, // Transition
    Atv = 35,                  // Motorcycling
    Motocross = 36,            // Motorcycling
    Backcountry = 37,          // Alpine Skiing/Snowboarding
    Resort = 38,               // Alpine Skiing/Snowboarding
    RcDrone = 39,              // Flying
    Wingsuit = 40,             // Flying
    Whitewater = 41,           // Kayaking/Rafting
    SkateSkiing = 42,          // Cross Country Skiing
    Yoga = 43,                 // Training
    Pilates = 44,              // Fitness Equipment
    IndoorRunning = 45,        // Run
    GravelCycling = 46,        // Cycling
    EBikeMountain = 47,        // Cycling
    Commuting = 48,            // Cycling
    MixedSurface = 49,         // Cycling
    Navigate = 50,
    TrackMe = 51,
    Map = 52,
    SingleGasDiving = 53, // Diving
    MultiGasDiving = 54,  // Diving
    GaugeDiving = 55,     // Diving
    ApneaDiving = 56,     // Diving
    ApneaHunting = 57,    // Diving
    VirtualActivity = 58,
    Obstacle = 59, // Used for events where participants run, crawl through mud, climb over walls, etc.
    All = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSubSport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSubSport::Generic => write!(f, "{}", "Generic"),
            FitFieldSubSport::Treadmill => write!(f, "{}", "Treadmill"),
            FitFieldSubSport::Street => write!(f, "{}", "Street"),
            FitFieldSubSport::Trail => write!(f, "{}", "Trail"),
            FitFieldSubSport::Track => write!(f, "{}", "Track"),
            FitFieldSubSport::Spin => write!(f, "{}", "Spin"),
            FitFieldSubSport::IndoorCycling => write!(f, "{}", "IndoorCycling"),
            FitFieldSubSport::Road => write!(f, "{}", "Road"),
            FitFieldSubSport::Mountain => write!(f, "{}", "Mountain"),
            FitFieldSubSport::Downhill => write!(f, "{}", "Downhill"),
            FitFieldSubSport::Recumbent => write!(f, "{}", "Recumbent"),
            FitFieldSubSport::Cyclocross => write!(f, "{}", "Cyclocross"),
            FitFieldSubSport::HandCycling => write!(f, "{}", "HandCycling"),
            FitFieldSubSport::TrackCycling => write!(f, "{}", "TrackCycling"),
            FitFieldSubSport::IndoorRowing => write!(f, "{}", "IndoorRowing"),
            FitFieldSubSport::Elliptical => write!(f, "{}", "Elliptical"),
            FitFieldSubSport::StairClimbing => write!(f, "{}", "StairClimbing"),
            FitFieldSubSport::LapSwimming => write!(f, "{}", "LapSwimming"),
            FitFieldSubSport::OpenWater => write!(f, "{}", "OpenWater"),
            FitFieldSubSport::FlexibilityTraining => write!(f, "{}", "FlexibilityTraining"),
            FitFieldSubSport::StrengthTraining => write!(f, "{}", "StrengthTraining"),
            FitFieldSubSport::WarmUp => write!(f, "{}", "WarmUp"),
            FitFieldSubSport::Match => write!(f, "{}", "Match"),
            FitFieldSubSport::Exercise => write!(f, "{}", "Exercise"),
            FitFieldSubSport::Challenge => write!(f, "{}", "Challenge"),
            FitFieldSubSport::IndoorSkiing => write!(f, "{}", "IndoorSkiing"),
            FitFieldSubSport::CardioTraining => write!(f, "{}", "CardioTraining"),
            FitFieldSubSport::IndoorWalking => write!(f, "{}", "IndoorWalking"),
            FitFieldSubSport::EBikeFitness => write!(f, "{}", "EBikeFitness"),
            FitFieldSubSport::Bmx => write!(f, "{}", "Bmx"),
            FitFieldSubSport::CasualWalking => write!(f, "{}", "CasualWalking"),
            FitFieldSubSport::SpeedWalking => write!(f, "{}", "SpeedWalking"),
            FitFieldSubSport::BikeToRunTransition => write!(f, "{}", "BikeToRunTransition"),
            FitFieldSubSport::RunToBikeTransition => write!(f, "{}", "RunToBikeTransition"),
            FitFieldSubSport::SwimToBikeTransition => write!(f, "{}", "SwimToBikeTransition"),
            FitFieldSubSport::Atv => write!(f, "{}", "Atv"),
            FitFieldSubSport::Motocross => write!(f, "{}", "Motocross"),
            FitFieldSubSport::Backcountry => write!(f, "{}", "Backcountry"),
            FitFieldSubSport::Resort => write!(f, "{}", "Resort"),
            FitFieldSubSport::RcDrone => write!(f, "{}", "RcDrone"),
            FitFieldSubSport::Wingsuit => write!(f, "{}", "Wingsuit"),
            FitFieldSubSport::Whitewater => write!(f, "{}", "Whitewater"),
            FitFieldSubSport::SkateSkiing => write!(f, "{}", "SkateSkiing"),
            FitFieldSubSport::Yoga => write!(f, "{}", "Yoga"),
            FitFieldSubSport::Pilates => write!(f, "{}", "Pilates"),
            FitFieldSubSport::IndoorRunning => write!(f, "{}", "IndoorRunning"),
            FitFieldSubSport::GravelCycling => write!(f, "{}", "GravelCycling"),
            FitFieldSubSport::EBikeMountain => write!(f, "{}", "EBikeMountain"),
            FitFieldSubSport::Commuting => write!(f, "{}", "Commuting"),
            FitFieldSubSport::MixedSurface => write!(f, "{}", "MixedSurface"),
            FitFieldSubSport::Navigate => write!(f, "{}", "Navigate"),
            FitFieldSubSport::TrackMe => write!(f, "{}", "TrackMe"),
            FitFieldSubSport::Map => write!(f, "{}", "Map"),
            FitFieldSubSport::SingleGasDiving => write!(f, "{}", "SingleGasDiving"),
            FitFieldSubSport::MultiGasDiving => write!(f, "{}", "MultiGasDiving"),
            FitFieldSubSport::GaugeDiving => write!(f, "{}", "GaugeDiving"),
            FitFieldSubSport::ApneaDiving => write!(f, "{}", "ApneaDiving"),
            FitFieldSubSport::ApneaHunting => write!(f, "{}", "ApneaHunting"),
            FitFieldSubSport::VirtualActivity => write!(f, "{}", "VirtualActivity"),
            FitFieldSubSport::Obstacle => write!(f, "{}", "Obstacle"),
            FitFieldSubSport::All => write!(f, "{}", "All"),
            FitFieldSubSport::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSubSport::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSubSport {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSubSport> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSubSport::from(v)),
            Err(_) => Ok(FitFieldSubSport::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSubSport);

impl From<u8> for FitFieldSubSport {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSubSport::Generic,
            1 => FitFieldSubSport::Treadmill,
            2 => FitFieldSubSport::Street,
            3 => FitFieldSubSport::Trail,
            4 => FitFieldSubSport::Track,
            5 => FitFieldSubSport::Spin,
            6 => FitFieldSubSport::IndoorCycling,
            7 => FitFieldSubSport::Road,
            8 => FitFieldSubSport::Mountain,
            9 => FitFieldSubSport::Downhill,
            10 => FitFieldSubSport::Recumbent,
            11 => FitFieldSubSport::Cyclocross,
            12 => FitFieldSubSport::HandCycling,
            13 => FitFieldSubSport::TrackCycling,
            14 => FitFieldSubSport::IndoorRowing,
            15 => FitFieldSubSport::Elliptical,
            16 => FitFieldSubSport::StairClimbing,
            17 => FitFieldSubSport::LapSwimming,
            18 => FitFieldSubSport::OpenWater,
            19 => FitFieldSubSport::FlexibilityTraining,
            20 => FitFieldSubSport::StrengthTraining,
            21 => FitFieldSubSport::WarmUp,
            22 => FitFieldSubSport::Match,
            23 => FitFieldSubSport::Exercise,
            24 => FitFieldSubSport::Challenge,
            25 => FitFieldSubSport::IndoorSkiing,
            26 => FitFieldSubSport::CardioTraining,
            27 => FitFieldSubSport::IndoorWalking,
            28 => FitFieldSubSport::EBikeFitness,
            29 => FitFieldSubSport::Bmx,
            30 => FitFieldSubSport::CasualWalking,
            31 => FitFieldSubSport::SpeedWalking,
            32 => FitFieldSubSport::BikeToRunTransition,
            33 => FitFieldSubSport::RunToBikeTransition,
            34 => FitFieldSubSport::SwimToBikeTransition,
            35 => FitFieldSubSport::Atv,
            36 => FitFieldSubSport::Motocross,
            37 => FitFieldSubSport::Backcountry,
            38 => FitFieldSubSport::Resort,
            39 => FitFieldSubSport::RcDrone,
            40 => FitFieldSubSport::Wingsuit,
            41 => FitFieldSubSport::Whitewater,
            42 => FitFieldSubSport::SkateSkiing,
            43 => FitFieldSubSport::Yoga,
            44 => FitFieldSubSport::Pilates,
            45 => FitFieldSubSport::IndoorRunning,
            46 => FitFieldSubSport::GravelCycling,
            47 => FitFieldSubSport::EBikeMountain,
            48 => FitFieldSubSport::Commuting,
            49 => FitFieldSubSport::MixedSurface,
            50 => FitFieldSubSport::Navigate,
            51 => FitFieldSubSport::TrackMe,
            52 => FitFieldSubSport::Map,
            53 => FitFieldSubSport::SingleGasDiving,
            54 => FitFieldSubSport::MultiGasDiving,
            55 => FitFieldSubSport::GaugeDiving,
            56 => FitFieldSubSport::ApneaDiving,
            57 => FitFieldSubSport::ApneaHunting,
            58 => FitFieldSubSport::VirtualActivity,
            59 => FitFieldSubSport::Obstacle,
            254 => FitFieldSubSport::All,
            _ => FitFieldSubSport::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSportEvent {
    // fit base type: enum
    Uncategorized = 0,
    Geocaching = 1,
    Fitness = 2,
    Recreation = 3,
    Race = 4,
    SpecialEvent = 5,
    Training = 6,
    Transportation = 7,
    Touring = 8,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSportEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSportEvent::Uncategorized => write!(f, "{}", "Uncategorized"),
            FitFieldSportEvent::Geocaching => write!(f, "{}", "Geocaching"),
            FitFieldSportEvent::Fitness => write!(f, "{}", "Fitness"),
            FitFieldSportEvent::Recreation => write!(f, "{}", "Recreation"),
            FitFieldSportEvent::Race => write!(f, "{}", "Race"),
            FitFieldSportEvent::SpecialEvent => write!(f, "{}", "SpecialEvent"),
            FitFieldSportEvent::Training => write!(f, "{}", "Training"),
            FitFieldSportEvent::Transportation => write!(f, "{}", "Transportation"),
            FitFieldSportEvent::Touring => write!(f, "{}", "Touring"),
            FitFieldSportEvent::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSportEvent::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSportEvent {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSportEvent> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSportEvent::from(v)),
            Err(_) => Ok(FitFieldSportEvent::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSportEvent);

impl From<u8> for FitFieldSportEvent {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSportEvent::Uncategorized,
            1 => FitFieldSportEvent::Geocaching,
            2 => FitFieldSportEvent::Fitness,
            3 => FitFieldSportEvent::Recreation,
            4 => FitFieldSportEvent::Race,
            5 => FitFieldSportEvent::SpecialEvent,
            6 => FitFieldSportEvent::Training,
            7 => FitFieldSportEvent::Transportation,
            8 => FitFieldSportEvent::Touring,
            _ => FitFieldSportEvent::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldActivity {
    // fit base type: enum
    Manual = 0,
    AutoMultiSport = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldActivity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldActivity::Manual => write!(f, "{}", "Manual"),
            FitFieldActivity::AutoMultiSport => write!(f, "{}", "AutoMultiSport"),
            FitFieldActivity::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldActivity::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldActivity {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldActivity> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldActivity::from(v)),
            Err(_) => Ok(FitFieldActivity::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldActivity);

impl From<u8> for FitFieldActivity {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivity::Manual,
            1 => FitFieldActivity::AutoMultiSport,
            _ => FitFieldActivity::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldIntensity {
    // fit base type: enum
    Active = 0,
    Rest = 1,
    Warmup = 2,
    Cooldown = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldIntensity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldIntensity::Active => write!(f, "{}", "Active"),
            FitFieldIntensity::Rest => write!(f, "{}", "Rest"),
            FitFieldIntensity::Warmup => write!(f, "{}", "Warmup"),
            FitFieldIntensity::Cooldown => write!(f, "{}", "Cooldown"),
            FitFieldIntensity::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldIntensity::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldIntensity {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldIntensity> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldIntensity::from(v)),
            Err(_) => Ok(FitFieldIntensity::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldIntensity);

impl From<u8> for FitFieldIntensity {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldIntensity::Active,
            1 => FitFieldIntensity::Rest,
            2 => FitFieldIntensity::Warmup,
            3 => FitFieldIntensity::Cooldown,
            _ => FitFieldIntensity::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSessionTrigger {
    // fit base type: enum
    ActivityEnd = 0,
    Manual = 1,           // User changed sport.
    AutoMultiSport = 2, // Auto multi-sport feature is enabled and user pressed lap button to advance session.
    FitnessEquipment = 3, // Auto sport change caused by user linking to fitness equipment.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSessionTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSessionTrigger::ActivityEnd => write!(f, "{}", "ActivityEnd"),
            FitFieldSessionTrigger::Manual => write!(f, "{}", "Manual"),
            FitFieldSessionTrigger::AutoMultiSport => write!(f, "{}", "AutoMultiSport"),
            FitFieldSessionTrigger::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldSessionTrigger::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSessionTrigger::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSessionTrigger {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSessionTrigger> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSessionTrigger::from(v)),
            Err(_) => Ok(FitFieldSessionTrigger::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSessionTrigger);

impl From<u8> for FitFieldSessionTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSessionTrigger::ActivityEnd,
            1 => FitFieldSessionTrigger::Manual,
            2 => FitFieldSessionTrigger::AutoMultiSport,
            3 => FitFieldSessionTrigger::FitnessEquipment,
            _ => FitFieldSessionTrigger::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAutolapTrigger {
    // fit base type: enum
    Time = 0,
    Distance = 1,
    PositionStart = 2,
    PositionLap = 3,
    PositionWaypoint = 4,
    PositionMarked = 5,
    Off = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldAutolapTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAutolapTrigger::Time => write!(f, "{}", "Time"),
            FitFieldAutolapTrigger::Distance => write!(f, "{}", "Distance"),
            FitFieldAutolapTrigger::PositionStart => write!(f, "{}", "PositionStart"),
            FitFieldAutolapTrigger::PositionLap => write!(f, "{}", "PositionLap"),
            FitFieldAutolapTrigger::PositionWaypoint => write!(f, "{}", "PositionWaypoint"),
            FitFieldAutolapTrigger::PositionMarked => write!(f, "{}", "PositionMarked"),
            FitFieldAutolapTrigger::Off => write!(f, "{}", "Off"),
            FitFieldAutolapTrigger::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAutolapTrigger::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAutolapTrigger {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAutolapTrigger> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldAutolapTrigger::from(v)),
            Err(_) => Ok(FitFieldAutolapTrigger::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldAutolapTrigger);

impl From<u8> for FitFieldAutolapTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAutolapTrigger::Time,
            1 => FitFieldAutolapTrigger::Distance,
            2 => FitFieldAutolapTrigger::PositionStart,
            3 => FitFieldAutolapTrigger::PositionLap,
            4 => FitFieldAutolapTrigger::PositionWaypoint,
            5 => FitFieldAutolapTrigger::PositionMarked,
            6 => FitFieldAutolapTrigger::Off,
            _ => FitFieldAutolapTrigger::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLapTrigger {
    // fit base type: enum
    Manual = 0,
    Time = 1,
    Distance = 2,
    PositionStart = 3,
    PositionLap = 4,
    PositionWaypoint = 5,
    PositionMarked = 6,
    SessionEnd = 7,
    FitnessEquipment = 8,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldLapTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLapTrigger::Manual => write!(f, "{}", "Manual"),
            FitFieldLapTrigger::Time => write!(f, "{}", "Time"),
            FitFieldLapTrigger::Distance => write!(f, "{}", "Distance"),
            FitFieldLapTrigger::PositionStart => write!(f, "{}", "PositionStart"),
            FitFieldLapTrigger::PositionLap => write!(f, "{}", "PositionLap"),
            FitFieldLapTrigger::PositionWaypoint => write!(f, "{}", "PositionWaypoint"),
            FitFieldLapTrigger::PositionMarked => write!(f, "{}", "PositionMarked"),
            FitFieldLapTrigger::SessionEnd => write!(f, "{}", "SessionEnd"),
            FitFieldLapTrigger::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldLapTrigger::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLapTrigger::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLapTrigger {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLapTrigger> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldLapTrigger::from(v)),
            Err(_) => Ok(FitFieldLapTrigger::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldLapTrigger);

impl From<u8> for FitFieldLapTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldLapTrigger::Manual,
            1 => FitFieldLapTrigger::Time,
            2 => FitFieldLapTrigger::Distance,
            3 => FitFieldLapTrigger::PositionStart,
            4 => FitFieldLapTrigger::PositionLap,
            5 => FitFieldLapTrigger::PositionWaypoint,
            6 => FitFieldLapTrigger::PositionMarked,
            7 => FitFieldLapTrigger::SessionEnd,
            8 => FitFieldLapTrigger::FitnessEquipment,
            _ => FitFieldLapTrigger::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTimeMode {
    // fit base type: enum
    Hour12 = 0,
    Hour24 = 1,   // Does not use a leading zero and has a colon
    Military = 2, // Uses a leading zero and does not have a colon
    Hour12WithSeconds = 3,
    Hour24WithSeconds = 4,
    Utc = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldTimeMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTimeMode::Hour12 => write!(f, "{}", "Hour12"),
            FitFieldTimeMode::Hour24 => write!(f, "{}", "Hour24"),
            FitFieldTimeMode::Military => write!(f, "{}", "Military"),
            FitFieldTimeMode::Hour12WithSeconds => write!(f, "{}", "Hour12WithSeconds"),
            FitFieldTimeMode::Hour24WithSeconds => write!(f, "{}", "Hour24WithSeconds"),
            FitFieldTimeMode::Utc => write!(f, "{}", "Utc"),
            FitFieldTimeMode::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTimeMode::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTimeMode {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTimeMode> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldTimeMode::from(v)),
            Err(_) => Ok(FitFieldTimeMode::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldTimeMode);

impl From<u8> for FitFieldTimeMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTimeMode::Hour12,
            1 => FitFieldTimeMode::Hour24,
            2 => FitFieldTimeMode::Military,
            3 => FitFieldTimeMode::Hour12WithSeconds,
            4 => FitFieldTimeMode::Hour24WithSeconds,
            5 => FitFieldTimeMode::Utc,
            _ => FitFieldTimeMode::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBacklightMode {
    // fit base type: enum
    Off = 0,
    Manual = 1,
    KeyAndMessages = 2,
    AutoBrightness = 3,
    SmartNotifications = 4,
    KeyAndMessagesNight = 5,
    KeyAndMessagesAndSmartNotifications = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldBacklightMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBacklightMode::Off => write!(f, "{}", "Off"),
            FitFieldBacklightMode::Manual => write!(f, "{}", "Manual"),
            FitFieldBacklightMode::KeyAndMessages => write!(f, "{}", "KeyAndMessages"),
            FitFieldBacklightMode::AutoBrightness => write!(f, "{}", "AutoBrightness"),
            FitFieldBacklightMode::SmartNotifications => write!(f, "{}", "SmartNotifications"),
            FitFieldBacklightMode::KeyAndMessagesNight => write!(f, "{}", "KeyAndMessagesNight"),
            FitFieldBacklightMode::KeyAndMessagesAndSmartNotifications => {
                write!(f, "{}", "KeyAndMessagesAndSmartNotifications")
            }
            FitFieldBacklightMode::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBacklightMode::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBacklightMode {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldBacklightMode> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldBacklightMode::from(v)),
            Err(_) => Ok(FitFieldBacklightMode::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldBacklightMode);

impl From<u8> for FitFieldBacklightMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBacklightMode::Off,
            1 => FitFieldBacklightMode::Manual,
            2 => FitFieldBacklightMode::KeyAndMessages,
            3 => FitFieldBacklightMode::AutoBrightness,
            4 => FitFieldBacklightMode::SmartNotifications,
            5 => FitFieldBacklightMode::KeyAndMessagesNight,
            6 => FitFieldBacklightMode::KeyAndMessagesAndSmartNotifications,
            _ => FitFieldBacklightMode::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDateMode {
    // fit base type: enum
    DayMonth = 0,
    MonthDay = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDateMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDateMode::DayMonth => write!(f, "{}", "DayMonth"),
            FitFieldDateMode::MonthDay => write!(f, "{}", "MonthDay"),
            FitFieldDateMode::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDateMode::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDateMode {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDateMode> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDateMode::from(v)),
            Err(_) => Ok(FitFieldDateMode::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDateMode);

impl From<u8> for FitFieldDateMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDateMode::DayMonth,
            1 => FitFieldDateMode::MonthDay,
            _ => FitFieldDateMode::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBacklightTimeout {
    // fit base type: uint8
    Infinite, // 0  Backlight stays on forever.
    BacklightTimeout(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldBacklightTimeout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBacklightTimeout::Infinite => write!(f, "{}", "Infinite"),
            FitFieldBacklightTimeout::BacklightTimeout(x) => {
                write!(f, "{}({})", "BacklightTimeout", x)
            }
            FitFieldBacklightTimeout::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBacklightTimeout::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBacklightTimeout {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldBacklightTimeout> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldBacklightTimeout::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldBacklightTimeout::from(v)),
                v => Ok(FitFieldBacklightTimeout::BacklightTimeout(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldBacklightTimeout);

impl From<u8> for FitFieldBacklightTimeout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBacklightTimeout::Infinite,
            _ => FitFieldBacklightTimeout::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldEvent {
    // fit base type: enum
    Timer = 0,                  // Group 0.  Start / stop_all
    Workout = 3,                // start / stop
    WorkoutStep = 4,            // Start at beginning of workout.  Stop at end of each step.
    PowerDown = 5,              // stop_all group 0
    PowerUp = 6,                // stop_all group 0
    OffCourse = 7,              // start / stop group 0
    Session = 8,                // Stop at end of each session.
    Lap = 9,                    // Stop at end of each lap.
    CoursePoint = 10,           // marker
    Battery = 11,               // marker
    VirtualPartnerPace = 12, // Group 1. Start at beginning of activity if VP enabled, when VP pace is changed during activity or VP enabled mid activity.  stop_disable when VP disabled.
    HrHighAlert = 13,        // Group 0.  Start / stop when in alert condition.
    HrLowAlert = 14,         // Group 0.  Start / stop when in alert condition.
    SpeedHighAlert = 15,     // Group 0.  Start / stop when in alert condition.
    SpeedLowAlert = 16,      // Group 0.  Start / stop when in alert condition.
    CadHighAlert = 17,       // Group 0.  Start / stop when in alert condition.
    CadLowAlert = 18,        // Group 0.  Start / stop when in alert condition.
    PowerHighAlert = 19,     // Group 0.  Start / stop when in alert condition.
    PowerLowAlert = 20,      // Group 0.  Start / stop when in alert condition.
    RecoveryHr = 21,         // marker
    BatteryLow = 22,         // marker
    TimeDurationAlert = 23, // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
    DistanceDurationAlert = 24, // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
    CalorieDurationAlert = 25, // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
    Activity = 26,             // Group 1..  Stop at end of activity.
    FitnessEquipment = 27,     // marker
    Length = 28,               // Stop at end of each length.
    UserMarker = 32,           // marker
    SportPoint = 33,           // marker
    Calibration = 36,          // start/stop/marker
    FrontGearChange = 42,      // marker
    RearGearChange = 43,       // marker
    RiderPositionChange = 44,  // marker
    ElevHighAlert = 45,        // Group 0.  Start / stop when in alert condition.
    ElevLowAlert = 46,         // Group 0.  Start / stop when in alert condition.
    CommTimeout = 47,          // marker
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldEvent::Timer => write!(f, "{}", "Timer"),
            FitFieldEvent::Workout => write!(f, "{}", "Workout"),
            FitFieldEvent::WorkoutStep => write!(f, "{}", "WorkoutStep"),
            FitFieldEvent::PowerDown => write!(f, "{}", "PowerDown"),
            FitFieldEvent::PowerUp => write!(f, "{}", "PowerUp"),
            FitFieldEvent::OffCourse => write!(f, "{}", "OffCourse"),
            FitFieldEvent::Session => write!(f, "{}", "Session"),
            FitFieldEvent::Lap => write!(f, "{}", "Lap"),
            FitFieldEvent::CoursePoint => write!(f, "{}", "CoursePoint"),
            FitFieldEvent::Battery => write!(f, "{}", "Battery"),
            FitFieldEvent::VirtualPartnerPace => write!(f, "{}", "VirtualPartnerPace"),
            FitFieldEvent::HrHighAlert => write!(f, "{}", "HrHighAlert"),
            FitFieldEvent::HrLowAlert => write!(f, "{}", "HrLowAlert"),
            FitFieldEvent::SpeedHighAlert => write!(f, "{}", "SpeedHighAlert"),
            FitFieldEvent::SpeedLowAlert => write!(f, "{}", "SpeedLowAlert"),
            FitFieldEvent::CadHighAlert => write!(f, "{}", "CadHighAlert"),
            FitFieldEvent::CadLowAlert => write!(f, "{}", "CadLowAlert"),
            FitFieldEvent::PowerHighAlert => write!(f, "{}", "PowerHighAlert"),
            FitFieldEvent::PowerLowAlert => write!(f, "{}", "PowerLowAlert"),
            FitFieldEvent::RecoveryHr => write!(f, "{}", "RecoveryHr"),
            FitFieldEvent::BatteryLow => write!(f, "{}", "BatteryLow"),
            FitFieldEvent::TimeDurationAlert => write!(f, "{}", "TimeDurationAlert"),
            FitFieldEvent::DistanceDurationAlert => write!(f, "{}", "DistanceDurationAlert"),
            FitFieldEvent::CalorieDurationAlert => write!(f, "{}", "CalorieDurationAlert"),
            FitFieldEvent::Activity => write!(f, "{}", "Activity"),
            FitFieldEvent::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldEvent::Length => write!(f, "{}", "Length"),
            FitFieldEvent::UserMarker => write!(f, "{}", "UserMarker"),
            FitFieldEvent::SportPoint => write!(f, "{}", "SportPoint"),
            FitFieldEvent::Calibration => write!(f, "{}", "Calibration"),
            FitFieldEvent::FrontGearChange => write!(f, "{}", "FrontGearChange"),
            FitFieldEvent::RearGearChange => write!(f, "{}", "RearGearChange"),
            FitFieldEvent::RiderPositionChange => write!(f, "{}", "RiderPositionChange"),
            FitFieldEvent::ElevHighAlert => write!(f, "{}", "ElevHighAlert"),
            FitFieldEvent::ElevLowAlert => write!(f, "{}", "ElevLowAlert"),
            FitFieldEvent::CommTimeout => write!(f, "{}", "CommTimeout"),
            FitFieldEvent::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldEvent::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldEvent {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldEvent> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldEvent::from(v)),
            Err(_) => Ok(FitFieldEvent::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldEvent);

impl From<u8> for FitFieldEvent {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldEvent::Timer,
            3 => FitFieldEvent::Workout,
            4 => FitFieldEvent::WorkoutStep,
            5 => FitFieldEvent::PowerDown,
            6 => FitFieldEvent::PowerUp,
            7 => FitFieldEvent::OffCourse,
            8 => FitFieldEvent::Session,
            9 => FitFieldEvent::Lap,
            10 => FitFieldEvent::CoursePoint,
            11 => FitFieldEvent::Battery,
            12 => FitFieldEvent::VirtualPartnerPace,
            13 => FitFieldEvent::HrHighAlert,
            14 => FitFieldEvent::HrLowAlert,
            15 => FitFieldEvent::SpeedHighAlert,
            16 => FitFieldEvent::SpeedLowAlert,
            17 => FitFieldEvent::CadHighAlert,
            18 => FitFieldEvent::CadLowAlert,
            19 => FitFieldEvent::PowerHighAlert,
            20 => FitFieldEvent::PowerLowAlert,
            21 => FitFieldEvent::RecoveryHr,
            22 => FitFieldEvent::BatteryLow,
            23 => FitFieldEvent::TimeDurationAlert,
            24 => FitFieldEvent::DistanceDurationAlert,
            25 => FitFieldEvent::CalorieDurationAlert,
            26 => FitFieldEvent::Activity,
            27 => FitFieldEvent::FitnessEquipment,
            28 => FitFieldEvent::Length,
            32 => FitFieldEvent::UserMarker,
            33 => FitFieldEvent::SportPoint,
            36 => FitFieldEvent::Calibration,
            42 => FitFieldEvent::FrontGearChange,
            43 => FitFieldEvent::RearGearChange,
            44 => FitFieldEvent::RiderPositionChange,
            45 => FitFieldEvent::ElevHighAlert,
            46 => FitFieldEvent::ElevLowAlert,
            47 => FitFieldEvent::CommTimeout,
            _ => FitFieldEvent::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldEventType {
    // fit base type: enum
    Start = 0,
    Stop = 1,
    ConsecutiveDepreciated = 2,
    Marker = 3,
    StopAll = 4,
    BeginDepreciated = 5,
    EndDepreciated = 6,
    EndAllDepreciated = 7,
    StopDisable = 8,
    StopDisableAll = 9,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldEventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldEventType::Start => write!(f, "{}", "Start"),
            FitFieldEventType::Stop => write!(f, "{}", "Stop"),
            FitFieldEventType::ConsecutiveDepreciated => write!(f, "{}", "ConsecutiveDepreciated"),
            FitFieldEventType::Marker => write!(f, "{}", "Marker"),
            FitFieldEventType::StopAll => write!(f, "{}", "StopAll"),
            FitFieldEventType::BeginDepreciated => write!(f, "{}", "BeginDepreciated"),
            FitFieldEventType::EndDepreciated => write!(f, "{}", "EndDepreciated"),
            FitFieldEventType::EndAllDepreciated => write!(f, "{}", "EndAllDepreciated"),
            FitFieldEventType::StopDisable => write!(f, "{}", "StopDisable"),
            FitFieldEventType::StopDisableAll => write!(f, "{}", "StopDisableAll"),
            FitFieldEventType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldEventType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldEventType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldEventType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldEventType::from(v)),
            Err(_) => Ok(FitFieldEventType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldEventType);

impl From<u8> for FitFieldEventType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldEventType::Start,
            1 => FitFieldEventType::Stop,
            2 => FitFieldEventType::ConsecutiveDepreciated,
            3 => FitFieldEventType::Marker,
            4 => FitFieldEventType::StopAll,
            5 => FitFieldEventType::BeginDepreciated,
            6 => FitFieldEventType::EndDepreciated,
            7 => FitFieldEventType::EndAllDepreciated,
            8 => FitFieldEventType::StopDisable,
            9 => FitFieldEventType::StopDisableAll,
            _ => FitFieldEventType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTimerTrigger {
    // fit base type: enum
    Manual = 0,
    Auto = 1,
    FitnessEquipment = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldTimerTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTimerTrigger::Manual => write!(f, "{}", "Manual"),
            FitFieldTimerTrigger::Auto => write!(f, "{}", "Auto"),
            FitFieldTimerTrigger::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldTimerTrigger::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTimerTrigger::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTimerTrigger {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTimerTrigger> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldTimerTrigger::from(v)),
            Err(_) => Ok(FitFieldTimerTrigger::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldTimerTrigger);

impl From<u8> for FitFieldTimerTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTimerTrigger::Manual,
            1 => FitFieldTimerTrigger::Auto,
            2 => FitFieldTimerTrigger::FitnessEquipment,
            _ => FitFieldTimerTrigger::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFitnessEquipmentState {
    // fit base type: enum
    Ready = 0,
    InUse = 1,
    Paused = 2,
    Unknown = 3, // lost connection to fitness equipment
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldFitnessEquipmentState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFitnessEquipmentState::Ready => write!(f, "{}", "Ready"),
            FitFieldFitnessEquipmentState::InUse => write!(f, "{}", "InUse"),
            FitFieldFitnessEquipmentState::Paused => write!(f, "{}", "Paused"),
            FitFieldFitnessEquipmentState::Unknown => write!(f, "{}", "Unknown"),
            FitFieldFitnessEquipmentState::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFitnessEquipmentState::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFitnessEquipmentState {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFitnessEquipmentState> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldFitnessEquipmentState::from(v)),
            Err(_) => Ok(FitFieldFitnessEquipmentState::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldFitnessEquipmentState);

impl From<u8> for FitFieldFitnessEquipmentState {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldFitnessEquipmentState::Ready,
            1 => FitFieldFitnessEquipmentState::InUse,
            2 => FitFieldFitnessEquipmentState::Paused,
            3 => FitFieldFitnessEquipmentState::Unknown,
            _ => FitFieldFitnessEquipmentState::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTone {
    // fit base type: enum
    Off = 0,
    Tone = 1,
    Vibrate = 2,
    ToneAndVibrate = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldTone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTone::Off => write!(f, "{}", "Off"),
            FitFieldTone::Tone => write!(f, "{}", "Tone"),
            FitFieldTone::Vibrate => write!(f, "{}", "Vibrate"),
            FitFieldTone::ToneAndVibrate => write!(f, "{}", "ToneAndVibrate"),
            FitFieldTone::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTone::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTone {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTone> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldTone::from(v)),
            Err(_) => Ok(FitFieldTone::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldTone);

impl From<u8> for FitFieldTone {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTone::Off,
            1 => FitFieldTone::Tone,
            2 => FitFieldTone::Vibrate,
            3 => FitFieldTone::ToneAndVibrate,
            _ => FitFieldTone::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAutoscroll {
    // fit base type: enum
    None = 0,
    Slow = 1,
    Medium = 2,
    Fast = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldAutoscroll {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAutoscroll::None => write!(f, "{}", "None"),
            FitFieldAutoscroll::Slow => write!(f, "{}", "Slow"),
            FitFieldAutoscroll::Medium => write!(f, "{}", "Medium"),
            FitFieldAutoscroll::Fast => write!(f, "{}", "Fast"),
            FitFieldAutoscroll::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAutoscroll::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAutoscroll {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAutoscroll> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldAutoscroll::from(v)),
            Err(_) => Ok(FitFieldAutoscroll::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldAutoscroll);

impl From<u8> for FitFieldAutoscroll {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAutoscroll::None,
            1 => FitFieldAutoscroll::Slow,
            2 => FitFieldAutoscroll::Medium,
            3 => FitFieldAutoscroll::Fast,
            _ => FitFieldAutoscroll::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldActivityClass {
    // fit base type: enum
    Level = 127, // 0 to 100
    LevelMax = 100,
    Athlete = 128,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldActivityClass {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldActivityClass::Level => write!(f, "{}", "Level"),
            FitFieldActivityClass::LevelMax => write!(f, "{}", "LevelMax"),
            FitFieldActivityClass::Athlete => write!(f, "{}", "Athlete"),
            FitFieldActivityClass::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldActivityClass::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldActivityClass {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldActivityClass> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldActivityClass::from(v)),
            Err(_) => Ok(FitFieldActivityClass::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldActivityClass);

impl From<u8> for FitFieldActivityClass {
    fn from(code: u8) -> Self {
        match code {
            127 => FitFieldActivityClass::Level,
            100 => FitFieldActivityClass::LevelMax,
            128 => FitFieldActivityClass::Athlete,
            _ => FitFieldActivityClass::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldHrZoneCalc {
    // fit base type: enum
    Custom = 0,
    PercentMaxHr = 1,
    PercentHrr = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldHrZoneCalc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldHrZoneCalc::Custom => write!(f, "{}", "Custom"),
            FitFieldHrZoneCalc::PercentMaxHr => write!(f, "{}", "PercentMaxHr"),
            FitFieldHrZoneCalc::PercentHrr => write!(f, "{}", "PercentHrr"),
            FitFieldHrZoneCalc::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldHrZoneCalc::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldHrZoneCalc {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldHrZoneCalc> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldHrZoneCalc::from(v)),
            Err(_) => Ok(FitFieldHrZoneCalc::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldHrZoneCalc);

impl From<u8> for FitFieldHrZoneCalc {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldHrZoneCalc::Custom,
            1 => FitFieldHrZoneCalc::PercentMaxHr,
            2 => FitFieldHrZoneCalc::PercentHrr,
            _ => FitFieldHrZoneCalc::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldPwrZoneCalc {
    // fit base type: enum
    Custom = 0,
    PercentFtp = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldPwrZoneCalc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldPwrZoneCalc::Custom => write!(f, "{}", "Custom"),
            FitFieldPwrZoneCalc::PercentFtp => write!(f, "{}", "PercentFtp"),
            FitFieldPwrZoneCalc::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldPwrZoneCalc::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldPwrZoneCalc {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldPwrZoneCalc> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldPwrZoneCalc::from(v)),
            Err(_) => Ok(FitFieldPwrZoneCalc::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldPwrZoneCalc);

impl From<u8> for FitFieldPwrZoneCalc {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldPwrZoneCalc::Custom,
            1 => FitFieldPwrZoneCalc::PercentFtp,
            _ => FitFieldPwrZoneCalc::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWktStepDuration {
    // fit base type: enum
    Time = 0,
    Distance = 1,
    HrLessThan = 2,
    HrGreaterThan = 3,
    Calories = 4,
    Open = 5,
    RepeatUntilStepsCmplt = 6,
    RepeatUntilTime = 7,
    RepeatUntilDistance = 8,
    RepeatUntilCalories = 9,
    RepeatUntilHrLessThan = 10,
    RepeatUntilHrGreaterThan = 11,
    RepeatUntilPowerLessThan = 12,
    RepeatUntilPowerGreaterThan = 13,
    PowerLessThan = 14,
    PowerGreaterThan = 15,
    TrainingPeaksTss = 16,
    RepeatUntilPowerLastLapLessThan = 17,
    RepeatUntilMaxPowerLastLapLessThan = 18,
    Power3sLessThan = 19,
    Power10sLessThan = 20,
    Power30sLessThan = 21,
    Power3sGreaterThan = 22,
    Power10sGreaterThan = 23,
    Power30sGreaterThan = 24,
    PowerLapLessThan = 25,
    PowerLapGreaterThan = 26,
    RepeatUntilTrainingPeaksTss = 27,
    RepetitionTime = 28,
    Reps = 29,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWktStepDuration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWktStepDuration::Time => write!(f, "{}", "Time"),
            FitFieldWktStepDuration::Distance => write!(f, "{}", "Distance"),
            FitFieldWktStepDuration::HrLessThan => write!(f, "{}", "HrLessThan"),
            FitFieldWktStepDuration::HrGreaterThan => write!(f, "{}", "HrGreaterThan"),
            FitFieldWktStepDuration::Calories => write!(f, "{}", "Calories"),
            FitFieldWktStepDuration::Open => write!(f, "{}", "Open"),
            FitFieldWktStepDuration::RepeatUntilStepsCmplt => {
                write!(f, "{}", "RepeatUntilStepsCmplt")
            }
            FitFieldWktStepDuration::RepeatUntilTime => write!(f, "{}", "RepeatUntilTime"),
            FitFieldWktStepDuration::RepeatUntilDistance => write!(f, "{}", "RepeatUntilDistance"),
            FitFieldWktStepDuration::RepeatUntilCalories => write!(f, "{}", "RepeatUntilCalories"),
            FitFieldWktStepDuration::RepeatUntilHrLessThan => {
                write!(f, "{}", "RepeatUntilHrLessThan")
            }
            FitFieldWktStepDuration::RepeatUntilHrGreaterThan => {
                write!(f, "{}", "RepeatUntilHrGreaterThan")
            }
            FitFieldWktStepDuration::RepeatUntilPowerLessThan => {
                write!(f, "{}", "RepeatUntilPowerLessThan")
            }
            FitFieldWktStepDuration::RepeatUntilPowerGreaterThan => {
                write!(f, "{}", "RepeatUntilPowerGreaterThan")
            }
            FitFieldWktStepDuration::PowerLessThan => write!(f, "{}", "PowerLessThan"),
            FitFieldWktStepDuration::PowerGreaterThan => write!(f, "{}", "PowerGreaterThan"),
            FitFieldWktStepDuration::TrainingPeaksTss => write!(f, "{}", "TrainingPeaksTss"),
            FitFieldWktStepDuration::RepeatUntilPowerLastLapLessThan => {
                write!(f, "{}", "RepeatUntilPowerLastLapLessThan")
            }
            FitFieldWktStepDuration::RepeatUntilMaxPowerLastLapLessThan => {
                write!(f, "{}", "RepeatUntilMaxPowerLastLapLessThan")
            }
            FitFieldWktStepDuration::Power3sLessThan => write!(f, "{}", "Power3sLessThan"),
            FitFieldWktStepDuration::Power10sLessThan => write!(f, "{}", "Power10sLessThan"),
            FitFieldWktStepDuration::Power30sLessThan => write!(f, "{}", "Power30sLessThan"),
            FitFieldWktStepDuration::Power3sGreaterThan => write!(f, "{}", "Power3sGreaterThan"),
            FitFieldWktStepDuration::Power10sGreaterThan => write!(f, "{}", "Power10sGreaterThan"),
            FitFieldWktStepDuration::Power30sGreaterThan => write!(f, "{}", "Power30sGreaterThan"),
            FitFieldWktStepDuration::PowerLapLessThan => write!(f, "{}", "PowerLapLessThan"),
            FitFieldWktStepDuration::PowerLapGreaterThan => write!(f, "{}", "PowerLapGreaterThan"),
            FitFieldWktStepDuration::RepeatUntilTrainingPeaksTss => {
                write!(f, "{}", "RepeatUntilTrainingPeaksTss")
            }
            FitFieldWktStepDuration::RepetitionTime => write!(f, "{}", "RepetitionTime"),
            FitFieldWktStepDuration::Reps => write!(f, "{}", "Reps"),
            FitFieldWktStepDuration::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWktStepDuration::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWktStepDuration {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWktStepDuration> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWktStepDuration::from(v)),
            Err(_) => Ok(FitFieldWktStepDuration::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWktStepDuration);

impl From<u8> for FitFieldWktStepDuration {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWktStepDuration::Time,
            1 => FitFieldWktStepDuration::Distance,
            2 => FitFieldWktStepDuration::HrLessThan,
            3 => FitFieldWktStepDuration::HrGreaterThan,
            4 => FitFieldWktStepDuration::Calories,
            5 => FitFieldWktStepDuration::Open,
            6 => FitFieldWktStepDuration::RepeatUntilStepsCmplt,
            7 => FitFieldWktStepDuration::RepeatUntilTime,
            8 => FitFieldWktStepDuration::RepeatUntilDistance,
            9 => FitFieldWktStepDuration::RepeatUntilCalories,
            10 => FitFieldWktStepDuration::RepeatUntilHrLessThan,
            11 => FitFieldWktStepDuration::RepeatUntilHrGreaterThan,
            12 => FitFieldWktStepDuration::RepeatUntilPowerLessThan,
            13 => FitFieldWktStepDuration::RepeatUntilPowerGreaterThan,
            14 => FitFieldWktStepDuration::PowerLessThan,
            15 => FitFieldWktStepDuration::PowerGreaterThan,
            16 => FitFieldWktStepDuration::TrainingPeaksTss,
            17 => FitFieldWktStepDuration::RepeatUntilPowerLastLapLessThan,
            18 => FitFieldWktStepDuration::RepeatUntilMaxPowerLastLapLessThan,
            19 => FitFieldWktStepDuration::Power3sLessThan,
            20 => FitFieldWktStepDuration::Power10sLessThan,
            21 => FitFieldWktStepDuration::Power30sLessThan,
            22 => FitFieldWktStepDuration::Power3sGreaterThan,
            23 => FitFieldWktStepDuration::Power10sGreaterThan,
            24 => FitFieldWktStepDuration::Power30sGreaterThan,
            25 => FitFieldWktStepDuration::PowerLapLessThan,
            26 => FitFieldWktStepDuration::PowerLapGreaterThan,
            27 => FitFieldWktStepDuration::RepeatUntilTrainingPeaksTss,
            28 => FitFieldWktStepDuration::RepetitionTime,
            29 => FitFieldWktStepDuration::Reps,
            _ => FitFieldWktStepDuration::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWktStepTarget {
    // fit base type: enum
    Speed = 0,
    HeartRate = 1,
    Open = 2,
    Cadence = 3,
    Power = 4,
    Grade = 5,
    Resistance = 6,
    Power3s = 7,
    Power10s = 8,
    Power30s = 9,
    PowerLap = 10,
    SwimStroke = 11,
    SpeedLap = 12,
    HeartRateLap = 13,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWktStepTarget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWktStepTarget::Speed => write!(f, "{}", "Speed"),
            FitFieldWktStepTarget::HeartRate => write!(f, "{}", "HeartRate"),
            FitFieldWktStepTarget::Open => write!(f, "{}", "Open"),
            FitFieldWktStepTarget::Cadence => write!(f, "{}", "Cadence"),
            FitFieldWktStepTarget::Power => write!(f, "{}", "Power"),
            FitFieldWktStepTarget::Grade => write!(f, "{}", "Grade"),
            FitFieldWktStepTarget::Resistance => write!(f, "{}", "Resistance"),
            FitFieldWktStepTarget::Power3s => write!(f, "{}", "Power3s"),
            FitFieldWktStepTarget::Power10s => write!(f, "{}", "Power10s"),
            FitFieldWktStepTarget::Power30s => write!(f, "{}", "Power30s"),
            FitFieldWktStepTarget::PowerLap => write!(f, "{}", "PowerLap"),
            FitFieldWktStepTarget::SwimStroke => write!(f, "{}", "SwimStroke"),
            FitFieldWktStepTarget::SpeedLap => write!(f, "{}", "SpeedLap"),
            FitFieldWktStepTarget::HeartRateLap => write!(f, "{}", "HeartRateLap"),
            FitFieldWktStepTarget::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWktStepTarget::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWktStepTarget {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWktStepTarget> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWktStepTarget::from(v)),
            Err(_) => Ok(FitFieldWktStepTarget::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWktStepTarget);

impl From<u8> for FitFieldWktStepTarget {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWktStepTarget::Speed,
            1 => FitFieldWktStepTarget::HeartRate,
            2 => FitFieldWktStepTarget::Open,
            3 => FitFieldWktStepTarget::Cadence,
            4 => FitFieldWktStepTarget::Power,
            5 => FitFieldWktStepTarget::Grade,
            6 => FitFieldWktStepTarget::Resistance,
            7 => FitFieldWktStepTarget::Power3s,
            8 => FitFieldWktStepTarget::Power10s,
            9 => FitFieldWktStepTarget::Power30s,
            10 => FitFieldWktStepTarget::PowerLap,
            11 => FitFieldWktStepTarget::SwimStroke,
            12 => FitFieldWktStepTarget::SpeedLap,
            13 => FitFieldWktStepTarget::HeartRateLap,
            _ => FitFieldWktStepTarget::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldGoal {
    // fit base type: enum
    Time = 0,
    Distance = 1,
    Calories = 2,
    Frequency = 3,
    Steps = 4,
    Ascent = 5,
    ActiveMinutes = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldGoal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldGoal::Time => write!(f, "{}", "Time"),
            FitFieldGoal::Distance => write!(f, "{}", "Distance"),
            FitFieldGoal::Calories => write!(f, "{}", "Calories"),
            FitFieldGoal::Frequency => write!(f, "{}", "Frequency"),
            FitFieldGoal::Steps => write!(f, "{}", "Steps"),
            FitFieldGoal::Ascent => write!(f, "{}", "Ascent"),
            FitFieldGoal::ActiveMinutes => write!(f, "{}", "ActiveMinutes"),
            FitFieldGoal::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldGoal::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldGoal {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldGoal> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldGoal::from(v)),
            Err(_) => Ok(FitFieldGoal::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldGoal);

impl From<u8> for FitFieldGoal {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGoal::Time,
            1 => FitFieldGoal::Distance,
            2 => FitFieldGoal::Calories,
            3 => FitFieldGoal::Frequency,
            4 => FitFieldGoal::Steps,
            5 => FitFieldGoal::Ascent,
            6 => FitFieldGoal::ActiveMinutes,
            _ => FitFieldGoal::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldGoalRecurrence {
    // fit base type: enum
    Off = 0,
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
    Yearly = 4,
    Custom = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldGoalRecurrence {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldGoalRecurrence::Off => write!(f, "{}", "Off"),
            FitFieldGoalRecurrence::Daily => write!(f, "{}", "Daily"),
            FitFieldGoalRecurrence::Weekly => write!(f, "{}", "Weekly"),
            FitFieldGoalRecurrence::Monthly => write!(f, "{}", "Monthly"),
            FitFieldGoalRecurrence::Yearly => write!(f, "{}", "Yearly"),
            FitFieldGoalRecurrence::Custom => write!(f, "{}", "Custom"),
            FitFieldGoalRecurrence::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldGoalRecurrence::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldGoalRecurrence {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldGoalRecurrence> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldGoalRecurrence::from(v)),
            Err(_) => Ok(FitFieldGoalRecurrence::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldGoalRecurrence);

impl From<u8> for FitFieldGoalRecurrence {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGoalRecurrence::Off,
            1 => FitFieldGoalRecurrence::Daily,
            2 => FitFieldGoalRecurrence::Weekly,
            3 => FitFieldGoalRecurrence::Monthly,
            4 => FitFieldGoalRecurrence::Yearly,
            5 => FitFieldGoalRecurrence::Custom,
            _ => FitFieldGoalRecurrence::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldGoalSource {
    // fit base type: enum
    Auto = 0,      // Device generated
    Community = 1, // Social network sourced goal
    User = 2,      // Manually generated
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldGoalSource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldGoalSource::Auto => write!(f, "{}", "Auto"),
            FitFieldGoalSource::Community => write!(f, "{}", "Community"),
            FitFieldGoalSource::User => write!(f, "{}", "User"),
            FitFieldGoalSource::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldGoalSource::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldGoalSource {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldGoalSource> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldGoalSource::from(v)),
            Err(_) => Ok(FitFieldGoalSource::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldGoalSource);

impl From<u8> for FitFieldGoalSource {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGoalSource::Auto,
            1 => FitFieldGoalSource::Community,
            2 => FitFieldGoalSource::User,
            _ => FitFieldGoalSource::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSchedule {
    // fit base type: enum
    Workout = 0,
    Course = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSchedule {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSchedule::Workout => write!(f, "{}", "Workout"),
            FitFieldSchedule::Course => write!(f, "{}", "Course"),
            FitFieldSchedule::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSchedule::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSchedule {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSchedule> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSchedule::from(v)),
            Err(_) => Ok(FitFieldSchedule::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSchedule);

impl From<u8> for FitFieldSchedule {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSchedule::Workout,
            1 => FitFieldSchedule::Course,
            _ => FitFieldSchedule::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCoursePoint {
    // fit base type: enum
    Generic = 0,
    Summit = 1,
    Valley = 2,
    Water = 3,
    Food = 4,
    Danger = 5,
    Left = 6,
    Right = 7,
    Straight = 8,
    FirstAid = 9,
    FourthCategory = 10,
    ThirdCategory = 11,
    SecondCategory = 12,
    FirstCategory = 13,
    HorsCategory = 14,
    Sprint = 15,
    LeftFork = 16,
    RightFork = 17,
    MiddleFork = 18,
    SlightLeft = 19,
    SharpLeft = 20,
    SlightRight = 21,
    SharpRight = 22,
    UTurn = 23,
    SegmentStart = 24,
    SegmentEnd = 25,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldCoursePoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCoursePoint::Generic => write!(f, "{}", "Generic"),
            FitFieldCoursePoint::Summit => write!(f, "{}", "Summit"),
            FitFieldCoursePoint::Valley => write!(f, "{}", "Valley"),
            FitFieldCoursePoint::Water => write!(f, "{}", "Water"),
            FitFieldCoursePoint::Food => write!(f, "{}", "Food"),
            FitFieldCoursePoint::Danger => write!(f, "{}", "Danger"),
            FitFieldCoursePoint::Left => write!(f, "{}", "Left"),
            FitFieldCoursePoint::Right => write!(f, "{}", "Right"),
            FitFieldCoursePoint::Straight => write!(f, "{}", "Straight"),
            FitFieldCoursePoint::FirstAid => write!(f, "{}", "FirstAid"),
            FitFieldCoursePoint::FourthCategory => write!(f, "{}", "FourthCategory"),
            FitFieldCoursePoint::ThirdCategory => write!(f, "{}", "ThirdCategory"),
            FitFieldCoursePoint::SecondCategory => write!(f, "{}", "SecondCategory"),
            FitFieldCoursePoint::FirstCategory => write!(f, "{}", "FirstCategory"),
            FitFieldCoursePoint::HorsCategory => write!(f, "{}", "HorsCategory"),
            FitFieldCoursePoint::Sprint => write!(f, "{}", "Sprint"),
            FitFieldCoursePoint::LeftFork => write!(f, "{}", "LeftFork"),
            FitFieldCoursePoint::RightFork => write!(f, "{}", "RightFork"),
            FitFieldCoursePoint::MiddleFork => write!(f, "{}", "MiddleFork"),
            FitFieldCoursePoint::SlightLeft => write!(f, "{}", "SlightLeft"),
            FitFieldCoursePoint::SharpLeft => write!(f, "{}", "SharpLeft"),
            FitFieldCoursePoint::SlightRight => write!(f, "{}", "SlightRight"),
            FitFieldCoursePoint::SharpRight => write!(f, "{}", "SharpRight"),
            FitFieldCoursePoint::UTurn => write!(f, "{}", "UTurn"),
            FitFieldCoursePoint::SegmentStart => write!(f, "{}", "SegmentStart"),
            FitFieldCoursePoint::SegmentEnd => write!(f, "{}", "SegmentEnd"),
            FitFieldCoursePoint::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCoursePoint::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCoursePoint {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCoursePoint> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldCoursePoint::from(v)),
            Err(_) => Ok(FitFieldCoursePoint::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldCoursePoint);

impl From<u8> for FitFieldCoursePoint {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldCoursePoint::Generic,
            1 => FitFieldCoursePoint::Summit,
            2 => FitFieldCoursePoint::Valley,
            3 => FitFieldCoursePoint::Water,
            4 => FitFieldCoursePoint::Food,
            5 => FitFieldCoursePoint::Danger,
            6 => FitFieldCoursePoint::Left,
            7 => FitFieldCoursePoint::Right,
            8 => FitFieldCoursePoint::Straight,
            9 => FitFieldCoursePoint::FirstAid,
            10 => FitFieldCoursePoint::FourthCategory,
            11 => FitFieldCoursePoint::ThirdCategory,
            12 => FitFieldCoursePoint::SecondCategory,
            13 => FitFieldCoursePoint::FirstCategory,
            14 => FitFieldCoursePoint::HorsCategory,
            15 => FitFieldCoursePoint::Sprint,
            16 => FitFieldCoursePoint::LeftFork,
            17 => FitFieldCoursePoint::RightFork,
            18 => FitFieldCoursePoint::MiddleFork,
            19 => FitFieldCoursePoint::SlightLeft,
            20 => FitFieldCoursePoint::SharpLeft,
            21 => FitFieldCoursePoint::SlightRight,
            22 => FitFieldCoursePoint::SharpRight,
            23 => FitFieldCoursePoint::UTurn,
            24 => FitFieldCoursePoint::SegmentStart,
            25 => FitFieldCoursePoint::SegmentEnd,
            _ => FitFieldCoursePoint::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldManufacturer {
    // fit base type: uint16
    Garmin,                 // 1
    GarminFr405Antfs,       // 2  Do not use.  Used by FR405 for ANTFS man id.
    Zephyr,                 // 3
    Dayton,                 // 4
    Idt,                    // 5
    Srm,                    // 6
    Quarq,                  // 7
    Ibike,                  // 8
    Saris,                  // 9
    SparkHk,                // 10
    Tanita,                 // 11
    Echowell,               // 12
    DynastreamOem,          // 13
    Nautilus,               // 14
    Dynastream,             // 15
    Timex,                  // 16
    Metrigear,              // 17
    Xelic,                  // 18
    Beurer,                 // 19
    Cardiosport,            // 20
    AAndD,                  // 21
    Hmm,                    // 22
    Suunto,                 // 23
    ThitaElektronik,        // 24
    Gpulse,                 // 25
    CleanMobile,            // 26
    PedalBrain,             // 27
    Peaksware,              // 28
    Saxonar,                // 29
    LemondFitness,          // 30
    Dexcom,                 // 31
    WahooFitness,           // 32
    OctaneFitness,          // 33
    Archinoetics,           // 34
    TheHurtBox,             // 35
    CitizenSystems,         // 36
    Magellan,               // 37
    Osynce,                 // 38
    Holux,                  // 39
    Concept2,               // 40
    OneGiantLeap,           // 42
    AceSensor,              // 43
    BrimBrothers,           // 44
    Xplova,                 // 45
    PerceptionDigital,      // 46
    Bf1systems,             // 47
    Pioneer,                // 48
    Spantec,                // 49
    Metalogics,             // 50
    SeikoEpson,             // 52
    SeikoEpsonOem,          // 53
    IforPowell,             // 54
    MaxwellGuider,          // 55
    StarTrac,               // 56
    Breakaway,              // 57
    AlatechTechnologyLtd,   // 58
    MioTechnologyEurope,    // 59
    Rotor,                  // 60
    Geonaute,               // 61
    IdBike,                 // 62
    Specialized,            // 63
    Wtek,                   // 64
    PhysicalEnterprises,    // 65
    NorthPoleEngineering,   // 66
    Bkool,                  // 67
    Cateye,                 // 68
    StagesCycling,          // 69
    Sigmasport,             // 70
    Tomtom,                 // 71
    Peripedal,              // 72
    Wattbike,               // 73
    Moxy,                   // 76
    Ciclosport,             // 77
    Powerbahn,              // 78
    AcornProjectsAps,       // 79
    Lifebeam,               // 80
    Bontrager,              // 81
    Wellgo,                 // 82
    Scosche,                // 83
    Magura,                 // 84
    Woodway,                // 85
    Elite,                  // 86
    NielsenKellerman,       // 87
    DkCity,                 // 88
    Tacx,                   // 89
    DirectionTechnology,    // 90
    Magtonic,               // 91
    InsideRideTechnologies, // 93
    SoundOfMotion,          // 94
    Stryd,                  // 95
    Icg,                    // 96  Indoorcycling Group
    MiPulse,                // 97
    BsxAthletics,           // 98
    Look,                   // 99
    CampagnoloSrl,          // 100
    BodyBikeSmart,          // 101
    Praxisworks,            // 102
    LimitsTechnology,       // 103  Limits Technology Ltd.
    TopactionTechnology,    // 104  TopAction Technology Inc.
    Cosinuss,               // 105
    Fitcare,                // 106
    Magene,                 // 107
    GiantManufacturingCo,   // 108
    Tigrasport,             // 109  Tigrasport
    Salutron,               // 110
    Technogym,              // 111
    BrytonSensors,          // 112
    LatitudeLimited,        // 113
    SoaringTechnology,      // 114
    Igpsport,               // 115
    Thinkrider,             // 116
    GopherSport,            // 117
    Waterrower,             // 118
    Orangetheory,           // 119
    Inpeak,                 // 120
    Kinetic,                // 121
    JohnsonHealthTech,      // 122
    PolarElectro,           // 123
    Seesense,               // 124
    NciTechnology,          // 125
    Iqsquare,               // 126
    Development,            // 255
    Healthandlife,          // 257
    Lezyne,                 // 258
    ScribeLabs,             // 259
    Zwift,                  // 260
    Watteam,                // 261
    Recon,                  // 262
    FaveroElectronics,      // 263
    Dynovelo,               // 264
    Strava,                 // 265
    Precor,                 // 266  Amer Sports
    Bryton,                 // 267
    Sram,                   // 268
    Navman,                 // 269  MiTAC Global Corporation (Mio Technology)
    Cobi,                   // 270  COBI GmbH
    Spivi,                  // 271
    MioMagellan,            // 272
    Evesports,              // 273
    SensitivusGauge,        // 274
    Podoon,                 // 275
    LifeTimeFitness,        // 276
    FalcoEMotors,           // 277  Falco eMotors Inc.
    Minoura,                // 278
    Cycliq,                 // 279
    Luxottica,              // 280
    TrainerRoad,            // 281
    TheSufferfest,          // 282
    Fullspeedahead,         // 283
    Virtualtraining,        // 284
    Feedbacksports,         // 285
    Omata,                  // 286
    Vdo,                    // 287
    Magneticdays,           // 288
    Hammerhead,             // 289
    KineticByKurt,          // 290
    Shapelog,               // 291
    Dabuziduo,              // 292
    Jetblack,               // 293
    Coros,                  // 294
    Virtugo,                // 295
    Velosense,              // 296
    Cycligentinc,           // 297
    Trailforks,             // 298
    Actigraphcorp,          // 5759
    Manufacturer(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldManufacturer {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldManufacturer::Garmin => write!(f, "{}", "Garmin"),
            FitFieldManufacturer::GarminFr405Antfs => write!(f, "{}", "GarminFr405Antfs"),
            FitFieldManufacturer::Zephyr => write!(f, "{}", "Zephyr"),
            FitFieldManufacturer::Dayton => write!(f, "{}", "Dayton"),
            FitFieldManufacturer::Idt => write!(f, "{}", "Idt"),
            FitFieldManufacturer::Srm => write!(f, "{}", "Srm"),
            FitFieldManufacturer::Quarq => write!(f, "{}", "Quarq"),
            FitFieldManufacturer::Ibike => write!(f, "{}", "Ibike"),
            FitFieldManufacturer::Saris => write!(f, "{}", "Saris"),
            FitFieldManufacturer::SparkHk => write!(f, "{}", "SparkHk"),
            FitFieldManufacturer::Tanita => write!(f, "{}", "Tanita"),
            FitFieldManufacturer::Echowell => write!(f, "{}", "Echowell"),
            FitFieldManufacturer::DynastreamOem => write!(f, "{}", "DynastreamOem"),
            FitFieldManufacturer::Nautilus => write!(f, "{}", "Nautilus"),
            FitFieldManufacturer::Dynastream => write!(f, "{}", "Dynastream"),
            FitFieldManufacturer::Timex => write!(f, "{}", "Timex"),
            FitFieldManufacturer::Metrigear => write!(f, "{}", "Metrigear"),
            FitFieldManufacturer::Xelic => write!(f, "{}", "Xelic"),
            FitFieldManufacturer::Beurer => write!(f, "{}", "Beurer"),
            FitFieldManufacturer::Cardiosport => write!(f, "{}", "Cardiosport"),
            FitFieldManufacturer::AAndD => write!(f, "{}", "AAndD"),
            FitFieldManufacturer::Hmm => write!(f, "{}", "Hmm"),
            FitFieldManufacturer::Suunto => write!(f, "{}", "Suunto"),
            FitFieldManufacturer::ThitaElektronik => write!(f, "{}", "ThitaElektronik"),
            FitFieldManufacturer::Gpulse => write!(f, "{}", "Gpulse"),
            FitFieldManufacturer::CleanMobile => write!(f, "{}", "CleanMobile"),
            FitFieldManufacturer::PedalBrain => write!(f, "{}", "PedalBrain"),
            FitFieldManufacturer::Peaksware => write!(f, "{}", "Peaksware"),
            FitFieldManufacturer::Saxonar => write!(f, "{}", "Saxonar"),
            FitFieldManufacturer::LemondFitness => write!(f, "{}", "LemondFitness"),
            FitFieldManufacturer::Dexcom => write!(f, "{}", "Dexcom"),
            FitFieldManufacturer::WahooFitness => write!(f, "{}", "WahooFitness"),
            FitFieldManufacturer::OctaneFitness => write!(f, "{}", "OctaneFitness"),
            FitFieldManufacturer::Archinoetics => write!(f, "{}", "Archinoetics"),
            FitFieldManufacturer::TheHurtBox => write!(f, "{}", "TheHurtBox"),
            FitFieldManufacturer::CitizenSystems => write!(f, "{}", "CitizenSystems"),
            FitFieldManufacturer::Magellan => write!(f, "{}", "Magellan"),
            FitFieldManufacturer::Osynce => write!(f, "{}", "Osynce"),
            FitFieldManufacturer::Holux => write!(f, "{}", "Holux"),
            FitFieldManufacturer::Concept2 => write!(f, "{}", "Concept2"),
            FitFieldManufacturer::OneGiantLeap => write!(f, "{}", "OneGiantLeap"),
            FitFieldManufacturer::AceSensor => write!(f, "{}", "AceSensor"),
            FitFieldManufacturer::BrimBrothers => write!(f, "{}", "BrimBrothers"),
            FitFieldManufacturer::Xplova => write!(f, "{}", "Xplova"),
            FitFieldManufacturer::PerceptionDigital => write!(f, "{}", "PerceptionDigital"),
            FitFieldManufacturer::Bf1systems => write!(f, "{}", "Bf1systems"),
            FitFieldManufacturer::Pioneer => write!(f, "{}", "Pioneer"),
            FitFieldManufacturer::Spantec => write!(f, "{}", "Spantec"),
            FitFieldManufacturer::Metalogics => write!(f, "{}", "Metalogics"),
            FitFieldManufacturer::SeikoEpson => write!(f, "{}", "SeikoEpson"),
            FitFieldManufacturer::SeikoEpsonOem => write!(f, "{}", "SeikoEpsonOem"),
            FitFieldManufacturer::IforPowell => write!(f, "{}", "IforPowell"),
            FitFieldManufacturer::MaxwellGuider => write!(f, "{}", "MaxwellGuider"),
            FitFieldManufacturer::StarTrac => write!(f, "{}", "StarTrac"),
            FitFieldManufacturer::Breakaway => write!(f, "{}", "Breakaway"),
            FitFieldManufacturer::AlatechTechnologyLtd => write!(f, "{}", "AlatechTechnologyLtd"),
            FitFieldManufacturer::MioTechnologyEurope => write!(f, "{}", "MioTechnologyEurope"),
            FitFieldManufacturer::Rotor => write!(f, "{}", "Rotor"),
            FitFieldManufacturer::Geonaute => write!(f, "{}", "Geonaute"),
            FitFieldManufacturer::IdBike => write!(f, "{}", "IdBike"),
            FitFieldManufacturer::Specialized => write!(f, "{}", "Specialized"),
            FitFieldManufacturer::Wtek => write!(f, "{}", "Wtek"),
            FitFieldManufacturer::PhysicalEnterprises => write!(f, "{}", "PhysicalEnterprises"),
            FitFieldManufacturer::NorthPoleEngineering => write!(f, "{}", "NorthPoleEngineering"),
            FitFieldManufacturer::Bkool => write!(f, "{}", "Bkool"),
            FitFieldManufacturer::Cateye => write!(f, "{}", "Cateye"),
            FitFieldManufacturer::StagesCycling => write!(f, "{}", "StagesCycling"),
            FitFieldManufacturer::Sigmasport => write!(f, "{}", "Sigmasport"),
            FitFieldManufacturer::Tomtom => write!(f, "{}", "Tomtom"),
            FitFieldManufacturer::Peripedal => write!(f, "{}", "Peripedal"),
            FitFieldManufacturer::Wattbike => write!(f, "{}", "Wattbike"),
            FitFieldManufacturer::Moxy => write!(f, "{}", "Moxy"),
            FitFieldManufacturer::Ciclosport => write!(f, "{}", "Ciclosport"),
            FitFieldManufacturer::Powerbahn => write!(f, "{}", "Powerbahn"),
            FitFieldManufacturer::AcornProjectsAps => write!(f, "{}", "AcornProjectsAps"),
            FitFieldManufacturer::Lifebeam => write!(f, "{}", "Lifebeam"),
            FitFieldManufacturer::Bontrager => write!(f, "{}", "Bontrager"),
            FitFieldManufacturer::Wellgo => write!(f, "{}", "Wellgo"),
            FitFieldManufacturer::Scosche => write!(f, "{}", "Scosche"),
            FitFieldManufacturer::Magura => write!(f, "{}", "Magura"),
            FitFieldManufacturer::Woodway => write!(f, "{}", "Woodway"),
            FitFieldManufacturer::Elite => write!(f, "{}", "Elite"),
            FitFieldManufacturer::NielsenKellerman => write!(f, "{}", "NielsenKellerman"),
            FitFieldManufacturer::DkCity => write!(f, "{}", "DkCity"),
            FitFieldManufacturer::Tacx => write!(f, "{}", "Tacx"),
            FitFieldManufacturer::DirectionTechnology => write!(f, "{}", "DirectionTechnology"),
            FitFieldManufacturer::Magtonic => write!(f, "{}", "Magtonic"),
            FitFieldManufacturer::InsideRideTechnologies => {
                write!(f, "{}", "InsideRideTechnologies")
            }
            FitFieldManufacturer::SoundOfMotion => write!(f, "{}", "SoundOfMotion"),
            FitFieldManufacturer::Stryd => write!(f, "{}", "Stryd"),
            FitFieldManufacturer::Icg => write!(f, "{}", "Icg"),
            FitFieldManufacturer::MiPulse => write!(f, "{}", "MiPulse"),
            FitFieldManufacturer::BsxAthletics => write!(f, "{}", "BsxAthletics"),
            FitFieldManufacturer::Look => write!(f, "{}", "Look"),
            FitFieldManufacturer::CampagnoloSrl => write!(f, "{}", "CampagnoloSrl"),
            FitFieldManufacturer::BodyBikeSmart => write!(f, "{}", "BodyBikeSmart"),
            FitFieldManufacturer::Praxisworks => write!(f, "{}", "Praxisworks"),
            FitFieldManufacturer::LimitsTechnology => write!(f, "{}", "LimitsTechnology"),
            FitFieldManufacturer::TopactionTechnology => write!(f, "{}", "TopactionTechnology"),
            FitFieldManufacturer::Cosinuss => write!(f, "{}", "Cosinuss"),
            FitFieldManufacturer::Fitcare => write!(f, "{}", "Fitcare"),
            FitFieldManufacturer::Magene => write!(f, "{}", "Magene"),
            FitFieldManufacturer::GiantManufacturingCo => write!(f, "{}", "GiantManufacturingCo"),
            FitFieldManufacturer::Tigrasport => write!(f, "{}", "Tigrasport"),
            FitFieldManufacturer::Salutron => write!(f, "{}", "Salutron"),
            FitFieldManufacturer::Technogym => write!(f, "{}", "Technogym"),
            FitFieldManufacturer::BrytonSensors => write!(f, "{}", "BrytonSensors"),
            FitFieldManufacturer::LatitudeLimited => write!(f, "{}", "LatitudeLimited"),
            FitFieldManufacturer::SoaringTechnology => write!(f, "{}", "SoaringTechnology"),
            FitFieldManufacturer::Igpsport => write!(f, "{}", "Igpsport"),
            FitFieldManufacturer::Thinkrider => write!(f, "{}", "Thinkrider"),
            FitFieldManufacturer::GopherSport => write!(f, "{}", "GopherSport"),
            FitFieldManufacturer::Waterrower => write!(f, "{}", "Waterrower"),
            FitFieldManufacturer::Orangetheory => write!(f, "{}", "Orangetheory"),
            FitFieldManufacturer::Inpeak => write!(f, "{}", "Inpeak"),
            FitFieldManufacturer::Kinetic => write!(f, "{}", "Kinetic"),
            FitFieldManufacturer::JohnsonHealthTech => write!(f, "{}", "JohnsonHealthTech"),
            FitFieldManufacturer::PolarElectro => write!(f, "{}", "PolarElectro"),
            FitFieldManufacturer::Seesense => write!(f, "{}", "Seesense"),
            FitFieldManufacturer::NciTechnology => write!(f, "{}", "NciTechnology"),
            FitFieldManufacturer::Iqsquare => write!(f, "{}", "Iqsquare"),
            FitFieldManufacturer::Development => write!(f, "{}", "Development"),
            FitFieldManufacturer::Healthandlife => write!(f, "{}", "Healthandlife"),
            FitFieldManufacturer::Lezyne => write!(f, "{}", "Lezyne"),
            FitFieldManufacturer::ScribeLabs => write!(f, "{}", "ScribeLabs"),
            FitFieldManufacturer::Zwift => write!(f, "{}", "Zwift"),
            FitFieldManufacturer::Watteam => write!(f, "{}", "Watteam"),
            FitFieldManufacturer::Recon => write!(f, "{}", "Recon"),
            FitFieldManufacturer::FaveroElectronics => write!(f, "{}", "FaveroElectronics"),
            FitFieldManufacturer::Dynovelo => write!(f, "{}", "Dynovelo"),
            FitFieldManufacturer::Strava => write!(f, "{}", "Strava"),
            FitFieldManufacturer::Precor => write!(f, "{}", "Precor"),
            FitFieldManufacturer::Bryton => write!(f, "{}", "Bryton"),
            FitFieldManufacturer::Sram => write!(f, "{}", "Sram"),
            FitFieldManufacturer::Navman => write!(f, "{}", "Navman"),
            FitFieldManufacturer::Cobi => write!(f, "{}", "Cobi"),
            FitFieldManufacturer::Spivi => write!(f, "{}", "Spivi"),
            FitFieldManufacturer::MioMagellan => write!(f, "{}", "MioMagellan"),
            FitFieldManufacturer::Evesports => write!(f, "{}", "Evesports"),
            FitFieldManufacturer::SensitivusGauge => write!(f, "{}", "SensitivusGauge"),
            FitFieldManufacturer::Podoon => write!(f, "{}", "Podoon"),
            FitFieldManufacturer::LifeTimeFitness => write!(f, "{}", "LifeTimeFitness"),
            FitFieldManufacturer::FalcoEMotors => write!(f, "{}", "FalcoEMotors"),
            FitFieldManufacturer::Minoura => write!(f, "{}", "Minoura"),
            FitFieldManufacturer::Cycliq => write!(f, "{}", "Cycliq"),
            FitFieldManufacturer::Luxottica => write!(f, "{}", "Luxottica"),
            FitFieldManufacturer::TrainerRoad => write!(f, "{}", "TrainerRoad"),
            FitFieldManufacturer::TheSufferfest => write!(f, "{}", "TheSufferfest"),
            FitFieldManufacturer::Fullspeedahead => write!(f, "{}", "Fullspeedahead"),
            FitFieldManufacturer::Virtualtraining => write!(f, "{}", "Virtualtraining"),
            FitFieldManufacturer::Feedbacksports => write!(f, "{}", "Feedbacksports"),
            FitFieldManufacturer::Omata => write!(f, "{}", "Omata"),
            FitFieldManufacturer::Vdo => write!(f, "{}", "Vdo"),
            FitFieldManufacturer::Magneticdays => write!(f, "{}", "Magneticdays"),
            FitFieldManufacturer::Hammerhead => write!(f, "{}", "Hammerhead"),
            FitFieldManufacturer::KineticByKurt => write!(f, "{}", "KineticByKurt"),
            FitFieldManufacturer::Shapelog => write!(f, "{}", "Shapelog"),
            FitFieldManufacturer::Dabuziduo => write!(f, "{}", "Dabuziduo"),
            FitFieldManufacturer::Jetblack => write!(f, "{}", "Jetblack"),
            FitFieldManufacturer::Coros => write!(f, "{}", "Coros"),
            FitFieldManufacturer::Virtugo => write!(f, "{}", "Virtugo"),
            FitFieldManufacturer::Velosense => write!(f, "{}", "Velosense"),
            FitFieldManufacturer::Cycligentinc => write!(f, "{}", "Cycligentinc"),
            FitFieldManufacturer::Trailforks => write!(f, "{}", "Trailforks"),
            FitFieldManufacturer::Actigraphcorp => write!(f, "{}", "Actigraphcorp"),
            FitFieldManufacturer::Manufacturer(x) => write!(f, "{}({})", "Manufacturer", x),
            FitFieldManufacturer::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldManufacturer::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldManufacturer {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldManufacturer> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldManufacturer::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldManufacturer::from(v)),
                2 => Ok(FitFieldManufacturer::from(v)),
                3 => Ok(FitFieldManufacturer::from(v)),
                4 => Ok(FitFieldManufacturer::from(v)),
                5 => Ok(FitFieldManufacturer::from(v)),
                6 => Ok(FitFieldManufacturer::from(v)),
                7 => Ok(FitFieldManufacturer::from(v)),
                8 => Ok(FitFieldManufacturer::from(v)),
                9 => Ok(FitFieldManufacturer::from(v)),
                10 => Ok(FitFieldManufacturer::from(v)),
                11 => Ok(FitFieldManufacturer::from(v)),
                12 => Ok(FitFieldManufacturer::from(v)),
                13 => Ok(FitFieldManufacturer::from(v)),
                14 => Ok(FitFieldManufacturer::from(v)),
                15 => Ok(FitFieldManufacturer::from(v)),
                16 => Ok(FitFieldManufacturer::from(v)),
                17 => Ok(FitFieldManufacturer::from(v)),
                18 => Ok(FitFieldManufacturer::from(v)),
                19 => Ok(FitFieldManufacturer::from(v)),
                20 => Ok(FitFieldManufacturer::from(v)),
                21 => Ok(FitFieldManufacturer::from(v)),
                22 => Ok(FitFieldManufacturer::from(v)),
                23 => Ok(FitFieldManufacturer::from(v)),
                24 => Ok(FitFieldManufacturer::from(v)),
                25 => Ok(FitFieldManufacturer::from(v)),
                26 => Ok(FitFieldManufacturer::from(v)),
                27 => Ok(FitFieldManufacturer::from(v)),
                28 => Ok(FitFieldManufacturer::from(v)),
                29 => Ok(FitFieldManufacturer::from(v)),
                30 => Ok(FitFieldManufacturer::from(v)),
                31 => Ok(FitFieldManufacturer::from(v)),
                32 => Ok(FitFieldManufacturer::from(v)),
                33 => Ok(FitFieldManufacturer::from(v)),
                34 => Ok(FitFieldManufacturer::from(v)),
                35 => Ok(FitFieldManufacturer::from(v)),
                36 => Ok(FitFieldManufacturer::from(v)),
                37 => Ok(FitFieldManufacturer::from(v)),
                38 => Ok(FitFieldManufacturer::from(v)),
                39 => Ok(FitFieldManufacturer::from(v)),
                40 => Ok(FitFieldManufacturer::from(v)),
                42 => Ok(FitFieldManufacturer::from(v)),
                43 => Ok(FitFieldManufacturer::from(v)),
                44 => Ok(FitFieldManufacturer::from(v)),
                45 => Ok(FitFieldManufacturer::from(v)),
                46 => Ok(FitFieldManufacturer::from(v)),
                47 => Ok(FitFieldManufacturer::from(v)),
                48 => Ok(FitFieldManufacturer::from(v)),
                49 => Ok(FitFieldManufacturer::from(v)),
                50 => Ok(FitFieldManufacturer::from(v)),
                52 => Ok(FitFieldManufacturer::from(v)),
                53 => Ok(FitFieldManufacturer::from(v)),
                54 => Ok(FitFieldManufacturer::from(v)),
                55 => Ok(FitFieldManufacturer::from(v)),
                56 => Ok(FitFieldManufacturer::from(v)),
                57 => Ok(FitFieldManufacturer::from(v)),
                58 => Ok(FitFieldManufacturer::from(v)),
                59 => Ok(FitFieldManufacturer::from(v)),
                60 => Ok(FitFieldManufacturer::from(v)),
                61 => Ok(FitFieldManufacturer::from(v)),
                62 => Ok(FitFieldManufacturer::from(v)),
                63 => Ok(FitFieldManufacturer::from(v)),
                64 => Ok(FitFieldManufacturer::from(v)),
                65 => Ok(FitFieldManufacturer::from(v)),
                66 => Ok(FitFieldManufacturer::from(v)),
                67 => Ok(FitFieldManufacturer::from(v)),
                68 => Ok(FitFieldManufacturer::from(v)),
                69 => Ok(FitFieldManufacturer::from(v)),
                70 => Ok(FitFieldManufacturer::from(v)),
                71 => Ok(FitFieldManufacturer::from(v)),
                72 => Ok(FitFieldManufacturer::from(v)),
                73 => Ok(FitFieldManufacturer::from(v)),
                76 => Ok(FitFieldManufacturer::from(v)),
                77 => Ok(FitFieldManufacturer::from(v)),
                78 => Ok(FitFieldManufacturer::from(v)),
                79 => Ok(FitFieldManufacturer::from(v)),
                80 => Ok(FitFieldManufacturer::from(v)),
                81 => Ok(FitFieldManufacturer::from(v)),
                82 => Ok(FitFieldManufacturer::from(v)),
                83 => Ok(FitFieldManufacturer::from(v)),
                84 => Ok(FitFieldManufacturer::from(v)),
                85 => Ok(FitFieldManufacturer::from(v)),
                86 => Ok(FitFieldManufacturer::from(v)),
                87 => Ok(FitFieldManufacturer::from(v)),
                88 => Ok(FitFieldManufacturer::from(v)),
                89 => Ok(FitFieldManufacturer::from(v)),
                90 => Ok(FitFieldManufacturer::from(v)),
                91 => Ok(FitFieldManufacturer::from(v)),
                93 => Ok(FitFieldManufacturer::from(v)),
                94 => Ok(FitFieldManufacturer::from(v)),
                95 => Ok(FitFieldManufacturer::from(v)),
                96 => Ok(FitFieldManufacturer::from(v)),
                97 => Ok(FitFieldManufacturer::from(v)),
                98 => Ok(FitFieldManufacturer::from(v)),
                99 => Ok(FitFieldManufacturer::from(v)),
                100 => Ok(FitFieldManufacturer::from(v)),
                101 => Ok(FitFieldManufacturer::from(v)),
                102 => Ok(FitFieldManufacturer::from(v)),
                103 => Ok(FitFieldManufacturer::from(v)),
                104 => Ok(FitFieldManufacturer::from(v)),
                105 => Ok(FitFieldManufacturer::from(v)),
                106 => Ok(FitFieldManufacturer::from(v)),
                107 => Ok(FitFieldManufacturer::from(v)),
                108 => Ok(FitFieldManufacturer::from(v)),
                109 => Ok(FitFieldManufacturer::from(v)),
                110 => Ok(FitFieldManufacturer::from(v)),
                111 => Ok(FitFieldManufacturer::from(v)),
                112 => Ok(FitFieldManufacturer::from(v)),
                113 => Ok(FitFieldManufacturer::from(v)),
                114 => Ok(FitFieldManufacturer::from(v)),
                115 => Ok(FitFieldManufacturer::from(v)),
                116 => Ok(FitFieldManufacturer::from(v)),
                117 => Ok(FitFieldManufacturer::from(v)),
                118 => Ok(FitFieldManufacturer::from(v)),
                119 => Ok(FitFieldManufacturer::from(v)),
                120 => Ok(FitFieldManufacturer::from(v)),
                121 => Ok(FitFieldManufacturer::from(v)),
                122 => Ok(FitFieldManufacturer::from(v)),
                123 => Ok(FitFieldManufacturer::from(v)),
                124 => Ok(FitFieldManufacturer::from(v)),
                125 => Ok(FitFieldManufacturer::from(v)),
                126 => Ok(FitFieldManufacturer::from(v)),
                255 => Ok(FitFieldManufacturer::from(v)),
                257 => Ok(FitFieldManufacturer::from(v)),
                258 => Ok(FitFieldManufacturer::from(v)),
                259 => Ok(FitFieldManufacturer::from(v)),
                260 => Ok(FitFieldManufacturer::from(v)),
                261 => Ok(FitFieldManufacturer::from(v)),
                262 => Ok(FitFieldManufacturer::from(v)),
                263 => Ok(FitFieldManufacturer::from(v)),
                264 => Ok(FitFieldManufacturer::from(v)),
                265 => Ok(FitFieldManufacturer::from(v)),
                266 => Ok(FitFieldManufacturer::from(v)),
                267 => Ok(FitFieldManufacturer::from(v)),
                268 => Ok(FitFieldManufacturer::from(v)),
                269 => Ok(FitFieldManufacturer::from(v)),
                270 => Ok(FitFieldManufacturer::from(v)),
                271 => Ok(FitFieldManufacturer::from(v)),
                272 => Ok(FitFieldManufacturer::from(v)),
                273 => Ok(FitFieldManufacturer::from(v)),
                274 => Ok(FitFieldManufacturer::from(v)),
                275 => Ok(FitFieldManufacturer::from(v)),
                276 => Ok(FitFieldManufacturer::from(v)),
                277 => Ok(FitFieldManufacturer::from(v)),
                278 => Ok(FitFieldManufacturer::from(v)),
                279 => Ok(FitFieldManufacturer::from(v)),
                280 => Ok(FitFieldManufacturer::from(v)),
                281 => Ok(FitFieldManufacturer::from(v)),
                282 => Ok(FitFieldManufacturer::from(v)),
                283 => Ok(FitFieldManufacturer::from(v)),
                284 => Ok(FitFieldManufacturer::from(v)),
                285 => Ok(FitFieldManufacturer::from(v)),
                286 => Ok(FitFieldManufacturer::from(v)),
                287 => Ok(FitFieldManufacturer::from(v)),
                288 => Ok(FitFieldManufacturer::from(v)),
                289 => Ok(FitFieldManufacturer::from(v)),
                290 => Ok(FitFieldManufacturer::from(v)),
                291 => Ok(FitFieldManufacturer::from(v)),
                292 => Ok(FitFieldManufacturer::from(v)),
                293 => Ok(FitFieldManufacturer::from(v)),
                294 => Ok(FitFieldManufacturer::from(v)),
                295 => Ok(FitFieldManufacturer::from(v)),
                296 => Ok(FitFieldManufacturer::from(v)),
                297 => Ok(FitFieldManufacturer::from(v)),
                298 => Ok(FitFieldManufacturer::from(v)),
                5759 => Ok(FitFieldManufacturer::from(v)),
                v => Ok(FitFieldManufacturer::Manufacturer(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldManufacturer);

impl From<u16> for FitFieldManufacturer {
    fn from(code: u16) -> Self {
        match code {
            1 => FitFieldManufacturer::Garmin,
            2 => FitFieldManufacturer::GarminFr405Antfs,
            3 => FitFieldManufacturer::Zephyr,
            4 => FitFieldManufacturer::Dayton,
            5 => FitFieldManufacturer::Idt,
            6 => FitFieldManufacturer::Srm,
            7 => FitFieldManufacturer::Quarq,
            8 => FitFieldManufacturer::Ibike,
            9 => FitFieldManufacturer::Saris,
            10 => FitFieldManufacturer::SparkHk,
            11 => FitFieldManufacturer::Tanita,
            12 => FitFieldManufacturer::Echowell,
            13 => FitFieldManufacturer::DynastreamOem,
            14 => FitFieldManufacturer::Nautilus,
            15 => FitFieldManufacturer::Dynastream,
            16 => FitFieldManufacturer::Timex,
            17 => FitFieldManufacturer::Metrigear,
            18 => FitFieldManufacturer::Xelic,
            19 => FitFieldManufacturer::Beurer,
            20 => FitFieldManufacturer::Cardiosport,
            21 => FitFieldManufacturer::AAndD,
            22 => FitFieldManufacturer::Hmm,
            23 => FitFieldManufacturer::Suunto,
            24 => FitFieldManufacturer::ThitaElektronik,
            25 => FitFieldManufacturer::Gpulse,
            26 => FitFieldManufacturer::CleanMobile,
            27 => FitFieldManufacturer::PedalBrain,
            28 => FitFieldManufacturer::Peaksware,
            29 => FitFieldManufacturer::Saxonar,
            30 => FitFieldManufacturer::LemondFitness,
            31 => FitFieldManufacturer::Dexcom,
            32 => FitFieldManufacturer::WahooFitness,
            33 => FitFieldManufacturer::OctaneFitness,
            34 => FitFieldManufacturer::Archinoetics,
            35 => FitFieldManufacturer::TheHurtBox,
            36 => FitFieldManufacturer::CitizenSystems,
            37 => FitFieldManufacturer::Magellan,
            38 => FitFieldManufacturer::Osynce,
            39 => FitFieldManufacturer::Holux,
            40 => FitFieldManufacturer::Concept2,
            42 => FitFieldManufacturer::OneGiantLeap,
            43 => FitFieldManufacturer::AceSensor,
            44 => FitFieldManufacturer::BrimBrothers,
            45 => FitFieldManufacturer::Xplova,
            46 => FitFieldManufacturer::PerceptionDigital,
            47 => FitFieldManufacturer::Bf1systems,
            48 => FitFieldManufacturer::Pioneer,
            49 => FitFieldManufacturer::Spantec,
            50 => FitFieldManufacturer::Metalogics,
            52 => FitFieldManufacturer::SeikoEpson,
            53 => FitFieldManufacturer::SeikoEpsonOem,
            54 => FitFieldManufacturer::IforPowell,
            55 => FitFieldManufacturer::MaxwellGuider,
            56 => FitFieldManufacturer::StarTrac,
            57 => FitFieldManufacturer::Breakaway,
            58 => FitFieldManufacturer::AlatechTechnologyLtd,
            59 => FitFieldManufacturer::MioTechnologyEurope,
            60 => FitFieldManufacturer::Rotor,
            61 => FitFieldManufacturer::Geonaute,
            62 => FitFieldManufacturer::IdBike,
            63 => FitFieldManufacturer::Specialized,
            64 => FitFieldManufacturer::Wtek,
            65 => FitFieldManufacturer::PhysicalEnterprises,
            66 => FitFieldManufacturer::NorthPoleEngineering,
            67 => FitFieldManufacturer::Bkool,
            68 => FitFieldManufacturer::Cateye,
            69 => FitFieldManufacturer::StagesCycling,
            70 => FitFieldManufacturer::Sigmasport,
            71 => FitFieldManufacturer::Tomtom,
            72 => FitFieldManufacturer::Peripedal,
            73 => FitFieldManufacturer::Wattbike,
            76 => FitFieldManufacturer::Moxy,
            77 => FitFieldManufacturer::Ciclosport,
            78 => FitFieldManufacturer::Powerbahn,
            79 => FitFieldManufacturer::AcornProjectsAps,
            80 => FitFieldManufacturer::Lifebeam,
            81 => FitFieldManufacturer::Bontrager,
            82 => FitFieldManufacturer::Wellgo,
            83 => FitFieldManufacturer::Scosche,
            84 => FitFieldManufacturer::Magura,
            85 => FitFieldManufacturer::Woodway,
            86 => FitFieldManufacturer::Elite,
            87 => FitFieldManufacturer::NielsenKellerman,
            88 => FitFieldManufacturer::DkCity,
            89 => FitFieldManufacturer::Tacx,
            90 => FitFieldManufacturer::DirectionTechnology,
            91 => FitFieldManufacturer::Magtonic,
            93 => FitFieldManufacturer::InsideRideTechnologies,
            94 => FitFieldManufacturer::SoundOfMotion,
            95 => FitFieldManufacturer::Stryd,
            96 => FitFieldManufacturer::Icg,
            97 => FitFieldManufacturer::MiPulse,
            98 => FitFieldManufacturer::BsxAthletics,
            99 => FitFieldManufacturer::Look,
            100 => FitFieldManufacturer::CampagnoloSrl,
            101 => FitFieldManufacturer::BodyBikeSmart,
            102 => FitFieldManufacturer::Praxisworks,
            103 => FitFieldManufacturer::LimitsTechnology,
            104 => FitFieldManufacturer::TopactionTechnology,
            105 => FitFieldManufacturer::Cosinuss,
            106 => FitFieldManufacturer::Fitcare,
            107 => FitFieldManufacturer::Magene,
            108 => FitFieldManufacturer::GiantManufacturingCo,
            109 => FitFieldManufacturer::Tigrasport,
            110 => FitFieldManufacturer::Salutron,
            111 => FitFieldManufacturer::Technogym,
            112 => FitFieldManufacturer::BrytonSensors,
            113 => FitFieldManufacturer::LatitudeLimited,
            114 => FitFieldManufacturer::SoaringTechnology,
            115 => FitFieldManufacturer::Igpsport,
            116 => FitFieldManufacturer::Thinkrider,
            117 => FitFieldManufacturer::GopherSport,
            118 => FitFieldManufacturer::Waterrower,
            119 => FitFieldManufacturer::Orangetheory,
            120 => FitFieldManufacturer::Inpeak,
            121 => FitFieldManufacturer::Kinetic,
            122 => FitFieldManufacturer::JohnsonHealthTech,
            123 => FitFieldManufacturer::PolarElectro,
            124 => FitFieldManufacturer::Seesense,
            125 => FitFieldManufacturer::NciTechnology,
            126 => FitFieldManufacturer::Iqsquare,
            255 => FitFieldManufacturer::Development,
            257 => FitFieldManufacturer::Healthandlife,
            258 => FitFieldManufacturer::Lezyne,
            259 => FitFieldManufacturer::ScribeLabs,
            260 => FitFieldManufacturer::Zwift,
            261 => FitFieldManufacturer::Watteam,
            262 => FitFieldManufacturer::Recon,
            263 => FitFieldManufacturer::FaveroElectronics,
            264 => FitFieldManufacturer::Dynovelo,
            265 => FitFieldManufacturer::Strava,
            266 => FitFieldManufacturer::Precor,
            267 => FitFieldManufacturer::Bryton,
            268 => FitFieldManufacturer::Sram,
            269 => FitFieldManufacturer::Navman,
            270 => FitFieldManufacturer::Cobi,
            271 => FitFieldManufacturer::Spivi,
            272 => FitFieldManufacturer::MioMagellan,
            273 => FitFieldManufacturer::Evesports,
            274 => FitFieldManufacturer::SensitivusGauge,
            275 => FitFieldManufacturer::Podoon,
            276 => FitFieldManufacturer::LifeTimeFitness,
            277 => FitFieldManufacturer::FalcoEMotors,
            278 => FitFieldManufacturer::Minoura,
            279 => FitFieldManufacturer::Cycliq,
            280 => FitFieldManufacturer::Luxottica,
            281 => FitFieldManufacturer::TrainerRoad,
            282 => FitFieldManufacturer::TheSufferfest,
            283 => FitFieldManufacturer::Fullspeedahead,
            284 => FitFieldManufacturer::Virtualtraining,
            285 => FitFieldManufacturer::Feedbacksports,
            286 => FitFieldManufacturer::Omata,
            287 => FitFieldManufacturer::Vdo,
            288 => FitFieldManufacturer::Magneticdays,
            289 => FitFieldManufacturer::Hammerhead,
            290 => FitFieldManufacturer::KineticByKurt,
            291 => FitFieldManufacturer::Shapelog,
            292 => FitFieldManufacturer::Dabuziduo,
            293 => FitFieldManufacturer::Jetblack,
            294 => FitFieldManufacturer::Coros,
            295 => FitFieldManufacturer::Virtugo,
            296 => FitFieldManufacturer::Velosense,
            297 => FitFieldManufacturer::Cycligentinc,
            298 => FitFieldManufacturer::Trailforks,
            5759 => FitFieldManufacturer::Actigraphcorp,
            _ => FitFieldManufacturer::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldGarminProduct {
    // fit base type: uint16
    Hrm1,                      // 1
    Axh01,                     // 2  AXH01 HRM chipset
    Axb01,                     // 3
    Axb02,                     // 4
    Hrm2ss,                    // 5
    DsiAlf02,                  // 6
    Hrm3ss,                    // 7
    HrmRunSingleByteProductId, // 8  hrm_run model for HRM ANT+ messaging
    Bsm,                       // 9  BSM model for ANT+ messaging
    Bcm,                       // 10  BCM model for ANT+ messaging
    Axs01,                     // 11  AXS01 HRM Bike Chipset model for ANT+ messaging
    HrmTriSingleByteProductId, // 12  hrm_tri model for HRM ANT+ messaging
    Fr225SingleByteProductId,  // 14  fr225 model for HRM ANT+ messaging
    Fr301China,                // 473
    Fr301Japan,                // 474
    Fr301Korea,                // 475
    Fr301Taiwan,               // 494
    Fr405,                     // 717  Forerunner 405
    Fr50,                      // 782  Forerunner 50
    Fr405Japan,                // 987
    Fr60,                      // 988  Forerunner 60
    DsiAlf01,                  // 1011
    Fr310xt,                   // 1018  Forerunner 310
    Edge500,                   // 1036
    Fr110,                     // 1124  Forerunner 110
    Edge800,                   // 1169
    Edge500Taiwan,             // 1199
    Edge500Japan,              // 1213
    Chirp,                     // 1253
    Fr110Japan,                // 1274
    Edge200,                   // 1325
    Fr910xt,                   // 1328
    Edge800Taiwan,             // 1333
    Edge800Japan,              // 1334
    Alf04,                     // 1341
    Fr610,                     // 1345
    Fr210Japan,                // 1360
    VectorSs,                  // 1380
    VectorCp,                  // 1381
    Edge800China,              // 1386
    Edge500China,              // 1387
    Fr610Japan,                // 1410
    Edge500Korea,              // 1422
    Fr70,                      // 1436
    Fr310xt4t,                 // 1446
    Amx,                       // 1461
    Fr10,                      // 1482
    Edge800Korea,              // 1497
    Swim,                      // 1499
    Fr910xtChina,              // 1537
    Fenix,                     // 1551
    Edge200Taiwan,             // 1555
    Edge510,                   // 1561
    Edge810,                   // 1567
    Tempe,                     // 1570
    Fr910xtJapan,              // 1600
    Fr620,                     // 1623
    Fr220,                     // 1632
    Fr910xtKorea,              // 1664
    Fr10Japan,                 // 1688
    Edge810Japan,              // 1721
    VirbElite,                 // 1735
    EdgeTouring,               // 1736  Also Edge Touring Plus
    Edge510Japan,              // 1742
    HrmTri,                    // 1743
    HrmRun,                    // 1752
    Fr920xt,                   // 1765
    Edge510Asia,               // 1821
    Edge810China,              // 1822
    Edge810Taiwan,             // 1823
    Edge1000,                  // 1836
    VivoFit,                   // 1837
    VirbRemote,                // 1853
    VivoKi,                    // 1885
    Fr15,                      // 1903
    VivoActive,                // 1907
    Edge510Korea,              // 1918
    Fr620Japan,                // 1928
    Fr620China,                // 1929
    Fr220Japan,                // 1930
    Fr220China,                // 1931
    ApproachS6,                // 1936
    VivoSmart,                 // 1956
    Fenix2,                    // 1967
    Epix,                      // 1988
    Fenix3,                    // 2050
    Edge1000Taiwan,            // 2052
    Edge1000Japan,             // 2053
    Fr15Japan,                 // 2061
    Edge520,                   // 2067
    Edge1000China,             // 2070
    Fr620Russia,               // 2072
    Fr220Russia,               // 2073
    VectorS,                   // 2079
    Edge1000Korea,             // 2100
    Fr920xtTaiwan,             // 2130
    Fr920xtChina,              // 2131
    Fr920xtJapan,              // 2132
    Virbx,                     // 2134
    VivoSmartApac,             // 2135
    EtrexTouch,                // 2140
    Edge25,                    // 2147
    Fr25,                      // 2148
    VivoFit2,                  // 2150
    Fr225,                     // 2153
    Fr630,                     // 2156
    Fr230,                     // 2157
    VivoActiveApac,            // 2160
    Vector2,                   // 2161
    Vector2s,                  // 2162
    Virbxe,                    // 2172
    Fr620Taiwan,               // 2173
    Fr220Taiwan,               // 2174
    Truswing,                  // 2175
    Fenix3China,               // 2188
    Fenix3Twn,                 // 2189
    VariaHeadlight,            // 2192
    VariaTaillightOld,         // 2193
    EdgeExplore1000,           // 2204
    Fr225Asia,                 // 2219
    VariaRadarTaillight,       // 2225
    VariaRadarDisplay,         // 2226
    Edge20,                    // 2238
    D2Bravo,                   // 2262
    ApproachS20,               // 2266
    VariaRemote,               // 2276
    Hrm4Run,                   // 2327
    VivoActiveHr,              // 2337
    VivoSmartGpsHr,            // 2347
    VivoSmartHr,               // 2348
    VivoMove,                  // 2368
    VariaVision,               // 2398
    VivoFit3,                  // 2406
    Fenix3Hr,                  // 2413
    VirbUltra30,               // 2417
    IndexSmartScale,           // 2429
    Fr235,                     // 2431
    Fenix3Chronos,             // 2432
    Oregon7xx,                 // 2441
    Rino7xx,                   // 2444
    Nautix,                    // 2496
    Edge820,                   // 2530
    EdgeExplore820,            // 2531
    Fenix5s,                   // 2544
    D2BravoTitanium,           // 2547
    VariaUt800,                // 2567  Varia UT 800 SW
    RunningDynamicsPod,        // 2593
    Fenix5x,                   // 2604
    VivoFitJr,                 // 2606
    Fr935,                     // 2691
    Fenix5,                    // 2697
    Sdm4,                      // 10007  SDM4 footpod
    EdgeRemote,                // 10014
    TrainingCenter,            // 20119
    ConnectiqSimulator,        // 65531
    AndroidAntplusPlugin,      // 65532
    Connect,                   // 65534  Garmin Connect website
    GarminProduct(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldGarminProduct {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldGarminProduct::Hrm1 => write!(f, "{}", "Hrm1"),
            FitFieldGarminProduct::Axh01 => write!(f, "{}", "Axh01"),
            FitFieldGarminProduct::Axb01 => write!(f, "{}", "Axb01"),
            FitFieldGarminProduct::Axb02 => write!(f, "{}", "Axb02"),
            FitFieldGarminProduct::Hrm2ss => write!(f, "{}", "Hrm2ss"),
            FitFieldGarminProduct::DsiAlf02 => write!(f, "{}", "DsiAlf02"),
            FitFieldGarminProduct::Hrm3ss => write!(f, "{}", "Hrm3ss"),
            FitFieldGarminProduct::HrmRunSingleByteProductId => {
                write!(f, "{}", "HrmRunSingleByteProductId")
            }
            FitFieldGarminProduct::Bsm => write!(f, "{}", "Bsm"),
            FitFieldGarminProduct::Bcm => write!(f, "{}", "Bcm"),
            FitFieldGarminProduct::Axs01 => write!(f, "{}", "Axs01"),
            FitFieldGarminProduct::HrmTriSingleByteProductId => {
                write!(f, "{}", "HrmTriSingleByteProductId")
            }
            FitFieldGarminProduct::Fr225SingleByteProductId => {
                write!(f, "{}", "Fr225SingleByteProductId")
            }
            FitFieldGarminProduct::Fr301China => write!(f, "{}", "Fr301China"),
            FitFieldGarminProduct::Fr301Japan => write!(f, "{}", "Fr301Japan"),
            FitFieldGarminProduct::Fr301Korea => write!(f, "{}", "Fr301Korea"),
            FitFieldGarminProduct::Fr301Taiwan => write!(f, "{}", "Fr301Taiwan"),
            FitFieldGarminProduct::Fr405 => write!(f, "{}", "Fr405"),
            FitFieldGarminProduct::Fr50 => write!(f, "{}", "Fr50"),
            FitFieldGarminProduct::Fr405Japan => write!(f, "{}", "Fr405Japan"),
            FitFieldGarminProduct::Fr60 => write!(f, "{}", "Fr60"),
            FitFieldGarminProduct::DsiAlf01 => write!(f, "{}", "DsiAlf01"),
            FitFieldGarminProduct::Fr310xt => write!(f, "{}", "Fr310xt"),
            FitFieldGarminProduct::Edge500 => write!(f, "{}", "Edge500"),
            FitFieldGarminProduct::Fr110 => write!(f, "{}", "Fr110"),
            FitFieldGarminProduct::Edge800 => write!(f, "{}", "Edge800"),
            FitFieldGarminProduct::Edge500Taiwan => write!(f, "{}", "Edge500Taiwan"),
            FitFieldGarminProduct::Edge500Japan => write!(f, "{}", "Edge500Japan"),
            FitFieldGarminProduct::Chirp => write!(f, "{}", "Chirp"),
            FitFieldGarminProduct::Fr110Japan => write!(f, "{}", "Fr110Japan"),
            FitFieldGarminProduct::Edge200 => write!(f, "{}", "Edge200"),
            FitFieldGarminProduct::Fr910xt => write!(f, "{}", "Fr910xt"),
            FitFieldGarminProduct::Edge800Taiwan => write!(f, "{}", "Edge800Taiwan"),
            FitFieldGarminProduct::Edge800Japan => write!(f, "{}", "Edge800Japan"),
            FitFieldGarminProduct::Alf04 => write!(f, "{}", "Alf04"),
            FitFieldGarminProduct::Fr610 => write!(f, "{}", "Fr610"),
            FitFieldGarminProduct::Fr210Japan => write!(f, "{}", "Fr210Japan"),
            FitFieldGarminProduct::VectorSs => write!(f, "{}", "VectorSs"),
            FitFieldGarminProduct::VectorCp => write!(f, "{}", "VectorCp"),
            FitFieldGarminProduct::Edge800China => write!(f, "{}", "Edge800China"),
            FitFieldGarminProduct::Edge500China => write!(f, "{}", "Edge500China"),
            FitFieldGarminProduct::Fr610Japan => write!(f, "{}", "Fr610Japan"),
            FitFieldGarminProduct::Edge500Korea => write!(f, "{}", "Edge500Korea"),
            FitFieldGarminProduct::Fr70 => write!(f, "{}", "Fr70"),
            FitFieldGarminProduct::Fr310xt4t => write!(f, "{}", "Fr310xt4t"),
            FitFieldGarminProduct::Amx => write!(f, "{}", "Amx"),
            FitFieldGarminProduct::Fr10 => write!(f, "{}", "Fr10"),
            FitFieldGarminProduct::Edge800Korea => write!(f, "{}", "Edge800Korea"),
            FitFieldGarminProduct::Swim => write!(f, "{}", "Swim"),
            FitFieldGarminProduct::Fr910xtChina => write!(f, "{}", "Fr910xtChina"),
            FitFieldGarminProduct::Fenix => write!(f, "{}", "Fenix"),
            FitFieldGarminProduct::Edge200Taiwan => write!(f, "{}", "Edge200Taiwan"),
            FitFieldGarminProduct::Edge510 => write!(f, "{}", "Edge510"),
            FitFieldGarminProduct::Edge810 => write!(f, "{}", "Edge810"),
            FitFieldGarminProduct::Tempe => write!(f, "{}", "Tempe"),
            FitFieldGarminProduct::Fr910xtJapan => write!(f, "{}", "Fr910xtJapan"),
            FitFieldGarminProduct::Fr620 => write!(f, "{}", "Fr620"),
            FitFieldGarminProduct::Fr220 => write!(f, "{}", "Fr220"),
            FitFieldGarminProduct::Fr910xtKorea => write!(f, "{}", "Fr910xtKorea"),
            FitFieldGarminProduct::Fr10Japan => write!(f, "{}", "Fr10Japan"),
            FitFieldGarminProduct::Edge810Japan => write!(f, "{}", "Edge810Japan"),
            FitFieldGarminProduct::VirbElite => write!(f, "{}", "VirbElite"),
            FitFieldGarminProduct::EdgeTouring => write!(f, "{}", "EdgeTouring"),
            FitFieldGarminProduct::Edge510Japan => write!(f, "{}", "Edge510Japan"),
            FitFieldGarminProduct::HrmTri => write!(f, "{}", "HrmTri"),
            FitFieldGarminProduct::HrmRun => write!(f, "{}", "HrmRun"),
            FitFieldGarminProduct::Fr920xt => write!(f, "{}", "Fr920xt"),
            FitFieldGarminProduct::Edge510Asia => write!(f, "{}", "Edge510Asia"),
            FitFieldGarminProduct::Edge810China => write!(f, "{}", "Edge810China"),
            FitFieldGarminProduct::Edge810Taiwan => write!(f, "{}", "Edge810Taiwan"),
            FitFieldGarminProduct::Edge1000 => write!(f, "{}", "Edge1000"),
            FitFieldGarminProduct::VivoFit => write!(f, "{}", "VivoFit"),
            FitFieldGarminProduct::VirbRemote => write!(f, "{}", "VirbRemote"),
            FitFieldGarminProduct::VivoKi => write!(f, "{}", "VivoKi"),
            FitFieldGarminProduct::Fr15 => write!(f, "{}", "Fr15"),
            FitFieldGarminProduct::VivoActive => write!(f, "{}", "VivoActive"),
            FitFieldGarminProduct::Edge510Korea => write!(f, "{}", "Edge510Korea"),
            FitFieldGarminProduct::Fr620Japan => write!(f, "{}", "Fr620Japan"),
            FitFieldGarminProduct::Fr620China => write!(f, "{}", "Fr620China"),
            FitFieldGarminProduct::Fr220Japan => write!(f, "{}", "Fr220Japan"),
            FitFieldGarminProduct::Fr220China => write!(f, "{}", "Fr220China"),
            FitFieldGarminProduct::ApproachS6 => write!(f, "{}", "ApproachS6"),
            FitFieldGarminProduct::VivoSmart => write!(f, "{}", "VivoSmart"),
            FitFieldGarminProduct::Fenix2 => write!(f, "{}", "Fenix2"),
            FitFieldGarminProduct::Epix => write!(f, "{}", "Epix"),
            FitFieldGarminProduct::Fenix3 => write!(f, "{}", "Fenix3"),
            FitFieldGarminProduct::Edge1000Taiwan => write!(f, "{}", "Edge1000Taiwan"),
            FitFieldGarminProduct::Edge1000Japan => write!(f, "{}", "Edge1000Japan"),
            FitFieldGarminProduct::Fr15Japan => write!(f, "{}", "Fr15Japan"),
            FitFieldGarminProduct::Edge520 => write!(f, "{}", "Edge520"),
            FitFieldGarminProduct::Edge1000China => write!(f, "{}", "Edge1000China"),
            FitFieldGarminProduct::Fr620Russia => write!(f, "{}", "Fr620Russia"),
            FitFieldGarminProduct::Fr220Russia => write!(f, "{}", "Fr220Russia"),
            FitFieldGarminProduct::VectorS => write!(f, "{}", "VectorS"),
            FitFieldGarminProduct::Edge1000Korea => write!(f, "{}", "Edge1000Korea"),
            FitFieldGarminProduct::Fr920xtTaiwan => write!(f, "{}", "Fr920xtTaiwan"),
            FitFieldGarminProduct::Fr920xtChina => write!(f, "{}", "Fr920xtChina"),
            FitFieldGarminProduct::Fr920xtJapan => write!(f, "{}", "Fr920xtJapan"),
            FitFieldGarminProduct::Virbx => write!(f, "{}", "Virbx"),
            FitFieldGarminProduct::VivoSmartApac => write!(f, "{}", "VivoSmartApac"),
            FitFieldGarminProduct::EtrexTouch => write!(f, "{}", "EtrexTouch"),
            FitFieldGarminProduct::Edge25 => write!(f, "{}", "Edge25"),
            FitFieldGarminProduct::Fr25 => write!(f, "{}", "Fr25"),
            FitFieldGarminProduct::VivoFit2 => write!(f, "{}", "VivoFit2"),
            FitFieldGarminProduct::Fr225 => write!(f, "{}", "Fr225"),
            FitFieldGarminProduct::Fr630 => write!(f, "{}", "Fr630"),
            FitFieldGarminProduct::Fr230 => write!(f, "{}", "Fr230"),
            FitFieldGarminProduct::VivoActiveApac => write!(f, "{}", "VivoActiveApac"),
            FitFieldGarminProduct::Vector2 => write!(f, "{}", "Vector2"),
            FitFieldGarminProduct::Vector2s => write!(f, "{}", "Vector2s"),
            FitFieldGarminProduct::Virbxe => write!(f, "{}", "Virbxe"),
            FitFieldGarminProduct::Fr620Taiwan => write!(f, "{}", "Fr620Taiwan"),
            FitFieldGarminProduct::Fr220Taiwan => write!(f, "{}", "Fr220Taiwan"),
            FitFieldGarminProduct::Truswing => write!(f, "{}", "Truswing"),
            FitFieldGarminProduct::Fenix3China => write!(f, "{}", "Fenix3China"),
            FitFieldGarminProduct::Fenix3Twn => write!(f, "{}", "Fenix3Twn"),
            FitFieldGarminProduct::VariaHeadlight => write!(f, "{}", "VariaHeadlight"),
            FitFieldGarminProduct::VariaTaillightOld => write!(f, "{}", "VariaTaillightOld"),
            FitFieldGarminProduct::EdgeExplore1000 => write!(f, "{}", "EdgeExplore1000"),
            FitFieldGarminProduct::Fr225Asia => write!(f, "{}", "Fr225Asia"),
            FitFieldGarminProduct::VariaRadarTaillight => write!(f, "{}", "VariaRadarTaillight"),
            FitFieldGarminProduct::VariaRadarDisplay => write!(f, "{}", "VariaRadarDisplay"),
            FitFieldGarminProduct::Edge20 => write!(f, "{}", "Edge20"),
            FitFieldGarminProduct::D2Bravo => write!(f, "{}", "D2Bravo"),
            FitFieldGarminProduct::ApproachS20 => write!(f, "{}", "ApproachS20"),
            FitFieldGarminProduct::VariaRemote => write!(f, "{}", "VariaRemote"),
            FitFieldGarminProduct::Hrm4Run => write!(f, "{}", "Hrm4Run"),
            FitFieldGarminProduct::VivoActiveHr => write!(f, "{}", "VivoActiveHr"),
            FitFieldGarminProduct::VivoSmartGpsHr => write!(f, "{}", "VivoSmartGpsHr"),
            FitFieldGarminProduct::VivoSmartHr => write!(f, "{}", "VivoSmartHr"),
            FitFieldGarminProduct::VivoMove => write!(f, "{}", "VivoMove"),
            FitFieldGarminProduct::VariaVision => write!(f, "{}", "VariaVision"),
            FitFieldGarminProduct::VivoFit3 => write!(f, "{}", "VivoFit3"),
            FitFieldGarminProduct::Fenix3Hr => write!(f, "{}", "Fenix3Hr"),
            FitFieldGarminProduct::VirbUltra30 => write!(f, "{}", "VirbUltra30"),
            FitFieldGarminProduct::IndexSmartScale => write!(f, "{}", "IndexSmartScale"),
            FitFieldGarminProduct::Fr235 => write!(f, "{}", "Fr235"),
            FitFieldGarminProduct::Fenix3Chronos => write!(f, "{}", "Fenix3Chronos"),
            FitFieldGarminProduct::Oregon7xx => write!(f, "{}", "Oregon7xx"),
            FitFieldGarminProduct::Rino7xx => write!(f, "{}", "Rino7xx"),
            FitFieldGarminProduct::Nautix => write!(f, "{}", "Nautix"),
            FitFieldGarminProduct::Edge820 => write!(f, "{}", "Edge820"),
            FitFieldGarminProduct::EdgeExplore820 => write!(f, "{}", "EdgeExplore820"),
            FitFieldGarminProduct::Fenix5s => write!(f, "{}", "Fenix5s"),
            FitFieldGarminProduct::D2BravoTitanium => write!(f, "{}", "D2BravoTitanium"),
            FitFieldGarminProduct::VariaUt800 => write!(f, "{}", "VariaUt800"),
            FitFieldGarminProduct::RunningDynamicsPod => write!(f, "{}", "RunningDynamicsPod"),
            FitFieldGarminProduct::Fenix5x => write!(f, "{}", "Fenix5x"),
            FitFieldGarminProduct::VivoFitJr => write!(f, "{}", "VivoFitJr"),
            FitFieldGarminProduct::Fr935 => write!(f, "{}", "Fr935"),
            FitFieldGarminProduct::Fenix5 => write!(f, "{}", "Fenix5"),
            FitFieldGarminProduct::Sdm4 => write!(f, "{}", "Sdm4"),
            FitFieldGarminProduct::EdgeRemote => write!(f, "{}", "EdgeRemote"),
            FitFieldGarminProduct::TrainingCenter => write!(f, "{}", "TrainingCenter"),
            FitFieldGarminProduct::ConnectiqSimulator => write!(f, "{}", "ConnectiqSimulator"),
            FitFieldGarminProduct::AndroidAntplusPlugin => write!(f, "{}", "AndroidAntplusPlugin"),
            FitFieldGarminProduct::Connect => write!(f, "{}", "Connect"),
            FitFieldGarminProduct::GarminProduct(x) => write!(f, "{}({})", "GarminProduct", x),
            FitFieldGarminProduct::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldGarminProduct::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldGarminProduct {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldGarminProduct> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldGarminProduct::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldGarminProduct::from(v)),
                2 => Ok(FitFieldGarminProduct::from(v)),
                3 => Ok(FitFieldGarminProduct::from(v)),
                4 => Ok(FitFieldGarminProduct::from(v)),
                5 => Ok(FitFieldGarminProduct::from(v)),
                6 => Ok(FitFieldGarminProduct::from(v)),
                7 => Ok(FitFieldGarminProduct::from(v)),
                8 => Ok(FitFieldGarminProduct::from(v)),
                9 => Ok(FitFieldGarminProduct::from(v)),
                10 => Ok(FitFieldGarminProduct::from(v)),
                11 => Ok(FitFieldGarminProduct::from(v)),
                12 => Ok(FitFieldGarminProduct::from(v)),
                14 => Ok(FitFieldGarminProduct::from(v)),
                473 => Ok(FitFieldGarminProduct::from(v)),
                474 => Ok(FitFieldGarminProduct::from(v)),
                475 => Ok(FitFieldGarminProduct::from(v)),
                494 => Ok(FitFieldGarminProduct::from(v)),
                717 => Ok(FitFieldGarminProduct::from(v)),
                782 => Ok(FitFieldGarminProduct::from(v)),
                987 => Ok(FitFieldGarminProduct::from(v)),
                988 => Ok(FitFieldGarminProduct::from(v)),
                1011 => Ok(FitFieldGarminProduct::from(v)),
                1018 => Ok(FitFieldGarminProduct::from(v)),
                1036 => Ok(FitFieldGarminProduct::from(v)),
                1124 => Ok(FitFieldGarminProduct::from(v)),
                1169 => Ok(FitFieldGarminProduct::from(v)),
                1199 => Ok(FitFieldGarminProduct::from(v)),
                1213 => Ok(FitFieldGarminProduct::from(v)),
                1253 => Ok(FitFieldGarminProduct::from(v)),
                1274 => Ok(FitFieldGarminProduct::from(v)),
                1325 => Ok(FitFieldGarminProduct::from(v)),
                1328 => Ok(FitFieldGarminProduct::from(v)),
                1333 => Ok(FitFieldGarminProduct::from(v)),
                1334 => Ok(FitFieldGarminProduct::from(v)),
                1341 => Ok(FitFieldGarminProduct::from(v)),
                1345 => Ok(FitFieldGarminProduct::from(v)),
                1360 => Ok(FitFieldGarminProduct::from(v)),
                1380 => Ok(FitFieldGarminProduct::from(v)),
                1381 => Ok(FitFieldGarminProduct::from(v)),
                1386 => Ok(FitFieldGarminProduct::from(v)),
                1387 => Ok(FitFieldGarminProduct::from(v)),
                1410 => Ok(FitFieldGarminProduct::from(v)),
                1422 => Ok(FitFieldGarminProduct::from(v)),
                1436 => Ok(FitFieldGarminProduct::from(v)),
                1446 => Ok(FitFieldGarminProduct::from(v)),
                1461 => Ok(FitFieldGarminProduct::from(v)),
                1482 => Ok(FitFieldGarminProduct::from(v)),
                1497 => Ok(FitFieldGarminProduct::from(v)),
                1499 => Ok(FitFieldGarminProduct::from(v)),
                1537 => Ok(FitFieldGarminProduct::from(v)),
                1551 => Ok(FitFieldGarminProduct::from(v)),
                1555 => Ok(FitFieldGarminProduct::from(v)),
                1561 => Ok(FitFieldGarminProduct::from(v)),
                1567 => Ok(FitFieldGarminProduct::from(v)),
                1570 => Ok(FitFieldGarminProduct::from(v)),
                1600 => Ok(FitFieldGarminProduct::from(v)),
                1623 => Ok(FitFieldGarminProduct::from(v)),
                1632 => Ok(FitFieldGarminProduct::from(v)),
                1664 => Ok(FitFieldGarminProduct::from(v)),
                1688 => Ok(FitFieldGarminProduct::from(v)),
                1721 => Ok(FitFieldGarminProduct::from(v)),
                1735 => Ok(FitFieldGarminProduct::from(v)),
                1736 => Ok(FitFieldGarminProduct::from(v)),
                1742 => Ok(FitFieldGarminProduct::from(v)),
                1743 => Ok(FitFieldGarminProduct::from(v)),
                1752 => Ok(FitFieldGarminProduct::from(v)),
                1765 => Ok(FitFieldGarminProduct::from(v)),
                1821 => Ok(FitFieldGarminProduct::from(v)),
                1822 => Ok(FitFieldGarminProduct::from(v)),
                1823 => Ok(FitFieldGarminProduct::from(v)),
                1836 => Ok(FitFieldGarminProduct::from(v)),
                1837 => Ok(FitFieldGarminProduct::from(v)),
                1853 => Ok(FitFieldGarminProduct::from(v)),
                1885 => Ok(FitFieldGarminProduct::from(v)),
                1903 => Ok(FitFieldGarminProduct::from(v)),
                1907 => Ok(FitFieldGarminProduct::from(v)),
                1918 => Ok(FitFieldGarminProduct::from(v)),
                1928 => Ok(FitFieldGarminProduct::from(v)),
                1929 => Ok(FitFieldGarminProduct::from(v)),
                1930 => Ok(FitFieldGarminProduct::from(v)),
                1931 => Ok(FitFieldGarminProduct::from(v)),
                1936 => Ok(FitFieldGarminProduct::from(v)),
                1956 => Ok(FitFieldGarminProduct::from(v)),
                1967 => Ok(FitFieldGarminProduct::from(v)),
                1988 => Ok(FitFieldGarminProduct::from(v)),
                2050 => Ok(FitFieldGarminProduct::from(v)),
                2052 => Ok(FitFieldGarminProduct::from(v)),
                2053 => Ok(FitFieldGarminProduct::from(v)),
                2061 => Ok(FitFieldGarminProduct::from(v)),
                2067 => Ok(FitFieldGarminProduct::from(v)),
                2070 => Ok(FitFieldGarminProduct::from(v)),
                2072 => Ok(FitFieldGarminProduct::from(v)),
                2073 => Ok(FitFieldGarminProduct::from(v)),
                2079 => Ok(FitFieldGarminProduct::from(v)),
                2100 => Ok(FitFieldGarminProduct::from(v)),
                2130 => Ok(FitFieldGarminProduct::from(v)),
                2131 => Ok(FitFieldGarminProduct::from(v)),
                2132 => Ok(FitFieldGarminProduct::from(v)),
                2134 => Ok(FitFieldGarminProduct::from(v)),
                2135 => Ok(FitFieldGarminProduct::from(v)),
                2140 => Ok(FitFieldGarminProduct::from(v)),
                2147 => Ok(FitFieldGarminProduct::from(v)),
                2148 => Ok(FitFieldGarminProduct::from(v)),
                2150 => Ok(FitFieldGarminProduct::from(v)),
                2153 => Ok(FitFieldGarminProduct::from(v)),
                2156 => Ok(FitFieldGarminProduct::from(v)),
                2157 => Ok(FitFieldGarminProduct::from(v)),
                2160 => Ok(FitFieldGarminProduct::from(v)),
                2161 => Ok(FitFieldGarminProduct::from(v)),
                2162 => Ok(FitFieldGarminProduct::from(v)),
                2172 => Ok(FitFieldGarminProduct::from(v)),
                2173 => Ok(FitFieldGarminProduct::from(v)),
                2174 => Ok(FitFieldGarminProduct::from(v)),
                2175 => Ok(FitFieldGarminProduct::from(v)),
                2188 => Ok(FitFieldGarminProduct::from(v)),
                2189 => Ok(FitFieldGarminProduct::from(v)),
                2192 => Ok(FitFieldGarminProduct::from(v)),
                2193 => Ok(FitFieldGarminProduct::from(v)),
                2204 => Ok(FitFieldGarminProduct::from(v)),
                2219 => Ok(FitFieldGarminProduct::from(v)),
                2225 => Ok(FitFieldGarminProduct::from(v)),
                2226 => Ok(FitFieldGarminProduct::from(v)),
                2238 => Ok(FitFieldGarminProduct::from(v)),
                2262 => Ok(FitFieldGarminProduct::from(v)),
                2266 => Ok(FitFieldGarminProduct::from(v)),
                2276 => Ok(FitFieldGarminProduct::from(v)),
                2327 => Ok(FitFieldGarminProduct::from(v)),
                2337 => Ok(FitFieldGarminProduct::from(v)),
                2347 => Ok(FitFieldGarminProduct::from(v)),
                2348 => Ok(FitFieldGarminProduct::from(v)),
                2368 => Ok(FitFieldGarminProduct::from(v)),
                2398 => Ok(FitFieldGarminProduct::from(v)),
                2406 => Ok(FitFieldGarminProduct::from(v)),
                2413 => Ok(FitFieldGarminProduct::from(v)),
                2417 => Ok(FitFieldGarminProduct::from(v)),
                2429 => Ok(FitFieldGarminProduct::from(v)),
                2431 => Ok(FitFieldGarminProduct::from(v)),
                2432 => Ok(FitFieldGarminProduct::from(v)),
                2441 => Ok(FitFieldGarminProduct::from(v)),
                2444 => Ok(FitFieldGarminProduct::from(v)),
                2496 => Ok(FitFieldGarminProduct::from(v)),
                2530 => Ok(FitFieldGarminProduct::from(v)),
                2531 => Ok(FitFieldGarminProduct::from(v)),
                2544 => Ok(FitFieldGarminProduct::from(v)),
                2547 => Ok(FitFieldGarminProduct::from(v)),
                2567 => Ok(FitFieldGarminProduct::from(v)),
                2593 => Ok(FitFieldGarminProduct::from(v)),
                2604 => Ok(FitFieldGarminProduct::from(v)),
                2606 => Ok(FitFieldGarminProduct::from(v)),
                2691 => Ok(FitFieldGarminProduct::from(v)),
                2697 => Ok(FitFieldGarminProduct::from(v)),
                10007 => Ok(FitFieldGarminProduct::from(v)),
                10014 => Ok(FitFieldGarminProduct::from(v)),
                20119 => Ok(FitFieldGarminProduct::from(v)),
                65531 => Ok(FitFieldGarminProduct::from(v)),
                65532 => Ok(FitFieldGarminProduct::from(v)),
                65534 => Ok(FitFieldGarminProduct::from(v)),
                v => Ok(FitFieldGarminProduct::GarminProduct(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldGarminProduct);

impl From<u16> for FitFieldGarminProduct {
    fn from(code: u16) -> Self {
        match code {
            1 => FitFieldGarminProduct::Hrm1,
            2 => FitFieldGarminProduct::Axh01,
            3 => FitFieldGarminProduct::Axb01,
            4 => FitFieldGarminProduct::Axb02,
            5 => FitFieldGarminProduct::Hrm2ss,
            6 => FitFieldGarminProduct::DsiAlf02,
            7 => FitFieldGarminProduct::Hrm3ss,
            8 => FitFieldGarminProduct::HrmRunSingleByteProductId,
            9 => FitFieldGarminProduct::Bsm,
            10 => FitFieldGarminProduct::Bcm,
            11 => FitFieldGarminProduct::Axs01,
            12 => FitFieldGarminProduct::HrmTriSingleByteProductId,
            14 => FitFieldGarminProduct::Fr225SingleByteProductId,
            473 => FitFieldGarminProduct::Fr301China,
            474 => FitFieldGarminProduct::Fr301Japan,
            475 => FitFieldGarminProduct::Fr301Korea,
            494 => FitFieldGarminProduct::Fr301Taiwan,
            717 => FitFieldGarminProduct::Fr405,
            782 => FitFieldGarminProduct::Fr50,
            987 => FitFieldGarminProduct::Fr405Japan,
            988 => FitFieldGarminProduct::Fr60,
            1011 => FitFieldGarminProduct::DsiAlf01,
            1018 => FitFieldGarminProduct::Fr310xt,
            1036 => FitFieldGarminProduct::Edge500,
            1124 => FitFieldGarminProduct::Fr110,
            1169 => FitFieldGarminProduct::Edge800,
            1199 => FitFieldGarminProduct::Edge500Taiwan,
            1213 => FitFieldGarminProduct::Edge500Japan,
            1253 => FitFieldGarminProduct::Chirp,
            1274 => FitFieldGarminProduct::Fr110Japan,
            1325 => FitFieldGarminProduct::Edge200,
            1328 => FitFieldGarminProduct::Fr910xt,
            1333 => FitFieldGarminProduct::Edge800Taiwan,
            1334 => FitFieldGarminProduct::Edge800Japan,
            1341 => FitFieldGarminProduct::Alf04,
            1345 => FitFieldGarminProduct::Fr610,
            1360 => FitFieldGarminProduct::Fr210Japan,
            1380 => FitFieldGarminProduct::VectorSs,
            1381 => FitFieldGarminProduct::VectorCp,
            1386 => FitFieldGarminProduct::Edge800China,
            1387 => FitFieldGarminProduct::Edge500China,
            1410 => FitFieldGarminProduct::Fr610Japan,
            1422 => FitFieldGarminProduct::Edge500Korea,
            1436 => FitFieldGarminProduct::Fr70,
            1446 => FitFieldGarminProduct::Fr310xt4t,
            1461 => FitFieldGarminProduct::Amx,
            1482 => FitFieldGarminProduct::Fr10,
            1497 => FitFieldGarminProduct::Edge800Korea,
            1499 => FitFieldGarminProduct::Swim,
            1537 => FitFieldGarminProduct::Fr910xtChina,
            1551 => FitFieldGarminProduct::Fenix,
            1555 => FitFieldGarminProduct::Edge200Taiwan,
            1561 => FitFieldGarminProduct::Edge510,
            1567 => FitFieldGarminProduct::Edge810,
            1570 => FitFieldGarminProduct::Tempe,
            1600 => FitFieldGarminProduct::Fr910xtJapan,
            1623 => FitFieldGarminProduct::Fr620,
            1632 => FitFieldGarminProduct::Fr220,
            1664 => FitFieldGarminProduct::Fr910xtKorea,
            1688 => FitFieldGarminProduct::Fr10Japan,
            1721 => FitFieldGarminProduct::Edge810Japan,
            1735 => FitFieldGarminProduct::VirbElite,
            1736 => FitFieldGarminProduct::EdgeTouring,
            1742 => FitFieldGarminProduct::Edge510Japan,
            1743 => FitFieldGarminProduct::HrmTri,
            1752 => FitFieldGarminProduct::HrmRun,
            1765 => FitFieldGarminProduct::Fr920xt,
            1821 => FitFieldGarminProduct::Edge510Asia,
            1822 => FitFieldGarminProduct::Edge810China,
            1823 => FitFieldGarminProduct::Edge810Taiwan,
            1836 => FitFieldGarminProduct::Edge1000,
            1837 => FitFieldGarminProduct::VivoFit,
            1853 => FitFieldGarminProduct::VirbRemote,
            1885 => FitFieldGarminProduct::VivoKi,
            1903 => FitFieldGarminProduct::Fr15,
            1907 => FitFieldGarminProduct::VivoActive,
            1918 => FitFieldGarminProduct::Edge510Korea,
            1928 => FitFieldGarminProduct::Fr620Japan,
            1929 => FitFieldGarminProduct::Fr620China,
            1930 => FitFieldGarminProduct::Fr220Japan,
            1931 => FitFieldGarminProduct::Fr220China,
            1936 => FitFieldGarminProduct::ApproachS6,
            1956 => FitFieldGarminProduct::VivoSmart,
            1967 => FitFieldGarminProduct::Fenix2,
            1988 => FitFieldGarminProduct::Epix,
            2050 => FitFieldGarminProduct::Fenix3,
            2052 => FitFieldGarminProduct::Edge1000Taiwan,
            2053 => FitFieldGarminProduct::Edge1000Japan,
            2061 => FitFieldGarminProduct::Fr15Japan,
            2067 => FitFieldGarminProduct::Edge520,
            2070 => FitFieldGarminProduct::Edge1000China,
            2072 => FitFieldGarminProduct::Fr620Russia,
            2073 => FitFieldGarminProduct::Fr220Russia,
            2079 => FitFieldGarminProduct::VectorS,
            2100 => FitFieldGarminProduct::Edge1000Korea,
            2130 => FitFieldGarminProduct::Fr920xtTaiwan,
            2131 => FitFieldGarminProduct::Fr920xtChina,
            2132 => FitFieldGarminProduct::Fr920xtJapan,
            2134 => FitFieldGarminProduct::Virbx,
            2135 => FitFieldGarminProduct::VivoSmartApac,
            2140 => FitFieldGarminProduct::EtrexTouch,
            2147 => FitFieldGarminProduct::Edge25,
            2148 => FitFieldGarminProduct::Fr25,
            2150 => FitFieldGarminProduct::VivoFit2,
            2153 => FitFieldGarminProduct::Fr225,
            2156 => FitFieldGarminProduct::Fr630,
            2157 => FitFieldGarminProduct::Fr230,
            2160 => FitFieldGarminProduct::VivoActiveApac,
            2161 => FitFieldGarminProduct::Vector2,
            2162 => FitFieldGarminProduct::Vector2s,
            2172 => FitFieldGarminProduct::Virbxe,
            2173 => FitFieldGarminProduct::Fr620Taiwan,
            2174 => FitFieldGarminProduct::Fr220Taiwan,
            2175 => FitFieldGarminProduct::Truswing,
            2188 => FitFieldGarminProduct::Fenix3China,
            2189 => FitFieldGarminProduct::Fenix3Twn,
            2192 => FitFieldGarminProduct::VariaHeadlight,
            2193 => FitFieldGarminProduct::VariaTaillightOld,
            2204 => FitFieldGarminProduct::EdgeExplore1000,
            2219 => FitFieldGarminProduct::Fr225Asia,
            2225 => FitFieldGarminProduct::VariaRadarTaillight,
            2226 => FitFieldGarminProduct::VariaRadarDisplay,
            2238 => FitFieldGarminProduct::Edge20,
            2262 => FitFieldGarminProduct::D2Bravo,
            2266 => FitFieldGarminProduct::ApproachS20,
            2276 => FitFieldGarminProduct::VariaRemote,
            2327 => FitFieldGarminProduct::Hrm4Run,
            2337 => FitFieldGarminProduct::VivoActiveHr,
            2347 => FitFieldGarminProduct::VivoSmartGpsHr,
            2348 => FitFieldGarminProduct::VivoSmartHr,
            2368 => FitFieldGarminProduct::VivoMove,
            2398 => FitFieldGarminProduct::VariaVision,
            2406 => FitFieldGarminProduct::VivoFit3,
            2413 => FitFieldGarminProduct::Fenix3Hr,
            2417 => FitFieldGarminProduct::VirbUltra30,
            2429 => FitFieldGarminProduct::IndexSmartScale,
            2431 => FitFieldGarminProduct::Fr235,
            2432 => FitFieldGarminProduct::Fenix3Chronos,
            2441 => FitFieldGarminProduct::Oregon7xx,
            2444 => FitFieldGarminProduct::Rino7xx,
            2496 => FitFieldGarminProduct::Nautix,
            2530 => FitFieldGarminProduct::Edge820,
            2531 => FitFieldGarminProduct::EdgeExplore820,
            2544 => FitFieldGarminProduct::Fenix5s,
            2547 => FitFieldGarminProduct::D2BravoTitanium,
            2567 => FitFieldGarminProduct::VariaUt800,
            2593 => FitFieldGarminProduct::RunningDynamicsPod,
            2604 => FitFieldGarminProduct::Fenix5x,
            2606 => FitFieldGarminProduct::VivoFitJr,
            2691 => FitFieldGarminProduct::Fr935,
            2697 => FitFieldGarminProduct::Fenix5,
            10007 => FitFieldGarminProduct::Sdm4,
            10014 => FitFieldGarminProduct::EdgeRemote,
            20119 => FitFieldGarminProduct::TrainingCenter,
            65531 => FitFieldGarminProduct::ConnectiqSimulator,
            65532 => FitFieldGarminProduct::AndroidAntplusPlugin,
            65534 => FitFieldGarminProduct::Connect,
            _ => FitFieldGarminProduct::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAntplusDeviceType {
    // fit base type: uint8
    Antfs,                   // 1
    BikePower,               // 11
    EnvironmentSensorLegacy, // 12
    MultiSportSpeedDistance, // 15
    Control,                 // 16
    FitnessEquipment,        // 17
    BloodPressure,           // 18
    GeocacheNode,            // 19
    LightElectricVehicle,    // 20
    EnvSensor,               // 25
    Racquet,                 // 26
    ControlHub,              // 27
    MuscleOxygen,            // 31
    BikeLightMain,           // 35
    BikeLightShared,         // 36
    Exd,                     // 38
    BikeRadar,               // 40
    BikeAero,                // 46
    WeightScale,             // 119
    HeartRate,               // 120
    BikeSpeedCadence,        // 121
    BikeCadence,             // 122
    BikeSpeed,               // 123
    StrideSpeedDistance,     // 124
    AntplusDeviceType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldAntplusDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAntplusDeviceType::Antfs => write!(f, "{}", "Antfs"),
            FitFieldAntplusDeviceType::BikePower => write!(f, "{}", "BikePower"),
            FitFieldAntplusDeviceType::EnvironmentSensorLegacy => {
                write!(f, "{}", "EnvironmentSensorLegacy")
            }
            FitFieldAntplusDeviceType::MultiSportSpeedDistance => {
                write!(f, "{}", "MultiSportSpeedDistance")
            }
            FitFieldAntplusDeviceType::Control => write!(f, "{}", "Control"),
            FitFieldAntplusDeviceType::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldAntplusDeviceType::BloodPressure => write!(f, "{}", "BloodPressure"),
            FitFieldAntplusDeviceType::GeocacheNode => write!(f, "{}", "GeocacheNode"),
            FitFieldAntplusDeviceType::LightElectricVehicle => {
                write!(f, "{}", "LightElectricVehicle")
            }
            FitFieldAntplusDeviceType::EnvSensor => write!(f, "{}", "EnvSensor"),
            FitFieldAntplusDeviceType::Racquet => write!(f, "{}", "Racquet"),
            FitFieldAntplusDeviceType::ControlHub => write!(f, "{}", "ControlHub"),
            FitFieldAntplusDeviceType::MuscleOxygen => write!(f, "{}", "MuscleOxygen"),
            FitFieldAntplusDeviceType::BikeLightMain => write!(f, "{}", "BikeLightMain"),
            FitFieldAntplusDeviceType::BikeLightShared => write!(f, "{}", "BikeLightShared"),
            FitFieldAntplusDeviceType::Exd => write!(f, "{}", "Exd"),
            FitFieldAntplusDeviceType::BikeRadar => write!(f, "{}", "BikeRadar"),
            FitFieldAntplusDeviceType::BikeAero => write!(f, "{}", "BikeAero"),
            FitFieldAntplusDeviceType::WeightScale => write!(f, "{}", "WeightScale"),
            FitFieldAntplusDeviceType::HeartRate => write!(f, "{}", "HeartRate"),
            FitFieldAntplusDeviceType::BikeSpeedCadence => write!(f, "{}", "BikeSpeedCadence"),
            FitFieldAntplusDeviceType::BikeCadence => write!(f, "{}", "BikeCadence"),
            FitFieldAntplusDeviceType::BikeSpeed => write!(f, "{}", "BikeSpeed"),
            FitFieldAntplusDeviceType::StrideSpeedDistance => {
                write!(f, "{}", "StrideSpeedDistance")
            }
            FitFieldAntplusDeviceType::AntplusDeviceType(x) => {
                write!(f, "{}({})", "AntplusDeviceType", x)
            }
            FitFieldAntplusDeviceType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAntplusDeviceType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAntplusDeviceType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAntplusDeviceType> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldAntplusDeviceType::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldAntplusDeviceType::from(v)),
                11 => Ok(FitFieldAntplusDeviceType::from(v)),
                12 => Ok(FitFieldAntplusDeviceType::from(v)),
                15 => Ok(FitFieldAntplusDeviceType::from(v)),
                16 => Ok(FitFieldAntplusDeviceType::from(v)),
                17 => Ok(FitFieldAntplusDeviceType::from(v)),
                18 => Ok(FitFieldAntplusDeviceType::from(v)),
                19 => Ok(FitFieldAntplusDeviceType::from(v)),
                20 => Ok(FitFieldAntplusDeviceType::from(v)),
                25 => Ok(FitFieldAntplusDeviceType::from(v)),
                26 => Ok(FitFieldAntplusDeviceType::from(v)),
                27 => Ok(FitFieldAntplusDeviceType::from(v)),
                31 => Ok(FitFieldAntplusDeviceType::from(v)),
                35 => Ok(FitFieldAntplusDeviceType::from(v)),
                36 => Ok(FitFieldAntplusDeviceType::from(v)),
                38 => Ok(FitFieldAntplusDeviceType::from(v)),
                40 => Ok(FitFieldAntplusDeviceType::from(v)),
                46 => Ok(FitFieldAntplusDeviceType::from(v)),
                119 => Ok(FitFieldAntplusDeviceType::from(v)),
                120 => Ok(FitFieldAntplusDeviceType::from(v)),
                121 => Ok(FitFieldAntplusDeviceType::from(v)),
                122 => Ok(FitFieldAntplusDeviceType::from(v)),
                123 => Ok(FitFieldAntplusDeviceType::from(v)),
                124 => Ok(FitFieldAntplusDeviceType::from(v)),
                v => Ok(FitFieldAntplusDeviceType::AntplusDeviceType(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldAntplusDeviceType);

impl From<u8> for FitFieldAntplusDeviceType {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldAntplusDeviceType::Antfs,
            11 => FitFieldAntplusDeviceType::BikePower,
            12 => FitFieldAntplusDeviceType::EnvironmentSensorLegacy,
            15 => FitFieldAntplusDeviceType::MultiSportSpeedDistance,
            16 => FitFieldAntplusDeviceType::Control,
            17 => FitFieldAntplusDeviceType::FitnessEquipment,
            18 => FitFieldAntplusDeviceType::BloodPressure,
            19 => FitFieldAntplusDeviceType::GeocacheNode,
            20 => FitFieldAntplusDeviceType::LightElectricVehicle,
            25 => FitFieldAntplusDeviceType::EnvSensor,
            26 => FitFieldAntplusDeviceType::Racquet,
            27 => FitFieldAntplusDeviceType::ControlHub,
            31 => FitFieldAntplusDeviceType::MuscleOxygen,
            35 => FitFieldAntplusDeviceType::BikeLightMain,
            36 => FitFieldAntplusDeviceType::BikeLightShared,
            38 => FitFieldAntplusDeviceType::Exd,
            40 => FitFieldAntplusDeviceType::BikeRadar,
            46 => FitFieldAntplusDeviceType::BikeAero,
            119 => FitFieldAntplusDeviceType::WeightScale,
            120 => FitFieldAntplusDeviceType::HeartRate,
            121 => FitFieldAntplusDeviceType::BikeSpeedCadence,
            122 => FitFieldAntplusDeviceType::BikeCadence,
            123 => FitFieldAntplusDeviceType::BikeSpeed,
            124 => FitFieldAntplusDeviceType::StrideSpeedDistance,
            _ => FitFieldAntplusDeviceType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAntNetwork {
    // fit base type: enum
    Public = 0,
    Antplus = 1,
    Antfs = 2,
    Private = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldAntNetwork {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAntNetwork::Public => write!(f, "{}", "Public"),
            FitFieldAntNetwork::Antplus => write!(f, "{}", "Antplus"),
            FitFieldAntNetwork::Antfs => write!(f, "{}", "Antfs"),
            FitFieldAntNetwork::Private => write!(f, "{}", "Private"),
            FitFieldAntNetwork::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAntNetwork::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAntNetwork {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAntNetwork> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldAntNetwork::from(v)),
            Err(_) => Ok(FitFieldAntNetwork::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldAntNetwork);

impl From<u8> for FitFieldAntNetwork {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAntNetwork::Public,
            1 => FitFieldAntNetwork::Antplus,
            2 => FitFieldAntNetwork::Antfs,
            3 => FitFieldAntNetwork::Private,
            _ => FitFieldAntNetwork::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWorkoutCapabilities {
    // fit base type: uint32z
    Interval,         // 1
    Custom,           // 2
    FitnessEquipment, // 4
    Firstbeat,        // 8
    NewLeaf,          // 16
    Tcx, // 32  For backwards compatibility.  Watch should add missing id fields then clear flag.
    Speed, // 128  Speed source required for workout step.
    HeartRate, // 256  Heart rate source required for workout step.
    Distance, // 512  Distance source required for workout step.
    Cadence, // 1024  Cadence source required for workout step.
    Power, // 2048  Power source required for workout step.
    Grade, // 4096  Grade source required for workout step.
    Resistance, // 8192  Resistance source required for workout step.
    Protected, // 16384
    WorkoutCapabilities(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldWorkoutCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWorkoutCapabilities::Interval => write!(f, "{}", "Interval"),
            FitFieldWorkoutCapabilities::Custom => write!(f, "{}", "Custom"),
            FitFieldWorkoutCapabilities::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldWorkoutCapabilities::Firstbeat => write!(f, "{}", "Firstbeat"),
            FitFieldWorkoutCapabilities::NewLeaf => write!(f, "{}", "NewLeaf"),
            FitFieldWorkoutCapabilities::Tcx => write!(f, "{}", "Tcx"),
            FitFieldWorkoutCapabilities::Speed => write!(f, "{}", "Speed"),
            FitFieldWorkoutCapabilities::HeartRate => write!(f, "{}", "HeartRate"),
            FitFieldWorkoutCapabilities::Distance => write!(f, "{}", "Distance"),
            FitFieldWorkoutCapabilities::Cadence => write!(f, "{}", "Cadence"),
            FitFieldWorkoutCapabilities::Power => write!(f, "{}", "Power"),
            FitFieldWorkoutCapabilities::Grade => write!(f, "{}", "Grade"),
            FitFieldWorkoutCapabilities::Resistance => write!(f, "{}", "Resistance"),
            FitFieldWorkoutCapabilities::Protected => write!(f, "{}", "Protected"),
            FitFieldWorkoutCapabilities::WorkoutCapabilities(x) => {
                write!(f, "{}({})", "WorkoutCapabilities", x)
            }
            FitFieldWorkoutCapabilities::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWorkoutCapabilities::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWorkoutCapabilities {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWorkoutCapabilities> {
        let val = parse_uint32z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldWorkoutCapabilities::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldWorkoutCapabilities::from(v)),
                2 => Ok(FitFieldWorkoutCapabilities::from(v)),
                4 => Ok(FitFieldWorkoutCapabilities::from(v)),
                8 => Ok(FitFieldWorkoutCapabilities::from(v)),
                16 => Ok(FitFieldWorkoutCapabilities::from(v)),
                32 => Ok(FitFieldWorkoutCapabilities::from(v)),
                128 => Ok(FitFieldWorkoutCapabilities::from(v)),
                256 => Ok(FitFieldWorkoutCapabilities::from(v)),
                512 => Ok(FitFieldWorkoutCapabilities::from(v)),
                1024 => Ok(FitFieldWorkoutCapabilities::from(v)),
                2048 => Ok(FitFieldWorkoutCapabilities::from(v)),
                4096 => Ok(FitFieldWorkoutCapabilities::from(v)),
                8192 => Ok(FitFieldWorkoutCapabilities::from(v)),
                16384 => Ok(FitFieldWorkoutCapabilities::from(v)),
                v => Ok(FitFieldWorkoutCapabilities::WorkoutCapabilities(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldWorkoutCapabilities);

impl From<u32> for FitFieldWorkoutCapabilities {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldWorkoutCapabilities::Interval,
            2 => FitFieldWorkoutCapabilities::Custom,
            4 => FitFieldWorkoutCapabilities::FitnessEquipment,
            8 => FitFieldWorkoutCapabilities::Firstbeat,
            16 => FitFieldWorkoutCapabilities::NewLeaf,
            32 => FitFieldWorkoutCapabilities::Tcx,
            128 => FitFieldWorkoutCapabilities::Speed,
            256 => FitFieldWorkoutCapabilities::HeartRate,
            512 => FitFieldWorkoutCapabilities::Distance,
            1024 => FitFieldWorkoutCapabilities::Cadence,
            2048 => FitFieldWorkoutCapabilities::Power,
            4096 => FitFieldWorkoutCapabilities::Grade,
            8192 => FitFieldWorkoutCapabilities::Resistance,
            16384 => FitFieldWorkoutCapabilities::Protected,
            _ => FitFieldWorkoutCapabilities::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBatteryStatus {
    // fit base type: uint8
    New,      // 1
    Good,     // 2
    Ok,       // 3
    Low,      // 4
    Critical, // 5
    Charging, // 6
    Unknown,  // 7
    BatteryStatus(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldBatteryStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBatteryStatus::New => write!(f, "{}", "New"),
            FitFieldBatteryStatus::Good => write!(f, "{}", "Good"),
            FitFieldBatteryStatus::Ok => write!(f, "{}", "Ok"),
            FitFieldBatteryStatus::Low => write!(f, "{}", "Low"),
            FitFieldBatteryStatus::Critical => write!(f, "{}", "Critical"),
            FitFieldBatteryStatus::Charging => write!(f, "{}", "Charging"),
            FitFieldBatteryStatus::Unknown => write!(f, "{}", "Unknown"),
            FitFieldBatteryStatus::BatteryStatus(x) => write!(f, "{}({})", "BatteryStatus", x),
            FitFieldBatteryStatus::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBatteryStatus::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBatteryStatus {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldBatteryStatus> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldBatteryStatus::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldBatteryStatus::from(v)),
                2 => Ok(FitFieldBatteryStatus::from(v)),
                3 => Ok(FitFieldBatteryStatus::from(v)),
                4 => Ok(FitFieldBatteryStatus::from(v)),
                5 => Ok(FitFieldBatteryStatus::from(v)),
                6 => Ok(FitFieldBatteryStatus::from(v)),
                7 => Ok(FitFieldBatteryStatus::from(v)),
                v => Ok(FitFieldBatteryStatus::BatteryStatus(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldBatteryStatus);

impl From<u8> for FitFieldBatteryStatus {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldBatteryStatus::New,
            2 => FitFieldBatteryStatus::Good,
            3 => FitFieldBatteryStatus::Ok,
            4 => FitFieldBatteryStatus::Low,
            5 => FitFieldBatteryStatus::Critical,
            6 => FitFieldBatteryStatus::Charging,
            7 => FitFieldBatteryStatus::Unknown,
            _ => FitFieldBatteryStatus::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldHrType {
    // fit base type: enum
    Normal = 0,
    Irregular = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldHrType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldHrType::Normal => write!(f, "{}", "Normal"),
            FitFieldHrType::Irregular => write!(f, "{}", "Irregular"),
            FitFieldHrType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldHrType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldHrType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldHrType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldHrType::from(v)),
            Err(_) => Ok(FitFieldHrType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldHrType);

impl From<u8> for FitFieldHrType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldHrType::Normal,
            1 => FitFieldHrType::Irregular,
            _ => FitFieldHrType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCourseCapabilities {
    // fit base type: uint32z
    Processed,  // 1
    Valid,      // 2
    Time,       // 4
    Distance,   // 8
    Position,   // 16
    HeartRate,  // 32
    Power,      // 64
    Cadence,    // 128
    Training,   // 256
    Navigation, // 512
    Bikeway,    // 1024
    CourseCapabilities(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCourseCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCourseCapabilities::Processed => write!(f, "{}", "Processed"),
            FitFieldCourseCapabilities::Valid => write!(f, "{}", "Valid"),
            FitFieldCourseCapabilities::Time => write!(f, "{}", "Time"),
            FitFieldCourseCapabilities::Distance => write!(f, "{}", "Distance"),
            FitFieldCourseCapabilities::Position => write!(f, "{}", "Position"),
            FitFieldCourseCapabilities::HeartRate => write!(f, "{}", "HeartRate"),
            FitFieldCourseCapabilities::Power => write!(f, "{}", "Power"),
            FitFieldCourseCapabilities::Cadence => write!(f, "{}", "Cadence"),
            FitFieldCourseCapabilities::Training => write!(f, "{}", "Training"),
            FitFieldCourseCapabilities::Navigation => write!(f, "{}", "Navigation"),
            FitFieldCourseCapabilities::Bikeway => write!(f, "{}", "Bikeway"),
            FitFieldCourseCapabilities::CourseCapabilities(x) => {
                write!(f, "{}({})", "CourseCapabilities", x)
            }
            FitFieldCourseCapabilities::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCourseCapabilities::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCourseCapabilities {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCourseCapabilities> {
        let val = parse_uint32z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCourseCapabilities::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldCourseCapabilities::from(v)),
                2 => Ok(FitFieldCourseCapabilities::from(v)),
                4 => Ok(FitFieldCourseCapabilities::from(v)),
                8 => Ok(FitFieldCourseCapabilities::from(v)),
                16 => Ok(FitFieldCourseCapabilities::from(v)),
                32 => Ok(FitFieldCourseCapabilities::from(v)),
                64 => Ok(FitFieldCourseCapabilities::from(v)),
                128 => Ok(FitFieldCourseCapabilities::from(v)),
                256 => Ok(FitFieldCourseCapabilities::from(v)),
                512 => Ok(FitFieldCourseCapabilities::from(v)),
                1024 => Ok(FitFieldCourseCapabilities::from(v)),
                v => Ok(FitFieldCourseCapabilities::CourseCapabilities(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCourseCapabilities);

impl From<u32> for FitFieldCourseCapabilities {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldCourseCapabilities::Processed,
            2 => FitFieldCourseCapabilities::Valid,
            4 => FitFieldCourseCapabilities::Time,
            8 => FitFieldCourseCapabilities::Distance,
            16 => FitFieldCourseCapabilities::Position,
            32 => FitFieldCourseCapabilities::HeartRate,
            64 => FitFieldCourseCapabilities::Power,
            128 => FitFieldCourseCapabilities::Cadence,
            256 => FitFieldCourseCapabilities::Training,
            512 => FitFieldCourseCapabilities::Navigation,
            1024 => FitFieldCourseCapabilities::Bikeway,
            _ => FitFieldCourseCapabilities::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWeight {
    // fit base type: uint16
    Calculating, // 65534
    Weight(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldWeight {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWeight::Calculating => write!(f, "{}", "Calculating"),
            FitFieldWeight::Weight(x) => write!(f, "{}({})", "Weight", x),
            FitFieldWeight::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWeight::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWeight {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWeight> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldWeight::InvalidFieldValue),
            Ok(v) => match v {
                65534 => Ok(FitFieldWeight::from(v)),
                v => Ok(FitFieldWeight::Weight(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldWeight);

impl From<u16> for FitFieldWeight {
    fn from(code: u16) -> Self {
        match code {
            65534 => FitFieldWeight::Calculating,
            _ => FitFieldWeight::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWorkoutHr {
    // fit base type: uint32
    BpmOffset, // 100
    WorkoutHr(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldWorkoutHr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWorkoutHr::BpmOffset => write!(f, "{}", "BpmOffset"),
            FitFieldWorkoutHr::WorkoutHr(x) => write!(f, "{}({})", "WorkoutHr", x),
            FitFieldWorkoutHr::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWorkoutHr::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWorkoutHr {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWorkoutHr> {
        let val = parse_uint32(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldWorkoutHr::InvalidFieldValue),
            Ok(v) => match v {
                100 => Ok(FitFieldWorkoutHr::from(v)),
                v => Ok(FitFieldWorkoutHr::WorkoutHr(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldWorkoutHr);

impl From<u32> for FitFieldWorkoutHr {
    fn from(code: u32) -> Self {
        match code {
            100 => FitFieldWorkoutHr::BpmOffset,
            _ => FitFieldWorkoutHr::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWorkoutPower {
    // fit base type: uint32
    WattsOffset, // 1000
    WorkoutPower(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldWorkoutPower {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWorkoutPower::WattsOffset => write!(f, "{}", "WattsOffset"),
            FitFieldWorkoutPower::WorkoutPower(x) => write!(f, "{}({})", "WorkoutPower", x),
            FitFieldWorkoutPower::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWorkoutPower::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWorkoutPower {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWorkoutPower> {
        let val = parse_uint32(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldWorkoutPower::InvalidFieldValue),
            Ok(v) => match v {
                1000 => Ok(FitFieldWorkoutPower::from(v)),
                v => Ok(FitFieldWorkoutPower::WorkoutPower(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldWorkoutPower);

impl From<u32> for FitFieldWorkoutPower {
    fn from(code: u32) -> Self {
        match code {
            1000 => FitFieldWorkoutPower::WattsOffset,
            _ => FitFieldWorkoutPower::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBpStatus {
    // fit base type: enum
    NoError = 0,
    ErrorIncompleteData = 1,
    ErrorNoMeasurement = 2,
    ErrorDataOutOfRange = 3,
    ErrorIrregularHeartRate = 4,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldBpStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBpStatus::NoError => write!(f, "{}", "NoError"),
            FitFieldBpStatus::ErrorIncompleteData => write!(f, "{}", "ErrorIncompleteData"),
            FitFieldBpStatus::ErrorNoMeasurement => write!(f, "{}", "ErrorNoMeasurement"),
            FitFieldBpStatus::ErrorDataOutOfRange => write!(f, "{}", "ErrorDataOutOfRange"),
            FitFieldBpStatus::ErrorIrregularHeartRate => write!(f, "{}", "ErrorIrregularHeartRate"),
            FitFieldBpStatus::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBpStatus::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBpStatus {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldBpStatus> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldBpStatus::from(v)),
            Err(_) => Ok(FitFieldBpStatus::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldBpStatus);

impl From<u8> for FitFieldBpStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBpStatus::NoError,
            1 => FitFieldBpStatus::ErrorIncompleteData,
            2 => FitFieldBpStatus::ErrorNoMeasurement,
            3 => FitFieldBpStatus::ErrorDataOutOfRange,
            4 => FitFieldBpStatus::ErrorIrregularHeartRate,
            _ => FitFieldBpStatus::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldUserLocalId {
    // fit base type: uint16
    LocalMin,      // 0
    LocalMax,      // 15
    StationaryMin, // 16
    StationaryMax, // 255
    PortableMin,   // 256
    PortableMax,   // 65534
    UserLocalId(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldUserLocalId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldUserLocalId::LocalMin => write!(f, "{}", "LocalMin"),
            FitFieldUserLocalId::LocalMax => write!(f, "{}", "LocalMax"),
            FitFieldUserLocalId::StationaryMin => write!(f, "{}", "StationaryMin"),
            FitFieldUserLocalId::StationaryMax => write!(f, "{}", "StationaryMax"),
            FitFieldUserLocalId::PortableMin => write!(f, "{}", "PortableMin"),
            FitFieldUserLocalId::PortableMax => write!(f, "{}", "PortableMax"),
            FitFieldUserLocalId::UserLocalId(x) => write!(f, "{}({})", "UserLocalId", x),
            FitFieldUserLocalId::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldUserLocalId::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldUserLocalId {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldUserLocalId> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldUserLocalId::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldUserLocalId::from(v)),
                15 => Ok(FitFieldUserLocalId::from(v)),
                16 => Ok(FitFieldUserLocalId::from(v)),
                255 => Ok(FitFieldUserLocalId::from(v)),
                256 => Ok(FitFieldUserLocalId::from(v)),
                65534 => Ok(FitFieldUserLocalId::from(v)),
                v => Ok(FitFieldUserLocalId::UserLocalId(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldUserLocalId);

impl From<u16> for FitFieldUserLocalId {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldUserLocalId::LocalMin,
            15 => FitFieldUserLocalId::LocalMax,
            16 => FitFieldUserLocalId::StationaryMin,
            255 => FitFieldUserLocalId::StationaryMax,
            256 => FitFieldUserLocalId::PortableMin,
            65534 => FitFieldUserLocalId::PortableMax,
            _ => FitFieldUserLocalId::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSwimStroke {
    // fit base type: enum
    Freestyle = 0,
    Backstroke = 1,
    Breaststroke = 2,
    Butterfly = 3,
    Drill = 4,
    Mixed = 5,
    Im = 6, // IM is a mixed interval containing the same number of lengths for each of: Butterfly, Backstroke, Breaststroke, Freestyle, swam in that order.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSwimStroke {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSwimStroke::Freestyle => write!(f, "{}", "Freestyle"),
            FitFieldSwimStroke::Backstroke => write!(f, "{}", "Backstroke"),
            FitFieldSwimStroke::Breaststroke => write!(f, "{}", "Breaststroke"),
            FitFieldSwimStroke::Butterfly => write!(f, "{}", "Butterfly"),
            FitFieldSwimStroke::Drill => write!(f, "{}", "Drill"),
            FitFieldSwimStroke::Mixed => write!(f, "{}", "Mixed"),
            FitFieldSwimStroke::Im => write!(f, "{}", "Im"),
            FitFieldSwimStroke::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSwimStroke::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSwimStroke {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSwimStroke> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSwimStroke::from(v)),
            Err(_) => Ok(FitFieldSwimStroke::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSwimStroke);

impl From<u8> for FitFieldSwimStroke {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSwimStroke::Freestyle,
            1 => FitFieldSwimStroke::Backstroke,
            2 => FitFieldSwimStroke::Breaststroke,
            3 => FitFieldSwimStroke::Butterfly,
            4 => FitFieldSwimStroke::Drill,
            5 => FitFieldSwimStroke::Mixed,
            6 => FitFieldSwimStroke::Im,
            _ => FitFieldSwimStroke::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldActivityType {
    // fit base type: enum
    Generic = 0,
    Running = 1,
    Cycling = 2,
    Transition = 3, // Mulitsport transition
    FitnessEquipment = 4,
    Swimming = 5,
    Walking = 6,
    Sedentary = 8,
    All = 254, // All is for goals only to include all sports.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldActivityType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldActivityType::Generic => write!(f, "{}", "Generic"),
            FitFieldActivityType::Running => write!(f, "{}", "Running"),
            FitFieldActivityType::Cycling => write!(f, "{}", "Cycling"),
            FitFieldActivityType::Transition => write!(f, "{}", "Transition"),
            FitFieldActivityType::FitnessEquipment => write!(f, "{}", "FitnessEquipment"),
            FitFieldActivityType::Swimming => write!(f, "{}", "Swimming"),
            FitFieldActivityType::Walking => write!(f, "{}", "Walking"),
            FitFieldActivityType::Sedentary => write!(f, "{}", "Sedentary"),
            FitFieldActivityType::All => write!(f, "{}", "All"),
            FitFieldActivityType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldActivityType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldActivityType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldActivityType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldActivityType::from(v)),
            Err(_) => Ok(FitFieldActivityType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldActivityType);

impl From<u8> for FitFieldActivityType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivityType::Generic,
            1 => FitFieldActivityType::Running,
            2 => FitFieldActivityType::Cycling,
            3 => FitFieldActivityType::Transition,
            4 => FitFieldActivityType::FitnessEquipment,
            5 => FitFieldActivityType::Swimming,
            6 => FitFieldActivityType::Walking,
            8 => FitFieldActivityType::Sedentary,
            254 => FitFieldActivityType::All,
            _ => FitFieldActivityType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldActivitySubtype {
    // fit base type: enum
    Generic = 0,
    Treadmill = 1,      // Run
    Street = 2,         // Run
    Trail = 3,          // Run
    Track = 4,          // Run
    Spin = 5,           // Cycling
    IndoorCycling = 6,  // Cycling
    Road = 7,           // Cycling
    Mountain = 8,       // Cycling
    Downhill = 9,       // Cycling
    Recumbent = 10,     // Cycling
    Cyclocross = 11,    // Cycling
    HandCycling = 12,   // Cycling
    TrackCycling = 13,  // Cycling
    IndoorRowing = 14,  // Fitness Equipment
    Elliptical = 15,    // Fitness Equipment
    StairClimbing = 16, // Fitness Equipment
    LapSwimming = 17,   // Swimming
    OpenWater = 18,     // Swimming
    All = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldActivitySubtype {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldActivitySubtype::Generic => write!(f, "{}", "Generic"),
            FitFieldActivitySubtype::Treadmill => write!(f, "{}", "Treadmill"),
            FitFieldActivitySubtype::Street => write!(f, "{}", "Street"),
            FitFieldActivitySubtype::Trail => write!(f, "{}", "Trail"),
            FitFieldActivitySubtype::Track => write!(f, "{}", "Track"),
            FitFieldActivitySubtype::Spin => write!(f, "{}", "Spin"),
            FitFieldActivitySubtype::IndoorCycling => write!(f, "{}", "IndoorCycling"),
            FitFieldActivitySubtype::Road => write!(f, "{}", "Road"),
            FitFieldActivitySubtype::Mountain => write!(f, "{}", "Mountain"),
            FitFieldActivitySubtype::Downhill => write!(f, "{}", "Downhill"),
            FitFieldActivitySubtype::Recumbent => write!(f, "{}", "Recumbent"),
            FitFieldActivitySubtype::Cyclocross => write!(f, "{}", "Cyclocross"),
            FitFieldActivitySubtype::HandCycling => write!(f, "{}", "HandCycling"),
            FitFieldActivitySubtype::TrackCycling => write!(f, "{}", "TrackCycling"),
            FitFieldActivitySubtype::IndoorRowing => write!(f, "{}", "IndoorRowing"),
            FitFieldActivitySubtype::Elliptical => write!(f, "{}", "Elliptical"),
            FitFieldActivitySubtype::StairClimbing => write!(f, "{}", "StairClimbing"),
            FitFieldActivitySubtype::LapSwimming => write!(f, "{}", "LapSwimming"),
            FitFieldActivitySubtype::OpenWater => write!(f, "{}", "OpenWater"),
            FitFieldActivitySubtype::All => write!(f, "{}", "All"),
            FitFieldActivitySubtype::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldActivitySubtype::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldActivitySubtype {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldActivitySubtype> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldActivitySubtype::from(v)),
            Err(_) => Ok(FitFieldActivitySubtype::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldActivitySubtype);

impl From<u8> for FitFieldActivitySubtype {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivitySubtype::Generic,
            1 => FitFieldActivitySubtype::Treadmill,
            2 => FitFieldActivitySubtype::Street,
            3 => FitFieldActivitySubtype::Trail,
            4 => FitFieldActivitySubtype::Track,
            5 => FitFieldActivitySubtype::Spin,
            6 => FitFieldActivitySubtype::IndoorCycling,
            7 => FitFieldActivitySubtype::Road,
            8 => FitFieldActivitySubtype::Mountain,
            9 => FitFieldActivitySubtype::Downhill,
            10 => FitFieldActivitySubtype::Recumbent,
            11 => FitFieldActivitySubtype::Cyclocross,
            12 => FitFieldActivitySubtype::HandCycling,
            13 => FitFieldActivitySubtype::TrackCycling,
            14 => FitFieldActivitySubtype::IndoorRowing,
            15 => FitFieldActivitySubtype::Elliptical,
            16 => FitFieldActivitySubtype::StairClimbing,
            17 => FitFieldActivitySubtype::LapSwimming,
            18 => FitFieldActivitySubtype::OpenWater,
            254 => FitFieldActivitySubtype::All,
            _ => FitFieldActivitySubtype::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldActivityLevel {
    // fit base type: enum
    Low = 0,
    Medium = 1,
    High = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldActivityLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldActivityLevel::Low => write!(f, "{}", "Low"),
            FitFieldActivityLevel::Medium => write!(f, "{}", "Medium"),
            FitFieldActivityLevel::High => write!(f, "{}", "High"),
            FitFieldActivityLevel::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldActivityLevel::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldActivityLevel {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldActivityLevel> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldActivityLevel::from(v)),
            Err(_) => Ok(FitFieldActivityLevel::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldActivityLevel);

impl From<u8> for FitFieldActivityLevel {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivityLevel::Low,
            1 => FitFieldActivityLevel::Medium,
            2 => FitFieldActivityLevel::High,
            _ => FitFieldActivityLevel::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSide {
    // fit base type: enum
    Right = 0,
    Left = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSide {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSide::Right => write!(f, "{}", "Right"),
            FitFieldSide::Left => write!(f, "{}", "Left"),
            FitFieldSide::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSide::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSide {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSide> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSide::from(v)),
            Err(_) => Ok(FitFieldSide::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSide);

impl From<u8> for FitFieldSide {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSide::Right,
            1 => FitFieldSide::Left,
            _ => FitFieldSide::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLeftRightBalance {
    // fit base type: uint8
    Mask,  // 127  % contribution
    Right, // 128  data corresponds to right if set, otherwise unknown
    LeftRightBalance(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLeftRightBalance {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLeftRightBalance::Mask => write!(f, "{}", "Mask"),
            FitFieldLeftRightBalance::Right => write!(f, "{}", "Right"),
            FitFieldLeftRightBalance::LeftRightBalance(x) => {
                write!(f, "{}({})", "LeftRightBalance", x)
            }
            FitFieldLeftRightBalance::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLeftRightBalance::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLeftRightBalance {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLeftRightBalance> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLeftRightBalance::InvalidFieldValue),
            Ok(v) => match v {
                127 => Ok(FitFieldLeftRightBalance::from(v)),
                128 => Ok(FitFieldLeftRightBalance::from(v)),
                v => Ok(FitFieldLeftRightBalance::LeftRightBalance(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLeftRightBalance);

impl From<u8> for FitFieldLeftRightBalance {
    fn from(code: u8) -> Self {
        match code {
            127 => FitFieldLeftRightBalance::Mask,
            128 => FitFieldLeftRightBalance::Right,
            _ => FitFieldLeftRightBalance::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLeftRightBalance100 {
    // fit base type: uint16
    Mask,  // 16383  % contribution scaled by 100
    Right, // 32768  data corresponds to right if set, otherwise unknown
    LeftRightBalance100(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLeftRightBalance100 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLeftRightBalance100::Mask => write!(f, "{}", "Mask"),
            FitFieldLeftRightBalance100::Right => write!(f, "{}", "Right"),
            FitFieldLeftRightBalance100::LeftRightBalance100(x) => {
                write!(f, "{}({})", "LeftRightBalance100", x)
            }
            FitFieldLeftRightBalance100::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLeftRightBalance100::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLeftRightBalance100 {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLeftRightBalance100> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLeftRightBalance100::InvalidFieldValue),
            Ok(v) => match v {
                16383 => Ok(FitFieldLeftRightBalance100::from(v)),
                32768 => Ok(FitFieldLeftRightBalance100::from(v)),
                v => Ok(FitFieldLeftRightBalance100::LeftRightBalance100(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLeftRightBalance100);

impl From<u16> for FitFieldLeftRightBalance100 {
    fn from(code: u16) -> Self {
        match code {
            16383 => FitFieldLeftRightBalance100::Mask,
            32768 => FitFieldLeftRightBalance100::Right,
            _ => FitFieldLeftRightBalance100::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLengthType {
    // fit base type: enum
    Idle = 0,   // Rest period. Length with no strokes
    Active = 1, // Length with strokes.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldLengthType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLengthType::Idle => write!(f, "{}", "Idle"),
            FitFieldLengthType::Active => write!(f, "{}", "Active"),
            FitFieldLengthType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLengthType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLengthType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLengthType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldLengthType::from(v)),
            Err(_) => Ok(FitFieldLengthType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldLengthType);

impl From<u8> for FitFieldLengthType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldLengthType::Idle,
            1 => FitFieldLengthType::Active,
            _ => FitFieldLengthType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDayOfWeek {
    // fit base type: enum
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDayOfWeek {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDayOfWeek::Sunday => write!(f, "{}", "Sunday"),
            FitFieldDayOfWeek::Monday => write!(f, "{}", "Monday"),
            FitFieldDayOfWeek::Tuesday => write!(f, "{}", "Tuesday"),
            FitFieldDayOfWeek::Wednesday => write!(f, "{}", "Wednesday"),
            FitFieldDayOfWeek::Thursday => write!(f, "{}", "Thursday"),
            FitFieldDayOfWeek::Friday => write!(f, "{}", "Friday"),
            FitFieldDayOfWeek::Saturday => write!(f, "{}", "Saturday"),
            FitFieldDayOfWeek::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDayOfWeek::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDayOfWeek {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDayOfWeek> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDayOfWeek::from(v)),
            Err(_) => Ok(FitFieldDayOfWeek::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDayOfWeek);

impl From<u8> for FitFieldDayOfWeek {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDayOfWeek::Sunday,
            1 => FitFieldDayOfWeek::Monday,
            2 => FitFieldDayOfWeek::Tuesday,
            3 => FitFieldDayOfWeek::Wednesday,
            4 => FitFieldDayOfWeek::Thursday,
            5 => FitFieldDayOfWeek::Friday,
            6 => FitFieldDayOfWeek::Saturday,
            _ => FitFieldDayOfWeek::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldConnectivityCapabilities {
    // fit base type: uint32z
    Bluetooth,                       // 1
    BluetoothLe,                     // 2
    Ant,                             // 4
    ActivityUpload,                  // 8
    CourseDownload,                  // 16
    WorkoutDownload,                 // 32
    LiveTrack,                       // 64
    WeatherConditions,               // 128
    WeatherAlerts,                   // 256
    GpsEphemerisDownload,            // 512
    ExplicitArchive,                 // 1024
    SetupIncomplete,                 // 2048
    ContinueSyncAfterSoftwareUpdate, // 4096
    ConnectIqAppDownload,            // 8192
    GolfCourseDownload,              // 16384
    DeviceInitiatesSync, // 32768  Indicates device is in control of initiating all syncs
    ConnectIqWatchAppDownload, // 65536
    ConnectIqWidgetDownload, // 131072
    ConnectIqWatchFaceDownload, // 262144
    ConnectIqDataFieldDownload, // 524288
    ConnectIqAppManagment, // 1048576  Device supports delete and reorder of apps via GCM
    SwingSensor,         // 2097152
    SwingSensorRemote,   // 4194304
    IncidentDetection,   // 8388608  Device supports incident detection
    AudioPrompts,        // 16777216
    WifiVerification,    // 33554432  Device supports reporting wifi verification via GCM
    TrueUp,              // 67108864  Device supports True Up
    FindMyWatch,         // 134217728  Device supports Find My Watch
    RemoteManualSync,    // 268435456
    LiveTrackAutoStart,  // 536870912  Device supports LiveTrack auto start
    LiveTrackMessaging,  // 1073741824  Device supports LiveTrack Messaging
    InstantInput,        // 2147483648  Device supports instant input feature
    ConnectivityCapabilities(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldConnectivityCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldConnectivityCapabilities::Bluetooth => write!(f, "{}", "Bluetooth"),
            FitFieldConnectivityCapabilities::BluetoothLe => write!(f, "{}", "BluetoothLe"),
            FitFieldConnectivityCapabilities::Ant => write!(f, "{}", "Ant"),
            FitFieldConnectivityCapabilities::ActivityUpload => write!(f, "{}", "ActivityUpload"),
            FitFieldConnectivityCapabilities::CourseDownload => write!(f, "{}", "CourseDownload"),
            FitFieldConnectivityCapabilities::WorkoutDownload => write!(f, "{}", "WorkoutDownload"),
            FitFieldConnectivityCapabilities::LiveTrack => write!(f, "{}", "LiveTrack"),
            FitFieldConnectivityCapabilities::WeatherConditions => {
                write!(f, "{}", "WeatherConditions")
            }
            FitFieldConnectivityCapabilities::WeatherAlerts => write!(f, "{}", "WeatherAlerts"),
            FitFieldConnectivityCapabilities::GpsEphemerisDownload => {
                write!(f, "{}", "GpsEphemerisDownload")
            }
            FitFieldConnectivityCapabilities::ExplicitArchive => write!(f, "{}", "ExplicitArchive"),
            FitFieldConnectivityCapabilities::SetupIncomplete => write!(f, "{}", "SetupIncomplete"),
            FitFieldConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate => {
                write!(f, "{}", "ContinueSyncAfterSoftwareUpdate")
            }
            FitFieldConnectivityCapabilities::ConnectIqAppDownload => {
                write!(f, "{}", "ConnectIqAppDownload")
            }
            FitFieldConnectivityCapabilities::GolfCourseDownload => {
                write!(f, "{}", "GolfCourseDownload")
            }
            FitFieldConnectivityCapabilities::DeviceInitiatesSync => {
                write!(f, "{}", "DeviceInitiatesSync")
            }
            FitFieldConnectivityCapabilities::ConnectIqWatchAppDownload => {
                write!(f, "{}", "ConnectIqWatchAppDownload")
            }
            FitFieldConnectivityCapabilities::ConnectIqWidgetDownload => {
                write!(f, "{}", "ConnectIqWidgetDownload")
            }
            FitFieldConnectivityCapabilities::ConnectIqWatchFaceDownload => {
                write!(f, "{}", "ConnectIqWatchFaceDownload")
            }
            FitFieldConnectivityCapabilities::ConnectIqDataFieldDownload => {
                write!(f, "{}", "ConnectIqDataFieldDownload")
            }
            FitFieldConnectivityCapabilities::ConnectIqAppManagment => {
                write!(f, "{}", "ConnectIqAppManagment")
            }
            FitFieldConnectivityCapabilities::SwingSensor => write!(f, "{}", "SwingSensor"),
            FitFieldConnectivityCapabilities::SwingSensorRemote => {
                write!(f, "{}", "SwingSensorRemote")
            }
            FitFieldConnectivityCapabilities::IncidentDetection => {
                write!(f, "{}", "IncidentDetection")
            }
            FitFieldConnectivityCapabilities::AudioPrompts => write!(f, "{}", "AudioPrompts"),
            FitFieldConnectivityCapabilities::WifiVerification => {
                write!(f, "{}", "WifiVerification")
            }
            FitFieldConnectivityCapabilities::TrueUp => write!(f, "{}", "TrueUp"),
            FitFieldConnectivityCapabilities::FindMyWatch => write!(f, "{}", "FindMyWatch"),
            FitFieldConnectivityCapabilities::RemoteManualSync => {
                write!(f, "{}", "RemoteManualSync")
            }
            FitFieldConnectivityCapabilities::LiveTrackAutoStart => {
                write!(f, "{}", "LiveTrackAutoStart")
            }
            FitFieldConnectivityCapabilities::LiveTrackMessaging => {
                write!(f, "{}", "LiveTrackMessaging")
            }
            FitFieldConnectivityCapabilities::InstantInput => write!(f, "{}", "InstantInput"),
            FitFieldConnectivityCapabilities::ConnectivityCapabilities(x) => {
                write!(f, "{}({})", "ConnectivityCapabilities", x)
            }
            FitFieldConnectivityCapabilities::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldConnectivityCapabilities::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldConnectivityCapabilities {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldConnectivityCapabilities> {
        let val = parse_uint32z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldConnectivityCapabilities::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldConnectivityCapabilities::from(v)),
                2 => Ok(FitFieldConnectivityCapabilities::from(v)),
                4 => Ok(FitFieldConnectivityCapabilities::from(v)),
                8 => Ok(FitFieldConnectivityCapabilities::from(v)),
                16 => Ok(FitFieldConnectivityCapabilities::from(v)),
                32 => Ok(FitFieldConnectivityCapabilities::from(v)),
                64 => Ok(FitFieldConnectivityCapabilities::from(v)),
                128 => Ok(FitFieldConnectivityCapabilities::from(v)),
                256 => Ok(FitFieldConnectivityCapabilities::from(v)),
                512 => Ok(FitFieldConnectivityCapabilities::from(v)),
                1024 => Ok(FitFieldConnectivityCapabilities::from(v)),
                2048 => Ok(FitFieldConnectivityCapabilities::from(v)),
                4096 => Ok(FitFieldConnectivityCapabilities::from(v)),
                8192 => Ok(FitFieldConnectivityCapabilities::from(v)),
                16384 => Ok(FitFieldConnectivityCapabilities::from(v)),
                32768 => Ok(FitFieldConnectivityCapabilities::from(v)),
                65536 => Ok(FitFieldConnectivityCapabilities::from(v)),
                131072 => Ok(FitFieldConnectivityCapabilities::from(v)),
                262144 => Ok(FitFieldConnectivityCapabilities::from(v)),
                524288 => Ok(FitFieldConnectivityCapabilities::from(v)),
                1048576 => Ok(FitFieldConnectivityCapabilities::from(v)),
                2097152 => Ok(FitFieldConnectivityCapabilities::from(v)),
                4194304 => Ok(FitFieldConnectivityCapabilities::from(v)),
                8388608 => Ok(FitFieldConnectivityCapabilities::from(v)),
                16777216 => Ok(FitFieldConnectivityCapabilities::from(v)),
                33554432 => Ok(FitFieldConnectivityCapabilities::from(v)),
                67108864 => Ok(FitFieldConnectivityCapabilities::from(v)),
                134217728 => Ok(FitFieldConnectivityCapabilities::from(v)),
                268435456 => Ok(FitFieldConnectivityCapabilities::from(v)),
                536870912 => Ok(FitFieldConnectivityCapabilities::from(v)),
                1073741824 => Ok(FitFieldConnectivityCapabilities::from(v)),
                2147483648 => Ok(FitFieldConnectivityCapabilities::from(v)),
                v => Ok(FitFieldConnectivityCapabilities::ConnectivityCapabilities(
                    v,
                )),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldConnectivityCapabilities);

impl From<u32> for FitFieldConnectivityCapabilities {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldConnectivityCapabilities::Bluetooth,
            2 => FitFieldConnectivityCapabilities::BluetoothLe,
            4 => FitFieldConnectivityCapabilities::Ant,
            8 => FitFieldConnectivityCapabilities::ActivityUpload,
            16 => FitFieldConnectivityCapabilities::CourseDownload,
            32 => FitFieldConnectivityCapabilities::WorkoutDownload,
            64 => FitFieldConnectivityCapabilities::LiveTrack,
            128 => FitFieldConnectivityCapabilities::WeatherConditions,
            256 => FitFieldConnectivityCapabilities::WeatherAlerts,
            512 => FitFieldConnectivityCapabilities::GpsEphemerisDownload,
            1024 => FitFieldConnectivityCapabilities::ExplicitArchive,
            2048 => FitFieldConnectivityCapabilities::SetupIncomplete,
            4096 => FitFieldConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate,
            8192 => FitFieldConnectivityCapabilities::ConnectIqAppDownload,
            16384 => FitFieldConnectivityCapabilities::GolfCourseDownload,
            32768 => FitFieldConnectivityCapabilities::DeviceInitiatesSync,
            65536 => FitFieldConnectivityCapabilities::ConnectIqWatchAppDownload,
            131072 => FitFieldConnectivityCapabilities::ConnectIqWidgetDownload,
            262144 => FitFieldConnectivityCapabilities::ConnectIqWatchFaceDownload,
            524288 => FitFieldConnectivityCapabilities::ConnectIqDataFieldDownload,
            1048576 => FitFieldConnectivityCapabilities::ConnectIqAppManagment,
            2097152 => FitFieldConnectivityCapabilities::SwingSensor,
            4194304 => FitFieldConnectivityCapabilities::SwingSensorRemote,
            8388608 => FitFieldConnectivityCapabilities::IncidentDetection,
            16777216 => FitFieldConnectivityCapabilities::AudioPrompts,
            33554432 => FitFieldConnectivityCapabilities::WifiVerification,
            67108864 => FitFieldConnectivityCapabilities::TrueUp,
            134217728 => FitFieldConnectivityCapabilities::FindMyWatch,
            268435456 => FitFieldConnectivityCapabilities::RemoteManualSync,
            536870912 => FitFieldConnectivityCapabilities::LiveTrackAutoStart,
            1073741824 => FitFieldConnectivityCapabilities::LiveTrackMessaging,
            2147483648 => FitFieldConnectivityCapabilities::InstantInput,
            _ => FitFieldConnectivityCapabilities::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWeatherReport {
    // fit base type: enum
    Current = 0,
    HourlyForecast = 1,
    DailyForecast = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWeatherReport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWeatherReport::Current => write!(f, "{}", "Current"),
            FitFieldWeatherReport::HourlyForecast => write!(f, "{}", "HourlyForecast"),
            FitFieldWeatherReport::DailyForecast => write!(f, "{}", "DailyForecast"),
            FitFieldWeatherReport::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWeatherReport::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWeatherReport {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWeatherReport> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWeatherReport::from(v)),
            Err(_) => Ok(FitFieldWeatherReport::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWeatherReport);

impl From<u8> for FitFieldWeatherReport {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherReport::Current,
            1 => FitFieldWeatherReport::HourlyForecast,
            2 => FitFieldWeatherReport::DailyForecast,
            _ => FitFieldWeatherReport::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWeatherStatus {
    // fit base type: enum
    Clear = 0,
    PartlyCloudy = 1,
    MostlyCloudy = 2,
    Rain = 3,
    Snow = 4,
    Windy = 5,
    Thunderstorms = 6,
    WintryMix = 7,
    Fog = 8,
    Hazy = 11,
    Hail = 12,
    ScatteredShowers = 13,
    ScatteredThunderstorms = 14,
    UnknownPrecipitation = 15,
    LightRain = 16,
    HeavyRain = 17,
    LightSnow = 18,
    HeavySnow = 19,
    LightRainSnow = 20,
    HeavyRainSnow = 21,
    Cloudy = 22,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWeatherStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWeatherStatus::Clear => write!(f, "{}", "Clear"),
            FitFieldWeatherStatus::PartlyCloudy => write!(f, "{}", "PartlyCloudy"),
            FitFieldWeatherStatus::MostlyCloudy => write!(f, "{}", "MostlyCloudy"),
            FitFieldWeatherStatus::Rain => write!(f, "{}", "Rain"),
            FitFieldWeatherStatus::Snow => write!(f, "{}", "Snow"),
            FitFieldWeatherStatus::Windy => write!(f, "{}", "Windy"),
            FitFieldWeatherStatus::Thunderstorms => write!(f, "{}", "Thunderstorms"),
            FitFieldWeatherStatus::WintryMix => write!(f, "{}", "WintryMix"),
            FitFieldWeatherStatus::Fog => write!(f, "{}", "Fog"),
            FitFieldWeatherStatus::Hazy => write!(f, "{}", "Hazy"),
            FitFieldWeatherStatus::Hail => write!(f, "{}", "Hail"),
            FitFieldWeatherStatus::ScatteredShowers => write!(f, "{}", "ScatteredShowers"),
            FitFieldWeatherStatus::ScatteredThunderstorms => {
                write!(f, "{}", "ScatteredThunderstorms")
            }
            FitFieldWeatherStatus::UnknownPrecipitation => write!(f, "{}", "UnknownPrecipitation"),
            FitFieldWeatherStatus::LightRain => write!(f, "{}", "LightRain"),
            FitFieldWeatherStatus::HeavyRain => write!(f, "{}", "HeavyRain"),
            FitFieldWeatherStatus::LightSnow => write!(f, "{}", "LightSnow"),
            FitFieldWeatherStatus::HeavySnow => write!(f, "{}", "HeavySnow"),
            FitFieldWeatherStatus::LightRainSnow => write!(f, "{}", "LightRainSnow"),
            FitFieldWeatherStatus::HeavyRainSnow => write!(f, "{}", "HeavyRainSnow"),
            FitFieldWeatherStatus::Cloudy => write!(f, "{}", "Cloudy"),
            FitFieldWeatherStatus::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWeatherStatus::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWeatherStatus {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWeatherStatus> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWeatherStatus::from(v)),
            Err(_) => Ok(FitFieldWeatherStatus::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWeatherStatus);

impl From<u8> for FitFieldWeatherStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherStatus::Clear,
            1 => FitFieldWeatherStatus::PartlyCloudy,
            2 => FitFieldWeatherStatus::MostlyCloudy,
            3 => FitFieldWeatherStatus::Rain,
            4 => FitFieldWeatherStatus::Snow,
            5 => FitFieldWeatherStatus::Windy,
            6 => FitFieldWeatherStatus::Thunderstorms,
            7 => FitFieldWeatherStatus::WintryMix,
            8 => FitFieldWeatherStatus::Fog,
            11 => FitFieldWeatherStatus::Hazy,
            12 => FitFieldWeatherStatus::Hail,
            13 => FitFieldWeatherStatus::ScatteredShowers,
            14 => FitFieldWeatherStatus::ScatteredThunderstorms,
            15 => FitFieldWeatherStatus::UnknownPrecipitation,
            16 => FitFieldWeatherStatus::LightRain,
            17 => FitFieldWeatherStatus::HeavyRain,
            18 => FitFieldWeatherStatus::LightSnow,
            19 => FitFieldWeatherStatus::HeavySnow,
            20 => FitFieldWeatherStatus::LightRainSnow,
            21 => FitFieldWeatherStatus::HeavyRainSnow,
            22 => FitFieldWeatherStatus::Cloudy,
            _ => FitFieldWeatherStatus::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWeatherSeverity {
    // fit base type: enum
    Unknown = 0,
    Warning = 1,
    Watch = 2,
    Advisory = 3,
    Statement = 4,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWeatherSeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWeatherSeverity::Unknown => write!(f, "{}", "Unknown"),
            FitFieldWeatherSeverity::Warning => write!(f, "{}", "Warning"),
            FitFieldWeatherSeverity::Watch => write!(f, "{}", "Watch"),
            FitFieldWeatherSeverity::Advisory => write!(f, "{}", "Advisory"),
            FitFieldWeatherSeverity::Statement => write!(f, "{}", "Statement"),
            FitFieldWeatherSeverity::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWeatherSeverity::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWeatherSeverity {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWeatherSeverity> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWeatherSeverity::from(v)),
            Err(_) => Ok(FitFieldWeatherSeverity::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWeatherSeverity);

impl From<u8> for FitFieldWeatherSeverity {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherSeverity::Unknown,
            1 => FitFieldWeatherSeverity::Warning,
            2 => FitFieldWeatherSeverity::Watch,
            3 => FitFieldWeatherSeverity::Advisory,
            4 => FitFieldWeatherSeverity::Statement,
            _ => FitFieldWeatherSeverity::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWeatherSevereType {
    // fit base type: enum
    Unspecified = 0,
    Tornado = 1,
    Tsunami = 2,
    Hurricane = 3,
    ExtremeWind = 4,
    Typhoon = 5,
    InlandHurricane = 6,
    HurricaneForceWind = 7,
    Waterspout = 8,
    SevereThunderstorm = 9,
    WreckhouseWinds = 10,
    LesSuetesWind = 11,
    Avalanche = 12,
    FlashFlood = 13,
    TropicalStorm = 14,
    InlandTropicalStorm = 15,
    Blizzard = 16,
    IceStorm = 17,
    FreezingRain = 18,
    DebrisFlow = 19,
    FlashFreeze = 20,
    DustStorm = 21,
    HighWind = 22,
    WinterStorm = 23,
    HeavyFreezingSpray = 24,
    ExtremeCold = 25,
    WindChill = 26,
    ColdWave = 27,
    HeavySnowAlert = 28,
    LakeEffectBlowingSnow = 29,
    SnowSquall = 30,
    LakeEffectSnow = 31,
    WinterWeather = 32,
    Sleet = 33,
    Snowfall = 34,
    SnowAndBlowingSnow = 35,
    BlowingSnow = 36,
    SnowAlert = 37,
    ArcticOutflow = 38,
    FreezingDrizzle = 39,
    Storm = 40,
    StormSurge = 41,
    Rainfall = 42,
    ArealFlood = 43,
    CoastalFlood = 44,
    LakeshoreFlood = 45,
    ExcessiveHeat = 46,
    Heat = 47,
    Weather = 48,
    HighHeatAndHumidity = 49,
    HumidexAndHealth = 50,
    Humidex = 51,
    Gale = 52,
    FreezingSpray = 53,
    SpecialMarine = 54,
    Squall = 55,
    StrongWind = 56,
    LakeWind = 57,
    MarineWeather = 58,
    Wind = 59,
    SmallCraftHazardousSeas = 60,
    HazardousSeas = 61,
    SmallCraft = 62,
    SmallCraftWinds = 63,
    SmallCraftRoughBar = 64,
    HighWaterLevel = 65,
    Ashfall = 66,
    FreezingFog = 67,
    DenseFog = 68,
    DenseSmoke = 69,
    BlowingDust = 70,
    HardFreeze = 71,
    Freeze = 72,
    Frost = 73,
    FireWeather = 74,
    Flood = 75,
    RipTide = 76,
    HighSurf = 77,
    Smog = 78,
    AirQuality = 79,
    BriskWind = 80,
    AirStagnation = 81,
    LowWater = 82,
    Hydrological = 83,
    SpecialWeather = 84,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWeatherSevereType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWeatherSevereType::Unspecified => write!(f, "{}", "Unspecified"),
            FitFieldWeatherSevereType::Tornado => write!(f, "{}", "Tornado"),
            FitFieldWeatherSevereType::Tsunami => write!(f, "{}", "Tsunami"),
            FitFieldWeatherSevereType::Hurricane => write!(f, "{}", "Hurricane"),
            FitFieldWeatherSevereType::ExtremeWind => write!(f, "{}", "ExtremeWind"),
            FitFieldWeatherSevereType::Typhoon => write!(f, "{}", "Typhoon"),
            FitFieldWeatherSevereType::InlandHurricane => write!(f, "{}", "InlandHurricane"),
            FitFieldWeatherSevereType::HurricaneForceWind => write!(f, "{}", "HurricaneForceWind"),
            FitFieldWeatherSevereType::Waterspout => write!(f, "{}", "Waterspout"),
            FitFieldWeatherSevereType::SevereThunderstorm => write!(f, "{}", "SevereThunderstorm"),
            FitFieldWeatherSevereType::WreckhouseWinds => write!(f, "{}", "WreckhouseWinds"),
            FitFieldWeatherSevereType::LesSuetesWind => write!(f, "{}", "LesSuetesWind"),
            FitFieldWeatherSevereType::Avalanche => write!(f, "{}", "Avalanche"),
            FitFieldWeatherSevereType::FlashFlood => write!(f, "{}", "FlashFlood"),
            FitFieldWeatherSevereType::TropicalStorm => write!(f, "{}", "TropicalStorm"),
            FitFieldWeatherSevereType::InlandTropicalStorm => {
                write!(f, "{}", "InlandTropicalStorm")
            }
            FitFieldWeatherSevereType::Blizzard => write!(f, "{}", "Blizzard"),
            FitFieldWeatherSevereType::IceStorm => write!(f, "{}", "IceStorm"),
            FitFieldWeatherSevereType::FreezingRain => write!(f, "{}", "FreezingRain"),
            FitFieldWeatherSevereType::DebrisFlow => write!(f, "{}", "DebrisFlow"),
            FitFieldWeatherSevereType::FlashFreeze => write!(f, "{}", "FlashFreeze"),
            FitFieldWeatherSevereType::DustStorm => write!(f, "{}", "DustStorm"),
            FitFieldWeatherSevereType::HighWind => write!(f, "{}", "HighWind"),
            FitFieldWeatherSevereType::WinterStorm => write!(f, "{}", "WinterStorm"),
            FitFieldWeatherSevereType::HeavyFreezingSpray => write!(f, "{}", "HeavyFreezingSpray"),
            FitFieldWeatherSevereType::ExtremeCold => write!(f, "{}", "ExtremeCold"),
            FitFieldWeatherSevereType::WindChill => write!(f, "{}", "WindChill"),
            FitFieldWeatherSevereType::ColdWave => write!(f, "{}", "ColdWave"),
            FitFieldWeatherSevereType::HeavySnowAlert => write!(f, "{}", "HeavySnowAlert"),
            FitFieldWeatherSevereType::LakeEffectBlowingSnow => {
                write!(f, "{}", "LakeEffectBlowingSnow")
            }
            FitFieldWeatherSevereType::SnowSquall => write!(f, "{}", "SnowSquall"),
            FitFieldWeatherSevereType::LakeEffectSnow => write!(f, "{}", "LakeEffectSnow"),
            FitFieldWeatherSevereType::WinterWeather => write!(f, "{}", "WinterWeather"),
            FitFieldWeatherSevereType::Sleet => write!(f, "{}", "Sleet"),
            FitFieldWeatherSevereType::Snowfall => write!(f, "{}", "Snowfall"),
            FitFieldWeatherSevereType::SnowAndBlowingSnow => write!(f, "{}", "SnowAndBlowingSnow"),
            FitFieldWeatherSevereType::BlowingSnow => write!(f, "{}", "BlowingSnow"),
            FitFieldWeatherSevereType::SnowAlert => write!(f, "{}", "SnowAlert"),
            FitFieldWeatherSevereType::ArcticOutflow => write!(f, "{}", "ArcticOutflow"),
            FitFieldWeatherSevereType::FreezingDrizzle => write!(f, "{}", "FreezingDrizzle"),
            FitFieldWeatherSevereType::Storm => write!(f, "{}", "Storm"),
            FitFieldWeatherSevereType::StormSurge => write!(f, "{}", "StormSurge"),
            FitFieldWeatherSevereType::Rainfall => write!(f, "{}", "Rainfall"),
            FitFieldWeatherSevereType::ArealFlood => write!(f, "{}", "ArealFlood"),
            FitFieldWeatherSevereType::CoastalFlood => write!(f, "{}", "CoastalFlood"),
            FitFieldWeatherSevereType::LakeshoreFlood => write!(f, "{}", "LakeshoreFlood"),
            FitFieldWeatherSevereType::ExcessiveHeat => write!(f, "{}", "ExcessiveHeat"),
            FitFieldWeatherSevereType::Heat => write!(f, "{}", "Heat"),
            FitFieldWeatherSevereType::Weather => write!(f, "{}", "Weather"),
            FitFieldWeatherSevereType::HighHeatAndHumidity => {
                write!(f, "{}", "HighHeatAndHumidity")
            }
            FitFieldWeatherSevereType::HumidexAndHealth => write!(f, "{}", "HumidexAndHealth"),
            FitFieldWeatherSevereType::Humidex => write!(f, "{}", "Humidex"),
            FitFieldWeatherSevereType::Gale => write!(f, "{}", "Gale"),
            FitFieldWeatherSevereType::FreezingSpray => write!(f, "{}", "FreezingSpray"),
            FitFieldWeatherSevereType::SpecialMarine => write!(f, "{}", "SpecialMarine"),
            FitFieldWeatherSevereType::Squall => write!(f, "{}", "Squall"),
            FitFieldWeatherSevereType::StrongWind => write!(f, "{}", "StrongWind"),
            FitFieldWeatherSevereType::LakeWind => write!(f, "{}", "LakeWind"),
            FitFieldWeatherSevereType::MarineWeather => write!(f, "{}", "MarineWeather"),
            FitFieldWeatherSevereType::Wind => write!(f, "{}", "Wind"),
            FitFieldWeatherSevereType::SmallCraftHazardousSeas => {
                write!(f, "{}", "SmallCraftHazardousSeas")
            }
            FitFieldWeatherSevereType::HazardousSeas => write!(f, "{}", "HazardousSeas"),
            FitFieldWeatherSevereType::SmallCraft => write!(f, "{}", "SmallCraft"),
            FitFieldWeatherSevereType::SmallCraftWinds => write!(f, "{}", "SmallCraftWinds"),
            FitFieldWeatherSevereType::SmallCraftRoughBar => write!(f, "{}", "SmallCraftRoughBar"),
            FitFieldWeatherSevereType::HighWaterLevel => write!(f, "{}", "HighWaterLevel"),
            FitFieldWeatherSevereType::Ashfall => write!(f, "{}", "Ashfall"),
            FitFieldWeatherSevereType::FreezingFog => write!(f, "{}", "FreezingFog"),
            FitFieldWeatherSevereType::DenseFog => write!(f, "{}", "DenseFog"),
            FitFieldWeatherSevereType::DenseSmoke => write!(f, "{}", "DenseSmoke"),
            FitFieldWeatherSevereType::BlowingDust => write!(f, "{}", "BlowingDust"),
            FitFieldWeatherSevereType::HardFreeze => write!(f, "{}", "HardFreeze"),
            FitFieldWeatherSevereType::Freeze => write!(f, "{}", "Freeze"),
            FitFieldWeatherSevereType::Frost => write!(f, "{}", "Frost"),
            FitFieldWeatherSevereType::FireWeather => write!(f, "{}", "FireWeather"),
            FitFieldWeatherSevereType::Flood => write!(f, "{}", "Flood"),
            FitFieldWeatherSevereType::RipTide => write!(f, "{}", "RipTide"),
            FitFieldWeatherSevereType::HighSurf => write!(f, "{}", "HighSurf"),
            FitFieldWeatherSevereType::Smog => write!(f, "{}", "Smog"),
            FitFieldWeatherSevereType::AirQuality => write!(f, "{}", "AirQuality"),
            FitFieldWeatherSevereType::BriskWind => write!(f, "{}", "BriskWind"),
            FitFieldWeatherSevereType::AirStagnation => write!(f, "{}", "AirStagnation"),
            FitFieldWeatherSevereType::LowWater => write!(f, "{}", "LowWater"),
            FitFieldWeatherSevereType::Hydrological => write!(f, "{}", "Hydrological"),
            FitFieldWeatherSevereType::SpecialWeather => write!(f, "{}", "SpecialWeather"),
            FitFieldWeatherSevereType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWeatherSevereType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWeatherSevereType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWeatherSevereType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWeatherSevereType::from(v)),
            Err(_) => Ok(FitFieldWeatherSevereType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWeatherSevereType);

impl From<u8> for FitFieldWeatherSevereType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherSevereType::Unspecified,
            1 => FitFieldWeatherSevereType::Tornado,
            2 => FitFieldWeatherSevereType::Tsunami,
            3 => FitFieldWeatherSevereType::Hurricane,
            4 => FitFieldWeatherSevereType::ExtremeWind,
            5 => FitFieldWeatherSevereType::Typhoon,
            6 => FitFieldWeatherSevereType::InlandHurricane,
            7 => FitFieldWeatherSevereType::HurricaneForceWind,
            8 => FitFieldWeatherSevereType::Waterspout,
            9 => FitFieldWeatherSevereType::SevereThunderstorm,
            10 => FitFieldWeatherSevereType::WreckhouseWinds,
            11 => FitFieldWeatherSevereType::LesSuetesWind,
            12 => FitFieldWeatherSevereType::Avalanche,
            13 => FitFieldWeatherSevereType::FlashFlood,
            14 => FitFieldWeatherSevereType::TropicalStorm,
            15 => FitFieldWeatherSevereType::InlandTropicalStorm,
            16 => FitFieldWeatherSevereType::Blizzard,
            17 => FitFieldWeatherSevereType::IceStorm,
            18 => FitFieldWeatherSevereType::FreezingRain,
            19 => FitFieldWeatherSevereType::DebrisFlow,
            20 => FitFieldWeatherSevereType::FlashFreeze,
            21 => FitFieldWeatherSevereType::DustStorm,
            22 => FitFieldWeatherSevereType::HighWind,
            23 => FitFieldWeatherSevereType::WinterStorm,
            24 => FitFieldWeatherSevereType::HeavyFreezingSpray,
            25 => FitFieldWeatherSevereType::ExtremeCold,
            26 => FitFieldWeatherSevereType::WindChill,
            27 => FitFieldWeatherSevereType::ColdWave,
            28 => FitFieldWeatherSevereType::HeavySnowAlert,
            29 => FitFieldWeatherSevereType::LakeEffectBlowingSnow,
            30 => FitFieldWeatherSevereType::SnowSquall,
            31 => FitFieldWeatherSevereType::LakeEffectSnow,
            32 => FitFieldWeatherSevereType::WinterWeather,
            33 => FitFieldWeatherSevereType::Sleet,
            34 => FitFieldWeatherSevereType::Snowfall,
            35 => FitFieldWeatherSevereType::SnowAndBlowingSnow,
            36 => FitFieldWeatherSevereType::BlowingSnow,
            37 => FitFieldWeatherSevereType::SnowAlert,
            38 => FitFieldWeatherSevereType::ArcticOutflow,
            39 => FitFieldWeatherSevereType::FreezingDrizzle,
            40 => FitFieldWeatherSevereType::Storm,
            41 => FitFieldWeatherSevereType::StormSurge,
            42 => FitFieldWeatherSevereType::Rainfall,
            43 => FitFieldWeatherSevereType::ArealFlood,
            44 => FitFieldWeatherSevereType::CoastalFlood,
            45 => FitFieldWeatherSevereType::LakeshoreFlood,
            46 => FitFieldWeatherSevereType::ExcessiveHeat,
            47 => FitFieldWeatherSevereType::Heat,
            48 => FitFieldWeatherSevereType::Weather,
            49 => FitFieldWeatherSevereType::HighHeatAndHumidity,
            50 => FitFieldWeatherSevereType::HumidexAndHealth,
            51 => FitFieldWeatherSevereType::Humidex,
            52 => FitFieldWeatherSevereType::Gale,
            53 => FitFieldWeatherSevereType::FreezingSpray,
            54 => FitFieldWeatherSevereType::SpecialMarine,
            55 => FitFieldWeatherSevereType::Squall,
            56 => FitFieldWeatherSevereType::StrongWind,
            57 => FitFieldWeatherSevereType::LakeWind,
            58 => FitFieldWeatherSevereType::MarineWeather,
            59 => FitFieldWeatherSevereType::Wind,
            60 => FitFieldWeatherSevereType::SmallCraftHazardousSeas,
            61 => FitFieldWeatherSevereType::HazardousSeas,
            62 => FitFieldWeatherSevereType::SmallCraft,
            63 => FitFieldWeatherSevereType::SmallCraftWinds,
            64 => FitFieldWeatherSevereType::SmallCraftRoughBar,
            65 => FitFieldWeatherSevereType::HighWaterLevel,
            66 => FitFieldWeatherSevereType::Ashfall,
            67 => FitFieldWeatherSevereType::FreezingFog,
            68 => FitFieldWeatherSevereType::DenseFog,
            69 => FitFieldWeatherSevereType::DenseSmoke,
            70 => FitFieldWeatherSevereType::BlowingDust,
            71 => FitFieldWeatherSevereType::HardFreeze,
            72 => FitFieldWeatherSevereType::Freeze,
            73 => FitFieldWeatherSevereType::Frost,
            74 => FitFieldWeatherSevereType::FireWeather,
            75 => FitFieldWeatherSevereType::Flood,
            76 => FitFieldWeatherSevereType::RipTide,
            77 => FitFieldWeatherSevereType::HighSurf,
            78 => FitFieldWeatherSevereType::Smog,
            79 => FitFieldWeatherSevereType::AirQuality,
            80 => FitFieldWeatherSevereType::BriskWind,
            81 => FitFieldWeatherSevereType::AirStagnation,
            82 => FitFieldWeatherSevereType::LowWater,
            83 => FitFieldWeatherSevereType::Hydrological,
            84 => FitFieldWeatherSevereType::SpecialWeather,
            _ => FitFieldWeatherSevereType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTimeIntoDay {
    // fit base type: uint32
    TimeIntoDay(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldTimeIntoDay {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTimeIntoDay::TimeIntoDay(x) => write!(f, "{}({})", "TimeIntoDay", x),
            FitFieldTimeIntoDay::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTimeIntoDay::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTimeIntoDay {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTimeIntoDay> {
        let val = parse_uint32(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldTimeIntoDay::InvalidFieldValue),
            Ok(v) => match v {
                v => Ok(FitFieldTimeIntoDay::TimeIntoDay(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldTimeIntoDay);

impl From<u32> for FitFieldTimeIntoDay {
    fn from(code: u32) -> Self {
        match code {
            _ => FitFieldTimeIntoDay::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLocaltimeIntoDay {
    // fit base type: uint32
    LocaltimeIntoDay(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLocaltimeIntoDay {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLocaltimeIntoDay::LocaltimeIntoDay(x) => {
                write!(f, "{}({})", "LocaltimeIntoDay", x)
            }
            FitFieldLocaltimeIntoDay::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLocaltimeIntoDay::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLocaltimeIntoDay {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLocaltimeIntoDay> {
        let val = parse_uint32(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLocaltimeIntoDay::InvalidFieldValue),
            Ok(v) => match v {
                v => Ok(FitFieldLocaltimeIntoDay::LocaltimeIntoDay(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLocaltimeIntoDay);

impl From<u32> for FitFieldLocaltimeIntoDay {
    fn from(code: u32) -> Self {
        match code {
            _ => FitFieldLocaltimeIntoDay::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldStrokeType {
    // fit base type: enum
    NoEvent = 0,
    Other = 1, // stroke was detected but cannot be identified
    Serve = 2,
    Forehand = 3,
    Backhand = 4,
    Smash = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldStrokeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldStrokeType::NoEvent => write!(f, "{}", "NoEvent"),
            FitFieldStrokeType::Other => write!(f, "{}", "Other"),
            FitFieldStrokeType::Serve => write!(f, "{}", "Serve"),
            FitFieldStrokeType::Forehand => write!(f, "{}", "Forehand"),
            FitFieldStrokeType::Backhand => write!(f, "{}", "Backhand"),
            FitFieldStrokeType::Smash => write!(f, "{}", "Smash"),
            FitFieldStrokeType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldStrokeType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldStrokeType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldStrokeType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldStrokeType::from(v)),
            Err(_) => Ok(FitFieldStrokeType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldStrokeType);

impl From<u8> for FitFieldStrokeType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldStrokeType::NoEvent,
            1 => FitFieldStrokeType::Other,
            2 => FitFieldStrokeType::Serve,
            3 => FitFieldStrokeType::Forehand,
            4 => FitFieldStrokeType::Backhand,
            5 => FitFieldStrokeType::Smash,
            _ => FitFieldStrokeType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBodyLocation {
    // fit base type: enum
    LeftLeg = 0,
    LeftCalf = 1,
    LeftShin = 2,
    LeftHamstring = 3,
    LeftQuad = 4,
    LeftGlute = 5,
    RightLeg = 6,
    RightCalf = 7,
    RightShin = 8,
    RightHamstring = 9,
    RightQuad = 10,
    RightGlute = 11,
    TorsoBack = 12,
    LeftLowerBack = 13,
    LeftUpperBack = 14,
    RightLowerBack = 15,
    RightUpperBack = 16,
    TorsoFront = 17,
    LeftAbdomen = 18,
    LeftChest = 19,
    RightAbdomen = 20,
    RightChest = 21,
    LeftArm = 22,
    LeftShoulder = 23,
    LeftBicep = 24,
    LeftTricep = 25,
    LeftBrachioradialis = 26,  // Left anterior forearm
    LeftForearmExtensors = 27, // Left posterior forearm
    RightArm = 28,
    RightShoulder = 29,
    RightBicep = 30,
    RightTricep = 31,
    RightBrachioradialis = 32,  // Right anterior forearm
    RightForearmExtensors = 33, // Right posterior forearm
    Neck = 34,
    Throat = 35,
    WaistMidBack = 36,
    WaistFront = 37,
    WaistLeft = 38,
    WaistRight = 39,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldBodyLocation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBodyLocation::LeftLeg => write!(f, "{}", "LeftLeg"),
            FitFieldBodyLocation::LeftCalf => write!(f, "{}", "LeftCalf"),
            FitFieldBodyLocation::LeftShin => write!(f, "{}", "LeftShin"),
            FitFieldBodyLocation::LeftHamstring => write!(f, "{}", "LeftHamstring"),
            FitFieldBodyLocation::LeftQuad => write!(f, "{}", "LeftQuad"),
            FitFieldBodyLocation::LeftGlute => write!(f, "{}", "LeftGlute"),
            FitFieldBodyLocation::RightLeg => write!(f, "{}", "RightLeg"),
            FitFieldBodyLocation::RightCalf => write!(f, "{}", "RightCalf"),
            FitFieldBodyLocation::RightShin => write!(f, "{}", "RightShin"),
            FitFieldBodyLocation::RightHamstring => write!(f, "{}", "RightHamstring"),
            FitFieldBodyLocation::RightQuad => write!(f, "{}", "RightQuad"),
            FitFieldBodyLocation::RightGlute => write!(f, "{}", "RightGlute"),
            FitFieldBodyLocation::TorsoBack => write!(f, "{}", "TorsoBack"),
            FitFieldBodyLocation::LeftLowerBack => write!(f, "{}", "LeftLowerBack"),
            FitFieldBodyLocation::LeftUpperBack => write!(f, "{}", "LeftUpperBack"),
            FitFieldBodyLocation::RightLowerBack => write!(f, "{}", "RightLowerBack"),
            FitFieldBodyLocation::RightUpperBack => write!(f, "{}", "RightUpperBack"),
            FitFieldBodyLocation::TorsoFront => write!(f, "{}", "TorsoFront"),
            FitFieldBodyLocation::LeftAbdomen => write!(f, "{}", "LeftAbdomen"),
            FitFieldBodyLocation::LeftChest => write!(f, "{}", "LeftChest"),
            FitFieldBodyLocation::RightAbdomen => write!(f, "{}", "RightAbdomen"),
            FitFieldBodyLocation::RightChest => write!(f, "{}", "RightChest"),
            FitFieldBodyLocation::LeftArm => write!(f, "{}", "LeftArm"),
            FitFieldBodyLocation::LeftShoulder => write!(f, "{}", "LeftShoulder"),
            FitFieldBodyLocation::LeftBicep => write!(f, "{}", "LeftBicep"),
            FitFieldBodyLocation::LeftTricep => write!(f, "{}", "LeftTricep"),
            FitFieldBodyLocation::LeftBrachioradialis => write!(f, "{}", "LeftBrachioradialis"),
            FitFieldBodyLocation::LeftForearmExtensors => write!(f, "{}", "LeftForearmExtensors"),
            FitFieldBodyLocation::RightArm => write!(f, "{}", "RightArm"),
            FitFieldBodyLocation::RightShoulder => write!(f, "{}", "RightShoulder"),
            FitFieldBodyLocation::RightBicep => write!(f, "{}", "RightBicep"),
            FitFieldBodyLocation::RightTricep => write!(f, "{}", "RightTricep"),
            FitFieldBodyLocation::RightBrachioradialis => write!(f, "{}", "RightBrachioradialis"),
            FitFieldBodyLocation::RightForearmExtensors => write!(f, "{}", "RightForearmExtensors"),
            FitFieldBodyLocation::Neck => write!(f, "{}", "Neck"),
            FitFieldBodyLocation::Throat => write!(f, "{}", "Throat"),
            FitFieldBodyLocation::WaistMidBack => write!(f, "{}", "WaistMidBack"),
            FitFieldBodyLocation::WaistFront => write!(f, "{}", "WaistFront"),
            FitFieldBodyLocation::WaistLeft => write!(f, "{}", "WaistLeft"),
            FitFieldBodyLocation::WaistRight => write!(f, "{}", "WaistRight"),
            FitFieldBodyLocation::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBodyLocation::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBodyLocation {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldBodyLocation> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldBodyLocation::from(v)),
            Err(_) => Ok(FitFieldBodyLocation::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldBodyLocation);

impl From<u8> for FitFieldBodyLocation {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBodyLocation::LeftLeg,
            1 => FitFieldBodyLocation::LeftCalf,
            2 => FitFieldBodyLocation::LeftShin,
            3 => FitFieldBodyLocation::LeftHamstring,
            4 => FitFieldBodyLocation::LeftQuad,
            5 => FitFieldBodyLocation::LeftGlute,
            6 => FitFieldBodyLocation::RightLeg,
            7 => FitFieldBodyLocation::RightCalf,
            8 => FitFieldBodyLocation::RightShin,
            9 => FitFieldBodyLocation::RightHamstring,
            10 => FitFieldBodyLocation::RightQuad,
            11 => FitFieldBodyLocation::RightGlute,
            12 => FitFieldBodyLocation::TorsoBack,
            13 => FitFieldBodyLocation::LeftLowerBack,
            14 => FitFieldBodyLocation::LeftUpperBack,
            15 => FitFieldBodyLocation::RightLowerBack,
            16 => FitFieldBodyLocation::RightUpperBack,
            17 => FitFieldBodyLocation::TorsoFront,
            18 => FitFieldBodyLocation::LeftAbdomen,
            19 => FitFieldBodyLocation::LeftChest,
            20 => FitFieldBodyLocation::RightAbdomen,
            21 => FitFieldBodyLocation::RightChest,
            22 => FitFieldBodyLocation::LeftArm,
            23 => FitFieldBodyLocation::LeftShoulder,
            24 => FitFieldBodyLocation::LeftBicep,
            25 => FitFieldBodyLocation::LeftTricep,
            26 => FitFieldBodyLocation::LeftBrachioradialis,
            27 => FitFieldBodyLocation::LeftForearmExtensors,
            28 => FitFieldBodyLocation::RightArm,
            29 => FitFieldBodyLocation::RightShoulder,
            30 => FitFieldBodyLocation::RightBicep,
            31 => FitFieldBodyLocation::RightTricep,
            32 => FitFieldBodyLocation::RightBrachioradialis,
            33 => FitFieldBodyLocation::RightForearmExtensors,
            34 => FitFieldBodyLocation::Neck,
            35 => FitFieldBodyLocation::Throat,
            36 => FitFieldBodyLocation::WaistMidBack,
            37 => FitFieldBodyLocation::WaistFront,
            38 => FitFieldBodyLocation::WaistLeft,
            39 => FitFieldBodyLocation::WaistRight,
            _ => FitFieldBodyLocation::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSegmentLapStatus {
    // fit base type: enum
    End = 0,
    Fail = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSegmentLapStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSegmentLapStatus::End => write!(f, "{}", "End"),
            FitFieldSegmentLapStatus::Fail => write!(f, "{}", "Fail"),
            FitFieldSegmentLapStatus::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSegmentLapStatus::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSegmentLapStatus {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSegmentLapStatus> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSegmentLapStatus::from(v)),
            Err(_) => Ok(FitFieldSegmentLapStatus::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSegmentLapStatus);

impl From<u8> for FitFieldSegmentLapStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentLapStatus::End,
            1 => FitFieldSegmentLapStatus::Fail,
            _ => FitFieldSegmentLapStatus::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSegmentLeaderboardType {
    // fit base type: enum
    Overall = 0,
    PersonalBest = 1,
    Connections = 2,
    Group = 3,
    Challenger = 4,
    Kom = 5,
    Qom = 6,
    Pr = 7,
    Goal = 8,
    Rival = 9,
    ClubLeader = 10,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSegmentLeaderboardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSegmentLeaderboardType::Overall => write!(f, "{}", "Overall"),
            FitFieldSegmentLeaderboardType::PersonalBest => write!(f, "{}", "PersonalBest"),
            FitFieldSegmentLeaderboardType::Connections => write!(f, "{}", "Connections"),
            FitFieldSegmentLeaderboardType::Group => write!(f, "{}", "Group"),
            FitFieldSegmentLeaderboardType::Challenger => write!(f, "{}", "Challenger"),
            FitFieldSegmentLeaderboardType::Kom => write!(f, "{}", "Kom"),
            FitFieldSegmentLeaderboardType::Qom => write!(f, "{}", "Qom"),
            FitFieldSegmentLeaderboardType::Pr => write!(f, "{}", "Pr"),
            FitFieldSegmentLeaderboardType::Goal => write!(f, "{}", "Goal"),
            FitFieldSegmentLeaderboardType::Rival => write!(f, "{}", "Rival"),
            FitFieldSegmentLeaderboardType::ClubLeader => write!(f, "{}", "ClubLeader"),
            FitFieldSegmentLeaderboardType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSegmentLeaderboardType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSegmentLeaderboardType {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldSegmentLeaderboardType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSegmentLeaderboardType::from(v)),
            Err(_) => Ok(FitFieldSegmentLeaderboardType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSegmentLeaderboardType);

impl From<u8> for FitFieldSegmentLeaderboardType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentLeaderboardType::Overall,
            1 => FitFieldSegmentLeaderboardType::PersonalBest,
            2 => FitFieldSegmentLeaderboardType::Connections,
            3 => FitFieldSegmentLeaderboardType::Group,
            4 => FitFieldSegmentLeaderboardType::Challenger,
            5 => FitFieldSegmentLeaderboardType::Kom,
            6 => FitFieldSegmentLeaderboardType::Qom,
            7 => FitFieldSegmentLeaderboardType::Pr,
            8 => FitFieldSegmentLeaderboardType::Goal,
            9 => FitFieldSegmentLeaderboardType::Rival,
            10 => FitFieldSegmentLeaderboardType::ClubLeader,
            _ => FitFieldSegmentLeaderboardType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSegmentDeleteStatus {
    // fit base type: enum
    DoNotDelete = 0,
    DeleteOne = 1,
    DeleteAll = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSegmentDeleteStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSegmentDeleteStatus::DoNotDelete => write!(f, "{}", "DoNotDelete"),
            FitFieldSegmentDeleteStatus::DeleteOne => write!(f, "{}", "DeleteOne"),
            FitFieldSegmentDeleteStatus::DeleteAll => write!(f, "{}", "DeleteAll"),
            FitFieldSegmentDeleteStatus::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSegmentDeleteStatus::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSegmentDeleteStatus {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSegmentDeleteStatus> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSegmentDeleteStatus::from(v)),
            Err(_) => Ok(FitFieldSegmentDeleteStatus::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSegmentDeleteStatus);

impl From<u8> for FitFieldSegmentDeleteStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentDeleteStatus::DoNotDelete,
            1 => FitFieldSegmentDeleteStatus::DeleteOne,
            2 => FitFieldSegmentDeleteStatus::DeleteAll,
            _ => FitFieldSegmentDeleteStatus::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSegmentSelectionType {
    // fit base type: enum
    Starred = 0,
    Suggested = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSegmentSelectionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSegmentSelectionType::Starred => write!(f, "{}", "Starred"),
            FitFieldSegmentSelectionType::Suggested => write!(f, "{}", "Suggested"),
            FitFieldSegmentSelectionType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSegmentSelectionType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSegmentSelectionType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSegmentSelectionType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSegmentSelectionType::from(v)),
            Err(_) => Ok(FitFieldSegmentSelectionType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSegmentSelectionType);

impl From<u8> for FitFieldSegmentSelectionType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentSelectionType::Starred,
            1 => FitFieldSegmentSelectionType::Suggested,
            _ => FitFieldSegmentSelectionType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSourceType {
    // fit base type: enum
    Ant = 0,                // External device connected with ANT
    Antplus = 1,            // External device connected with ANT+
    Bluetooth = 2,          // External device connected with BT
    BluetoothLowEnergy = 3, // External device connected with BLE
    Wifi = 4,               // External device connected with Wifi
    Local = 5,              // Onboard device
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSourceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSourceType::Ant => write!(f, "{}", "Ant"),
            FitFieldSourceType::Antplus => write!(f, "{}", "Antplus"),
            FitFieldSourceType::Bluetooth => write!(f, "{}", "Bluetooth"),
            FitFieldSourceType::BluetoothLowEnergy => write!(f, "{}", "BluetoothLowEnergy"),
            FitFieldSourceType::Wifi => write!(f, "{}", "Wifi"),
            FitFieldSourceType::Local => write!(f, "{}", "Local"),
            FitFieldSourceType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSourceType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSourceType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSourceType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSourceType::from(v)),
            Err(_) => Ok(FitFieldSourceType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSourceType);

impl From<u8> for FitFieldSourceType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSourceType::Ant,
            1 => FitFieldSourceType::Antplus,
            2 => FitFieldSourceType::Bluetooth,
            3 => FitFieldSourceType::BluetoothLowEnergy,
            4 => FitFieldSourceType::Wifi,
            5 => FitFieldSourceType::Local,
            _ => FitFieldSourceType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLocalDeviceType {
    // fit base type: uint8
    LocalDeviceType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLocalDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLocalDeviceType::LocalDeviceType(x) => {
                write!(f, "{}({})", "LocalDeviceType", x)
            }
            FitFieldLocalDeviceType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLocalDeviceType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLocalDeviceType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLocalDeviceType> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLocalDeviceType::InvalidFieldValue),
            Ok(v) => match v {
                v => Ok(FitFieldLocalDeviceType::LocalDeviceType(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLocalDeviceType);

impl From<u8> for FitFieldLocalDeviceType {
    fn from(code: u8) -> Self {
        match code {
            _ => FitFieldLocalDeviceType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDisplayOrientation {
    // fit base type: enum
    Auto = 0, // automatic if the device supports it
    Portrait = 1,
    Landscape = 2,
    PortraitFlipped = 3,  // portrait mode but rotated 180 degrees
    LandscapeFlipped = 4, // landscape mode but rotated 180 degrees
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDisplayOrientation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDisplayOrientation::Auto => write!(f, "{}", "Auto"),
            FitFieldDisplayOrientation::Portrait => write!(f, "{}", "Portrait"),
            FitFieldDisplayOrientation::Landscape => write!(f, "{}", "Landscape"),
            FitFieldDisplayOrientation::PortraitFlipped => write!(f, "{}", "PortraitFlipped"),
            FitFieldDisplayOrientation::LandscapeFlipped => write!(f, "{}", "LandscapeFlipped"),
            FitFieldDisplayOrientation::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDisplayOrientation::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDisplayOrientation {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDisplayOrientation> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDisplayOrientation::from(v)),
            Err(_) => Ok(FitFieldDisplayOrientation::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDisplayOrientation);

impl From<u8> for FitFieldDisplayOrientation {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayOrientation::Auto,
            1 => FitFieldDisplayOrientation::Portrait,
            2 => FitFieldDisplayOrientation::Landscape,
            3 => FitFieldDisplayOrientation::PortraitFlipped,
            4 => FitFieldDisplayOrientation::LandscapeFlipped,
            _ => FitFieldDisplayOrientation::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWorkoutEquipment {
    // fit base type: enum
    None = 0,
    SwimFins = 1,
    SwimKickboard = 2,
    SwimPaddles = 3,
    SwimPullBuoy = 4,
    SwimSnorkel = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWorkoutEquipment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWorkoutEquipment::None => write!(f, "{}", "None"),
            FitFieldWorkoutEquipment::SwimFins => write!(f, "{}", "SwimFins"),
            FitFieldWorkoutEquipment::SwimKickboard => write!(f, "{}", "SwimKickboard"),
            FitFieldWorkoutEquipment::SwimPaddles => write!(f, "{}", "SwimPaddles"),
            FitFieldWorkoutEquipment::SwimPullBuoy => write!(f, "{}", "SwimPullBuoy"),
            FitFieldWorkoutEquipment::SwimSnorkel => write!(f, "{}", "SwimSnorkel"),
            FitFieldWorkoutEquipment::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWorkoutEquipment::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWorkoutEquipment {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWorkoutEquipment> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWorkoutEquipment::from(v)),
            Err(_) => Ok(FitFieldWorkoutEquipment::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWorkoutEquipment);

impl From<u8> for FitFieldWorkoutEquipment {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWorkoutEquipment::None,
            1 => FitFieldWorkoutEquipment::SwimFins,
            2 => FitFieldWorkoutEquipment::SwimKickboard,
            3 => FitFieldWorkoutEquipment::SwimPaddles,
            4 => FitFieldWorkoutEquipment::SwimPullBuoy,
            5 => FitFieldWorkoutEquipment::SwimSnorkel,
            _ => FitFieldWorkoutEquipment::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWatchfaceMode {
    // fit base type: enum
    Digital = 0,
    Analog = 1,
    ConnectIq = 2,
    Disabled = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWatchfaceMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWatchfaceMode::Digital => write!(f, "{}", "Digital"),
            FitFieldWatchfaceMode::Analog => write!(f, "{}", "Analog"),
            FitFieldWatchfaceMode::ConnectIq => write!(f, "{}", "ConnectIq"),
            FitFieldWatchfaceMode::Disabled => write!(f, "{}", "Disabled"),
            FitFieldWatchfaceMode::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWatchfaceMode::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWatchfaceMode {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWatchfaceMode> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWatchfaceMode::from(v)),
            Err(_) => Ok(FitFieldWatchfaceMode::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWatchfaceMode);

impl From<u8> for FitFieldWatchfaceMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWatchfaceMode::Digital,
            1 => FitFieldWatchfaceMode::Analog,
            2 => FitFieldWatchfaceMode::ConnectIq,
            3 => FitFieldWatchfaceMode::Disabled,
            _ => FitFieldWatchfaceMode::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDigitalWatchfaceLayout {
    // fit base type: enum
    Traditional = 0,
    Modern = 1,
    Bold = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDigitalWatchfaceLayout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDigitalWatchfaceLayout::Traditional => write!(f, "{}", "Traditional"),
            FitFieldDigitalWatchfaceLayout::Modern => write!(f, "{}", "Modern"),
            FitFieldDigitalWatchfaceLayout::Bold => write!(f, "{}", "Bold"),
            FitFieldDigitalWatchfaceLayout::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDigitalWatchfaceLayout::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDigitalWatchfaceLayout {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldDigitalWatchfaceLayout> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDigitalWatchfaceLayout::from(v)),
            Err(_) => Ok(FitFieldDigitalWatchfaceLayout::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDigitalWatchfaceLayout);

impl From<u8> for FitFieldDigitalWatchfaceLayout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDigitalWatchfaceLayout::Traditional,
            1 => FitFieldDigitalWatchfaceLayout::Modern,
            2 => FitFieldDigitalWatchfaceLayout::Bold,
            _ => FitFieldDigitalWatchfaceLayout::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAnalogWatchfaceLayout {
    // fit base type: enum
    Minimal = 0,
    Traditional = 1,
    Modern = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldAnalogWatchfaceLayout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAnalogWatchfaceLayout::Minimal => write!(f, "{}", "Minimal"),
            FitFieldAnalogWatchfaceLayout::Traditional => write!(f, "{}", "Traditional"),
            FitFieldAnalogWatchfaceLayout::Modern => write!(f, "{}", "Modern"),
            FitFieldAnalogWatchfaceLayout::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAnalogWatchfaceLayout::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAnalogWatchfaceLayout {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAnalogWatchfaceLayout> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldAnalogWatchfaceLayout::from(v)),
            Err(_) => Ok(FitFieldAnalogWatchfaceLayout::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldAnalogWatchfaceLayout);

impl From<u8> for FitFieldAnalogWatchfaceLayout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAnalogWatchfaceLayout::Minimal,
            1 => FitFieldAnalogWatchfaceLayout::Traditional,
            2 => FitFieldAnalogWatchfaceLayout::Modern,
            _ => FitFieldAnalogWatchfaceLayout::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldRiderPositionType {
    // fit base type: enum
    Seated = 0,
    Standing = 1,
    TransitionToSeated = 2,
    TransitionToStanding = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldRiderPositionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldRiderPositionType::Seated => write!(f, "{}", "Seated"),
            FitFieldRiderPositionType::Standing => write!(f, "{}", "Standing"),
            FitFieldRiderPositionType::TransitionToSeated => write!(f, "{}", "TransitionToSeated"),
            FitFieldRiderPositionType::TransitionToStanding => {
                write!(f, "{}", "TransitionToStanding")
            }
            FitFieldRiderPositionType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldRiderPositionType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldRiderPositionType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldRiderPositionType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldRiderPositionType::from(v)),
            Err(_) => Ok(FitFieldRiderPositionType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldRiderPositionType);

impl From<u8> for FitFieldRiderPositionType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldRiderPositionType::Seated,
            1 => FitFieldRiderPositionType::Standing,
            2 => FitFieldRiderPositionType::TransitionToSeated,
            3 => FitFieldRiderPositionType::TransitionToStanding,
            _ => FitFieldRiderPositionType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldPowerPhaseType {
    // fit base type: enum
    PowerPhaseStartAngle = 0,
    PowerPhaseEndAngle = 1,
    PowerPhaseArcLength = 2,
    PowerPhaseCenter = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldPowerPhaseType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldPowerPhaseType::PowerPhaseStartAngle => write!(f, "{}", "PowerPhaseStartAngle"),
            FitFieldPowerPhaseType::PowerPhaseEndAngle => write!(f, "{}", "PowerPhaseEndAngle"),
            FitFieldPowerPhaseType::PowerPhaseArcLength => write!(f, "{}", "PowerPhaseArcLength"),
            FitFieldPowerPhaseType::PowerPhaseCenter => write!(f, "{}", "PowerPhaseCenter"),
            FitFieldPowerPhaseType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldPowerPhaseType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldPowerPhaseType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldPowerPhaseType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldPowerPhaseType::from(v)),
            Err(_) => Ok(FitFieldPowerPhaseType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldPowerPhaseType);

impl From<u8> for FitFieldPowerPhaseType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldPowerPhaseType::PowerPhaseStartAngle,
            1 => FitFieldPowerPhaseType::PowerPhaseEndAngle,
            2 => FitFieldPowerPhaseType::PowerPhaseArcLength,
            3 => FitFieldPowerPhaseType::PowerPhaseCenter,
            _ => FitFieldPowerPhaseType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCameraEventType {
    // fit base type: enum
    VideoStart = 0, // Start of video recording
    VideoSplit = 1, // Mark of video file split (end of one file, beginning of the other)
    VideoEnd = 2,   // End of video recording
    PhotoTaken = 3, // Still photo taken
    VideoSecondStreamStart = 4,
    VideoSecondStreamSplit = 5,
    VideoSecondStreamEnd = 6,
    VideoSplitStart = 7, // Mark of video file split start
    VideoSecondStreamSplitStart = 8,
    VideoPause = 11, // Mark when a video recording has been paused
    VideoSecondStreamPause = 12,
    VideoResume = 13, // Mark when a video recording has been resumed
    VideoSecondStreamResume = 14,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldCameraEventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCameraEventType::VideoStart => write!(f, "{}", "VideoStart"),
            FitFieldCameraEventType::VideoSplit => write!(f, "{}", "VideoSplit"),
            FitFieldCameraEventType::VideoEnd => write!(f, "{}", "VideoEnd"),
            FitFieldCameraEventType::PhotoTaken => write!(f, "{}", "PhotoTaken"),
            FitFieldCameraEventType::VideoSecondStreamStart => {
                write!(f, "{}", "VideoSecondStreamStart")
            }
            FitFieldCameraEventType::VideoSecondStreamSplit => {
                write!(f, "{}", "VideoSecondStreamSplit")
            }
            FitFieldCameraEventType::VideoSecondStreamEnd => {
                write!(f, "{}", "VideoSecondStreamEnd")
            }
            FitFieldCameraEventType::VideoSplitStart => write!(f, "{}", "VideoSplitStart"),
            FitFieldCameraEventType::VideoSecondStreamSplitStart => {
                write!(f, "{}", "VideoSecondStreamSplitStart")
            }
            FitFieldCameraEventType::VideoPause => write!(f, "{}", "VideoPause"),
            FitFieldCameraEventType::VideoSecondStreamPause => {
                write!(f, "{}", "VideoSecondStreamPause")
            }
            FitFieldCameraEventType::VideoResume => write!(f, "{}", "VideoResume"),
            FitFieldCameraEventType::VideoSecondStreamResume => {
                write!(f, "{}", "VideoSecondStreamResume")
            }
            FitFieldCameraEventType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCameraEventType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCameraEventType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCameraEventType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldCameraEventType::from(v)),
            Err(_) => Ok(FitFieldCameraEventType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldCameraEventType);

impl From<u8> for FitFieldCameraEventType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldCameraEventType::VideoStart,
            1 => FitFieldCameraEventType::VideoSplit,
            2 => FitFieldCameraEventType::VideoEnd,
            3 => FitFieldCameraEventType::PhotoTaken,
            4 => FitFieldCameraEventType::VideoSecondStreamStart,
            5 => FitFieldCameraEventType::VideoSecondStreamSplit,
            6 => FitFieldCameraEventType::VideoSecondStreamEnd,
            7 => FitFieldCameraEventType::VideoSplitStart,
            8 => FitFieldCameraEventType::VideoSecondStreamSplitStart,
            11 => FitFieldCameraEventType::VideoPause,
            12 => FitFieldCameraEventType::VideoSecondStreamPause,
            13 => FitFieldCameraEventType::VideoResume,
            14 => FitFieldCameraEventType::VideoSecondStreamResume,
            _ => FitFieldCameraEventType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSensorType {
    // fit base type: enum
    Accelerometer = 0,
    Gyroscope = 1,
    Compass = 2, // Magnetometer
    Barometer = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldSensorType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSensorType::Accelerometer => write!(f, "{}", "Accelerometer"),
            FitFieldSensorType::Gyroscope => write!(f, "{}", "Gyroscope"),
            FitFieldSensorType::Compass => write!(f, "{}", "Compass"),
            FitFieldSensorType::Barometer => write!(f, "{}", "Barometer"),
            FitFieldSensorType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSensorType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSensorType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSensorType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldSensorType::from(v)),
            Err(_) => Ok(FitFieldSensorType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldSensorType);

impl From<u8> for FitFieldSensorType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSensorType::Accelerometer,
            1 => FitFieldSensorType::Gyroscope,
            2 => FitFieldSensorType::Compass,
            3 => FitFieldSensorType::Barometer,
            _ => FitFieldSensorType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBikeLightNetworkConfigType {
    // fit base type: enum
    Auto = 0,
    Individual = 4,
    HighVisibility = 5,
    Trail = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldBikeLightNetworkConfigType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBikeLightNetworkConfigType::Auto => write!(f, "{}", "Auto"),
            FitFieldBikeLightNetworkConfigType::Individual => write!(f, "{}", "Individual"),
            FitFieldBikeLightNetworkConfigType::HighVisibility => write!(f, "{}", "HighVisibility"),
            FitFieldBikeLightNetworkConfigType::Trail => write!(f, "{}", "Trail"),
            FitFieldBikeLightNetworkConfigType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBikeLightNetworkConfigType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBikeLightNetworkConfigType {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldBikeLightNetworkConfigType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldBikeLightNetworkConfigType::from(v)),
            Err(_) => Ok(FitFieldBikeLightNetworkConfigType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldBikeLightNetworkConfigType);

impl From<u8> for FitFieldBikeLightNetworkConfigType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBikeLightNetworkConfigType::Auto,
            4 => FitFieldBikeLightNetworkConfigType::Individual,
            5 => FitFieldBikeLightNetworkConfigType::HighVisibility,
            6 => FitFieldBikeLightNetworkConfigType::Trail,
            _ => FitFieldBikeLightNetworkConfigType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCommTimeoutType {
    // fit base type: uint16
    WildcardPairingTimeout, // 0  Timeout pairing to any device
    PairingTimeout,         // 1  Timeout pairing to previously paired device
    ConnectionLost,         // 2  Temporary loss of communications
    ConnectionTimeout,      // 3  Connection closed due to extended bad communications
    CommTimeoutType(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCommTimeoutType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCommTimeoutType::WildcardPairingTimeout => {
                write!(f, "{}", "WildcardPairingTimeout")
            }
            FitFieldCommTimeoutType::PairingTimeout => write!(f, "{}", "PairingTimeout"),
            FitFieldCommTimeoutType::ConnectionLost => write!(f, "{}", "ConnectionLost"),
            FitFieldCommTimeoutType::ConnectionTimeout => write!(f, "{}", "ConnectionTimeout"),
            FitFieldCommTimeoutType::CommTimeoutType(x) => {
                write!(f, "{}({})", "CommTimeoutType", x)
            }
            FitFieldCommTimeoutType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCommTimeoutType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCommTimeoutType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCommTimeoutType> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCommTimeoutType::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCommTimeoutType::from(v)),
                1 => Ok(FitFieldCommTimeoutType::from(v)),
                2 => Ok(FitFieldCommTimeoutType::from(v)),
                3 => Ok(FitFieldCommTimeoutType::from(v)),
                v => Ok(FitFieldCommTimeoutType::CommTimeoutType(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCommTimeoutType);

impl From<u16> for FitFieldCommTimeoutType {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCommTimeoutType::WildcardPairingTimeout,
            1 => FitFieldCommTimeoutType::PairingTimeout,
            2 => FitFieldCommTimeoutType::ConnectionLost,
            3 => FitFieldCommTimeoutType::ConnectionTimeout,
            _ => FitFieldCommTimeoutType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCameraOrientationType {
    // fit base type: enum
    CameraOrientation0 = 0,
    CameraOrientation90 = 1,
    CameraOrientation180 = 2,
    CameraOrientation270 = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldCameraOrientationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCameraOrientationType::CameraOrientation0 => {
                write!(f, "{}", "CameraOrientation0")
            }
            FitFieldCameraOrientationType::CameraOrientation90 => {
                write!(f, "{}", "CameraOrientation90")
            }
            FitFieldCameraOrientationType::CameraOrientation180 => {
                write!(f, "{}", "CameraOrientation180")
            }
            FitFieldCameraOrientationType::CameraOrientation270 => {
                write!(f, "{}", "CameraOrientation270")
            }
            FitFieldCameraOrientationType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCameraOrientationType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCameraOrientationType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCameraOrientationType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldCameraOrientationType::from(v)),
            Err(_) => Ok(FitFieldCameraOrientationType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldCameraOrientationType);

impl From<u8> for FitFieldCameraOrientationType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldCameraOrientationType::CameraOrientation0,
            1 => FitFieldCameraOrientationType::CameraOrientation90,
            2 => FitFieldCameraOrientationType::CameraOrientation180,
            3 => FitFieldCameraOrientationType::CameraOrientation270,
            _ => FitFieldCameraOrientationType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAttitudeStage {
    // fit base type: enum
    Failed = 0,
    Aligning = 1,
    Degraded = 2,
    Valid = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldAttitudeStage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAttitudeStage::Failed => write!(f, "{}", "Failed"),
            FitFieldAttitudeStage::Aligning => write!(f, "{}", "Aligning"),
            FitFieldAttitudeStage::Degraded => write!(f, "{}", "Degraded"),
            FitFieldAttitudeStage::Valid => write!(f, "{}", "Valid"),
            FitFieldAttitudeStage::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAttitudeStage::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAttitudeStage {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAttitudeStage> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldAttitudeStage::from(v)),
            Err(_) => Ok(FitFieldAttitudeStage::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldAttitudeStage);

impl From<u8> for FitFieldAttitudeStage {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAttitudeStage::Failed,
            1 => FitFieldAttitudeStage::Aligning,
            2 => FitFieldAttitudeStage::Degraded,
            3 => FitFieldAttitudeStage::Valid,
            _ => FitFieldAttitudeStage::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAttitudeValidity {
    // fit base type: uint16
    TrackAngleHeadingValid, // 1
    PitchValid,             // 2
    RollValid,              // 4
    LateralBodyAccelValid,  // 8
    NormalBodyAccelValid,   // 16
    TurnRateValid,          // 32
    HwFail,                 // 64
    MagInvalid,             // 128
    NoGps,                  // 256
    GpsInvalid,             // 512
    SolutionCoasting,       // 1024
    TrueTrackAngle,         // 2048
    MagneticHeading,        // 4096
    AttitudeValidity(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldAttitudeValidity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAttitudeValidity::TrackAngleHeadingValid => {
                write!(f, "{}", "TrackAngleHeadingValid")
            }
            FitFieldAttitudeValidity::PitchValid => write!(f, "{}", "PitchValid"),
            FitFieldAttitudeValidity::RollValid => write!(f, "{}", "RollValid"),
            FitFieldAttitudeValidity::LateralBodyAccelValid => {
                write!(f, "{}", "LateralBodyAccelValid")
            }
            FitFieldAttitudeValidity::NormalBodyAccelValid => {
                write!(f, "{}", "NormalBodyAccelValid")
            }
            FitFieldAttitudeValidity::TurnRateValid => write!(f, "{}", "TurnRateValid"),
            FitFieldAttitudeValidity::HwFail => write!(f, "{}", "HwFail"),
            FitFieldAttitudeValidity::MagInvalid => write!(f, "{}", "MagInvalid"),
            FitFieldAttitudeValidity::NoGps => write!(f, "{}", "NoGps"),
            FitFieldAttitudeValidity::GpsInvalid => write!(f, "{}", "GpsInvalid"),
            FitFieldAttitudeValidity::SolutionCoasting => write!(f, "{}", "SolutionCoasting"),
            FitFieldAttitudeValidity::TrueTrackAngle => write!(f, "{}", "TrueTrackAngle"),
            FitFieldAttitudeValidity::MagneticHeading => write!(f, "{}", "MagneticHeading"),
            FitFieldAttitudeValidity::AttitudeValidity(x) => {
                write!(f, "{}({})", "AttitudeValidity", x)
            }
            FitFieldAttitudeValidity::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAttitudeValidity::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAttitudeValidity {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAttitudeValidity> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldAttitudeValidity::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldAttitudeValidity::from(v)),
                2 => Ok(FitFieldAttitudeValidity::from(v)),
                4 => Ok(FitFieldAttitudeValidity::from(v)),
                8 => Ok(FitFieldAttitudeValidity::from(v)),
                16 => Ok(FitFieldAttitudeValidity::from(v)),
                32 => Ok(FitFieldAttitudeValidity::from(v)),
                64 => Ok(FitFieldAttitudeValidity::from(v)),
                128 => Ok(FitFieldAttitudeValidity::from(v)),
                256 => Ok(FitFieldAttitudeValidity::from(v)),
                512 => Ok(FitFieldAttitudeValidity::from(v)),
                1024 => Ok(FitFieldAttitudeValidity::from(v)),
                2048 => Ok(FitFieldAttitudeValidity::from(v)),
                4096 => Ok(FitFieldAttitudeValidity::from(v)),
                v => Ok(FitFieldAttitudeValidity::AttitudeValidity(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldAttitudeValidity);

impl From<u16> for FitFieldAttitudeValidity {
    fn from(code: u16) -> Self {
        match code {
            1 => FitFieldAttitudeValidity::TrackAngleHeadingValid,
            2 => FitFieldAttitudeValidity::PitchValid,
            4 => FitFieldAttitudeValidity::RollValid,
            8 => FitFieldAttitudeValidity::LateralBodyAccelValid,
            16 => FitFieldAttitudeValidity::NormalBodyAccelValid,
            32 => FitFieldAttitudeValidity::TurnRateValid,
            64 => FitFieldAttitudeValidity::HwFail,
            128 => FitFieldAttitudeValidity::MagInvalid,
            256 => FitFieldAttitudeValidity::NoGps,
            512 => FitFieldAttitudeValidity::GpsInvalid,
            1024 => FitFieldAttitudeValidity::SolutionCoasting,
            2048 => FitFieldAttitudeValidity::TrueTrackAngle,
            4096 => FitFieldAttitudeValidity::MagneticHeading,
            _ => FitFieldAttitudeValidity::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAutoSyncFrequency {
    // fit base type: enum
    Never = 0,
    Occasionally = 1,
    Frequent = 2,
    OnceADay = 3,
    Remote = 4,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldAutoSyncFrequency {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAutoSyncFrequency::Never => write!(f, "{}", "Never"),
            FitFieldAutoSyncFrequency::Occasionally => write!(f, "{}", "Occasionally"),
            FitFieldAutoSyncFrequency::Frequent => write!(f, "{}", "Frequent"),
            FitFieldAutoSyncFrequency::OnceADay => write!(f, "{}", "OnceADay"),
            FitFieldAutoSyncFrequency::Remote => write!(f, "{}", "Remote"),
            FitFieldAutoSyncFrequency::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAutoSyncFrequency::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAutoSyncFrequency {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAutoSyncFrequency> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldAutoSyncFrequency::from(v)),
            Err(_) => Ok(FitFieldAutoSyncFrequency::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldAutoSyncFrequency);

impl From<u8> for FitFieldAutoSyncFrequency {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAutoSyncFrequency::Never,
            1 => FitFieldAutoSyncFrequency::Occasionally,
            2 => FitFieldAutoSyncFrequency::Frequent,
            3 => FitFieldAutoSyncFrequency::OnceADay,
            4 => FitFieldAutoSyncFrequency::Remote,
            _ => FitFieldAutoSyncFrequency::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldExdLayout {
    // fit base type: enum
    FullScreen = 0,
    HalfVertical = 1,
    HalfHorizontal = 2,
    HalfVerticalRightSplit = 3,
    HalfHorizontalBottomSplit = 4,
    FullQuarterSplit = 5,
    HalfVerticalLeftSplit = 6,
    HalfHorizontalTopSplit = 7,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldExdLayout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldExdLayout::FullScreen => write!(f, "{}", "FullScreen"),
            FitFieldExdLayout::HalfVertical => write!(f, "{}", "HalfVertical"),
            FitFieldExdLayout::HalfHorizontal => write!(f, "{}", "HalfHorizontal"),
            FitFieldExdLayout::HalfVerticalRightSplit => write!(f, "{}", "HalfVerticalRightSplit"),
            FitFieldExdLayout::HalfHorizontalBottomSplit => {
                write!(f, "{}", "HalfHorizontalBottomSplit")
            }
            FitFieldExdLayout::FullQuarterSplit => write!(f, "{}", "FullQuarterSplit"),
            FitFieldExdLayout::HalfVerticalLeftSplit => write!(f, "{}", "HalfVerticalLeftSplit"),
            FitFieldExdLayout::HalfHorizontalTopSplit => write!(f, "{}", "HalfHorizontalTopSplit"),
            FitFieldExdLayout::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldExdLayout::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldExdLayout {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldExdLayout> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldExdLayout::from(v)),
            Err(_) => Ok(FitFieldExdLayout::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldExdLayout);

impl From<u8> for FitFieldExdLayout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdLayout::FullScreen,
            1 => FitFieldExdLayout::HalfVertical,
            2 => FitFieldExdLayout::HalfHorizontal,
            3 => FitFieldExdLayout::HalfVerticalRightSplit,
            4 => FitFieldExdLayout::HalfHorizontalBottomSplit,
            5 => FitFieldExdLayout::FullQuarterSplit,
            6 => FitFieldExdLayout::HalfVerticalLeftSplit,
            7 => FitFieldExdLayout::HalfHorizontalTopSplit,
            _ => FitFieldExdLayout::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldExdDisplayType {
    // fit base type: enum
    Numerical = 0,
    Simple = 1,
    Graph = 2,
    Bar = 3,
    CircleGraph = 4,
    VirtualPartner = 5,
    Balance = 6,
    StringList = 7,
    String = 8,
    SimpleDynamicIcon = 9,
    Gauge = 10,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldExdDisplayType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldExdDisplayType::Numerical => write!(f, "{}", "Numerical"),
            FitFieldExdDisplayType::Simple => write!(f, "{}", "Simple"),
            FitFieldExdDisplayType::Graph => write!(f, "{}", "Graph"),
            FitFieldExdDisplayType::Bar => write!(f, "{}", "Bar"),
            FitFieldExdDisplayType::CircleGraph => write!(f, "{}", "CircleGraph"),
            FitFieldExdDisplayType::VirtualPartner => write!(f, "{}", "VirtualPartner"),
            FitFieldExdDisplayType::Balance => write!(f, "{}", "Balance"),
            FitFieldExdDisplayType::StringList => write!(f, "{}", "StringList"),
            FitFieldExdDisplayType::String => write!(f, "{}", "String"),
            FitFieldExdDisplayType::SimpleDynamicIcon => write!(f, "{}", "SimpleDynamicIcon"),
            FitFieldExdDisplayType::Gauge => write!(f, "{}", "Gauge"),
            FitFieldExdDisplayType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldExdDisplayType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldExdDisplayType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldExdDisplayType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldExdDisplayType::from(v)),
            Err(_) => Ok(FitFieldExdDisplayType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldExdDisplayType);

impl From<u8> for FitFieldExdDisplayType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdDisplayType::Numerical,
            1 => FitFieldExdDisplayType::Simple,
            2 => FitFieldExdDisplayType::Graph,
            3 => FitFieldExdDisplayType::Bar,
            4 => FitFieldExdDisplayType::CircleGraph,
            5 => FitFieldExdDisplayType::VirtualPartner,
            6 => FitFieldExdDisplayType::Balance,
            7 => FitFieldExdDisplayType::StringList,
            8 => FitFieldExdDisplayType::String,
            9 => FitFieldExdDisplayType::SimpleDynamicIcon,
            10 => FitFieldExdDisplayType::Gauge,
            _ => FitFieldExdDisplayType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldExdDataUnits {
    // fit base type: enum
    NoUnits = 0,
    Laps = 1,
    MilesPerHour = 2,
    KilometersPerHour = 3,
    FeetPerHour = 4,
    MetersPerHour = 5,
    DegreesCelsius = 6,
    DegreesFarenheit = 7,
    Zone = 8,
    Gear = 9,
    Rpm = 10,
    Bpm = 11,
    Degrees = 12,
    Millimeters = 13,
    Meters = 14,
    Kilometers = 15,
    Feet = 16,
    Yards = 17,
    Kilofeet = 18,
    Miles = 19,
    Time = 20,
    EnumTurnType = 21,
    Percent = 22,
    Watts = 23,
    WattsPerKilogram = 24,
    EnumBatteryStatus = 25,
    EnumBikeLightBeamAngleMode = 26,
    EnumBikeLightBatteryStatus = 27,
    EnumBikeLightNetworkConfigType = 28,
    Lights = 29,
    Seconds = 30,
    Minutes = 31,
    Hours = 32,
    Calories = 33,
    Kilojoules = 34,
    Milliseconds = 35,
    SecondPerMile = 36,
    SecondPerKilometer = 37,
    Centimeter = 38,
    EnumCoursePoint = 39,
    Bradians = 40,
    EnumSport = 41,
    InchesHg = 42,
    MmHg = 43,
    Mbars = 44,
    HectoPascals = 45,
    FeetPerMin = 46,
    MetersPerMin = 47,
    MetersPerSec = 48,
    EightCardinal = 49,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldExdDataUnits {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldExdDataUnits::NoUnits => write!(f, "{}", "NoUnits"),
            FitFieldExdDataUnits::Laps => write!(f, "{}", "Laps"),
            FitFieldExdDataUnits::MilesPerHour => write!(f, "{}", "MilesPerHour"),
            FitFieldExdDataUnits::KilometersPerHour => write!(f, "{}", "KilometersPerHour"),
            FitFieldExdDataUnits::FeetPerHour => write!(f, "{}", "FeetPerHour"),
            FitFieldExdDataUnits::MetersPerHour => write!(f, "{}", "MetersPerHour"),
            FitFieldExdDataUnits::DegreesCelsius => write!(f, "{}", "DegreesCelsius"),
            FitFieldExdDataUnits::DegreesFarenheit => write!(f, "{}", "DegreesFarenheit"),
            FitFieldExdDataUnits::Zone => write!(f, "{}", "Zone"),
            FitFieldExdDataUnits::Gear => write!(f, "{}", "Gear"),
            FitFieldExdDataUnits::Rpm => write!(f, "{}", "Rpm"),
            FitFieldExdDataUnits::Bpm => write!(f, "{}", "Bpm"),
            FitFieldExdDataUnits::Degrees => write!(f, "{}", "Degrees"),
            FitFieldExdDataUnits::Millimeters => write!(f, "{}", "Millimeters"),
            FitFieldExdDataUnits::Meters => write!(f, "{}", "Meters"),
            FitFieldExdDataUnits::Kilometers => write!(f, "{}", "Kilometers"),
            FitFieldExdDataUnits::Feet => write!(f, "{}", "Feet"),
            FitFieldExdDataUnits::Yards => write!(f, "{}", "Yards"),
            FitFieldExdDataUnits::Kilofeet => write!(f, "{}", "Kilofeet"),
            FitFieldExdDataUnits::Miles => write!(f, "{}", "Miles"),
            FitFieldExdDataUnits::Time => write!(f, "{}", "Time"),
            FitFieldExdDataUnits::EnumTurnType => write!(f, "{}", "EnumTurnType"),
            FitFieldExdDataUnits::Percent => write!(f, "{}", "Percent"),
            FitFieldExdDataUnits::Watts => write!(f, "{}", "Watts"),
            FitFieldExdDataUnits::WattsPerKilogram => write!(f, "{}", "WattsPerKilogram"),
            FitFieldExdDataUnits::EnumBatteryStatus => write!(f, "{}", "EnumBatteryStatus"),
            FitFieldExdDataUnits::EnumBikeLightBeamAngleMode => {
                write!(f, "{}", "EnumBikeLightBeamAngleMode")
            }
            FitFieldExdDataUnits::EnumBikeLightBatteryStatus => {
                write!(f, "{}", "EnumBikeLightBatteryStatus")
            }
            FitFieldExdDataUnits::EnumBikeLightNetworkConfigType => {
                write!(f, "{}", "EnumBikeLightNetworkConfigType")
            }
            FitFieldExdDataUnits::Lights => write!(f, "{}", "Lights"),
            FitFieldExdDataUnits::Seconds => write!(f, "{}", "Seconds"),
            FitFieldExdDataUnits::Minutes => write!(f, "{}", "Minutes"),
            FitFieldExdDataUnits::Hours => write!(f, "{}", "Hours"),
            FitFieldExdDataUnits::Calories => write!(f, "{}", "Calories"),
            FitFieldExdDataUnits::Kilojoules => write!(f, "{}", "Kilojoules"),
            FitFieldExdDataUnits::Milliseconds => write!(f, "{}", "Milliseconds"),
            FitFieldExdDataUnits::SecondPerMile => write!(f, "{}", "SecondPerMile"),
            FitFieldExdDataUnits::SecondPerKilometer => write!(f, "{}", "SecondPerKilometer"),
            FitFieldExdDataUnits::Centimeter => write!(f, "{}", "Centimeter"),
            FitFieldExdDataUnits::EnumCoursePoint => write!(f, "{}", "EnumCoursePoint"),
            FitFieldExdDataUnits::Bradians => write!(f, "{}", "Bradians"),
            FitFieldExdDataUnits::EnumSport => write!(f, "{}", "EnumSport"),
            FitFieldExdDataUnits::InchesHg => write!(f, "{}", "InchesHg"),
            FitFieldExdDataUnits::MmHg => write!(f, "{}", "MmHg"),
            FitFieldExdDataUnits::Mbars => write!(f, "{}", "Mbars"),
            FitFieldExdDataUnits::HectoPascals => write!(f, "{}", "HectoPascals"),
            FitFieldExdDataUnits::FeetPerMin => write!(f, "{}", "FeetPerMin"),
            FitFieldExdDataUnits::MetersPerMin => write!(f, "{}", "MetersPerMin"),
            FitFieldExdDataUnits::MetersPerSec => write!(f, "{}", "MetersPerSec"),
            FitFieldExdDataUnits::EightCardinal => write!(f, "{}", "EightCardinal"),
            FitFieldExdDataUnits::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldExdDataUnits::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldExdDataUnits {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldExdDataUnits> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldExdDataUnits::from(v)),
            Err(_) => Ok(FitFieldExdDataUnits::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldExdDataUnits);

impl From<u8> for FitFieldExdDataUnits {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdDataUnits::NoUnits,
            1 => FitFieldExdDataUnits::Laps,
            2 => FitFieldExdDataUnits::MilesPerHour,
            3 => FitFieldExdDataUnits::KilometersPerHour,
            4 => FitFieldExdDataUnits::FeetPerHour,
            5 => FitFieldExdDataUnits::MetersPerHour,
            6 => FitFieldExdDataUnits::DegreesCelsius,
            7 => FitFieldExdDataUnits::DegreesFarenheit,
            8 => FitFieldExdDataUnits::Zone,
            9 => FitFieldExdDataUnits::Gear,
            10 => FitFieldExdDataUnits::Rpm,
            11 => FitFieldExdDataUnits::Bpm,
            12 => FitFieldExdDataUnits::Degrees,
            13 => FitFieldExdDataUnits::Millimeters,
            14 => FitFieldExdDataUnits::Meters,
            15 => FitFieldExdDataUnits::Kilometers,
            16 => FitFieldExdDataUnits::Feet,
            17 => FitFieldExdDataUnits::Yards,
            18 => FitFieldExdDataUnits::Kilofeet,
            19 => FitFieldExdDataUnits::Miles,
            20 => FitFieldExdDataUnits::Time,
            21 => FitFieldExdDataUnits::EnumTurnType,
            22 => FitFieldExdDataUnits::Percent,
            23 => FitFieldExdDataUnits::Watts,
            24 => FitFieldExdDataUnits::WattsPerKilogram,
            25 => FitFieldExdDataUnits::EnumBatteryStatus,
            26 => FitFieldExdDataUnits::EnumBikeLightBeamAngleMode,
            27 => FitFieldExdDataUnits::EnumBikeLightBatteryStatus,
            28 => FitFieldExdDataUnits::EnumBikeLightNetworkConfigType,
            29 => FitFieldExdDataUnits::Lights,
            30 => FitFieldExdDataUnits::Seconds,
            31 => FitFieldExdDataUnits::Minutes,
            32 => FitFieldExdDataUnits::Hours,
            33 => FitFieldExdDataUnits::Calories,
            34 => FitFieldExdDataUnits::Kilojoules,
            35 => FitFieldExdDataUnits::Milliseconds,
            36 => FitFieldExdDataUnits::SecondPerMile,
            37 => FitFieldExdDataUnits::SecondPerKilometer,
            38 => FitFieldExdDataUnits::Centimeter,
            39 => FitFieldExdDataUnits::EnumCoursePoint,
            40 => FitFieldExdDataUnits::Bradians,
            41 => FitFieldExdDataUnits::EnumSport,
            42 => FitFieldExdDataUnits::InchesHg,
            43 => FitFieldExdDataUnits::MmHg,
            44 => FitFieldExdDataUnits::Mbars,
            45 => FitFieldExdDataUnits::HectoPascals,
            46 => FitFieldExdDataUnits::FeetPerMin,
            47 => FitFieldExdDataUnits::MetersPerMin,
            48 => FitFieldExdDataUnits::MetersPerSec,
            49 => FitFieldExdDataUnits::EightCardinal,
            _ => FitFieldExdDataUnits::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldExdQualifiers {
    // fit base type: enum
    NoQualifier = 0,
    Instantaneous = 1,
    Average = 2,
    Lap = 3,
    Maximum = 4,
    MaximumAverage = 5,
    MaximumLap = 6,
    LastLap = 7,
    AverageLap = 8,
    ToDestination = 9,
    ToGo = 10,
    ToNext = 11,
    NextCoursePoint = 12,
    Total = 13,
    ThreeSecondAverage = 14,
    TenSecondAverage = 15,
    ThirtySecondAverage = 16,
    PercentMaximum = 17,
    PercentMaximumAverage = 18,
    LapPercentMaximum = 19,
    Elapsed = 20,
    Sunrise = 21,
    Sunset = 22,
    ComparedToVirtualPartner = 23,
    Maximum24h = 24,
    Minimum24h = 25,
    Minimum = 26,
    First = 27,
    Second = 28,
    Third = 29,
    Shifter = 30,
    LastSport = 31,
    Moving = 32,
    Stopped = 33,
    EstimatedTotal = 34,
    Zone9 = 242,
    Zone8 = 243,
    Zone7 = 244,
    Zone6 = 245,
    Zone5 = 246,
    Zone4 = 247,
    Zone3 = 248,
    Zone2 = 249,
    Zone1 = 250,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldExdQualifiers {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldExdQualifiers::NoQualifier => write!(f, "{}", "NoQualifier"),
            FitFieldExdQualifiers::Instantaneous => write!(f, "{}", "Instantaneous"),
            FitFieldExdQualifiers::Average => write!(f, "{}", "Average"),
            FitFieldExdQualifiers::Lap => write!(f, "{}", "Lap"),
            FitFieldExdQualifiers::Maximum => write!(f, "{}", "Maximum"),
            FitFieldExdQualifiers::MaximumAverage => write!(f, "{}", "MaximumAverage"),
            FitFieldExdQualifiers::MaximumLap => write!(f, "{}", "MaximumLap"),
            FitFieldExdQualifiers::LastLap => write!(f, "{}", "LastLap"),
            FitFieldExdQualifiers::AverageLap => write!(f, "{}", "AverageLap"),
            FitFieldExdQualifiers::ToDestination => write!(f, "{}", "ToDestination"),
            FitFieldExdQualifiers::ToGo => write!(f, "{}", "ToGo"),
            FitFieldExdQualifiers::ToNext => write!(f, "{}", "ToNext"),
            FitFieldExdQualifiers::NextCoursePoint => write!(f, "{}", "NextCoursePoint"),
            FitFieldExdQualifiers::Total => write!(f, "{}", "Total"),
            FitFieldExdQualifiers::ThreeSecondAverage => write!(f, "{}", "ThreeSecondAverage"),
            FitFieldExdQualifiers::TenSecondAverage => write!(f, "{}", "TenSecondAverage"),
            FitFieldExdQualifiers::ThirtySecondAverage => write!(f, "{}", "ThirtySecondAverage"),
            FitFieldExdQualifiers::PercentMaximum => write!(f, "{}", "PercentMaximum"),
            FitFieldExdQualifiers::PercentMaximumAverage => {
                write!(f, "{}", "PercentMaximumAverage")
            }
            FitFieldExdQualifiers::LapPercentMaximum => write!(f, "{}", "LapPercentMaximum"),
            FitFieldExdQualifiers::Elapsed => write!(f, "{}", "Elapsed"),
            FitFieldExdQualifiers::Sunrise => write!(f, "{}", "Sunrise"),
            FitFieldExdQualifiers::Sunset => write!(f, "{}", "Sunset"),
            FitFieldExdQualifiers::ComparedToVirtualPartner => {
                write!(f, "{}", "ComparedToVirtualPartner")
            }
            FitFieldExdQualifiers::Maximum24h => write!(f, "{}", "Maximum24h"),
            FitFieldExdQualifiers::Minimum24h => write!(f, "{}", "Minimum24h"),
            FitFieldExdQualifiers::Minimum => write!(f, "{}", "Minimum"),
            FitFieldExdQualifiers::First => write!(f, "{}", "First"),
            FitFieldExdQualifiers::Second => write!(f, "{}", "Second"),
            FitFieldExdQualifiers::Third => write!(f, "{}", "Third"),
            FitFieldExdQualifiers::Shifter => write!(f, "{}", "Shifter"),
            FitFieldExdQualifiers::LastSport => write!(f, "{}", "LastSport"),
            FitFieldExdQualifiers::Moving => write!(f, "{}", "Moving"),
            FitFieldExdQualifiers::Stopped => write!(f, "{}", "Stopped"),
            FitFieldExdQualifiers::EstimatedTotal => write!(f, "{}", "EstimatedTotal"),
            FitFieldExdQualifiers::Zone9 => write!(f, "{}", "Zone9"),
            FitFieldExdQualifiers::Zone8 => write!(f, "{}", "Zone8"),
            FitFieldExdQualifiers::Zone7 => write!(f, "{}", "Zone7"),
            FitFieldExdQualifiers::Zone6 => write!(f, "{}", "Zone6"),
            FitFieldExdQualifiers::Zone5 => write!(f, "{}", "Zone5"),
            FitFieldExdQualifiers::Zone4 => write!(f, "{}", "Zone4"),
            FitFieldExdQualifiers::Zone3 => write!(f, "{}", "Zone3"),
            FitFieldExdQualifiers::Zone2 => write!(f, "{}", "Zone2"),
            FitFieldExdQualifiers::Zone1 => write!(f, "{}", "Zone1"),
            FitFieldExdQualifiers::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldExdQualifiers::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldExdQualifiers {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldExdQualifiers> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldExdQualifiers::from(v)),
            Err(_) => Ok(FitFieldExdQualifiers::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldExdQualifiers);

impl From<u8> for FitFieldExdQualifiers {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdQualifiers::NoQualifier,
            1 => FitFieldExdQualifiers::Instantaneous,
            2 => FitFieldExdQualifiers::Average,
            3 => FitFieldExdQualifiers::Lap,
            4 => FitFieldExdQualifiers::Maximum,
            5 => FitFieldExdQualifiers::MaximumAverage,
            6 => FitFieldExdQualifiers::MaximumLap,
            7 => FitFieldExdQualifiers::LastLap,
            8 => FitFieldExdQualifiers::AverageLap,
            9 => FitFieldExdQualifiers::ToDestination,
            10 => FitFieldExdQualifiers::ToGo,
            11 => FitFieldExdQualifiers::ToNext,
            12 => FitFieldExdQualifiers::NextCoursePoint,
            13 => FitFieldExdQualifiers::Total,
            14 => FitFieldExdQualifiers::ThreeSecondAverage,
            15 => FitFieldExdQualifiers::TenSecondAverage,
            16 => FitFieldExdQualifiers::ThirtySecondAverage,
            17 => FitFieldExdQualifiers::PercentMaximum,
            18 => FitFieldExdQualifiers::PercentMaximumAverage,
            19 => FitFieldExdQualifiers::LapPercentMaximum,
            20 => FitFieldExdQualifiers::Elapsed,
            21 => FitFieldExdQualifiers::Sunrise,
            22 => FitFieldExdQualifiers::Sunset,
            23 => FitFieldExdQualifiers::ComparedToVirtualPartner,
            24 => FitFieldExdQualifiers::Maximum24h,
            25 => FitFieldExdQualifiers::Minimum24h,
            26 => FitFieldExdQualifiers::Minimum,
            27 => FitFieldExdQualifiers::First,
            28 => FitFieldExdQualifiers::Second,
            29 => FitFieldExdQualifiers::Third,
            30 => FitFieldExdQualifiers::Shifter,
            31 => FitFieldExdQualifiers::LastSport,
            32 => FitFieldExdQualifiers::Moving,
            33 => FitFieldExdQualifiers::Stopped,
            34 => FitFieldExdQualifiers::EstimatedTotal,
            242 => FitFieldExdQualifiers::Zone9,
            243 => FitFieldExdQualifiers::Zone8,
            244 => FitFieldExdQualifiers::Zone7,
            245 => FitFieldExdQualifiers::Zone6,
            246 => FitFieldExdQualifiers::Zone5,
            247 => FitFieldExdQualifiers::Zone4,
            248 => FitFieldExdQualifiers::Zone3,
            249 => FitFieldExdQualifiers::Zone2,
            250 => FitFieldExdQualifiers::Zone1,
            _ => FitFieldExdQualifiers::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldExdDescriptors {
    // fit base type: enum
    BikeLightBatteryStatus = 0,
    BeamAngleStatus = 1,
    BateryLevel = 2,
    LightNetworkMode = 3,
    NumberLightsConnected = 4,
    Cadence = 5,
    Distance = 6,
    EstimatedTimeOfArrival = 7,
    Heading = 8,
    Time = 9,
    BatteryLevel = 10,
    TrainerResistance = 11,
    TrainerTargetPower = 12,
    TimeSeated = 13,
    TimeStanding = 14,
    Elevation = 15,
    Grade = 16,
    Ascent = 17,
    Descent = 18,
    VerticalSpeed = 19,
    Di2BatteryLevel = 20,
    FrontGear = 21,
    RearGear = 22,
    GearRatio = 23,
    HeartRate = 24,
    HeartRateZone = 25,
    TimeInHeartRateZone = 26,
    HeartRateReserve = 27,
    Calories = 28,
    GpsAccuracy = 29,
    GpsSignalStrength = 30,
    Temperature = 31,
    TimeOfDay = 32,
    Balance = 33,
    PedalSmoothness = 34,
    Power = 35,
    FunctionalThresholdPower = 36,
    IntensityFactor = 37,
    Work = 38,
    PowerRatio = 39,
    NormalizedPower = 40,
    TrainingStressScore = 41,
    TimeOnZone = 42,
    Speed = 43,
    Laps = 44,
    Reps = 45,
    WorkoutStep = 46,
    CourseDistance = 47,
    NavigationDistance = 48,
    CourseEstimatedTimeOfArrival = 49,
    NavigationEstimatedTimeOfArrival = 50,
    CourseTime = 51,
    NavigationTime = 52,
    CourseHeading = 53,
    NavigationHeading = 54,
    PowerZone = 55,
    TorqueEffectiveness = 56,
    TimerTime = 57,
    PowerWeightRatio = 58,
    LeftPlatformCenterOffset = 59,
    RightPlatformCenterOffset = 60,
    LeftPowerPhaseStartAngle = 61,
    RightPowerPhaseStartAngle = 62,
    LeftPowerPhaseFinishAngle = 63,
    RightPowerPhaseFinishAngle = 64,
    Gears = 65, // Combined gear information
    Pace = 66,
    TrainingEffect = 67,
    VerticalOscillation = 68,
    VerticalRatio = 69,
    GroundContactTime = 70,
    LeftGroundContactTimeBalance = 71,
    RightGroundContactTimeBalance = 72,
    StrideLength = 73,
    RunningCadence = 74,
    PerformanceCondition = 75,
    CourseType = 76,
    TimeInPowerZone = 77,
    NavigationTurn = 78,
    CourseLocation = 79,
    NavigationLocation = 80,
    Compass = 81,
    GearCombo = 82,
    MuscleOxygen = 83,
    Icon = 84,
    CompassHeading = 85,
    GpsHeading = 86,
    GpsElevation = 87,
    AnaerobicTrainingEffect = 88,
    Course = 89,
    OffCourse = 90,
    GlideRatio = 91,
    VerticalDistance = 92,
    Vmg = 93,
    AmbientPressure = 94,
    Pressure = 95,
    Vam = 96,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldExdDescriptors {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldExdDescriptors::BikeLightBatteryStatus => {
                write!(f, "{}", "BikeLightBatteryStatus")
            }
            FitFieldExdDescriptors::BeamAngleStatus => write!(f, "{}", "BeamAngleStatus"),
            FitFieldExdDescriptors::BateryLevel => write!(f, "{}", "BateryLevel"),
            FitFieldExdDescriptors::LightNetworkMode => write!(f, "{}", "LightNetworkMode"),
            FitFieldExdDescriptors::NumberLightsConnected => {
                write!(f, "{}", "NumberLightsConnected")
            }
            FitFieldExdDescriptors::Cadence => write!(f, "{}", "Cadence"),
            FitFieldExdDescriptors::Distance => write!(f, "{}", "Distance"),
            FitFieldExdDescriptors::EstimatedTimeOfArrival => {
                write!(f, "{}", "EstimatedTimeOfArrival")
            }
            FitFieldExdDescriptors::Heading => write!(f, "{}", "Heading"),
            FitFieldExdDescriptors::Time => write!(f, "{}", "Time"),
            FitFieldExdDescriptors::BatteryLevel => write!(f, "{}", "BatteryLevel"),
            FitFieldExdDescriptors::TrainerResistance => write!(f, "{}", "TrainerResistance"),
            FitFieldExdDescriptors::TrainerTargetPower => write!(f, "{}", "TrainerTargetPower"),
            FitFieldExdDescriptors::TimeSeated => write!(f, "{}", "TimeSeated"),
            FitFieldExdDescriptors::TimeStanding => write!(f, "{}", "TimeStanding"),
            FitFieldExdDescriptors::Elevation => write!(f, "{}", "Elevation"),
            FitFieldExdDescriptors::Grade => write!(f, "{}", "Grade"),
            FitFieldExdDescriptors::Ascent => write!(f, "{}", "Ascent"),
            FitFieldExdDescriptors::Descent => write!(f, "{}", "Descent"),
            FitFieldExdDescriptors::VerticalSpeed => write!(f, "{}", "VerticalSpeed"),
            FitFieldExdDescriptors::Di2BatteryLevel => write!(f, "{}", "Di2BatteryLevel"),
            FitFieldExdDescriptors::FrontGear => write!(f, "{}", "FrontGear"),
            FitFieldExdDescriptors::RearGear => write!(f, "{}", "RearGear"),
            FitFieldExdDescriptors::GearRatio => write!(f, "{}", "GearRatio"),
            FitFieldExdDescriptors::HeartRate => write!(f, "{}", "HeartRate"),
            FitFieldExdDescriptors::HeartRateZone => write!(f, "{}", "HeartRateZone"),
            FitFieldExdDescriptors::TimeInHeartRateZone => write!(f, "{}", "TimeInHeartRateZone"),
            FitFieldExdDescriptors::HeartRateReserve => write!(f, "{}", "HeartRateReserve"),
            FitFieldExdDescriptors::Calories => write!(f, "{}", "Calories"),
            FitFieldExdDescriptors::GpsAccuracy => write!(f, "{}", "GpsAccuracy"),
            FitFieldExdDescriptors::GpsSignalStrength => write!(f, "{}", "GpsSignalStrength"),
            FitFieldExdDescriptors::Temperature => write!(f, "{}", "Temperature"),
            FitFieldExdDescriptors::TimeOfDay => write!(f, "{}", "TimeOfDay"),
            FitFieldExdDescriptors::Balance => write!(f, "{}", "Balance"),
            FitFieldExdDescriptors::PedalSmoothness => write!(f, "{}", "PedalSmoothness"),
            FitFieldExdDescriptors::Power => write!(f, "{}", "Power"),
            FitFieldExdDescriptors::FunctionalThresholdPower => {
                write!(f, "{}", "FunctionalThresholdPower")
            }
            FitFieldExdDescriptors::IntensityFactor => write!(f, "{}", "IntensityFactor"),
            FitFieldExdDescriptors::Work => write!(f, "{}", "Work"),
            FitFieldExdDescriptors::PowerRatio => write!(f, "{}", "PowerRatio"),
            FitFieldExdDescriptors::NormalizedPower => write!(f, "{}", "NormalizedPower"),
            FitFieldExdDescriptors::TrainingStressScore => write!(f, "{}", "TrainingStressScore"),
            FitFieldExdDescriptors::TimeOnZone => write!(f, "{}", "TimeOnZone"),
            FitFieldExdDescriptors::Speed => write!(f, "{}", "Speed"),
            FitFieldExdDescriptors::Laps => write!(f, "{}", "Laps"),
            FitFieldExdDescriptors::Reps => write!(f, "{}", "Reps"),
            FitFieldExdDescriptors::WorkoutStep => write!(f, "{}", "WorkoutStep"),
            FitFieldExdDescriptors::CourseDistance => write!(f, "{}", "CourseDistance"),
            FitFieldExdDescriptors::NavigationDistance => write!(f, "{}", "NavigationDistance"),
            FitFieldExdDescriptors::CourseEstimatedTimeOfArrival => {
                write!(f, "{}", "CourseEstimatedTimeOfArrival")
            }
            FitFieldExdDescriptors::NavigationEstimatedTimeOfArrival => {
                write!(f, "{}", "NavigationEstimatedTimeOfArrival")
            }
            FitFieldExdDescriptors::CourseTime => write!(f, "{}", "CourseTime"),
            FitFieldExdDescriptors::NavigationTime => write!(f, "{}", "NavigationTime"),
            FitFieldExdDescriptors::CourseHeading => write!(f, "{}", "CourseHeading"),
            FitFieldExdDescriptors::NavigationHeading => write!(f, "{}", "NavigationHeading"),
            FitFieldExdDescriptors::PowerZone => write!(f, "{}", "PowerZone"),
            FitFieldExdDescriptors::TorqueEffectiveness => write!(f, "{}", "TorqueEffectiveness"),
            FitFieldExdDescriptors::TimerTime => write!(f, "{}", "TimerTime"),
            FitFieldExdDescriptors::PowerWeightRatio => write!(f, "{}", "PowerWeightRatio"),
            FitFieldExdDescriptors::LeftPlatformCenterOffset => {
                write!(f, "{}", "LeftPlatformCenterOffset")
            }
            FitFieldExdDescriptors::RightPlatformCenterOffset => {
                write!(f, "{}", "RightPlatformCenterOffset")
            }
            FitFieldExdDescriptors::LeftPowerPhaseStartAngle => {
                write!(f, "{}", "LeftPowerPhaseStartAngle")
            }
            FitFieldExdDescriptors::RightPowerPhaseStartAngle => {
                write!(f, "{}", "RightPowerPhaseStartAngle")
            }
            FitFieldExdDescriptors::LeftPowerPhaseFinishAngle => {
                write!(f, "{}", "LeftPowerPhaseFinishAngle")
            }
            FitFieldExdDescriptors::RightPowerPhaseFinishAngle => {
                write!(f, "{}", "RightPowerPhaseFinishAngle")
            }
            FitFieldExdDescriptors::Gears => write!(f, "{}", "Gears"),
            FitFieldExdDescriptors::Pace => write!(f, "{}", "Pace"),
            FitFieldExdDescriptors::TrainingEffect => write!(f, "{}", "TrainingEffect"),
            FitFieldExdDescriptors::VerticalOscillation => write!(f, "{}", "VerticalOscillation"),
            FitFieldExdDescriptors::VerticalRatio => write!(f, "{}", "VerticalRatio"),
            FitFieldExdDescriptors::GroundContactTime => write!(f, "{}", "GroundContactTime"),
            FitFieldExdDescriptors::LeftGroundContactTimeBalance => {
                write!(f, "{}", "LeftGroundContactTimeBalance")
            }
            FitFieldExdDescriptors::RightGroundContactTimeBalance => {
                write!(f, "{}", "RightGroundContactTimeBalance")
            }
            FitFieldExdDescriptors::StrideLength => write!(f, "{}", "StrideLength"),
            FitFieldExdDescriptors::RunningCadence => write!(f, "{}", "RunningCadence"),
            FitFieldExdDescriptors::PerformanceCondition => write!(f, "{}", "PerformanceCondition"),
            FitFieldExdDescriptors::CourseType => write!(f, "{}", "CourseType"),
            FitFieldExdDescriptors::TimeInPowerZone => write!(f, "{}", "TimeInPowerZone"),
            FitFieldExdDescriptors::NavigationTurn => write!(f, "{}", "NavigationTurn"),
            FitFieldExdDescriptors::CourseLocation => write!(f, "{}", "CourseLocation"),
            FitFieldExdDescriptors::NavigationLocation => write!(f, "{}", "NavigationLocation"),
            FitFieldExdDescriptors::Compass => write!(f, "{}", "Compass"),
            FitFieldExdDescriptors::GearCombo => write!(f, "{}", "GearCombo"),
            FitFieldExdDescriptors::MuscleOxygen => write!(f, "{}", "MuscleOxygen"),
            FitFieldExdDescriptors::Icon => write!(f, "{}", "Icon"),
            FitFieldExdDescriptors::CompassHeading => write!(f, "{}", "CompassHeading"),
            FitFieldExdDescriptors::GpsHeading => write!(f, "{}", "GpsHeading"),
            FitFieldExdDescriptors::GpsElevation => write!(f, "{}", "GpsElevation"),
            FitFieldExdDescriptors::AnaerobicTrainingEffect => {
                write!(f, "{}", "AnaerobicTrainingEffect")
            }
            FitFieldExdDescriptors::Course => write!(f, "{}", "Course"),
            FitFieldExdDescriptors::OffCourse => write!(f, "{}", "OffCourse"),
            FitFieldExdDescriptors::GlideRatio => write!(f, "{}", "GlideRatio"),
            FitFieldExdDescriptors::VerticalDistance => write!(f, "{}", "VerticalDistance"),
            FitFieldExdDescriptors::Vmg => write!(f, "{}", "Vmg"),
            FitFieldExdDescriptors::AmbientPressure => write!(f, "{}", "AmbientPressure"),
            FitFieldExdDescriptors::Pressure => write!(f, "{}", "Pressure"),
            FitFieldExdDescriptors::Vam => write!(f, "{}", "Vam"),
            FitFieldExdDescriptors::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldExdDescriptors::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldExdDescriptors {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldExdDescriptors> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldExdDescriptors::from(v)),
            Err(_) => Ok(FitFieldExdDescriptors::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldExdDescriptors);

impl From<u8> for FitFieldExdDescriptors {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdDescriptors::BikeLightBatteryStatus,
            1 => FitFieldExdDescriptors::BeamAngleStatus,
            2 => FitFieldExdDescriptors::BateryLevel,
            3 => FitFieldExdDescriptors::LightNetworkMode,
            4 => FitFieldExdDescriptors::NumberLightsConnected,
            5 => FitFieldExdDescriptors::Cadence,
            6 => FitFieldExdDescriptors::Distance,
            7 => FitFieldExdDescriptors::EstimatedTimeOfArrival,
            8 => FitFieldExdDescriptors::Heading,
            9 => FitFieldExdDescriptors::Time,
            10 => FitFieldExdDescriptors::BatteryLevel,
            11 => FitFieldExdDescriptors::TrainerResistance,
            12 => FitFieldExdDescriptors::TrainerTargetPower,
            13 => FitFieldExdDescriptors::TimeSeated,
            14 => FitFieldExdDescriptors::TimeStanding,
            15 => FitFieldExdDescriptors::Elevation,
            16 => FitFieldExdDescriptors::Grade,
            17 => FitFieldExdDescriptors::Ascent,
            18 => FitFieldExdDescriptors::Descent,
            19 => FitFieldExdDescriptors::VerticalSpeed,
            20 => FitFieldExdDescriptors::Di2BatteryLevel,
            21 => FitFieldExdDescriptors::FrontGear,
            22 => FitFieldExdDescriptors::RearGear,
            23 => FitFieldExdDescriptors::GearRatio,
            24 => FitFieldExdDescriptors::HeartRate,
            25 => FitFieldExdDescriptors::HeartRateZone,
            26 => FitFieldExdDescriptors::TimeInHeartRateZone,
            27 => FitFieldExdDescriptors::HeartRateReserve,
            28 => FitFieldExdDescriptors::Calories,
            29 => FitFieldExdDescriptors::GpsAccuracy,
            30 => FitFieldExdDescriptors::GpsSignalStrength,
            31 => FitFieldExdDescriptors::Temperature,
            32 => FitFieldExdDescriptors::TimeOfDay,
            33 => FitFieldExdDescriptors::Balance,
            34 => FitFieldExdDescriptors::PedalSmoothness,
            35 => FitFieldExdDescriptors::Power,
            36 => FitFieldExdDescriptors::FunctionalThresholdPower,
            37 => FitFieldExdDescriptors::IntensityFactor,
            38 => FitFieldExdDescriptors::Work,
            39 => FitFieldExdDescriptors::PowerRatio,
            40 => FitFieldExdDescriptors::NormalizedPower,
            41 => FitFieldExdDescriptors::TrainingStressScore,
            42 => FitFieldExdDescriptors::TimeOnZone,
            43 => FitFieldExdDescriptors::Speed,
            44 => FitFieldExdDescriptors::Laps,
            45 => FitFieldExdDescriptors::Reps,
            46 => FitFieldExdDescriptors::WorkoutStep,
            47 => FitFieldExdDescriptors::CourseDistance,
            48 => FitFieldExdDescriptors::NavigationDistance,
            49 => FitFieldExdDescriptors::CourseEstimatedTimeOfArrival,
            50 => FitFieldExdDescriptors::NavigationEstimatedTimeOfArrival,
            51 => FitFieldExdDescriptors::CourseTime,
            52 => FitFieldExdDescriptors::NavigationTime,
            53 => FitFieldExdDescriptors::CourseHeading,
            54 => FitFieldExdDescriptors::NavigationHeading,
            55 => FitFieldExdDescriptors::PowerZone,
            56 => FitFieldExdDescriptors::TorqueEffectiveness,
            57 => FitFieldExdDescriptors::TimerTime,
            58 => FitFieldExdDescriptors::PowerWeightRatio,
            59 => FitFieldExdDescriptors::LeftPlatformCenterOffset,
            60 => FitFieldExdDescriptors::RightPlatformCenterOffset,
            61 => FitFieldExdDescriptors::LeftPowerPhaseStartAngle,
            62 => FitFieldExdDescriptors::RightPowerPhaseStartAngle,
            63 => FitFieldExdDescriptors::LeftPowerPhaseFinishAngle,
            64 => FitFieldExdDescriptors::RightPowerPhaseFinishAngle,
            65 => FitFieldExdDescriptors::Gears,
            66 => FitFieldExdDescriptors::Pace,
            67 => FitFieldExdDescriptors::TrainingEffect,
            68 => FitFieldExdDescriptors::VerticalOscillation,
            69 => FitFieldExdDescriptors::VerticalRatio,
            70 => FitFieldExdDescriptors::GroundContactTime,
            71 => FitFieldExdDescriptors::LeftGroundContactTimeBalance,
            72 => FitFieldExdDescriptors::RightGroundContactTimeBalance,
            73 => FitFieldExdDescriptors::StrideLength,
            74 => FitFieldExdDescriptors::RunningCadence,
            75 => FitFieldExdDescriptors::PerformanceCondition,
            76 => FitFieldExdDescriptors::CourseType,
            77 => FitFieldExdDescriptors::TimeInPowerZone,
            78 => FitFieldExdDescriptors::NavigationTurn,
            79 => FitFieldExdDescriptors::CourseLocation,
            80 => FitFieldExdDescriptors::NavigationLocation,
            81 => FitFieldExdDescriptors::Compass,
            82 => FitFieldExdDescriptors::GearCombo,
            83 => FitFieldExdDescriptors::MuscleOxygen,
            84 => FitFieldExdDescriptors::Icon,
            85 => FitFieldExdDescriptors::CompassHeading,
            86 => FitFieldExdDescriptors::GpsHeading,
            87 => FitFieldExdDescriptors::GpsElevation,
            88 => FitFieldExdDescriptors::AnaerobicTrainingEffect,
            89 => FitFieldExdDescriptors::Course,
            90 => FitFieldExdDescriptors::OffCourse,
            91 => FitFieldExdDescriptors::GlideRatio,
            92 => FitFieldExdDescriptors::VerticalDistance,
            93 => FitFieldExdDescriptors::Vmg,
            94 => FitFieldExdDescriptors::AmbientPressure,
            95 => FitFieldExdDescriptors::Pressure,
            96 => FitFieldExdDescriptors::Vam,
            _ => FitFieldExdDescriptors::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldAutoActivityDetect {
    // fit base type: uint32
    None,       // 0
    Running,    // 1
    Cycling,    // 2
    Swimming,   // 4
    Walking,    // 8
    Elliptical, // 32
    Sedentary,  // 1024
    AutoActivityDetect(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldAutoActivityDetect {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldAutoActivityDetect::None => write!(f, "{}", "None"),
            FitFieldAutoActivityDetect::Running => write!(f, "{}", "Running"),
            FitFieldAutoActivityDetect::Cycling => write!(f, "{}", "Cycling"),
            FitFieldAutoActivityDetect::Swimming => write!(f, "{}", "Swimming"),
            FitFieldAutoActivityDetect::Walking => write!(f, "{}", "Walking"),
            FitFieldAutoActivityDetect::Elliptical => write!(f, "{}", "Elliptical"),
            FitFieldAutoActivityDetect::Sedentary => write!(f, "{}", "Sedentary"),
            FitFieldAutoActivityDetect::AutoActivityDetect(x) => {
                write!(f, "{}({})", "AutoActivityDetect", x)
            }
            FitFieldAutoActivityDetect::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldAutoActivityDetect::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldAutoActivityDetect {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldAutoActivityDetect> {
        let val = parse_uint32(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldAutoActivityDetect::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldAutoActivityDetect::from(v)),
                1 => Ok(FitFieldAutoActivityDetect::from(v)),
                2 => Ok(FitFieldAutoActivityDetect::from(v)),
                4 => Ok(FitFieldAutoActivityDetect::from(v)),
                8 => Ok(FitFieldAutoActivityDetect::from(v)),
                32 => Ok(FitFieldAutoActivityDetect::from(v)),
                1024 => Ok(FitFieldAutoActivityDetect::from(v)),
                v => Ok(FitFieldAutoActivityDetect::AutoActivityDetect(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldAutoActivityDetect);

impl From<u32> for FitFieldAutoActivityDetect {
    fn from(code: u32) -> Self {
        match code {
            0 => FitFieldAutoActivityDetect::None,
            1 => FitFieldAutoActivityDetect::Running,
            2 => FitFieldAutoActivityDetect::Cycling,
            4 => FitFieldAutoActivityDetect::Swimming,
            8 => FitFieldAutoActivityDetect::Walking,
            32 => FitFieldAutoActivityDetect::Elliptical,
            1024 => FitFieldAutoActivityDetect::Sedentary,
            _ => FitFieldAutoActivityDetect::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSupportedExdScreenLayouts {
    // fit base type: uint32z
    FullScreen,                // 1
    HalfVertical,              // 2
    HalfHorizontal,            // 4
    HalfVerticalRightSplit,    // 8
    HalfHorizontalBottomSplit, // 16
    FullQuarterSplit,          // 32
    HalfVerticalLeftSplit,     // 64
    HalfHorizontalTopSplit,    // 128
    SupportedExdScreenLayouts(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSupportedExdScreenLayouts {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSupportedExdScreenLayouts::FullScreen => write!(f, "{}", "FullScreen"),
            FitFieldSupportedExdScreenLayouts::HalfVertical => write!(f, "{}", "HalfVertical"),
            FitFieldSupportedExdScreenLayouts::HalfHorizontal => write!(f, "{}", "HalfHorizontal"),
            FitFieldSupportedExdScreenLayouts::HalfVerticalRightSplit => {
                write!(f, "{}", "HalfVerticalRightSplit")
            }
            FitFieldSupportedExdScreenLayouts::HalfHorizontalBottomSplit => {
                write!(f, "{}", "HalfHorizontalBottomSplit")
            }
            FitFieldSupportedExdScreenLayouts::FullQuarterSplit => {
                write!(f, "{}", "FullQuarterSplit")
            }
            FitFieldSupportedExdScreenLayouts::HalfVerticalLeftSplit => {
                write!(f, "{}", "HalfVerticalLeftSplit")
            }
            FitFieldSupportedExdScreenLayouts::HalfHorizontalTopSplit => {
                write!(f, "{}", "HalfHorizontalTopSplit")
            }
            FitFieldSupportedExdScreenLayouts::SupportedExdScreenLayouts(x) => {
                write!(f, "{}({})", "SupportedExdScreenLayouts", x)
            }
            FitFieldSupportedExdScreenLayouts::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSupportedExdScreenLayouts::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSupportedExdScreenLayouts {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldSupportedExdScreenLayouts> {
        let val = parse_uint32z(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSupportedExdScreenLayouts::InvalidFieldValue),
            Ok(v) => match v {
                1 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                2 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                4 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                8 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                16 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                32 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                64 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                128 => Ok(FitFieldSupportedExdScreenLayouts::from(v)),
                v => Ok(FitFieldSupportedExdScreenLayouts::SupportedExdScreenLayouts(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSupportedExdScreenLayouts);

impl From<u32> for FitFieldSupportedExdScreenLayouts {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldSupportedExdScreenLayouts::FullScreen,
            2 => FitFieldSupportedExdScreenLayouts::HalfVertical,
            4 => FitFieldSupportedExdScreenLayouts::HalfHorizontal,
            8 => FitFieldSupportedExdScreenLayouts::HalfVerticalRightSplit,
            16 => FitFieldSupportedExdScreenLayouts::HalfHorizontalBottomSplit,
            32 => FitFieldSupportedExdScreenLayouts::FullQuarterSplit,
            64 => FitFieldSupportedExdScreenLayouts::HalfVerticalLeftSplit,
            128 => FitFieldSupportedExdScreenLayouts::HalfHorizontalTopSplit,
            _ => FitFieldSupportedExdScreenLayouts::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFitBaseType {
    // fit base type: uint8
    Enum,    // 0
    Sint8,   // 1
    Uint8,   // 2
    Sint16,  // 131
    Uint16,  // 132
    Sint32,  // 133
    Uint32,  // 134
    String,  // 7
    Float32, // 136
    Float64, // 137
    Uint8z,  // 10
    Uint16z, // 139
    Uint32z, // 140
    Byte,    // 13
    Sint64,  // 142
    Uint64,  // 143
    Uint64z, // 144
    FitBaseType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldFitBaseType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFitBaseType::Enum => write!(f, "{}", "Enum"),
            FitFieldFitBaseType::Sint8 => write!(f, "{}", "Sint8"),
            FitFieldFitBaseType::Uint8 => write!(f, "{}", "Uint8"),
            FitFieldFitBaseType::Sint16 => write!(f, "{}", "Sint16"),
            FitFieldFitBaseType::Uint16 => write!(f, "{}", "Uint16"),
            FitFieldFitBaseType::Sint32 => write!(f, "{}", "Sint32"),
            FitFieldFitBaseType::Uint32 => write!(f, "{}", "Uint32"),
            FitFieldFitBaseType::String => write!(f, "{}", "String"),
            FitFieldFitBaseType::Float32 => write!(f, "{}", "Float32"),
            FitFieldFitBaseType::Float64 => write!(f, "{}", "Float64"),
            FitFieldFitBaseType::Uint8z => write!(f, "{}", "Uint8z"),
            FitFieldFitBaseType::Uint16z => write!(f, "{}", "Uint16z"),
            FitFieldFitBaseType::Uint32z => write!(f, "{}", "Uint32z"),
            FitFieldFitBaseType::Byte => write!(f, "{}", "Byte"),
            FitFieldFitBaseType::Sint64 => write!(f, "{}", "Sint64"),
            FitFieldFitBaseType::Uint64 => write!(f, "{}", "Uint64"),
            FitFieldFitBaseType::Uint64z => write!(f, "{}", "Uint64z"),
            FitFieldFitBaseType::FitBaseType(x) => write!(f, "{}({})", "FitBaseType", x),
            FitFieldFitBaseType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFitBaseType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFitBaseType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFitBaseType> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldFitBaseType::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldFitBaseType::from(v)),
                1 => Ok(FitFieldFitBaseType::from(v)),
                2 => Ok(FitFieldFitBaseType::from(v)),
                131 => Ok(FitFieldFitBaseType::from(v)),
                132 => Ok(FitFieldFitBaseType::from(v)),
                133 => Ok(FitFieldFitBaseType::from(v)),
                134 => Ok(FitFieldFitBaseType::from(v)),
                7 => Ok(FitFieldFitBaseType::from(v)),
                136 => Ok(FitFieldFitBaseType::from(v)),
                137 => Ok(FitFieldFitBaseType::from(v)),
                10 => Ok(FitFieldFitBaseType::from(v)),
                139 => Ok(FitFieldFitBaseType::from(v)),
                140 => Ok(FitFieldFitBaseType::from(v)),
                13 => Ok(FitFieldFitBaseType::from(v)),
                142 => Ok(FitFieldFitBaseType::from(v)),
                143 => Ok(FitFieldFitBaseType::from(v)),
                144 => Ok(FitFieldFitBaseType::from(v)),
                v => Ok(FitFieldFitBaseType::FitBaseType(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldFitBaseType);

impl From<u8> for FitFieldFitBaseType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldFitBaseType::Enum,
            1 => FitFieldFitBaseType::Sint8,
            2 => FitFieldFitBaseType::Uint8,
            131 => FitFieldFitBaseType::Sint16,
            132 => FitFieldFitBaseType::Uint16,
            133 => FitFieldFitBaseType::Sint32,
            134 => FitFieldFitBaseType::Uint32,
            7 => FitFieldFitBaseType::String,
            136 => FitFieldFitBaseType::Float32,
            137 => FitFieldFitBaseType::Float64,
            10 => FitFieldFitBaseType::Uint8z,
            139 => FitFieldFitBaseType::Uint16z,
            140 => FitFieldFitBaseType::Uint32z,
            13 => FitFieldFitBaseType::Byte,
            142 => FitFieldFitBaseType::Sint64,
            143 => FitFieldFitBaseType::Uint64,
            144 => FitFieldFitBaseType::Uint64z,
            _ => FitFieldFitBaseType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTurnType {
    // fit base type: enum
    ArrivingIdx = 0,
    ArrivingLeftIdx = 1,
    ArrivingRightIdx = 2,
    ArrivingViaIdx = 3,
    ArrivingViaLeftIdx = 4,
    ArrivingViaRightIdx = 5,
    BearKeepLeftIdx = 6,
    BearKeepRightIdx = 7,
    ContinueIdx = 8,
    ExitLeftIdx = 9,
    ExitRightIdx = 10,
    FerryIdx = 11,
    Roundabout45Idx = 12,
    Roundabout90Idx = 13,
    Roundabout135Idx = 14,
    Roundabout180Idx = 15,
    Roundabout225Idx = 16,
    Roundabout270Idx = 17,
    Roundabout315Idx = 18,
    Roundabout360Idx = 19,
    RoundaboutNeg45Idx = 20,
    RoundaboutNeg90Idx = 21,
    RoundaboutNeg135Idx = 22,
    RoundaboutNeg180Idx = 23,
    RoundaboutNeg225Idx = 24,
    RoundaboutNeg270Idx = 25,
    RoundaboutNeg315Idx = 26,
    RoundaboutNeg360Idx = 27,
    RoundaboutGenericIdx = 28,
    RoundaboutNegGenericIdx = 29,
    SharpTurnLeftIdx = 30,
    SharpTurnRightIdx = 31,
    TurnLeftIdx = 32,
    TurnRightIdx = 33,
    UturnLeftIdx = 34,
    UturnRightIdx = 35,
    IconInvIdx = 36,
    IconIdxCnt = 37,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldTurnType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTurnType::ArrivingIdx => write!(f, "{}", "ArrivingIdx"),
            FitFieldTurnType::ArrivingLeftIdx => write!(f, "{}", "ArrivingLeftIdx"),
            FitFieldTurnType::ArrivingRightIdx => write!(f, "{}", "ArrivingRightIdx"),
            FitFieldTurnType::ArrivingViaIdx => write!(f, "{}", "ArrivingViaIdx"),
            FitFieldTurnType::ArrivingViaLeftIdx => write!(f, "{}", "ArrivingViaLeftIdx"),
            FitFieldTurnType::ArrivingViaRightIdx => write!(f, "{}", "ArrivingViaRightIdx"),
            FitFieldTurnType::BearKeepLeftIdx => write!(f, "{}", "BearKeepLeftIdx"),
            FitFieldTurnType::BearKeepRightIdx => write!(f, "{}", "BearKeepRightIdx"),
            FitFieldTurnType::ContinueIdx => write!(f, "{}", "ContinueIdx"),
            FitFieldTurnType::ExitLeftIdx => write!(f, "{}", "ExitLeftIdx"),
            FitFieldTurnType::ExitRightIdx => write!(f, "{}", "ExitRightIdx"),
            FitFieldTurnType::FerryIdx => write!(f, "{}", "FerryIdx"),
            FitFieldTurnType::Roundabout45Idx => write!(f, "{}", "Roundabout45Idx"),
            FitFieldTurnType::Roundabout90Idx => write!(f, "{}", "Roundabout90Idx"),
            FitFieldTurnType::Roundabout135Idx => write!(f, "{}", "Roundabout135Idx"),
            FitFieldTurnType::Roundabout180Idx => write!(f, "{}", "Roundabout180Idx"),
            FitFieldTurnType::Roundabout225Idx => write!(f, "{}", "Roundabout225Idx"),
            FitFieldTurnType::Roundabout270Idx => write!(f, "{}", "Roundabout270Idx"),
            FitFieldTurnType::Roundabout315Idx => write!(f, "{}", "Roundabout315Idx"),
            FitFieldTurnType::Roundabout360Idx => write!(f, "{}", "Roundabout360Idx"),
            FitFieldTurnType::RoundaboutNeg45Idx => write!(f, "{}", "RoundaboutNeg45Idx"),
            FitFieldTurnType::RoundaboutNeg90Idx => write!(f, "{}", "RoundaboutNeg90Idx"),
            FitFieldTurnType::RoundaboutNeg135Idx => write!(f, "{}", "RoundaboutNeg135Idx"),
            FitFieldTurnType::RoundaboutNeg180Idx => write!(f, "{}", "RoundaboutNeg180Idx"),
            FitFieldTurnType::RoundaboutNeg225Idx => write!(f, "{}", "RoundaboutNeg225Idx"),
            FitFieldTurnType::RoundaboutNeg270Idx => write!(f, "{}", "RoundaboutNeg270Idx"),
            FitFieldTurnType::RoundaboutNeg315Idx => write!(f, "{}", "RoundaboutNeg315Idx"),
            FitFieldTurnType::RoundaboutNeg360Idx => write!(f, "{}", "RoundaboutNeg360Idx"),
            FitFieldTurnType::RoundaboutGenericIdx => write!(f, "{}", "RoundaboutGenericIdx"),
            FitFieldTurnType::RoundaboutNegGenericIdx => write!(f, "{}", "RoundaboutNegGenericIdx"),
            FitFieldTurnType::SharpTurnLeftIdx => write!(f, "{}", "SharpTurnLeftIdx"),
            FitFieldTurnType::SharpTurnRightIdx => write!(f, "{}", "SharpTurnRightIdx"),
            FitFieldTurnType::TurnLeftIdx => write!(f, "{}", "TurnLeftIdx"),
            FitFieldTurnType::TurnRightIdx => write!(f, "{}", "TurnRightIdx"),
            FitFieldTurnType::UturnLeftIdx => write!(f, "{}", "UturnLeftIdx"),
            FitFieldTurnType::UturnRightIdx => write!(f, "{}", "UturnRightIdx"),
            FitFieldTurnType::IconInvIdx => write!(f, "{}", "IconInvIdx"),
            FitFieldTurnType::IconIdxCnt => write!(f, "{}", "IconIdxCnt"),
            FitFieldTurnType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTurnType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTurnType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTurnType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldTurnType::from(v)),
            Err(_) => Ok(FitFieldTurnType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldTurnType);

impl From<u8> for FitFieldTurnType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTurnType::ArrivingIdx,
            1 => FitFieldTurnType::ArrivingLeftIdx,
            2 => FitFieldTurnType::ArrivingRightIdx,
            3 => FitFieldTurnType::ArrivingViaIdx,
            4 => FitFieldTurnType::ArrivingViaLeftIdx,
            5 => FitFieldTurnType::ArrivingViaRightIdx,
            6 => FitFieldTurnType::BearKeepLeftIdx,
            7 => FitFieldTurnType::BearKeepRightIdx,
            8 => FitFieldTurnType::ContinueIdx,
            9 => FitFieldTurnType::ExitLeftIdx,
            10 => FitFieldTurnType::ExitRightIdx,
            11 => FitFieldTurnType::FerryIdx,
            12 => FitFieldTurnType::Roundabout45Idx,
            13 => FitFieldTurnType::Roundabout90Idx,
            14 => FitFieldTurnType::Roundabout135Idx,
            15 => FitFieldTurnType::Roundabout180Idx,
            16 => FitFieldTurnType::Roundabout225Idx,
            17 => FitFieldTurnType::Roundabout270Idx,
            18 => FitFieldTurnType::Roundabout315Idx,
            19 => FitFieldTurnType::Roundabout360Idx,
            20 => FitFieldTurnType::RoundaboutNeg45Idx,
            21 => FitFieldTurnType::RoundaboutNeg90Idx,
            22 => FitFieldTurnType::RoundaboutNeg135Idx,
            23 => FitFieldTurnType::RoundaboutNeg180Idx,
            24 => FitFieldTurnType::RoundaboutNeg225Idx,
            25 => FitFieldTurnType::RoundaboutNeg270Idx,
            26 => FitFieldTurnType::RoundaboutNeg315Idx,
            27 => FitFieldTurnType::RoundaboutNeg360Idx,
            28 => FitFieldTurnType::RoundaboutGenericIdx,
            29 => FitFieldTurnType::RoundaboutNegGenericIdx,
            30 => FitFieldTurnType::SharpTurnLeftIdx,
            31 => FitFieldTurnType::SharpTurnRightIdx,
            32 => FitFieldTurnType::TurnLeftIdx,
            33 => FitFieldTurnType::TurnRightIdx,
            34 => FitFieldTurnType::UturnLeftIdx,
            35 => FitFieldTurnType::UturnRightIdx,
            36 => FitFieldTurnType::IconInvIdx,
            37 => FitFieldTurnType::IconIdxCnt,
            _ => FitFieldTurnType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBikeLightBeamAngleMode {
    // fit base type: uint8
    Manual, // 0
    Auto,   // 1
    BikeLightBeamAngleMode(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldBikeLightBeamAngleMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBikeLightBeamAngleMode::Manual => write!(f, "{}", "Manual"),
            FitFieldBikeLightBeamAngleMode::Auto => write!(f, "{}", "Auto"),
            FitFieldBikeLightBeamAngleMode::BikeLightBeamAngleMode(x) => {
                write!(f, "{}({})", "BikeLightBeamAngleMode", x)
            }
            FitFieldBikeLightBeamAngleMode::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBikeLightBeamAngleMode::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBikeLightBeamAngleMode {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldBikeLightBeamAngleMode> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldBikeLightBeamAngleMode::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldBikeLightBeamAngleMode::from(v)),
                1 => Ok(FitFieldBikeLightBeamAngleMode::from(v)),
                v => Ok(FitFieldBikeLightBeamAngleMode::BikeLightBeamAngleMode(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldBikeLightBeamAngleMode);

impl From<u8> for FitFieldBikeLightBeamAngleMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBikeLightBeamAngleMode::Manual,
            1 => FitFieldBikeLightBeamAngleMode::Auto,
            _ => FitFieldBikeLightBeamAngleMode::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFitBaseUnit {
    // fit base type: uint16
    Other,    // 0
    Kilogram, // 1
    Pound,    // 2
    FitBaseUnit(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldFitBaseUnit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFitBaseUnit::Other => write!(f, "{}", "Other"),
            FitFieldFitBaseUnit::Kilogram => write!(f, "{}", "Kilogram"),
            FitFieldFitBaseUnit::Pound => write!(f, "{}", "Pound"),
            FitFieldFitBaseUnit::FitBaseUnit(x) => write!(f, "{}({})", "FitBaseUnit", x),
            FitFieldFitBaseUnit::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFitBaseUnit::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFitBaseUnit {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFitBaseUnit> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldFitBaseUnit::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldFitBaseUnit::from(v)),
                1 => Ok(FitFieldFitBaseUnit::from(v)),
                2 => Ok(FitFieldFitBaseUnit::from(v)),
                v => Ok(FitFieldFitBaseUnit::FitBaseUnit(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldFitBaseUnit);

impl From<u16> for FitFieldFitBaseUnit {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldFitBaseUnit::Other,
            1 => FitFieldFitBaseUnit::Kilogram,
            2 => FitFieldFitBaseUnit::Pound,
            _ => FitFieldFitBaseUnit::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSetType {
    // fit base type: uint8
    Rest,   // 0
    Active, // 1
    SetType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSetType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSetType::Rest => write!(f, "{}", "Rest"),
            FitFieldSetType::Active => write!(f, "{}", "Active"),
            FitFieldSetType::SetType(x) => write!(f, "{}({})", "SetType", x),
            FitFieldSetType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSetType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSetType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSetType> {
        let val = parse_uint8(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSetType::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldSetType::from(v)),
                1 => Ok(FitFieldSetType::from(v)),
                v => Ok(FitFieldSetType::SetType(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSetType);

impl From<u8> for FitFieldSetType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSetType::Rest,
            1 => FitFieldSetType::Active,
            _ => FitFieldSetType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldExerciseCategory {
    // fit base type: uint16
    BenchPress,        // 0
    CalfRaise,         // 1
    Cardio,            // 2
    Carry,             // 3
    Chop,              // 4
    Core,              // 5
    Crunch,            // 6
    Curl,              // 7
    Deadlift,          // 8
    Flye,              // 9
    HipRaise,          // 10
    HipStability,      // 11
    HipSwing,          // 12
    Hyperextension,    // 13
    LateralRaise,      // 14
    LegCurl,           // 15
    LegRaise,          // 16
    Lunge,             // 17
    OlympicLift,       // 18
    Plank,             // 19
    Plyo,              // 20
    PullUp,            // 21
    PushUp,            // 22
    Row,               // 23
    ShoulderPress,     // 24
    ShoulderStability, // 25
    Shrug,             // 26
    SitUp,             // 27
    Squat,             // 28
    TotalBody,         // 29
    TricepsExtension,  // 30
    WarmUp,            // 31
    Run,               // 32
    Unknown,           // 65534
    ExerciseCategory(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldExerciseCategory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldExerciseCategory::BenchPress => write!(f, "{}", "BenchPress"),
            FitFieldExerciseCategory::CalfRaise => write!(f, "{}", "CalfRaise"),
            FitFieldExerciseCategory::Cardio => write!(f, "{}", "Cardio"),
            FitFieldExerciseCategory::Carry => write!(f, "{}", "Carry"),
            FitFieldExerciseCategory::Chop => write!(f, "{}", "Chop"),
            FitFieldExerciseCategory::Core => write!(f, "{}", "Core"),
            FitFieldExerciseCategory::Crunch => write!(f, "{}", "Crunch"),
            FitFieldExerciseCategory::Curl => write!(f, "{}", "Curl"),
            FitFieldExerciseCategory::Deadlift => write!(f, "{}", "Deadlift"),
            FitFieldExerciseCategory::Flye => write!(f, "{}", "Flye"),
            FitFieldExerciseCategory::HipRaise => write!(f, "{}", "HipRaise"),
            FitFieldExerciseCategory::HipStability => write!(f, "{}", "HipStability"),
            FitFieldExerciseCategory::HipSwing => write!(f, "{}", "HipSwing"),
            FitFieldExerciseCategory::Hyperextension => write!(f, "{}", "Hyperextension"),
            FitFieldExerciseCategory::LateralRaise => write!(f, "{}", "LateralRaise"),
            FitFieldExerciseCategory::LegCurl => write!(f, "{}", "LegCurl"),
            FitFieldExerciseCategory::LegRaise => write!(f, "{}", "LegRaise"),
            FitFieldExerciseCategory::Lunge => write!(f, "{}", "Lunge"),
            FitFieldExerciseCategory::OlympicLift => write!(f, "{}", "OlympicLift"),
            FitFieldExerciseCategory::Plank => write!(f, "{}", "Plank"),
            FitFieldExerciseCategory::Plyo => write!(f, "{}", "Plyo"),
            FitFieldExerciseCategory::PullUp => write!(f, "{}", "PullUp"),
            FitFieldExerciseCategory::PushUp => write!(f, "{}", "PushUp"),
            FitFieldExerciseCategory::Row => write!(f, "{}", "Row"),
            FitFieldExerciseCategory::ShoulderPress => write!(f, "{}", "ShoulderPress"),
            FitFieldExerciseCategory::ShoulderStability => write!(f, "{}", "ShoulderStability"),
            FitFieldExerciseCategory::Shrug => write!(f, "{}", "Shrug"),
            FitFieldExerciseCategory::SitUp => write!(f, "{}", "SitUp"),
            FitFieldExerciseCategory::Squat => write!(f, "{}", "Squat"),
            FitFieldExerciseCategory::TotalBody => write!(f, "{}", "TotalBody"),
            FitFieldExerciseCategory::TricepsExtension => write!(f, "{}", "TricepsExtension"),
            FitFieldExerciseCategory::WarmUp => write!(f, "{}", "WarmUp"),
            FitFieldExerciseCategory::Run => write!(f, "{}", "Run"),
            FitFieldExerciseCategory::Unknown => write!(f, "{}", "Unknown"),
            FitFieldExerciseCategory::ExerciseCategory(x) => {
                write!(f, "{}({})", "ExerciseCategory", x)
            }
            FitFieldExerciseCategory::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldExerciseCategory::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldExerciseCategory {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldExerciseCategory> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldExerciseCategory::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldExerciseCategory::from(v)),
                1 => Ok(FitFieldExerciseCategory::from(v)),
                2 => Ok(FitFieldExerciseCategory::from(v)),
                3 => Ok(FitFieldExerciseCategory::from(v)),
                4 => Ok(FitFieldExerciseCategory::from(v)),
                5 => Ok(FitFieldExerciseCategory::from(v)),
                6 => Ok(FitFieldExerciseCategory::from(v)),
                7 => Ok(FitFieldExerciseCategory::from(v)),
                8 => Ok(FitFieldExerciseCategory::from(v)),
                9 => Ok(FitFieldExerciseCategory::from(v)),
                10 => Ok(FitFieldExerciseCategory::from(v)),
                11 => Ok(FitFieldExerciseCategory::from(v)),
                12 => Ok(FitFieldExerciseCategory::from(v)),
                13 => Ok(FitFieldExerciseCategory::from(v)),
                14 => Ok(FitFieldExerciseCategory::from(v)),
                15 => Ok(FitFieldExerciseCategory::from(v)),
                16 => Ok(FitFieldExerciseCategory::from(v)),
                17 => Ok(FitFieldExerciseCategory::from(v)),
                18 => Ok(FitFieldExerciseCategory::from(v)),
                19 => Ok(FitFieldExerciseCategory::from(v)),
                20 => Ok(FitFieldExerciseCategory::from(v)),
                21 => Ok(FitFieldExerciseCategory::from(v)),
                22 => Ok(FitFieldExerciseCategory::from(v)),
                23 => Ok(FitFieldExerciseCategory::from(v)),
                24 => Ok(FitFieldExerciseCategory::from(v)),
                25 => Ok(FitFieldExerciseCategory::from(v)),
                26 => Ok(FitFieldExerciseCategory::from(v)),
                27 => Ok(FitFieldExerciseCategory::from(v)),
                28 => Ok(FitFieldExerciseCategory::from(v)),
                29 => Ok(FitFieldExerciseCategory::from(v)),
                30 => Ok(FitFieldExerciseCategory::from(v)),
                31 => Ok(FitFieldExerciseCategory::from(v)),
                32 => Ok(FitFieldExerciseCategory::from(v)),
                65534 => Ok(FitFieldExerciseCategory::from(v)),
                v => Ok(FitFieldExerciseCategory::ExerciseCategory(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldExerciseCategory);

impl From<u16> for FitFieldExerciseCategory {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldExerciseCategory::BenchPress,
            1 => FitFieldExerciseCategory::CalfRaise,
            2 => FitFieldExerciseCategory::Cardio,
            3 => FitFieldExerciseCategory::Carry,
            4 => FitFieldExerciseCategory::Chop,
            5 => FitFieldExerciseCategory::Core,
            6 => FitFieldExerciseCategory::Crunch,
            7 => FitFieldExerciseCategory::Curl,
            8 => FitFieldExerciseCategory::Deadlift,
            9 => FitFieldExerciseCategory::Flye,
            10 => FitFieldExerciseCategory::HipRaise,
            11 => FitFieldExerciseCategory::HipStability,
            12 => FitFieldExerciseCategory::HipSwing,
            13 => FitFieldExerciseCategory::Hyperextension,
            14 => FitFieldExerciseCategory::LateralRaise,
            15 => FitFieldExerciseCategory::LegCurl,
            16 => FitFieldExerciseCategory::LegRaise,
            17 => FitFieldExerciseCategory::Lunge,
            18 => FitFieldExerciseCategory::OlympicLift,
            19 => FitFieldExerciseCategory::Plank,
            20 => FitFieldExerciseCategory::Plyo,
            21 => FitFieldExerciseCategory::PullUp,
            22 => FitFieldExerciseCategory::PushUp,
            23 => FitFieldExerciseCategory::Row,
            24 => FitFieldExerciseCategory::ShoulderPress,
            25 => FitFieldExerciseCategory::ShoulderStability,
            26 => FitFieldExerciseCategory::Shrug,
            27 => FitFieldExerciseCategory::SitUp,
            28 => FitFieldExerciseCategory::Squat,
            29 => FitFieldExerciseCategory::TotalBody,
            30 => FitFieldExerciseCategory::TricepsExtension,
            31 => FitFieldExerciseCategory::WarmUp,
            32 => FitFieldExerciseCategory::Run,
            65534 => FitFieldExerciseCategory::Unknown,
            _ => FitFieldExerciseCategory::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldBenchPressExerciseName {
    // fit base type: uint16
    AlternatingDumbbellChestPressOnSwissBall, // 0
    BarbellBenchPress,                        // 1
    BarbellBoardBenchPress,                   // 2
    BarbellFloorPress,                        // 3
    CloseGripBarbellBenchPress,               // 4
    DeclineDumbbellBenchPress,                // 5
    DumbbellBenchPress,                       // 6
    DumbbellFloorPress,                       // 7
    InclineBarbellBenchPress,                 // 8
    InclineDumbbellBenchPress,                // 9
    InclineSmithMachineBenchPress,            // 10
    IsometricBarbellBenchPress,               // 11
    KettlebellChestPress,                     // 12
    NeutralGripDumbbellBenchPress,            // 13
    NeutralGripDumbbellInclineBenchPress,     // 14
    OneArmFloorPress,                         // 15
    WeightedOneArmFloorPress,                 // 16
    PartialLockout,                           // 17
    ReverseGripBarbellBenchPress,             // 18
    ReverseGripInclineBenchPress,             // 19
    SingleArmCableChestPress,                 // 20
    SingleArmDumbbellBenchPress,              // 21
    SmithMachineBenchPress,                   // 22
    SwissBallDumbbellChestPress,              // 23
    TripleStopBarbellBenchPress,              // 24
    WideGripBarbellBenchPress,                // 25
    AlternatingDumbbellChestPress,            // 26
    BenchPressExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldBenchPressExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldBenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall => {
                write!(f, "{}", "AlternatingDumbbellChestPressOnSwissBall")
            }
            FitFieldBenchPressExerciseName::BarbellBenchPress => {
                write!(f, "{}", "BarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::BarbellBoardBenchPress => {
                write!(f, "{}", "BarbellBoardBenchPress")
            }
            FitFieldBenchPressExerciseName::BarbellFloorPress => {
                write!(f, "{}", "BarbellFloorPress")
            }
            FitFieldBenchPressExerciseName::CloseGripBarbellBenchPress => {
                write!(f, "{}", "CloseGripBarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::DeclineDumbbellBenchPress => {
                write!(f, "{}", "DeclineDumbbellBenchPress")
            }
            FitFieldBenchPressExerciseName::DumbbellBenchPress => {
                write!(f, "{}", "DumbbellBenchPress")
            }
            FitFieldBenchPressExerciseName::DumbbellFloorPress => {
                write!(f, "{}", "DumbbellFloorPress")
            }
            FitFieldBenchPressExerciseName::InclineBarbellBenchPress => {
                write!(f, "{}", "InclineBarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::InclineDumbbellBenchPress => {
                write!(f, "{}", "InclineDumbbellBenchPress")
            }
            FitFieldBenchPressExerciseName::InclineSmithMachineBenchPress => {
                write!(f, "{}", "InclineSmithMachineBenchPress")
            }
            FitFieldBenchPressExerciseName::IsometricBarbellBenchPress => {
                write!(f, "{}", "IsometricBarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::KettlebellChestPress => {
                write!(f, "{}", "KettlebellChestPress")
            }
            FitFieldBenchPressExerciseName::NeutralGripDumbbellBenchPress => {
                write!(f, "{}", "NeutralGripDumbbellBenchPress")
            }
            FitFieldBenchPressExerciseName::NeutralGripDumbbellInclineBenchPress => {
                write!(f, "{}", "NeutralGripDumbbellInclineBenchPress")
            }
            FitFieldBenchPressExerciseName::OneArmFloorPress => write!(f, "{}", "OneArmFloorPress"),
            FitFieldBenchPressExerciseName::WeightedOneArmFloorPress => {
                write!(f, "{}", "WeightedOneArmFloorPress")
            }
            FitFieldBenchPressExerciseName::PartialLockout => write!(f, "{}", "PartialLockout"),
            FitFieldBenchPressExerciseName::ReverseGripBarbellBenchPress => {
                write!(f, "{}", "ReverseGripBarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::ReverseGripInclineBenchPress => {
                write!(f, "{}", "ReverseGripInclineBenchPress")
            }
            FitFieldBenchPressExerciseName::SingleArmCableChestPress => {
                write!(f, "{}", "SingleArmCableChestPress")
            }
            FitFieldBenchPressExerciseName::SingleArmDumbbellBenchPress => {
                write!(f, "{}", "SingleArmDumbbellBenchPress")
            }
            FitFieldBenchPressExerciseName::SmithMachineBenchPress => {
                write!(f, "{}", "SmithMachineBenchPress")
            }
            FitFieldBenchPressExerciseName::SwissBallDumbbellChestPress => {
                write!(f, "{}", "SwissBallDumbbellChestPress")
            }
            FitFieldBenchPressExerciseName::TripleStopBarbellBenchPress => {
                write!(f, "{}", "TripleStopBarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::WideGripBarbellBenchPress => {
                write!(f, "{}", "WideGripBarbellBenchPress")
            }
            FitFieldBenchPressExerciseName::AlternatingDumbbellChestPress => {
                write!(f, "{}", "AlternatingDumbbellChestPress")
            }
            FitFieldBenchPressExerciseName::BenchPressExerciseName(x) => {
                write!(f, "{}({})", "BenchPressExerciseName", x)
            }
            FitFieldBenchPressExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldBenchPressExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldBenchPressExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldBenchPressExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldBenchPressExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldBenchPressExerciseName::from(v)),
                1 => Ok(FitFieldBenchPressExerciseName::from(v)),
                2 => Ok(FitFieldBenchPressExerciseName::from(v)),
                3 => Ok(FitFieldBenchPressExerciseName::from(v)),
                4 => Ok(FitFieldBenchPressExerciseName::from(v)),
                5 => Ok(FitFieldBenchPressExerciseName::from(v)),
                6 => Ok(FitFieldBenchPressExerciseName::from(v)),
                7 => Ok(FitFieldBenchPressExerciseName::from(v)),
                8 => Ok(FitFieldBenchPressExerciseName::from(v)),
                9 => Ok(FitFieldBenchPressExerciseName::from(v)),
                10 => Ok(FitFieldBenchPressExerciseName::from(v)),
                11 => Ok(FitFieldBenchPressExerciseName::from(v)),
                12 => Ok(FitFieldBenchPressExerciseName::from(v)),
                13 => Ok(FitFieldBenchPressExerciseName::from(v)),
                14 => Ok(FitFieldBenchPressExerciseName::from(v)),
                15 => Ok(FitFieldBenchPressExerciseName::from(v)),
                16 => Ok(FitFieldBenchPressExerciseName::from(v)),
                17 => Ok(FitFieldBenchPressExerciseName::from(v)),
                18 => Ok(FitFieldBenchPressExerciseName::from(v)),
                19 => Ok(FitFieldBenchPressExerciseName::from(v)),
                20 => Ok(FitFieldBenchPressExerciseName::from(v)),
                21 => Ok(FitFieldBenchPressExerciseName::from(v)),
                22 => Ok(FitFieldBenchPressExerciseName::from(v)),
                23 => Ok(FitFieldBenchPressExerciseName::from(v)),
                24 => Ok(FitFieldBenchPressExerciseName::from(v)),
                25 => Ok(FitFieldBenchPressExerciseName::from(v)),
                26 => Ok(FitFieldBenchPressExerciseName::from(v)),
                v => Ok(FitFieldBenchPressExerciseName::BenchPressExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldBenchPressExerciseName);

impl From<u16> for FitFieldBenchPressExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldBenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall,
            1 => FitFieldBenchPressExerciseName::BarbellBenchPress,
            2 => FitFieldBenchPressExerciseName::BarbellBoardBenchPress,
            3 => FitFieldBenchPressExerciseName::BarbellFloorPress,
            4 => FitFieldBenchPressExerciseName::CloseGripBarbellBenchPress,
            5 => FitFieldBenchPressExerciseName::DeclineDumbbellBenchPress,
            6 => FitFieldBenchPressExerciseName::DumbbellBenchPress,
            7 => FitFieldBenchPressExerciseName::DumbbellFloorPress,
            8 => FitFieldBenchPressExerciseName::InclineBarbellBenchPress,
            9 => FitFieldBenchPressExerciseName::InclineDumbbellBenchPress,
            10 => FitFieldBenchPressExerciseName::InclineSmithMachineBenchPress,
            11 => FitFieldBenchPressExerciseName::IsometricBarbellBenchPress,
            12 => FitFieldBenchPressExerciseName::KettlebellChestPress,
            13 => FitFieldBenchPressExerciseName::NeutralGripDumbbellBenchPress,
            14 => FitFieldBenchPressExerciseName::NeutralGripDumbbellInclineBenchPress,
            15 => FitFieldBenchPressExerciseName::OneArmFloorPress,
            16 => FitFieldBenchPressExerciseName::WeightedOneArmFloorPress,
            17 => FitFieldBenchPressExerciseName::PartialLockout,
            18 => FitFieldBenchPressExerciseName::ReverseGripBarbellBenchPress,
            19 => FitFieldBenchPressExerciseName::ReverseGripInclineBenchPress,
            20 => FitFieldBenchPressExerciseName::SingleArmCableChestPress,
            21 => FitFieldBenchPressExerciseName::SingleArmDumbbellBenchPress,
            22 => FitFieldBenchPressExerciseName::SmithMachineBenchPress,
            23 => FitFieldBenchPressExerciseName::SwissBallDumbbellChestPress,
            24 => FitFieldBenchPressExerciseName::TripleStopBarbellBenchPress,
            25 => FitFieldBenchPressExerciseName::WideGripBarbellBenchPress,
            26 => FitFieldBenchPressExerciseName::AlternatingDumbbellChestPress,
            _ => FitFieldBenchPressExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCalfRaiseExerciseName {
    // fit base type: uint16
    ThreeWayCalfRaise,                  // 0
    ThreeWayWeightedCalfRaise,          // 1
    ThreeWaySingleLegCalfRaise,         // 2
    ThreeWayWeightedSingleLegCalfRaise, // 3
    DonkeyCalfRaise,                    // 4
    WeightedDonkeyCalfRaise,            // 5
    SeatedCalfRaise,                    // 6
    WeightedSeatedCalfRaise,            // 7
    SeatedDumbbellToeRaise,             // 8
    SingleLegBentKneeCalfRaise,         // 9
    WeightedSingleLegBentKneeCalfRaise, // 10
    SingleLegDeclinePushUp,             // 11
    SingleLegDonkeyCalfRaise,           // 12
    WeightedSingleLegDonkeyCalfRaise,   // 13
    SingleLegHipRaiseWithKneeHold,      // 14
    SingleLegStandingCalfRaise,         // 15
    SingleLegStandingDumbbellCalfRaise, // 16
    StandingBarbellCalfRaise,           // 17
    StandingCalfRaise,                  // 18
    WeightedStandingCalfRaise,          // 19
    StandingDumbbellCalfRaise,          // 20
    CalfRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCalfRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCalfRaiseExerciseName::ThreeWayCalfRaise => {
                write!(f, "{}", "ThreeWayCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::ThreeWayWeightedCalfRaise => {
                write!(f, "{}", "ThreeWayWeightedCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::ThreeWaySingleLegCalfRaise => {
                write!(f, "{}", "ThreeWaySingleLegCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::ThreeWayWeightedSingleLegCalfRaise => {
                write!(f, "{}", "ThreeWayWeightedSingleLegCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::DonkeyCalfRaise => write!(f, "{}", "DonkeyCalfRaise"),
            FitFieldCalfRaiseExerciseName::WeightedDonkeyCalfRaise => {
                write!(f, "{}", "WeightedDonkeyCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::SeatedCalfRaise => write!(f, "{}", "SeatedCalfRaise"),
            FitFieldCalfRaiseExerciseName::WeightedSeatedCalfRaise => {
                write!(f, "{}", "WeightedSeatedCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::SeatedDumbbellToeRaise => {
                write!(f, "{}", "SeatedDumbbellToeRaise")
            }
            FitFieldCalfRaiseExerciseName::SingleLegBentKneeCalfRaise => {
                write!(f, "{}", "SingleLegBentKneeCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise => {
                write!(f, "{}", "WeightedSingleLegBentKneeCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::SingleLegDeclinePushUp => {
                write!(f, "{}", "SingleLegDeclinePushUp")
            }
            FitFieldCalfRaiseExerciseName::SingleLegDonkeyCalfRaise => {
                write!(f, "{}", "SingleLegDonkeyCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise => {
                write!(f, "{}", "WeightedSingleLegDonkeyCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold => {
                write!(f, "{}", "SingleLegHipRaiseWithKneeHold")
            }
            FitFieldCalfRaiseExerciseName::SingleLegStandingCalfRaise => {
                write!(f, "{}", "SingleLegStandingCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise => {
                write!(f, "{}", "SingleLegStandingDumbbellCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::StandingBarbellCalfRaise => {
                write!(f, "{}", "StandingBarbellCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::StandingCalfRaise => {
                write!(f, "{}", "StandingCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::WeightedStandingCalfRaise => {
                write!(f, "{}", "WeightedStandingCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::StandingDumbbellCalfRaise => {
                write!(f, "{}", "StandingDumbbellCalfRaise")
            }
            FitFieldCalfRaiseExerciseName::CalfRaiseExerciseName(x) => {
                write!(f, "{}({})", "CalfRaiseExerciseName", x)
            }
            FitFieldCalfRaiseExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCalfRaiseExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCalfRaiseExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCalfRaiseExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCalfRaiseExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                1 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                2 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                3 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                4 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                5 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                6 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                7 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                8 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                9 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                10 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                11 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                12 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                13 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                14 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                15 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                16 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                17 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                18 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                19 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                20 => Ok(FitFieldCalfRaiseExerciseName::from(v)),
                v => Ok(FitFieldCalfRaiseExerciseName::CalfRaiseExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCalfRaiseExerciseName);

impl From<u16> for FitFieldCalfRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCalfRaiseExerciseName::ThreeWayCalfRaise,
            1 => FitFieldCalfRaiseExerciseName::ThreeWayWeightedCalfRaise,
            2 => FitFieldCalfRaiseExerciseName::ThreeWaySingleLegCalfRaise,
            3 => FitFieldCalfRaiseExerciseName::ThreeWayWeightedSingleLegCalfRaise,
            4 => FitFieldCalfRaiseExerciseName::DonkeyCalfRaise,
            5 => FitFieldCalfRaiseExerciseName::WeightedDonkeyCalfRaise,
            6 => FitFieldCalfRaiseExerciseName::SeatedCalfRaise,
            7 => FitFieldCalfRaiseExerciseName::WeightedSeatedCalfRaise,
            8 => FitFieldCalfRaiseExerciseName::SeatedDumbbellToeRaise,
            9 => FitFieldCalfRaiseExerciseName::SingleLegBentKneeCalfRaise,
            10 => FitFieldCalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise,
            11 => FitFieldCalfRaiseExerciseName::SingleLegDeclinePushUp,
            12 => FitFieldCalfRaiseExerciseName::SingleLegDonkeyCalfRaise,
            13 => FitFieldCalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise,
            14 => FitFieldCalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold,
            15 => FitFieldCalfRaiseExerciseName::SingleLegStandingCalfRaise,
            16 => FitFieldCalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise,
            17 => FitFieldCalfRaiseExerciseName::StandingBarbellCalfRaise,
            18 => FitFieldCalfRaiseExerciseName::StandingCalfRaise,
            19 => FitFieldCalfRaiseExerciseName::WeightedStandingCalfRaise,
            20 => FitFieldCalfRaiseExerciseName::StandingDumbbellCalfRaise,
            _ => FitFieldCalfRaiseExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCardioExerciseName {
    // fit base type: uint16
    BobAndWeaveCircle,         // 0
    WeightedBobAndWeaveCircle, // 1
    CardioCoreCrawl,           // 2
    WeightedCardioCoreCrawl,   // 3
    DoubleUnder,               // 4
    WeightedDoubleUnder,       // 5
    JumpRope,                  // 6
    WeightedJumpRope,          // 7
    JumpRopeCrossover,         // 8
    WeightedJumpRopeCrossover, // 9
    JumpRopeJog,               // 10
    WeightedJumpRopeJog,       // 11
    JumpingJacks,              // 12
    WeightedJumpingJacks,      // 13
    SkiMoguls,                 // 14
    WeightedSkiMoguls,         // 15
    SplitJacks,                // 16
    WeightedSplitJacks,        // 17
    SquatJacks,                // 18
    WeightedSquatJacks,        // 19
    TripleUnder,               // 20
    WeightedTripleUnder,       // 21
    CardioExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCardioExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCardioExerciseName::BobAndWeaveCircle => write!(f, "{}", "BobAndWeaveCircle"),
            FitFieldCardioExerciseName::WeightedBobAndWeaveCircle => {
                write!(f, "{}", "WeightedBobAndWeaveCircle")
            }
            FitFieldCardioExerciseName::CardioCoreCrawl => write!(f, "{}", "CardioCoreCrawl"),
            FitFieldCardioExerciseName::WeightedCardioCoreCrawl => {
                write!(f, "{}", "WeightedCardioCoreCrawl")
            }
            FitFieldCardioExerciseName::DoubleUnder => write!(f, "{}", "DoubleUnder"),
            FitFieldCardioExerciseName::WeightedDoubleUnder => {
                write!(f, "{}", "WeightedDoubleUnder")
            }
            FitFieldCardioExerciseName::JumpRope => write!(f, "{}", "JumpRope"),
            FitFieldCardioExerciseName::WeightedJumpRope => write!(f, "{}", "WeightedJumpRope"),
            FitFieldCardioExerciseName::JumpRopeCrossover => write!(f, "{}", "JumpRopeCrossover"),
            FitFieldCardioExerciseName::WeightedJumpRopeCrossover => {
                write!(f, "{}", "WeightedJumpRopeCrossover")
            }
            FitFieldCardioExerciseName::JumpRopeJog => write!(f, "{}", "JumpRopeJog"),
            FitFieldCardioExerciseName::WeightedJumpRopeJog => {
                write!(f, "{}", "WeightedJumpRopeJog")
            }
            FitFieldCardioExerciseName::JumpingJacks => write!(f, "{}", "JumpingJacks"),
            FitFieldCardioExerciseName::WeightedJumpingJacks => {
                write!(f, "{}", "WeightedJumpingJacks")
            }
            FitFieldCardioExerciseName::SkiMoguls => write!(f, "{}", "SkiMoguls"),
            FitFieldCardioExerciseName::WeightedSkiMoguls => write!(f, "{}", "WeightedSkiMoguls"),
            FitFieldCardioExerciseName::SplitJacks => write!(f, "{}", "SplitJacks"),
            FitFieldCardioExerciseName::WeightedSplitJacks => write!(f, "{}", "WeightedSplitJacks"),
            FitFieldCardioExerciseName::SquatJacks => write!(f, "{}", "SquatJacks"),
            FitFieldCardioExerciseName::WeightedSquatJacks => write!(f, "{}", "WeightedSquatJacks"),
            FitFieldCardioExerciseName::TripleUnder => write!(f, "{}", "TripleUnder"),
            FitFieldCardioExerciseName::WeightedTripleUnder => {
                write!(f, "{}", "WeightedTripleUnder")
            }
            FitFieldCardioExerciseName::CardioExerciseName(x) => {
                write!(f, "{}({})", "CardioExerciseName", x)
            }
            FitFieldCardioExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCardioExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCardioExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCardioExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCardioExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCardioExerciseName::from(v)),
                1 => Ok(FitFieldCardioExerciseName::from(v)),
                2 => Ok(FitFieldCardioExerciseName::from(v)),
                3 => Ok(FitFieldCardioExerciseName::from(v)),
                4 => Ok(FitFieldCardioExerciseName::from(v)),
                5 => Ok(FitFieldCardioExerciseName::from(v)),
                6 => Ok(FitFieldCardioExerciseName::from(v)),
                7 => Ok(FitFieldCardioExerciseName::from(v)),
                8 => Ok(FitFieldCardioExerciseName::from(v)),
                9 => Ok(FitFieldCardioExerciseName::from(v)),
                10 => Ok(FitFieldCardioExerciseName::from(v)),
                11 => Ok(FitFieldCardioExerciseName::from(v)),
                12 => Ok(FitFieldCardioExerciseName::from(v)),
                13 => Ok(FitFieldCardioExerciseName::from(v)),
                14 => Ok(FitFieldCardioExerciseName::from(v)),
                15 => Ok(FitFieldCardioExerciseName::from(v)),
                16 => Ok(FitFieldCardioExerciseName::from(v)),
                17 => Ok(FitFieldCardioExerciseName::from(v)),
                18 => Ok(FitFieldCardioExerciseName::from(v)),
                19 => Ok(FitFieldCardioExerciseName::from(v)),
                20 => Ok(FitFieldCardioExerciseName::from(v)),
                21 => Ok(FitFieldCardioExerciseName::from(v)),
                v => Ok(FitFieldCardioExerciseName::CardioExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCardioExerciseName);

impl From<u16> for FitFieldCardioExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCardioExerciseName::BobAndWeaveCircle,
            1 => FitFieldCardioExerciseName::WeightedBobAndWeaveCircle,
            2 => FitFieldCardioExerciseName::CardioCoreCrawl,
            3 => FitFieldCardioExerciseName::WeightedCardioCoreCrawl,
            4 => FitFieldCardioExerciseName::DoubleUnder,
            5 => FitFieldCardioExerciseName::WeightedDoubleUnder,
            6 => FitFieldCardioExerciseName::JumpRope,
            7 => FitFieldCardioExerciseName::WeightedJumpRope,
            8 => FitFieldCardioExerciseName::JumpRopeCrossover,
            9 => FitFieldCardioExerciseName::WeightedJumpRopeCrossover,
            10 => FitFieldCardioExerciseName::JumpRopeJog,
            11 => FitFieldCardioExerciseName::WeightedJumpRopeJog,
            12 => FitFieldCardioExerciseName::JumpingJacks,
            13 => FitFieldCardioExerciseName::WeightedJumpingJacks,
            14 => FitFieldCardioExerciseName::SkiMoguls,
            15 => FitFieldCardioExerciseName::WeightedSkiMoguls,
            16 => FitFieldCardioExerciseName::SplitJacks,
            17 => FitFieldCardioExerciseName::WeightedSplitJacks,
            18 => FitFieldCardioExerciseName::SquatJacks,
            19 => FitFieldCardioExerciseName::WeightedSquatJacks,
            20 => FitFieldCardioExerciseName::TripleUnder,
            21 => FitFieldCardioExerciseName::WeightedTripleUnder,
            _ => FitFieldCardioExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCarryExerciseName {
    // fit base type: uint16
    BarHolds,          // 0
    FarmersWalk,       // 1
    FarmersWalkOnToes, // 2
    HexDumbbellHold,   // 3
    OverheadCarry,     // 4
    CarryExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCarryExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCarryExerciseName::BarHolds => write!(f, "{}", "BarHolds"),
            FitFieldCarryExerciseName::FarmersWalk => write!(f, "{}", "FarmersWalk"),
            FitFieldCarryExerciseName::FarmersWalkOnToes => write!(f, "{}", "FarmersWalkOnToes"),
            FitFieldCarryExerciseName::HexDumbbellHold => write!(f, "{}", "HexDumbbellHold"),
            FitFieldCarryExerciseName::OverheadCarry => write!(f, "{}", "OverheadCarry"),
            FitFieldCarryExerciseName::CarryExerciseName(x) => {
                write!(f, "{}({})", "CarryExerciseName", x)
            }
            FitFieldCarryExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCarryExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCarryExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCarryExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCarryExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCarryExerciseName::from(v)),
                1 => Ok(FitFieldCarryExerciseName::from(v)),
                2 => Ok(FitFieldCarryExerciseName::from(v)),
                3 => Ok(FitFieldCarryExerciseName::from(v)),
                4 => Ok(FitFieldCarryExerciseName::from(v)),
                v => Ok(FitFieldCarryExerciseName::CarryExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCarryExerciseName);

impl From<u16> for FitFieldCarryExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCarryExerciseName::BarHolds,
            1 => FitFieldCarryExerciseName::FarmersWalk,
            2 => FitFieldCarryExerciseName::FarmersWalkOnToes,
            3 => FitFieldCarryExerciseName::HexDumbbellHold,
            4 => FitFieldCarryExerciseName::OverheadCarry,
            _ => FitFieldCarryExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldChopExerciseName {
    // fit base type: uint16
    CablePullThrough,                   // 0
    CableRotationalLift,                // 1
    CableWoodchop,                      // 2
    CrossChopToKnee,                    // 3
    WeightedCrossChopToKnee,            // 4
    DumbbellChop,                       // 5
    HalfKneelingRotation,               // 6
    WeightedHalfKneelingRotation,       // 7
    HalfKneelingRotationalChop,         // 8
    HalfKneelingRotationalReverseChop,  // 9
    HalfKneelingStabilityChop,          // 10
    HalfKneelingStabilityReverseChop,   // 11
    KneelingRotationalChop,             // 12
    KneelingRotationalReverseChop,      // 13
    KneelingStabilityChop,              // 14
    KneelingWoodchopper,                // 15
    MedicineBallWoodChops,              // 16
    PowerSquatChops,                    // 17
    WeightedPowerSquatChops,            // 18
    StandingRotationalChop,             // 19
    StandingSplitRotationalChop,        // 20
    StandingSplitRotationalReverseChop, // 21
    StandingStabilityReverseChop,       // 22
    ChopExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldChopExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldChopExerciseName::CablePullThrough => write!(f, "{}", "CablePullThrough"),
            FitFieldChopExerciseName::CableRotationalLift => write!(f, "{}", "CableRotationalLift"),
            FitFieldChopExerciseName::CableWoodchop => write!(f, "{}", "CableWoodchop"),
            FitFieldChopExerciseName::CrossChopToKnee => write!(f, "{}", "CrossChopToKnee"),
            FitFieldChopExerciseName::WeightedCrossChopToKnee => {
                write!(f, "{}", "WeightedCrossChopToKnee")
            }
            FitFieldChopExerciseName::DumbbellChop => write!(f, "{}", "DumbbellChop"),
            FitFieldChopExerciseName::HalfKneelingRotation => {
                write!(f, "{}", "HalfKneelingRotation")
            }
            FitFieldChopExerciseName::WeightedHalfKneelingRotation => {
                write!(f, "{}", "WeightedHalfKneelingRotation")
            }
            FitFieldChopExerciseName::HalfKneelingRotationalChop => {
                write!(f, "{}", "HalfKneelingRotationalChop")
            }
            FitFieldChopExerciseName::HalfKneelingRotationalReverseChop => {
                write!(f, "{}", "HalfKneelingRotationalReverseChop")
            }
            FitFieldChopExerciseName::HalfKneelingStabilityChop => {
                write!(f, "{}", "HalfKneelingStabilityChop")
            }
            FitFieldChopExerciseName::HalfKneelingStabilityReverseChop => {
                write!(f, "{}", "HalfKneelingStabilityReverseChop")
            }
            FitFieldChopExerciseName::KneelingRotationalChop => {
                write!(f, "{}", "KneelingRotationalChop")
            }
            FitFieldChopExerciseName::KneelingRotationalReverseChop => {
                write!(f, "{}", "KneelingRotationalReverseChop")
            }
            FitFieldChopExerciseName::KneelingStabilityChop => {
                write!(f, "{}", "KneelingStabilityChop")
            }
            FitFieldChopExerciseName::KneelingWoodchopper => write!(f, "{}", "KneelingWoodchopper"),
            FitFieldChopExerciseName::MedicineBallWoodChops => {
                write!(f, "{}", "MedicineBallWoodChops")
            }
            FitFieldChopExerciseName::PowerSquatChops => write!(f, "{}", "PowerSquatChops"),
            FitFieldChopExerciseName::WeightedPowerSquatChops => {
                write!(f, "{}", "WeightedPowerSquatChops")
            }
            FitFieldChopExerciseName::StandingRotationalChop => {
                write!(f, "{}", "StandingRotationalChop")
            }
            FitFieldChopExerciseName::StandingSplitRotationalChop => {
                write!(f, "{}", "StandingSplitRotationalChop")
            }
            FitFieldChopExerciseName::StandingSplitRotationalReverseChop => {
                write!(f, "{}", "StandingSplitRotationalReverseChop")
            }
            FitFieldChopExerciseName::StandingStabilityReverseChop => {
                write!(f, "{}", "StandingStabilityReverseChop")
            }
            FitFieldChopExerciseName::ChopExerciseName(x) => {
                write!(f, "{}({})", "ChopExerciseName", x)
            }
            FitFieldChopExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldChopExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldChopExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldChopExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldChopExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldChopExerciseName::from(v)),
                1 => Ok(FitFieldChopExerciseName::from(v)),
                2 => Ok(FitFieldChopExerciseName::from(v)),
                3 => Ok(FitFieldChopExerciseName::from(v)),
                4 => Ok(FitFieldChopExerciseName::from(v)),
                5 => Ok(FitFieldChopExerciseName::from(v)),
                6 => Ok(FitFieldChopExerciseName::from(v)),
                7 => Ok(FitFieldChopExerciseName::from(v)),
                8 => Ok(FitFieldChopExerciseName::from(v)),
                9 => Ok(FitFieldChopExerciseName::from(v)),
                10 => Ok(FitFieldChopExerciseName::from(v)),
                11 => Ok(FitFieldChopExerciseName::from(v)),
                12 => Ok(FitFieldChopExerciseName::from(v)),
                13 => Ok(FitFieldChopExerciseName::from(v)),
                14 => Ok(FitFieldChopExerciseName::from(v)),
                15 => Ok(FitFieldChopExerciseName::from(v)),
                16 => Ok(FitFieldChopExerciseName::from(v)),
                17 => Ok(FitFieldChopExerciseName::from(v)),
                18 => Ok(FitFieldChopExerciseName::from(v)),
                19 => Ok(FitFieldChopExerciseName::from(v)),
                20 => Ok(FitFieldChopExerciseName::from(v)),
                21 => Ok(FitFieldChopExerciseName::from(v)),
                22 => Ok(FitFieldChopExerciseName::from(v)),
                v => Ok(FitFieldChopExerciseName::ChopExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldChopExerciseName);

impl From<u16> for FitFieldChopExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldChopExerciseName::CablePullThrough,
            1 => FitFieldChopExerciseName::CableRotationalLift,
            2 => FitFieldChopExerciseName::CableWoodchop,
            3 => FitFieldChopExerciseName::CrossChopToKnee,
            4 => FitFieldChopExerciseName::WeightedCrossChopToKnee,
            5 => FitFieldChopExerciseName::DumbbellChop,
            6 => FitFieldChopExerciseName::HalfKneelingRotation,
            7 => FitFieldChopExerciseName::WeightedHalfKneelingRotation,
            8 => FitFieldChopExerciseName::HalfKneelingRotationalChop,
            9 => FitFieldChopExerciseName::HalfKneelingRotationalReverseChop,
            10 => FitFieldChopExerciseName::HalfKneelingStabilityChop,
            11 => FitFieldChopExerciseName::HalfKneelingStabilityReverseChop,
            12 => FitFieldChopExerciseName::KneelingRotationalChop,
            13 => FitFieldChopExerciseName::KneelingRotationalReverseChop,
            14 => FitFieldChopExerciseName::KneelingStabilityChop,
            15 => FitFieldChopExerciseName::KneelingWoodchopper,
            16 => FitFieldChopExerciseName::MedicineBallWoodChops,
            17 => FitFieldChopExerciseName::PowerSquatChops,
            18 => FitFieldChopExerciseName::WeightedPowerSquatChops,
            19 => FitFieldChopExerciseName::StandingRotationalChop,
            20 => FitFieldChopExerciseName::StandingSplitRotationalChop,
            21 => FitFieldChopExerciseName::StandingSplitRotationalReverseChop,
            22 => FitFieldChopExerciseName::StandingStabilityReverseChop,
            _ => FitFieldChopExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCoreExerciseName {
    // fit base type: uint16
    AbsJabs,                          // 0
    WeightedAbsJabs,                  // 1
    AlternatingPlateReach,            // 2
    BarbellRollout,                   // 3
    WeightedBarbellRollout,           // 4
    BodyBarObliqueTwist,              // 5
    CableCorePress,                   // 6
    CableSideBend,                    // 7
    SideBend,                         // 8
    WeightedSideBend,                 // 9
    CrescentCircle,                   // 10
    WeightedCrescentCircle,           // 11
    CyclingRussianTwist,              // 12
    WeightedCyclingRussianTwist,      // 13
    ElevatedFeetRussianTwist,         // 14
    WeightedElevatedFeetRussianTwist, // 15
    HalfTurkishGetUp,                 // 16
    KettlebellWindmill,               // 17
    KneelingAbWheel,                  // 18
    WeightedKneelingAbWheel,          // 19
    ModifiedFrontLever,               // 20
    OpenKneeTucks,                    // 21
    WeightedOpenKneeTucks,            // 22
    SideAbsLegLift,                   // 23
    WeightedSideAbsLegLift,           // 24
    SwissBallJackknife,               // 25
    WeightedSwissBallJackknife,       // 26
    SwissBallPike,                    // 27
    WeightedSwissBallPike,            // 28
    SwissBallRollout,                 // 29
    WeightedSwissBallRollout,         // 30
    TriangleHipPress,                 // 31
    WeightedTriangleHipPress,         // 32
    TrxSuspendedJackknife,            // 33
    WeightedTrxSuspendedJackknife,    // 34
    UBoat,                            // 35
    WeightedUBoat,                    // 36
    WindmillSwitches,                 // 37
    WeightedWindmillSwitches,         // 38
    AlternatingSlideOut,              // 39
    WeightedAlternatingSlideOut,      // 40
    GhdBackExtensions,                // 41
    WeightedGhdBackExtensions,        // 42
    OverheadWalk,                     // 43
    Inchworm,                         // 44
    WeightedModifiedFrontLever,       // 45
    RussianTwist,                     // 46
    AbdominalLegRotations,            // 47
    ArmAndLegExtensionOnKnees,        // 48
    Bicycle,                          // 49
    BicepCurlWithLegExtension,        // 50
    CatCow,                           // 51
    Corkscrew,                        // 52
    CrissCross,                       // 53
    CrissCrossWithBall,               // 54
    DoubleLegStretch,                 // 55
    KneeFolds,                        // 56
    LowerLift,                        // 57
    NeckPull,                         // 58
    PelvicClocks,                     // 59
    RollOver,                         // 60
    RollUp,                           // 61
    Rolling,                          // 62
    Rowing1,                          // 63
    Rowing2,                          // 64
    Scissors,                         // 65
    SingleLegCircles,                 // 66
    SingleLegStretch,                 // 67
    SnakeTwist1And2,                  // 68
    Swan,                             // 69
    Swimming,                         // 70
    Teaser,                           // 71
    TheHundred,                       // 72
    CoreExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCoreExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCoreExerciseName::AbsJabs => write!(f, "{}", "AbsJabs"),
            FitFieldCoreExerciseName::WeightedAbsJabs => write!(f, "{}", "WeightedAbsJabs"),
            FitFieldCoreExerciseName::AlternatingPlateReach => {
                write!(f, "{}", "AlternatingPlateReach")
            }
            FitFieldCoreExerciseName::BarbellRollout => write!(f, "{}", "BarbellRollout"),
            FitFieldCoreExerciseName::WeightedBarbellRollout => {
                write!(f, "{}", "WeightedBarbellRollout")
            }
            FitFieldCoreExerciseName::BodyBarObliqueTwist => write!(f, "{}", "BodyBarObliqueTwist"),
            FitFieldCoreExerciseName::CableCorePress => write!(f, "{}", "CableCorePress"),
            FitFieldCoreExerciseName::CableSideBend => write!(f, "{}", "CableSideBend"),
            FitFieldCoreExerciseName::SideBend => write!(f, "{}", "SideBend"),
            FitFieldCoreExerciseName::WeightedSideBend => write!(f, "{}", "WeightedSideBend"),
            FitFieldCoreExerciseName::CrescentCircle => write!(f, "{}", "CrescentCircle"),
            FitFieldCoreExerciseName::WeightedCrescentCircle => {
                write!(f, "{}", "WeightedCrescentCircle")
            }
            FitFieldCoreExerciseName::CyclingRussianTwist => write!(f, "{}", "CyclingRussianTwist"),
            FitFieldCoreExerciseName::WeightedCyclingRussianTwist => {
                write!(f, "{}", "WeightedCyclingRussianTwist")
            }
            FitFieldCoreExerciseName::ElevatedFeetRussianTwist => {
                write!(f, "{}", "ElevatedFeetRussianTwist")
            }
            FitFieldCoreExerciseName::WeightedElevatedFeetRussianTwist => {
                write!(f, "{}", "WeightedElevatedFeetRussianTwist")
            }
            FitFieldCoreExerciseName::HalfTurkishGetUp => write!(f, "{}", "HalfTurkishGetUp"),
            FitFieldCoreExerciseName::KettlebellWindmill => write!(f, "{}", "KettlebellWindmill"),
            FitFieldCoreExerciseName::KneelingAbWheel => write!(f, "{}", "KneelingAbWheel"),
            FitFieldCoreExerciseName::WeightedKneelingAbWheel => {
                write!(f, "{}", "WeightedKneelingAbWheel")
            }
            FitFieldCoreExerciseName::ModifiedFrontLever => write!(f, "{}", "ModifiedFrontLever"),
            FitFieldCoreExerciseName::OpenKneeTucks => write!(f, "{}", "OpenKneeTucks"),
            FitFieldCoreExerciseName::WeightedOpenKneeTucks => {
                write!(f, "{}", "WeightedOpenKneeTucks")
            }
            FitFieldCoreExerciseName::SideAbsLegLift => write!(f, "{}", "SideAbsLegLift"),
            FitFieldCoreExerciseName::WeightedSideAbsLegLift => {
                write!(f, "{}", "WeightedSideAbsLegLift")
            }
            FitFieldCoreExerciseName::SwissBallJackknife => write!(f, "{}", "SwissBallJackknife"),
            FitFieldCoreExerciseName::WeightedSwissBallJackknife => {
                write!(f, "{}", "WeightedSwissBallJackknife")
            }
            FitFieldCoreExerciseName::SwissBallPike => write!(f, "{}", "SwissBallPike"),
            FitFieldCoreExerciseName::WeightedSwissBallPike => {
                write!(f, "{}", "WeightedSwissBallPike")
            }
            FitFieldCoreExerciseName::SwissBallRollout => write!(f, "{}", "SwissBallRollout"),
            FitFieldCoreExerciseName::WeightedSwissBallRollout => {
                write!(f, "{}", "WeightedSwissBallRollout")
            }
            FitFieldCoreExerciseName::TriangleHipPress => write!(f, "{}", "TriangleHipPress"),
            FitFieldCoreExerciseName::WeightedTriangleHipPress => {
                write!(f, "{}", "WeightedTriangleHipPress")
            }
            FitFieldCoreExerciseName::TrxSuspendedJackknife => {
                write!(f, "{}", "TrxSuspendedJackknife")
            }
            FitFieldCoreExerciseName::WeightedTrxSuspendedJackknife => {
                write!(f, "{}", "WeightedTrxSuspendedJackknife")
            }
            FitFieldCoreExerciseName::UBoat => write!(f, "{}", "UBoat"),
            FitFieldCoreExerciseName::WeightedUBoat => write!(f, "{}", "WeightedUBoat"),
            FitFieldCoreExerciseName::WindmillSwitches => write!(f, "{}", "WindmillSwitches"),
            FitFieldCoreExerciseName::WeightedWindmillSwitches => {
                write!(f, "{}", "WeightedWindmillSwitches")
            }
            FitFieldCoreExerciseName::AlternatingSlideOut => write!(f, "{}", "AlternatingSlideOut"),
            FitFieldCoreExerciseName::WeightedAlternatingSlideOut => {
                write!(f, "{}", "WeightedAlternatingSlideOut")
            }
            FitFieldCoreExerciseName::GhdBackExtensions => write!(f, "{}", "GhdBackExtensions"),
            FitFieldCoreExerciseName::WeightedGhdBackExtensions => {
                write!(f, "{}", "WeightedGhdBackExtensions")
            }
            FitFieldCoreExerciseName::OverheadWalk => write!(f, "{}", "OverheadWalk"),
            FitFieldCoreExerciseName::Inchworm => write!(f, "{}", "Inchworm"),
            FitFieldCoreExerciseName::WeightedModifiedFrontLever => {
                write!(f, "{}", "WeightedModifiedFrontLever")
            }
            FitFieldCoreExerciseName::RussianTwist => write!(f, "{}", "RussianTwist"),
            FitFieldCoreExerciseName::AbdominalLegRotations => {
                write!(f, "{}", "AbdominalLegRotations")
            }
            FitFieldCoreExerciseName::ArmAndLegExtensionOnKnees => {
                write!(f, "{}", "ArmAndLegExtensionOnKnees")
            }
            FitFieldCoreExerciseName::Bicycle => write!(f, "{}", "Bicycle"),
            FitFieldCoreExerciseName::BicepCurlWithLegExtension => {
                write!(f, "{}", "BicepCurlWithLegExtension")
            }
            FitFieldCoreExerciseName::CatCow => write!(f, "{}", "CatCow"),
            FitFieldCoreExerciseName::Corkscrew => write!(f, "{}", "Corkscrew"),
            FitFieldCoreExerciseName::CrissCross => write!(f, "{}", "CrissCross"),
            FitFieldCoreExerciseName::CrissCrossWithBall => write!(f, "{}", "CrissCrossWithBall"),
            FitFieldCoreExerciseName::DoubleLegStretch => write!(f, "{}", "DoubleLegStretch"),
            FitFieldCoreExerciseName::KneeFolds => write!(f, "{}", "KneeFolds"),
            FitFieldCoreExerciseName::LowerLift => write!(f, "{}", "LowerLift"),
            FitFieldCoreExerciseName::NeckPull => write!(f, "{}", "NeckPull"),
            FitFieldCoreExerciseName::PelvicClocks => write!(f, "{}", "PelvicClocks"),
            FitFieldCoreExerciseName::RollOver => write!(f, "{}", "RollOver"),
            FitFieldCoreExerciseName::RollUp => write!(f, "{}", "RollUp"),
            FitFieldCoreExerciseName::Rolling => write!(f, "{}", "Rolling"),
            FitFieldCoreExerciseName::Rowing1 => write!(f, "{}", "Rowing1"),
            FitFieldCoreExerciseName::Rowing2 => write!(f, "{}", "Rowing2"),
            FitFieldCoreExerciseName::Scissors => write!(f, "{}", "Scissors"),
            FitFieldCoreExerciseName::SingleLegCircles => write!(f, "{}", "SingleLegCircles"),
            FitFieldCoreExerciseName::SingleLegStretch => write!(f, "{}", "SingleLegStretch"),
            FitFieldCoreExerciseName::SnakeTwist1And2 => write!(f, "{}", "SnakeTwist1And2"),
            FitFieldCoreExerciseName::Swan => write!(f, "{}", "Swan"),
            FitFieldCoreExerciseName::Swimming => write!(f, "{}", "Swimming"),
            FitFieldCoreExerciseName::Teaser => write!(f, "{}", "Teaser"),
            FitFieldCoreExerciseName::TheHundred => write!(f, "{}", "TheHundred"),
            FitFieldCoreExerciseName::CoreExerciseName(x) => {
                write!(f, "{}({})", "CoreExerciseName", x)
            }
            FitFieldCoreExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCoreExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCoreExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCoreExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCoreExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCoreExerciseName::from(v)),
                1 => Ok(FitFieldCoreExerciseName::from(v)),
                2 => Ok(FitFieldCoreExerciseName::from(v)),
                3 => Ok(FitFieldCoreExerciseName::from(v)),
                4 => Ok(FitFieldCoreExerciseName::from(v)),
                5 => Ok(FitFieldCoreExerciseName::from(v)),
                6 => Ok(FitFieldCoreExerciseName::from(v)),
                7 => Ok(FitFieldCoreExerciseName::from(v)),
                8 => Ok(FitFieldCoreExerciseName::from(v)),
                9 => Ok(FitFieldCoreExerciseName::from(v)),
                10 => Ok(FitFieldCoreExerciseName::from(v)),
                11 => Ok(FitFieldCoreExerciseName::from(v)),
                12 => Ok(FitFieldCoreExerciseName::from(v)),
                13 => Ok(FitFieldCoreExerciseName::from(v)),
                14 => Ok(FitFieldCoreExerciseName::from(v)),
                15 => Ok(FitFieldCoreExerciseName::from(v)),
                16 => Ok(FitFieldCoreExerciseName::from(v)),
                17 => Ok(FitFieldCoreExerciseName::from(v)),
                18 => Ok(FitFieldCoreExerciseName::from(v)),
                19 => Ok(FitFieldCoreExerciseName::from(v)),
                20 => Ok(FitFieldCoreExerciseName::from(v)),
                21 => Ok(FitFieldCoreExerciseName::from(v)),
                22 => Ok(FitFieldCoreExerciseName::from(v)),
                23 => Ok(FitFieldCoreExerciseName::from(v)),
                24 => Ok(FitFieldCoreExerciseName::from(v)),
                25 => Ok(FitFieldCoreExerciseName::from(v)),
                26 => Ok(FitFieldCoreExerciseName::from(v)),
                27 => Ok(FitFieldCoreExerciseName::from(v)),
                28 => Ok(FitFieldCoreExerciseName::from(v)),
                29 => Ok(FitFieldCoreExerciseName::from(v)),
                30 => Ok(FitFieldCoreExerciseName::from(v)),
                31 => Ok(FitFieldCoreExerciseName::from(v)),
                32 => Ok(FitFieldCoreExerciseName::from(v)),
                33 => Ok(FitFieldCoreExerciseName::from(v)),
                34 => Ok(FitFieldCoreExerciseName::from(v)),
                35 => Ok(FitFieldCoreExerciseName::from(v)),
                36 => Ok(FitFieldCoreExerciseName::from(v)),
                37 => Ok(FitFieldCoreExerciseName::from(v)),
                38 => Ok(FitFieldCoreExerciseName::from(v)),
                39 => Ok(FitFieldCoreExerciseName::from(v)),
                40 => Ok(FitFieldCoreExerciseName::from(v)),
                41 => Ok(FitFieldCoreExerciseName::from(v)),
                42 => Ok(FitFieldCoreExerciseName::from(v)),
                43 => Ok(FitFieldCoreExerciseName::from(v)),
                44 => Ok(FitFieldCoreExerciseName::from(v)),
                45 => Ok(FitFieldCoreExerciseName::from(v)),
                46 => Ok(FitFieldCoreExerciseName::from(v)),
                47 => Ok(FitFieldCoreExerciseName::from(v)),
                48 => Ok(FitFieldCoreExerciseName::from(v)),
                49 => Ok(FitFieldCoreExerciseName::from(v)),
                50 => Ok(FitFieldCoreExerciseName::from(v)),
                51 => Ok(FitFieldCoreExerciseName::from(v)),
                52 => Ok(FitFieldCoreExerciseName::from(v)),
                53 => Ok(FitFieldCoreExerciseName::from(v)),
                54 => Ok(FitFieldCoreExerciseName::from(v)),
                55 => Ok(FitFieldCoreExerciseName::from(v)),
                56 => Ok(FitFieldCoreExerciseName::from(v)),
                57 => Ok(FitFieldCoreExerciseName::from(v)),
                58 => Ok(FitFieldCoreExerciseName::from(v)),
                59 => Ok(FitFieldCoreExerciseName::from(v)),
                60 => Ok(FitFieldCoreExerciseName::from(v)),
                61 => Ok(FitFieldCoreExerciseName::from(v)),
                62 => Ok(FitFieldCoreExerciseName::from(v)),
                63 => Ok(FitFieldCoreExerciseName::from(v)),
                64 => Ok(FitFieldCoreExerciseName::from(v)),
                65 => Ok(FitFieldCoreExerciseName::from(v)),
                66 => Ok(FitFieldCoreExerciseName::from(v)),
                67 => Ok(FitFieldCoreExerciseName::from(v)),
                68 => Ok(FitFieldCoreExerciseName::from(v)),
                69 => Ok(FitFieldCoreExerciseName::from(v)),
                70 => Ok(FitFieldCoreExerciseName::from(v)),
                71 => Ok(FitFieldCoreExerciseName::from(v)),
                72 => Ok(FitFieldCoreExerciseName::from(v)),
                v => Ok(FitFieldCoreExerciseName::CoreExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCoreExerciseName);

impl From<u16> for FitFieldCoreExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCoreExerciseName::AbsJabs,
            1 => FitFieldCoreExerciseName::WeightedAbsJabs,
            2 => FitFieldCoreExerciseName::AlternatingPlateReach,
            3 => FitFieldCoreExerciseName::BarbellRollout,
            4 => FitFieldCoreExerciseName::WeightedBarbellRollout,
            5 => FitFieldCoreExerciseName::BodyBarObliqueTwist,
            6 => FitFieldCoreExerciseName::CableCorePress,
            7 => FitFieldCoreExerciseName::CableSideBend,
            8 => FitFieldCoreExerciseName::SideBend,
            9 => FitFieldCoreExerciseName::WeightedSideBend,
            10 => FitFieldCoreExerciseName::CrescentCircle,
            11 => FitFieldCoreExerciseName::WeightedCrescentCircle,
            12 => FitFieldCoreExerciseName::CyclingRussianTwist,
            13 => FitFieldCoreExerciseName::WeightedCyclingRussianTwist,
            14 => FitFieldCoreExerciseName::ElevatedFeetRussianTwist,
            15 => FitFieldCoreExerciseName::WeightedElevatedFeetRussianTwist,
            16 => FitFieldCoreExerciseName::HalfTurkishGetUp,
            17 => FitFieldCoreExerciseName::KettlebellWindmill,
            18 => FitFieldCoreExerciseName::KneelingAbWheel,
            19 => FitFieldCoreExerciseName::WeightedKneelingAbWheel,
            20 => FitFieldCoreExerciseName::ModifiedFrontLever,
            21 => FitFieldCoreExerciseName::OpenKneeTucks,
            22 => FitFieldCoreExerciseName::WeightedOpenKneeTucks,
            23 => FitFieldCoreExerciseName::SideAbsLegLift,
            24 => FitFieldCoreExerciseName::WeightedSideAbsLegLift,
            25 => FitFieldCoreExerciseName::SwissBallJackknife,
            26 => FitFieldCoreExerciseName::WeightedSwissBallJackknife,
            27 => FitFieldCoreExerciseName::SwissBallPike,
            28 => FitFieldCoreExerciseName::WeightedSwissBallPike,
            29 => FitFieldCoreExerciseName::SwissBallRollout,
            30 => FitFieldCoreExerciseName::WeightedSwissBallRollout,
            31 => FitFieldCoreExerciseName::TriangleHipPress,
            32 => FitFieldCoreExerciseName::WeightedTriangleHipPress,
            33 => FitFieldCoreExerciseName::TrxSuspendedJackknife,
            34 => FitFieldCoreExerciseName::WeightedTrxSuspendedJackknife,
            35 => FitFieldCoreExerciseName::UBoat,
            36 => FitFieldCoreExerciseName::WeightedUBoat,
            37 => FitFieldCoreExerciseName::WindmillSwitches,
            38 => FitFieldCoreExerciseName::WeightedWindmillSwitches,
            39 => FitFieldCoreExerciseName::AlternatingSlideOut,
            40 => FitFieldCoreExerciseName::WeightedAlternatingSlideOut,
            41 => FitFieldCoreExerciseName::GhdBackExtensions,
            42 => FitFieldCoreExerciseName::WeightedGhdBackExtensions,
            43 => FitFieldCoreExerciseName::OverheadWalk,
            44 => FitFieldCoreExerciseName::Inchworm,
            45 => FitFieldCoreExerciseName::WeightedModifiedFrontLever,
            46 => FitFieldCoreExerciseName::RussianTwist,
            47 => FitFieldCoreExerciseName::AbdominalLegRotations,
            48 => FitFieldCoreExerciseName::ArmAndLegExtensionOnKnees,
            49 => FitFieldCoreExerciseName::Bicycle,
            50 => FitFieldCoreExerciseName::BicepCurlWithLegExtension,
            51 => FitFieldCoreExerciseName::CatCow,
            52 => FitFieldCoreExerciseName::Corkscrew,
            53 => FitFieldCoreExerciseName::CrissCross,
            54 => FitFieldCoreExerciseName::CrissCrossWithBall,
            55 => FitFieldCoreExerciseName::DoubleLegStretch,
            56 => FitFieldCoreExerciseName::KneeFolds,
            57 => FitFieldCoreExerciseName::LowerLift,
            58 => FitFieldCoreExerciseName::NeckPull,
            59 => FitFieldCoreExerciseName::PelvicClocks,
            60 => FitFieldCoreExerciseName::RollOver,
            61 => FitFieldCoreExerciseName::RollUp,
            62 => FitFieldCoreExerciseName::Rolling,
            63 => FitFieldCoreExerciseName::Rowing1,
            64 => FitFieldCoreExerciseName::Rowing2,
            65 => FitFieldCoreExerciseName::Scissors,
            66 => FitFieldCoreExerciseName::SingleLegCircles,
            67 => FitFieldCoreExerciseName::SingleLegStretch,
            68 => FitFieldCoreExerciseName::SnakeTwist1And2,
            69 => FitFieldCoreExerciseName::Swan,
            70 => FitFieldCoreExerciseName::Swimming,
            71 => FitFieldCoreExerciseName::Teaser,
            72 => FitFieldCoreExerciseName::TheHundred,
            _ => FitFieldCoreExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCrunchExerciseName {
    // fit base type: uint16
    BicycleCrunch,                           // 0
    CableCrunch,                             // 1
    CircularArmCrunch,                       // 2
    CrossedArmsCrunch,                       // 3
    WeightedCrossedArmsCrunch,               // 4
    CrossLegReverseCrunch,                   // 5
    WeightedCrossLegReverseCrunch,           // 6
    CrunchChop,                              // 7
    WeightedCrunchChop,                      // 8
    DoubleCrunch,                            // 9
    WeightedDoubleCrunch,                    // 10
    ElbowToKneeCrunch,                       // 11
    WeightedElbowToKneeCrunch,               // 12
    FlutterKicks,                            // 13
    WeightedFlutterKicks,                    // 14
    FoamRollerReverseCrunchOnBench,          // 15
    WeightedFoamRollerReverseCrunchOnBench,  // 16
    FoamRollerReverseCrunchWithDumbbell,     // 17
    FoamRollerReverseCrunchWithMedicineBall, // 18
    FrogPress,                               // 19
    HangingKneeRaiseObliqueCrunch,           // 20
    WeightedHangingKneeRaiseObliqueCrunch,   // 21
    HipCrossover,                            // 22
    WeightedHipCrossover,                    // 23
    HollowRock,                              // 24
    WeightedHollowRock,                      // 25
    InclineReverseCrunch,                    // 26
    WeightedInclineReverseCrunch,            // 27
    KneelingCableCrunch,                     // 28
    KneelingCrossCrunch,                     // 29
    WeightedKneelingCrossCrunch,             // 30
    KneelingObliqueCableCrunch,              // 31
    KneesToElbow,                            // 32
    LegExtensions,                           // 33
    WeightedLegExtensions,                   // 34
    LegLevers,                               // 35
    McgillCurlUp,                            // 36
    WeightedMcgillCurlUp,                    // 37
    ModifiedPilatesRollUpWithBall,           // 38
    WeightedModifiedPilatesRollUpWithBall,   // 39
    PilatesCrunch,                           // 40
    WeightedPilatesCrunch,                   // 41
    PilatesRollUpWithBall,                   // 42
    WeightedPilatesRollUpWithBall,           // 43
    RaisedLegsCrunch,                        // 44
    WeightedRaisedLegsCrunch,                // 45
    ReverseCrunch,                           // 46
    WeightedReverseCrunch,                   // 47
    ReverseCrunchOnABench,                   // 48
    WeightedReverseCrunchOnABench,           // 49
    ReverseCurlAndLift,                      // 50
    WeightedReverseCurlAndLift,              // 51
    RotationalLift,                          // 52
    WeightedRotationalLift,                  // 53
    SeatedAlternatingReverseCrunch,          // 54
    WeightedSeatedAlternatingReverseCrunch,  // 55
    SeatedLegU,                              // 56
    WeightedSeatedLegU,                      // 57
    SideToSideCrunchAndWeave,                // 58
    WeightedSideToSideCrunchAndWeave,        // 59
    SingleLegReverseCrunch,                  // 60
    WeightedSingleLegReverseCrunch,          // 61
    SkaterCrunchCross,                       // 62
    WeightedSkaterCrunchCross,               // 63
    StandingCableCrunch,                     // 64
    StandingSideCrunch,                      // 65
    StepClimb,                               // 66
    WeightedStepClimb,                       // 67
    SwissBallCrunch,                         // 68
    SwissBallReverseCrunch,                  // 69
    WeightedSwissBallReverseCrunch,          // 70
    SwissBallRussianTwist,                   // 71
    WeightedSwissBallRussianTwist,           // 72
    SwissBallSideCrunch,                     // 73
    WeightedSwissBallSideCrunch,             // 74
    ThoracicCrunchesOnFoamRoller,            // 75
    WeightedThoracicCrunchesOnFoamRoller,    // 76
    TricepsCrunch,                           // 77
    WeightedBicycleCrunch,                   // 78
    WeightedCrunch,                          // 79
    WeightedSwissBallCrunch,                 // 80
    ToesToBar,                               // 81
    WeightedToesToBar,                       // 82
    Crunch,                                  // 83
    StraightLegCrunchWithBall,               // 84
    CrunchExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCrunchExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCrunchExerciseName::BicycleCrunch => write!(f, "{}", "BicycleCrunch"),
            FitFieldCrunchExerciseName::CableCrunch => write!(f, "{}", "CableCrunch"),
            FitFieldCrunchExerciseName::CircularArmCrunch => write!(f, "{}", "CircularArmCrunch"),
            FitFieldCrunchExerciseName::CrossedArmsCrunch => write!(f, "{}", "CrossedArmsCrunch"),
            FitFieldCrunchExerciseName::WeightedCrossedArmsCrunch => {
                write!(f, "{}", "WeightedCrossedArmsCrunch")
            }
            FitFieldCrunchExerciseName::CrossLegReverseCrunch => {
                write!(f, "{}", "CrossLegReverseCrunch")
            }
            FitFieldCrunchExerciseName::WeightedCrossLegReverseCrunch => {
                write!(f, "{}", "WeightedCrossLegReverseCrunch")
            }
            FitFieldCrunchExerciseName::CrunchChop => write!(f, "{}", "CrunchChop"),
            FitFieldCrunchExerciseName::WeightedCrunchChop => write!(f, "{}", "WeightedCrunchChop"),
            FitFieldCrunchExerciseName::DoubleCrunch => write!(f, "{}", "DoubleCrunch"),
            FitFieldCrunchExerciseName::WeightedDoubleCrunch => {
                write!(f, "{}", "WeightedDoubleCrunch")
            }
            FitFieldCrunchExerciseName::ElbowToKneeCrunch => write!(f, "{}", "ElbowToKneeCrunch"),
            FitFieldCrunchExerciseName::WeightedElbowToKneeCrunch => {
                write!(f, "{}", "WeightedElbowToKneeCrunch")
            }
            FitFieldCrunchExerciseName::FlutterKicks => write!(f, "{}", "FlutterKicks"),
            FitFieldCrunchExerciseName::WeightedFlutterKicks => {
                write!(f, "{}", "WeightedFlutterKicks")
            }
            FitFieldCrunchExerciseName::FoamRollerReverseCrunchOnBench => {
                write!(f, "{}", "FoamRollerReverseCrunchOnBench")
            }
            FitFieldCrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench => {
                write!(f, "{}", "WeightedFoamRollerReverseCrunchOnBench")
            }
            FitFieldCrunchExerciseName::FoamRollerReverseCrunchWithDumbbell => {
                write!(f, "{}", "FoamRollerReverseCrunchWithDumbbell")
            }
            FitFieldCrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall => {
                write!(f, "{}", "FoamRollerReverseCrunchWithMedicineBall")
            }
            FitFieldCrunchExerciseName::FrogPress => write!(f, "{}", "FrogPress"),
            FitFieldCrunchExerciseName::HangingKneeRaiseObliqueCrunch => {
                write!(f, "{}", "HangingKneeRaiseObliqueCrunch")
            }
            FitFieldCrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch => {
                write!(f, "{}", "WeightedHangingKneeRaiseObliqueCrunch")
            }
            FitFieldCrunchExerciseName::HipCrossover => write!(f, "{}", "HipCrossover"),
            FitFieldCrunchExerciseName::WeightedHipCrossover => {
                write!(f, "{}", "WeightedHipCrossover")
            }
            FitFieldCrunchExerciseName::HollowRock => write!(f, "{}", "HollowRock"),
            FitFieldCrunchExerciseName::WeightedHollowRock => write!(f, "{}", "WeightedHollowRock"),
            FitFieldCrunchExerciseName::InclineReverseCrunch => {
                write!(f, "{}", "InclineReverseCrunch")
            }
            FitFieldCrunchExerciseName::WeightedInclineReverseCrunch => {
                write!(f, "{}", "WeightedInclineReverseCrunch")
            }
            FitFieldCrunchExerciseName::KneelingCableCrunch => {
                write!(f, "{}", "KneelingCableCrunch")
            }
            FitFieldCrunchExerciseName::KneelingCrossCrunch => {
                write!(f, "{}", "KneelingCrossCrunch")
            }
            FitFieldCrunchExerciseName::WeightedKneelingCrossCrunch => {
                write!(f, "{}", "WeightedKneelingCrossCrunch")
            }
            FitFieldCrunchExerciseName::KneelingObliqueCableCrunch => {
                write!(f, "{}", "KneelingObliqueCableCrunch")
            }
            FitFieldCrunchExerciseName::KneesToElbow => write!(f, "{}", "KneesToElbow"),
            FitFieldCrunchExerciseName::LegExtensions => write!(f, "{}", "LegExtensions"),
            FitFieldCrunchExerciseName::WeightedLegExtensions => {
                write!(f, "{}", "WeightedLegExtensions")
            }
            FitFieldCrunchExerciseName::LegLevers => write!(f, "{}", "LegLevers"),
            FitFieldCrunchExerciseName::McgillCurlUp => write!(f, "{}", "McgillCurlUp"),
            FitFieldCrunchExerciseName::WeightedMcgillCurlUp => {
                write!(f, "{}", "WeightedMcgillCurlUp")
            }
            FitFieldCrunchExerciseName::ModifiedPilatesRollUpWithBall => {
                write!(f, "{}", "ModifiedPilatesRollUpWithBall")
            }
            FitFieldCrunchExerciseName::WeightedModifiedPilatesRollUpWithBall => {
                write!(f, "{}", "WeightedModifiedPilatesRollUpWithBall")
            }
            FitFieldCrunchExerciseName::PilatesCrunch => write!(f, "{}", "PilatesCrunch"),
            FitFieldCrunchExerciseName::WeightedPilatesCrunch => {
                write!(f, "{}", "WeightedPilatesCrunch")
            }
            FitFieldCrunchExerciseName::PilatesRollUpWithBall => {
                write!(f, "{}", "PilatesRollUpWithBall")
            }
            FitFieldCrunchExerciseName::WeightedPilatesRollUpWithBall => {
                write!(f, "{}", "WeightedPilatesRollUpWithBall")
            }
            FitFieldCrunchExerciseName::RaisedLegsCrunch => write!(f, "{}", "RaisedLegsCrunch"),
            FitFieldCrunchExerciseName::WeightedRaisedLegsCrunch => {
                write!(f, "{}", "WeightedRaisedLegsCrunch")
            }
            FitFieldCrunchExerciseName::ReverseCrunch => write!(f, "{}", "ReverseCrunch"),
            FitFieldCrunchExerciseName::WeightedReverseCrunch => {
                write!(f, "{}", "WeightedReverseCrunch")
            }
            FitFieldCrunchExerciseName::ReverseCrunchOnABench => {
                write!(f, "{}", "ReverseCrunchOnABench")
            }
            FitFieldCrunchExerciseName::WeightedReverseCrunchOnABench => {
                write!(f, "{}", "WeightedReverseCrunchOnABench")
            }
            FitFieldCrunchExerciseName::ReverseCurlAndLift => write!(f, "{}", "ReverseCurlAndLift"),
            FitFieldCrunchExerciseName::WeightedReverseCurlAndLift => {
                write!(f, "{}", "WeightedReverseCurlAndLift")
            }
            FitFieldCrunchExerciseName::RotationalLift => write!(f, "{}", "RotationalLift"),
            FitFieldCrunchExerciseName::WeightedRotationalLift => {
                write!(f, "{}", "WeightedRotationalLift")
            }
            FitFieldCrunchExerciseName::SeatedAlternatingReverseCrunch => {
                write!(f, "{}", "SeatedAlternatingReverseCrunch")
            }
            FitFieldCrunchExerciseName::WeightedSeatedAlternatingReverseCrunch => {
                write!(f, "{}", "WeightedSeatedAlternatingReverseCrunch")
            }
            FitFieldCrunchExerciseName::SeatedLegU => write!(f, "{}", "SeatedLegU"),
            FitFieldCrunchExerciseName::WeightedSeatedLegU => write!(f, "{}", "WeightedSeatedLegU"),
            FitFieldCrunchExerciseName::SideToSideCrunchAndWeave => {
                write!(f, "{}", "SideToSideCrunchAndWeave")
            }
            FitFieldCrunchExerciseName::WeightedSideToSideCrunchAndWeave => {
                write!(f, "{}", "WeightedSideToSideCrunchAndWeave")
            }
            FitFieldCrunchExerciseName::SingleLegReverseCrunch => {
                write!(f, "{}", "SingleLegReverseCrunch")
            }
            FitFieldCrunchExerciseName::WeightedSingleLegReverseCrunch => {
                write!(f, "{}", "WeightedSingleLegReverseCrunch")
            }
            FitFieldCrunchExerciseName::SkaterCrunchCross => write!(f, "{}", "SkaterCrunchCross"),
            FitFieldCrunchExerciseName::WeightedSkaterCrunchCross => {
                write!(f, "{}", "WeightedSkaterCrunchCross")
            }
            FitFieldCrunchExerciseName::StandingCableCrunch => {
                write!(f, "{}", "StandingCableCrunch")
            }
            FitFieldCrunchExerciseName::StandingSideCrunch => write!(f, "{}", "StandingSideCrunch"),
            FitFieldCrunchExerciseName::StepClimb => write!(f, "{}", "StepClimb"),
            FitFieldCrunchExerciseName::WeightedStepClimb => write!(f, "{}", "WeightedStepClimb"),
            FitFieldCrunchExerciseName::SwissBallCrunch => write!(f, "{}", "SwissBallCrunch"),
            FitFieldCrunchExerciseName::SwissBallReverseCrunch => {
                write!(f, "{}", "SwissBallReverseCrunch")
            }
            FitFieldCrunchExerciseName::WeightedSwissBallReverseCrunch => {
                write!(f, "{}", "WeightedSwissBallReverseCrunch")
            }
            FitFieldCrunchExerciseName::SwissBallRussianTwist => {
                write!(f, "{}", "SwissBallRussianTwist")
            }
            FitFieldCrunchExerciseName::WeightedSwissBallRussianTwist => {
                write!(f, "{}", "WeightedSwissBallRussianTwist")
            }
            FitFieldCrunchExerciseName::SwissBallSideCrunch => {
                write!(f, "{}", "SwissBallSideCrunch")
            }
            FitFieldCrunchExerciseName::WeightedSwissBallSideCrunch => {
                write!(f, "{}", "WeightedSwissBallSideCrunch")
            }
            FitFieldCrunchExerciseName::ThoracicCrunchesOnFoamRoller => {
                write!(f, "{}", "ThoracicCrunchesOnFoamRoller")
            }
            FitFieldCrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller => {
                write!(f, "{}", "WeightedThoracicCrunchesOnFoamRoller")
            }
            FitFieldCrunchExerciseName::TricepsCrunch => write!(f, "{}", "TricepsCrunch"),
            FitFieldCrunchExerciseName::WeightedBicycleCrunch => {
                write!(f, "{}", "WeightedBicycleCrunch")
            }
            FitFieldCrunchExerciseName::WeightedCrunch => write!(f, "{}", "WeightedCrunch"),
            FitFieldCrunchExerciseName::WeightedSwissBallCrunch => {
                write!(f, "{}", "WeightedSwissBallCrunch")
            }
            FitFieldCrunchExerciseName::ToesToBar => write!(f, "{}", "ToesToBar"),
            FitFieldCrunchExerciseName::WeightedToesToBar => write!(f, "{}", "WeightedToesToBar"),
            FitFieldCrunchExerciseName::Crunch => write!(f, "{}", "Crunch"),
            FitFieldCrunchExerciseName::StraightLegCrunchWithBall => {
                write!(f, "{}", "StraightLegCrunchWithBall")
            }
            FitFieldCrunchExerciseName::CrunchExerciseName(x) => {
                write!(f, "{}({})", "CrunchExerciseName", x)
            }
            FitFieldCrunchExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCrunchExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCrunchExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCrunchExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCrunchExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCrunchExerciseName::from(v)),
                1 => Ok(FitFieldCrunchExerciseName::from(v)),
                2 => Ok(FitFieldCrunchExerciseName::from(v)),
                3 => Ok(FitFieldCrunchExerciseName::from(v)),
                4 => Ok(FitFieldCrunchExerciseName::from(v)),
                5 => Ok(FitFieldCrunchExerciseName::from(v)),
                6 => Ok(FitFieldCrunchExerciseName::from(v)),
                7 => Ok(FitFieldCrunchExerciseName::from(v)),
                8 => Ok(FitFieldCrunchExerciseName::from(v)),
                9 => Ok(FitFieldCrunchExerciseName::from(v)),
                10 => Ok(FitFieldCrunchExerciseName::from(v)),
                11 => Ok(FitFieldCrunchExerciseName::from(v)),
                12 => Ok(FitFieldCrunchExerciseName::from(v)),
                13 => Ok(FitFieldCrunchExerciseName::from(v)),
                14 => Ok(FitFieldCrunchExerciseName::from(v)),
                15 => Ok(FitFieldCrunchExerciseName::from(v)),
                16 => Ok(FitFieldCrunchExerciseName::from(v)),
                17 => Ok(FitFieldCrunchExerciseName::from(v)),
                18 => Ok(FitFieldCrunchExerciseName::from(v)),
                19 => Ok(FitFieldCrunchExerciseName::from(v)),
                20 => Ok(FitFieldCrunchExerciseName::from(v)),
                21 => Ok(FitFieldCrunchExerciseName::from(v)),
                22 => Ok(FitFieldCrunchExerciseName::from(v)),
                23 => Ok(FitFieldCrunchExerciseName::from(v)),
                24 => Ok(FitFieldCrunchExerciseName::from(v)),
                25 => Ok(FitFieldCrunchExerciseName::from(v)),
                26 => Ok(FitFieldCrunchExerciseName::from(v)),
                27 => Ok(FitFieldCrunchExerciseName::from(v)),
                28 => Ok(FitFieldCrunchExerciseName::from(v)),
                29 => Ok(FitFieldCrunchExerciseName::from(v)),
                30 => Ok(FitFieldCrunchExerciseName::from(v)),
                31 => Ok(FitFieldCrunchExerciseName::from(v)),
                32 => Ok(FitFieldCrunchExerciseName::from(v)),
                33 => Ok(FitFieldCrunchExerciseName::from(v)),
                34 => Ok(FitFieldCrunchExerciseName::from(v)),
                35 => Ok(FitFieldCrunchExerciseName::from(v)),
                36 => Ok(FitFieldCrunchExerciseName::from(v)),
                37 => Ok(FitFieldCrunchExerciseName::from(v)),
                38 => Ok(FitFieldCrunchExerciseName::from(v)),
                39 => Ok(FitFieldCrunchExerciseName::from(v)),
                40 => Ok(FitFieldCrunchExerciseName::from(v)),
                41 => Ok(FitFieldCrunchExerciseName::from(v)),
                42 => Ok(FitFieldCrunchExerciseName::from(v)),
                43 => Ok(FitFieldCrunchExerciseName::from(v)),
                44 => Ok(FitFieldCrunchExerciseName::from(v)),
                45 => Ok(FitFieldCrunchExerciseName::from(v)),
                46 => Ok(FitFieldCrunchExerciseName::from(v)),
                47 => Ok(FitFieldCrunchExerciseName::from(v)),
                48 => Ok(FitFieldCrunchExerciseName::from(v)),
                49 => Ok(FitFieldCrunchExerciseName::from(v)),
                50 => Ok(FitFieldCrunchExerciseName::from(v)),
                51 => Ok(FitFieldCrunchExerciseName::from(v)),
                52 => Ok(FitFieldCrunchExerciseName::from(v)),
                53 => Ok(FitFieldCrunchExerciseName::from(v)),
                54 => Ok(FitFieldCrunchExerciseName::from(v)),
                55 => Ok(FitFieldCrunchExerciseName::from(v)),
                56 => Ok(FitFieldCrunchExerciseName::from(v)),
                57 => Ok(FitFieldCrunchExerciseName::from(v)),
                58 => Ok(FitFieldCrunchExerciseName::from(v)),
                59 => Ok(FitFieldCrunchExerciseName::from(v)),
                60 => Ok(FitFieldCrunchExerciseName::from(v)),
                61 => Ok(FitFieldCrunchExerciseName::from(v)),
                62 => Ok(FitFieldCrunchExerciseName::from(v)),
                63 => Ok(FitFieldCrunchExerciseName::from(v)),
                64 => Ok(FitFieldCrunchExerciseName::from(v)),
                65 => Ok(FitFieldCrunchExerciseName::from(v)),
                66 => Ok(FitFieldCrunchExerciseName::from(v)),
                67 => Ok(FitFieldCrunchExerciseName::from(v)),
                68 => Ok(FitFieldCrunchExerciseName::from(v)),
                69 => Ok(FitFieldCrunchExerciseName::from(v)),
                70 => Ok(FitFieldCrunchExerciseName::from(v)),
                71 => Ok(FitFieldCrunchExerciseName::from(v)),
                72 => Ok(FitFieldCrunchExerciseName::from(v)),
                73 => Ok(FitFieldCrunchExerciseName::from(v)),
                74 => Ok(FitFieldCrunchExerciseName::from(v)),
                75 => Ok(FitFieldCrunchExerciseName::from(v)),
                76 => Ok(FitFieldCrunchExerciseName::from(v)),
                77 => Ok(FitFieldCrunchExerciseName::from(v)),
                78 => Ok(FitFieldCrunchExerciseName::from(v)),
                79 => Ok(FitFieldCrunchExerciseName::from(v)),
                80 => Ok(FitFieldCrunchExerciseName::from(v)),
                81 => Ok(FitFieldCrunchExerciseName::from(v)),
                82 => Ok(FitFieldCrunchExerciseName::from(v)),
                83 => Ok(FitFieldCrunchExerciseName::from(v)),
                84 => Ok(FitFieldCrunchExerciseName::from(v)),
                v => Ok(FitFieldCrunchExerciseName::CrunchExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCrunchExerciseName);

impl From<u16> for FitFieldCrunchExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCrunchExerciseName::BicycleCrunch,
            1 => FitFieldCrunchExerciseName::CableCrunch,
            2 => FitFieldCrunchExerciseName::CircularArmCrunch,
            3 => FitFieldCrunchExerciseName::CrossedArmsCrunch,
            4 => FitFieldCrunchExerciseName::WeightedCrossedArmsCrunch,
            5 => FitFieldCrunchExerciseName::CrossLegReverseCrunch,
            6 => FitFieldCrunchExerciseName::WeightedCrossLegReverseCrunch,
            7 => FitFieldCrunchExerciseName::CrunchChop,
            8 => FitFieldCrunchExerciseName::WeightedCrunchChop,
            9 => FitFieldCrunchExerciseName::DoubleCrunch,
            10 => FitFieldCrunchExerciseName::WeightedDoubleCrunch,
            11 => FitFieldCrunchExerciseName::ElbowToKneeCrunch,
            12 => FitFieldCrunchExerciseName::WeightedElbowToKneeCrunch,
            13 => FitFieldCrunchExerciseName::FlutterKicks,
            14 => FitFieldCrunchExerciseName::WeightedFlutterKicks,
            15 => FitFieldCrunchExerciseName::FoamRollerReverseCrunchOnBench,
            16 => FitFieldCrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench,
            17 => FitFieldCrunchExerciseName::FoamRollerReverseCrunchWithDumbbell,
            18 => FitFieldCrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall,
            19 => FitFieldCrunchExerciseName::FrogPress,
            20 => FitFieldCrunchExerciseName::HangingKneeRaiseObliqueCrunch,
            21 => FitFieldCrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch,
            22 => FitFieldCrunchExerciseName::HipCrossover,
            23 => FitFieldCrunchExerciseName::WeightedHipCrossover,
            24 => FitFieldCrunchExerciseName::HollowRock,
            25 => FitFieldCrunchExerciseName::WeightedHollowRock,
            26 => FitFieldCrunchExerciseName::InclineReverseCrunch,
            27 => FitFieldCrunchExerciseName::WeightedInclineReverseCrunch,
            28 => FitFieldCrunchExerciseName::KneelingCableCrunch,
            29 => FitFieldCrunchExerciseName::KneelingCrossCrunch,
            30 => FitFieldCrunchExerciseName::WeightedKneelingCrossCrunch,
            31 => FitFieldCrunchExerciseName::KneelingObliqueCableCrunch,
            32 => FitFieldCrunchExerciseName::KneesToElbow,
            33 => FitFieldCrunchExerciseName::LegExtensions,
            34 => FitFieldCrunchExerciseName::WeightedLegExtensions,
            35 => FitFieldCrunchExerciseName::LegLevers,
            36 => FitFieldCrunchExerciseName::McgillCurlUp,
            37 => FitFieldCrunchExerciseName::WeightedMcgillCurlUp,
            38 => FitFieldCrunchExerciseName::ModifiedPilatesRollUpWithBall,
            39 => FitFieldCrunchExerciseName::WeightedModifiedPilatesRollUpWithBall,
            40 => FitFieldCrunchExerciseName::PilatesCrunch,
            41 => FitFieldCrunchExerciseName::WeightedPilatesCrunch,
            42 => FitFieldCrunchExerciseName::PilatesRollUpWithBall,
            43 => FitFieldCrunchExerciseName::WeightedPilatesRollUpWithBall,
            44 => FitFieldCrunchExerciseName::RaisedLegsCrunch,
            45 => FitFieldCrunchExerciseName::WeightedRaisedLegsCrunch,
            46 => FitFieldCrunchExerciseName::ReverseCrunch,
            47 => FitFieldCrunchExerciseName::WeightedReverseCrunch,
            48 => FitFieldCrunchExerciseName::ReverseCrunchOnABench,
            49 => FitFieldCrunchExerciseName::WeightedReverseCrunchOnABench,
            50 => FitFieldCrunchExerciseName::ReverseCurlAndLift,
            51 => FitFieldCrunchExerciseName::WeightedReverseCurlAndLift,
            52 => FitFieldCrunchExerciseName::RotationalLift,
            53 => FitFieldCrunchExerciseName::WeightedRotationalLift,
            54 => FitFieldCrunchExerciseName::SeatedAlternatingReverseCrunch,
            55 => FitFieldCrunchExerciseName::WeightedSeatedAlternatingReverseCrunch,
            56 => FitFieldCrunchExerciseName::SeatedLegU,
            57 => FitFieldCrunchExerciseName::WeightedSeatedLegU,
            58 => FitFieldCrunchExerciseName::SideToSideCrunchAndWeave,
            59 => FitFieldCrunchExerciseName::WeightedSideToSideCrunchAndWeave,
            60 => FitFieldCrunchExerciseName::SingleLegReverseCrunch,
            61 => FitFieldCrunchExerciseName::WeightedSingleLegReverseCrunch,
            62 => FitFieldCrunchExerciseName::SkaterCrunchCross,
            63 => FitFieldCrunchExerciseName::WeightedSkaterCrunchCross,
            64 => FitFieldCrunchExerciseName::StandingCableCrunch,
            65 => FitFieldCrunchExerciseName::StandingSideCrunch,
            66 => FitFieldCrunchExerciseName::StepClimb,
            67 => FitFieldCrunchExerciseName::WeightedStepClimb,
            68 => FitFieldCrunchExerciseName::SwissBallCrunch,
            69 => FitFieldCrunchExerciseName::SwissBallReverseCrunch,
            70 => FitFieldCrunchExerciseName::WeightedSwissBallReverseCrunch,
            71 => FitFieldCrunchExerciseName::SwissBallRussianTwist,
            72 => FitFieldCrunchExerciseName::WeightedSwissBallRussianTwist,
            73 => FitFieldCrunchExerciseName::SwissBallSideCrunch,
            74 => FitFieldCrunchExerciseName::WeightedSwissBallSideCrunch,
            75 => FitFieldCrunchExerciseName::ThoracicCrunchesOnFoamRoller,
            76 => FitFieldCrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller,
            77 => FitFieldCrunchExerciseName::TricepsCrunch,
            78 => FitFieldCrunchExerciseName::WeightedBicycleCrunch,
            79 => FitFieldCrunchExerciseName::WeightedCrunch,
            80 => FitFieldCrunchExerciseName::WeightedSwissBallCrunch,
            81 => FitFieldCrunchExerciseName::ToesToBar,
            82 => FitFieldCrunchExerciseName::WeightedToesToBar,
            83 => FitFieldCrunchExerciseName::Crunch,
            84 => FitFieldCrunchExerciseName::StraightLegCrunchWithBall,
            _ => FitFieldCrunchExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldCurlExerciseName {
    // fit base type: uint16
    AlternatingDumbbellBicepsCurl,             // 0
    AlternatingDumbbellBicepsCurlOnSwissBall,  // 1
    AlternatingInclineDumbbellBicepsCurl,      // 2
    BarbellBicepsCurl,                         // 3
    BarbellReverseWristCurl,                   // 4
    BarbellWristCurl,                          // 5
    BehindTheBackBarbellReverseWristCurl,      // 6
    BehindTheBackOneArmCableCurl,              // 7
    CableBicepsCurl,                           // 8
    CableHammerCurl,                           // 9
    CheatingBarbellBicepsCurl,                 // 10
    CloseGripEzBarBicepsCurl,                  // 11
    CrossBodyDumbbellHammerCurl,               // 12
    DeadHangBicepsCurl,                        // 13
    DeclineHammerCurl,                         // 14
    DumbbellBicepsCurlWithStaticHold,          // 15
    DumbbellHammerCurl,                        // 16
    DumbbellReverseWristCurl,                  // 17
    DumbbellWristCurl,                         // 18
    EzBarPreacherCurl,                         // 19
    ForwardBendBicepsCurl,                     // 20
    HammerCurlToPress,                         // 21
    InclineDumbbellBicepsCurl,                 // 22
    InclineOffsetThumbDumbbellCurl,            // 23
    KettlebellBicepsCurl,                      // 24
    LyingConcentrationCableCurl,               // 25
    OneArmPreacherCurl,                        // 26
    PlatePinchCurl,                            // 27
    PreacherCurlWithCable,                     // 28
    ReverseEzBarCurl,                          // 29
    ReverseGripWristCurl,                      // 30
    ReverseGripBarbellBicepsCurl,              // 31
    SeatedAlternatingDumbbellBicepsCurl,       // 32
    SeatedDumbbellBicepsCurl,                  // 33
    SeatedReverseDumbbellCurl,                 // 34
    SplitStanceOffsetPinkyDumbbellCurl,        // 35
    StandingAlternatingDumbbellCurls,          // 36
    StandingDumbbellBicepsCurl,                // 37
    StandingEzBarBicepsCurl,                   // 38
    StaticCurl,                                // 39
    SwissBallDumbbellOverheadTricepsExtension, // 40
    SwissBallEzBarPreacherCurl,                // 41
    TwistingStandingDumbbellBicepsCurl,        // 42
    WideGripEzBarBicepsCurl,                   // 43
    CurlExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldCurlExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldCurlExerciseName::AlternatingDumbbellBicepsCurl => {
                write!(f, "{}", "AlternatingDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall => {
                write!(f, "{}", "AlternatingDumbbellBicepsCurlOnSwissBall")
            }
            FitFieldCurlExerciseName::AlternatingInclineDumbbellBicepsCurl => {
                write!(f, "{}", "AlternatingInclineDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::BarbellBicepsCurl => write!(f, "{}", "BarbellBicepsCurl"),
            FitFieldCurlExerciseName::BarbellReverseWristCurl => {
                write!(f, "{}", "BarbellReverseWristCurl")
            }
            FitFieldCurlExerciseName::BarbellWristCurl => write!(f, "{}", "BarbellWristCurl"),
            FitFieldCurlExerciseName::BehindTheBackBarbellReverseWristCurl => {
                write!(f, "{}", "BehindTheBackBarbellReverseWristCurl")
            }
            FitFieldCurlExerciseName::BehindTheBackOneArmCableCurl => {
                write!(f, "{}", "BehindTheBackOneArmCableCurl")
            }
            FitFieldCurlExerciseName::CableBicepsCurl => write!(f, "{}", "CableBicepsCurl"),
            FitFieldCurlExerciseName::CableHammerCurl => write!(f, "{}", "CableHammerCurl"),
            FitFieldCurlExerciseName::CheatingBarbellBicepsCurl => {
                write!(f, "{}", "CheatingBarbellBicepsCurl")
            }
            FitFieldCurlExerciseName::CloseGripEzBarBicepsCurl => {
                write!(f, "{}", "CloseGripEzBarBicepsCurl")
            }
            FitFieldCurlExerciseName::CrossBodyDumbbellHammerCurl => {
                write!(f, "{}", "CrossBodyDumbbellHammerCurl")
            }
            FitFieldCurlExerciseName::DeadHangBicepsCurl => write!(f, "{}", "DeadHangBicepsCurl"),
            FitFieldCurlExerciseName::DeclineHammerCurl => write!(f, "{}", "DeclineHammerCurl"),
            FitFieldCurlExerciseName::DumbbellBicepsCurlWithStaticHold => {
                write!(f, "{}", "DumbbellBicepsCurlWithStaticHold")
            }
            FitFieldCurlExerciseName::DumbbellHammerCurl => write!(f, "{}", "DumbbellHammerCurl"),
            FitFieldCurlExerciseName::DumbbellReverseWristCurl => {
                write!(f, "{}", "DumbbellReverseWristCurl")
            }
            FitFieldCurlExerciseName::DumbbellWristCurl => write!(f, "{}", "DumbbellWristCurl"),
            FitFieldCurlExerciseName::EzBarPreacherCurl => write!(f, "{}", "EzBarPreacherCurl"),
            FitFieldCurlExerciseName::ForwardBendBicepsCurl => {
                write!(f, "{}", "ForwardBendBicepsCurl")
            }
            FitFieldCurlExerciseName::HammerCurlToPress => write!(f, "{}", "HammerCurlToPress"),
            FitFieldCurlExerciseName::InclineDumbbellBicepsCurl => {
                write!(f, "{}", "InclineDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::InclineOffsetThumbDumbbellCurl => {
                write!(f, "{}", "InclineOffsetThumbDumbbellCurl")
            }
            FitFieldCurlExerciseName::KettlebellBicepsCurl => {
                write!(f, "{}", "KettlebellBicepsCurl")
            }
            FitFieldCurlExerciseName::LyingConcentrationCableCurl => {
                write!(f, "{}", "LyingConcentrationCableCurl")
            }
            FitFieldCurlExerciseName::OneArmPreacherCurl => write!(f, "{}", "OneArmPreacherCurl"),
            FitFieldCurlExerciseName::PlatePinchCurl => write!(f, "{}", "PlatePinchCurl"),
            FitFieldCurlExerciseName::PreacherCurlWithCable => {
                write!(f, "{}", "PreacherCurlWithCable")
            }
            FitFieldCurlExerciseName::ReverseEzBarCurl => write!(f, "{}", "ReverseEzBarCurl"),
            FitFieldCurlExerciseName::ReverseGripWristCurl => {
                write!(f, "{}", "ReverseGripWristCurl")
            }
            FitFieldCurlExerciseName::ReverseGripBarbellBicepsCurl => {
                write!(f, "{}", "ReverseGripBarbellBicepsCurl")
            }
            FitFieldCurlExerciseName::SeatedAlternatingDumbbellBicepsCurl => {
                write!(f, "{}", "SeatedAlternatingDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::SeatedDumbbellBicepsCurl => {
                write!(f, "{}", "SeatedDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::SeatedReverseDumbbellCurl => {
                write!(f, "{}", "SeatedReverseDumbbellCurl")
            }
            FitFieldCurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl => {
                write!(f, "{}", "SplitStanceOffsetPinkyDumbbellCurl")
            }
            FitFieldCurlExerciseName::StandingAlternatingDumbbellCurls => {
                write!(f, "{}", "StandingAlternatingDumbbellCurls")
            }
            FitFieldCurlExerciseName::StandingDumbbellBicepsCurl => {
                write!(f, "{}", "StandingDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::StandingEzBarBicepsCurl => {
                write!(f, "{}", "StandingEzBarBicepsCurl")
            }
            FitFieldCurlExerciseName::StaticCurl => write!(f, "{}", "StaticCurl"),
            FitFieldCurlExerciseName::SwissBallDumbbellOverheadTricepsExtension => {
                write!(f, "{}", "SwissBallDumbbellOverheadTricepsExtension")
            }
            FitFieldCurlExerciseName::SwissBallEzBarPreacherCurl => {
                write!(f, "{}", "SwissBallEzBarPreacherCurl")
            }
            FitFieldCurlExerciseName::TwistingStandingDumbbellBicepsCurl => {
                write!(f, "{}", "TwistingStandingDumbbellBicepsCurl")
            }
            FitFieldCurlExerciseName::WideGripEzBarBicepsCurl => {
                write!(f, "{}", "WideGripEzBarBicepsCurl")
            }
            FitFieldCurlExerciseName::CurlExerciseName(x) => {
                write!(f, "{}({})", "CurlExerciseName", x)
            }
            FitFieldCurlExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldCurlExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldCurlExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldCurlExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldCurlExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldCurlExerciseName::from(v)),
                1 => Ok(FitFieldCurlExerciseName::from(v)),
                2 => Ok(FitFieldCurlExerciseName::from(v)),
                3 => Ok(FitFieldCurlExerciseName::from(v)),
                4 => Ok(FitFieldCurlExerciseName::from(v)),
                5 => Ok(FitFieldCurlExerciseName::from(v)),
                6 => Ok(FitFieldCurlExerciseName::from(v)),
                7 => Ok(FitFieldCurlExerciseName::from(v)),
                8 => Ok(FitFieldCurlExerciseName::from(v)),
                9 => Ok(FitFieldCurlExerciseName::from(v)),
                10 => Ok(FitFieldCurlExerciseName::from(v)),
                11 => Ok(FitFieldCurlExerciseName::from(v)),
                12 => Ok(FitFieldCurlExerciseName::from(v)),
                13 => Ok(FitFieldCurlExerciseName::from(v)),
                14 => Ok(FitFieldCurlExerciseName::from(v)),
                15 => Ok(FitFieldCurlExerciseName::from(v)),
                16 => Ok(FitFieldCurlExerciseName::from(v)),
                17 => Ok(FitFieldCurlExerciseName::from(v)),
                18 => Ok(FitFieldCurlExerciseName::from(v)),
                19 => Ok(FitFieldCurlExerciseName::from(v)),
                20 => Ok(FitFieldCurlExerciseName::from(v)),
                21 => Ok(FitFieldCurlExerciseName::from(v)),
                22 => Ok(FitFieldCurlExerciseName::from(v)),
                23 => Ok(FitFieldCurlExerciseName::from(v)),
                24 => Ok(FitFieldCurlExerciseName::from(v)),
                25 => Ok(FitFieldCurlExerciseName::from(v)),
                26 => Ok(FitFieldCurlExerciseName::from(v)),
                27 => Ok(FitFieldCurlExerciseName::from(v)),
                28 => Ok(FitFieldCurlExerciseName::from(v)),
                29 => Ok(FitFieldCurlExerciseName::from(v)),
                30 => Ok(FitFieldCurlExerciseName::from(v)),
                31 => Ok(FitFieldCurlExerciseName::from(v)),
                32 => Ok(FitFieldCurlExerciseName::from(v)),
                33 => Ok(FitFieldCurlExerciseName::from(v)),
                34 => Ok(FitFieldCurlExerciseName::from(v)),
                35 => Ok(FitFieldCurlExerciseName::from(v)),
                36 => Ok(FitFieldCurlExerciseName::from(v)),
                37 => Ok(FitFieldCurlExerciseName::from(v)),
                38 => Ok(FitFieldCurlExerciseName::from(v)),
                39 => Ok(FitFieldCurlExerciseName::from(v)),
                40 => Ok(FitFieldCurlExerciseName::from(v)),
                41 => Ok(FitFieldCurlExerciseName::from(v)),
                42 => Ok(FitFieldCurlExerciseName::from(v)),
                43 => Ok(FitFieldCurlExerciseName::from(v)),
                v => Ok(FitFieldCurlExerciseName::CurlExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldCurlExerciseName);

impl From<u16> for FitFieldCurlExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCurlExerciseName::AlternatingDumbbellBicepsCurl,
            1 => FitFieldCurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall,
            2 => FitFieldCurlExerciseName::AlternatingInclineDumbbellBicepsCurl,
            3 => FitFieldCurlExerciseName::BarbellBicepsCurl,
            4 => FitFieldCurlExerciseName::BarbellReverseWristCurl,
            5 => FitFieldCurlExerciseName::BarbellWristCurl,
            6 => FitFieldCurlExerciseName::BehindTheBackBarbellReverseWristCurl,
            7 => FitFieldCurlExerciseName::BehindTheBackOneArmCableCurl,
            8 => FitFieldCurlExerciseName::CableBicepsCurl,
            9 => FitFieldCurlExerciseName::CableHammerCurl,
            10 => FitFieldCurlExerciseName::CheatingBarbellBicepsCurl,
            11 => FitFieldCurlExerciseName::CloseGripEzBarBicepsCurl,
            12 => FitFieldCurlExerciseName::CrossBodyDumbbellHammerCurl,
            13 => FitFieldCurlExerciseName::DeadHangBicepsCurl,
            14 => FitFieldCurlExerciseName::DeclineHammerCurl,
            15 => FitFieldCurlExerciseName::DumbbellBicepsCurlWithStaticHold,
            16 => FitFieldCurlExerciseName::DumbbellHammerCurl,
            17 => FitFieldCurlExerciseName::DumbbellReverseWristCurl,
            18 => FitFieldCurlExerciseName::DumbbellWristCurl,
            19 => FitFieldCurlExerciseName::EzBarPreacherCurl,
            20 => FitFieldCurlExerciseName::ForwardBendBicepsCurl,
            21 => FitFieldCurlExerciseName::HammerCurlToPress,
            22 => FitFieldCurlExerciseName::InclineDumbbellBicepsCurl,
            23 => FitFieldCurlExerciseName::InclineOffsetThumbDumbbellCurl,
            24 => FitFieldCurlExerciseName::KettlebellBicepsCurl,
            25 => FitFieldCurlExerciseName::LyingConcentrationCableCurl,
            26 => FitFieldCurlExerciseName::OneArmPreacherCurl,
            27 => FitFieldCurlExerciseName::PlatePinchCurl,
            28 => FitFieldCurlExerciseName::PreacherCurlWithCable,
            29 => FitFieldCurlExerciseName::ReverseEzBarCurl,
            30 => FitFieldCurlExerciseName::ReverseGripWristCurl,
            31 => FitFieldCurlExerciseName::ReverseGripBarbellBicepsCurl,
            32 => FitFieldCurlExerciseName::SeatedAlternatingDumbbellBicepsCurl,
            33 => FitFieldCurlExerciseName::SeatedDumbbellBicepsCurl,
            34 => FitFieldCurlExerciseName::SeatedReverseDumbbellCurl,
            35 => FitFieldCurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl,
            36 => FitFieldCurlExerciseName::StandingAlternatingDumbbellCurls,
            37 => FitFieldCurlExerciseName::StandingDumbbellBicepsCurl,
            38 => FitFieldCurlExerciseName::StandingEzBarBicepsCurl,
            39 => FitFieldCurlExerciseName::StaticCurl,
            40 => FitFieldCurlExerciseName::SwissBallDumbbellOverheadTricepsExtension,
            41 => FitFieldCurlExerciseName::SwissBallEzBarPreacherCurl,
            42 => FitFieldCurlExerciseName::TwistingStandingDumbbellBicepsCurl,
            43 => FitFieldCurlExerciseName::WideGripEzBarBicepsCurl,
            _ => FitFieldCurlExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDeadliftExerciseName {
    // fit base type: uint16
    BarbellDeadlift,                       // 0
    BarbellStraightLegDeadlift,            // 1
    DumbbellDeadlift,                      // 2
    DumbbellSingleLegDeadliftToRow,        // 3
    DumbbellStraightLegDeadlift,           // 4
    KettlebellFloorToShelf,                // 5
    OneArmOneLegDeadlift,                  // 6
    RackPull,                              // 7
    RotationalDumbbellStraightLegDeadlift, // 8
    SingleArmDeadlift,                     // 9
    SingleLegBarbellDeadlift,              // 10
    SingleLegBarbellStraightLegDeadlift,   // 11
    SingleLegDeadliftWithBarbell,          // 12
    SingleLegRdlCircuit,                   // 13
    SingleLegRomanianDeadliftWithDumbbell, // 14
    SumoDeadlift,                          // 15
    SumoDeadliftHighPull,                  // 16
    TrapBarDeadlift,                       // 17
    WideGripBarbellDeadlift,               // 18
    DeadliftExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldDeadliftExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDeadliftExerciseName::BarbellDeadlift => write!(f, "{}", "BarbellDeadlift"),
            FitFieldDeadliftExerciseName::BarbellStraightLegDeadlift => {
                write!(f, "{}", "BarbellStraightLegDeadlift")
            }
            FitFieldDeadliftExerciseName::DumbbellDeadlift => write!(f, "{}", "DumbbellDeadlift"),
            FitFieldDeadliftExerciseName::DumbbellSingleLegDeadliftToRow => {
                write!(f, "{}", "DumbbellSingleLegDeadliftToRow")
            }
            FitFieldDeadliftExerciseName::DumbbellStraightLegDeadlift => {
                write!(f, "{}", "DumbbellStraightLegDeadlift")
            }
            FitFieldDeadliftExerciseName::KettlebellFloorToShelf => {
                write!(f, "{}", "KettlebellFloorToShelf")
            }
            FitFieldDeadliftExerciseName::OneArmOneLegDeadlift => {
                write!(f, "{}", "OneArmOneLegDeadlift")
            }
            FitFieldDeadliftExerciseName::RackPull => write!(f, "{}", "RackPull"),
            FitFieldDeadliftExerciseName::RotationalDumbbellStraightLegDeadlift => {
                write!(f, "{}", "RotationalDumbbellStraightLegDeadlift")
            }
            FitFieldDeadliftExerciseName::SingleArmDeadlift => write!(f, "{}", "SingleArmDeadlift"),
            FitFieldDeadliftExerciseName::SingleLegBarbellDeadlift => {
                write!(f, "{}", "SingleLegBarbellDeadlift")
            }
            FitFieldDeadliftExerciseName::SingleLegBarbellStraightLegDeadlift => {
                write!(f, "{}", "SingleLegBarbellStraightLegDeadlift")
            }
            FitFieldDeadliftExerciseName::SingleLegDeadliftWithBarbell => {
                write!(f, "{}", "SingleLegDeadliftWithBarbell")
            }
            FitFieldDeadliftExerciseName::SingleLegRdlCircuit => {
                write!(f, "{}", "SingleLegRdlCircuit")
            }
            FitFieldDeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell => {
                write!(f, "{}", "SingleLegRomanianDeadliftWithDumbbell")
            }
            FitFieldDeadliftExerciseName::SumoDeadlift => write!(f, "{}", "SumoDeadlift"),
            FitFieldDeadliftExerciseName::SumoDeadliftHighPull => {
                write!(f, "{}", "SumoDeadliftHighPull")
            }
            FitFieldDeadliftExerciseName::TrapBarDeadlift => write!(f, "{}", "TrapBarDeadlift"),
            FitFieldDeadliftExerciseName::WideGripBarbellDeadlift => {
                write!(f, "{}", "WideGripBarbellDeadlift")
            }
            FitFieldDeadliftExerciseName::DeadliftExerciseName(x) => {
                write!(f, "{}({})", "DeadliftExerciseName", x)
            }
            FitFieldDeadliftExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDeadliftExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDeadliftExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDeadliftExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldDeadliftExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldDeadliftExerciseName::from(v)),
                1 => Ok(FitFieldDeadliftExerciseName::from(v)),
                2 => Ok(FitFieldDeadliftExerciseName::from(v)),
                3 => Ok(FitFieldDeadliftExerciseName::from(v)),
                4 => Ok(FitFieldDeadliftExerciseName::from(v)),
                5 => Ok(FitFieldDeadliftExerciseName::from(v)),
                6 => Ok(FitFieldDeadliftExerciseName::from(v)),
                7 => Ok(FitFieldDeadliftExerciseName::from(v)),
                8 => Ok(FitFieldDeadliftExerciseName::from(v)),
                9 => Ok(FitFieldDeadliftExerciseName::from(v)),
                10 => Ok(FitFieldDeadliftExerciseName::from(v)),
                11 => Ok(FitFieldDeadliftExerciseName::from(v)),
                12 => Ok(FitFieldDeadliftExerciseName::from(v)),
                13 => Ok(FitFieldDeadliftExerciseName::from(v)),
                14 => Ok(FitFieldDeadliftExerciseName::from(v)),
                15 => Ok(FitFieldDeadliftExerciseName::from(v)),
                16 => Ok(FitFieldDeadliftExerciseName::from(v)),
                17 => Ok(FitFieldDeadliftExerciseName::from(v)),
                18 => Ok(FitFieldDeadliftExerciseName::from(v)),
                v => Ok(FitFieldDeadliftExerciseName::DeadliftExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldDeadliftExerciseName);

impl From<u16> for FitFieldDeadliftExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldDeadliftExerciseName::BarbellDeadlift,
            1 => FitFieldDeadliftExerciseName::BarbellStraightLegDeadlift,
            2 => FitFieldDeadliftExerciseName::DumbbellDeadlift,
            3 => FitFieldDeadliftExerciseName::DumbbellSingleLegDeadliftToRow,
            4 => FitFieldDeadliftExerciseName::DumbbellStraightLegDeadlift,
            5 => FitFieldDeadliftExerciseName::KettlebellFloorToShelf,
            6 => FitFieldDeadliftExerciseName::OneArmOneLegDeadlift,
            7 => FitFieldDeadliftExerciseName::RackPull,
            8 => FitFieldDeadliftExerciseName::RotationalDumbbellStraightLegDeadlift,
            9 => FitFieldDeadliftExerciseName::SingleArmDeadlift,
            10 => FitFieldDeadliftExerciseName::SingleLegBarbellDeadlift,
            11 => FitFieldDeadliftExerciseName::SingleLegBarbellStraightLegDeadlift,
            12 => FitFieldDeadliftExerciseName::SingleLegDeadliftWithBarbell,
            13 => FitFieldDeadliftExerciseName::SingleLegRdlCircuit,
            14 => FitFieldDeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell,
            15 => FitFieldDeadliftExerciseName::SumoDeadlift,
            16 => FitFieldDeadliftExerciseName::SumoDeadliftHighPull,
            17 => FitFieldDeadliftExerciseName::TrapBarDeadlift,
            18 => FitFieldDeadliftExerciseName::WideGripBarbellDeadlift,
            _ => FitFieldDeadliftExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFlyeExerciseName {
    // fit base type: uint16
    CableCrossover,                    // 0
    DeclineDumbbellFlye,               // 1
    DumbbellFlye,                      // 2
    InclineDumbbellFlye,               // 3
    KettlebellFlye,                    // 4
    KneelingRearFlye,                  // 5
    SingleArmStandingCableReverseFlye, // 6
    SwissBallDumbbellFlye,             // 7
    ArmRotations,                      // 8
    HugATree,                          // 9
    FlyeExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldFlyeExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFlyeExerciseName::CableCrossover => write!(f, "{}", "CableCrossover"),
            FitFieldFlyeExerciseName::DeclineDumbbellFlye => write!(f, "{}", "DeclineDumbbellFlye"),
            FitFieldFlyeExerciseName::DumbbellFlye => write!(f, "{}", "DumbbellFlye"),
            FitFieldFlyeExerciseName::InclineDumbbellFlye => write!(f, "{}", "InclineDumbbellFlye"),
            FitFieldFlyeExerciseName::KettlebellFlye => write!(f, "{}", "KettlebellFlye"),
            FitFieldFlyeExerciseName::KneelingRearFlye => write!(f, "{}", "KneelingRearFlye"),
            FitFieldFlyeExerciseName::SingleArmStandingCableReverseFlye => {
                write!(f, "{}", "SingleArmStandingCableReverseFlye")
            }
            FitFieldFlyeExerciseName::SwissBallDumbbellFlye => {
                write!(f, "{}", "SwissBallDumbbellFlye")
            }
            FitFieldFlyeExerciseName::ArmRotations => write!(f, "{}", "ArmRotations"),
            FitFieldFlyeExerciseName::HugATree => write!(f, "{}", "HugATree"),
            FitFieldFlyeExerciseName::FlyeExerciseName(x) => {
                write!(f, "{}({})", "FlyeExerciseName", x)
            }
            FitFieldFlyeExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFlyeExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFlyeExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFlyeExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldFlyeExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldFlyeExerciseName::from(v)),
                1 => Ok(FitFieldFlyeExerciseName::from(v)),
                2 => Ok(FitFieldFlyeExerciseName::from(v)),
                3 => Ok(FitFieldFlyeExerciseName::from(v)),
                4 => Ok(FitFieldFlyeExerciseName::from(v)),
                5 => Ok(FitFieldFlyeExerciseName::from(v)),
                6 => Ok(FitFieldFlyeExerciseName::from(v)),
                7 => Ok(FitFieldFlyeExerciseName::from(v)),
                8 => Ok(FitFieldFlyeExerciseName::from(v)),
                9 => Ok(FitFieldFlyeExerciseName::from(v)),
                v => Ok(FitFieldFlyeExerciseName::FlyeExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldFlyeExerciseName);

impl From<u16> for FitFieldFlyeExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldFlyeExerciseName::CableCrossover,
            1 => FitFieldFlyeExerciseName::DeclineDumbbellFlye,
            2 => FitFieldFlyeExerciseName::DumbbellFlye,
            3 => FitFieldFlyeExerciseName::InclineDumbbellFlye,
            4 => FitFieldFlyeExerciseName::KettlebellFlye,
            5 => FitFieldFlyeExerciseName::KneelingRearFlye,
            6 => FitFieldFlyeExerciseName::SingleArmStandingCableReverseFlye,
            7 => FitFieldFlyeExerciseName::SwissBallDumbbellFlye,
            8 => FitFieldFlyeExerciseName::ArmRotations,
            9 => FitFieldFlyeExerciseName::HugATree,
            _ => FitFieldFlyeExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldHipRaiseExerciseName {
    // fit base type: uint16
    BarbellHipThrustOnFloor,                         // 0
    BarbellHipThrustWithBench,                       // 1
    BentKneeSwissBallReverseHipRaise,                // 2
    WeightedBentKneeSwissBallReverseHipRaise,        // 3
    BridgeWithLegExtension,                          // 4
    WeightedBridgeWithLegExtension,                  // 5
    ClamBridge,                                      // 6
    FrontKickTabletop,                               // 7
    WeightedFrontKickTabletop,                       // 8
    HipExtensionAndCross,                            // 9
    WeightedHipExtensionAndCross,                    // 10
    HipRaise,                                        // 11
    WeightedHipRaise,                                // 12
    HipRaiseWithFeetOnSwissBall,                     // 13
    WeightedHipRaiseWithFeetOnSwissBall,             // 14
    HipRaiseWithHeadOnBosuBall,                      // 15
    WeightedHipRaiseWithHeadOnBosuBall,              // 16
    HipRaiseWithHeadOnSwissBall,                     // 17
    WeightedHipRaiseWithHeadOnSwissBall,             // 18
    HipRaiseWithKneeSqueeze,                         // 19
    WeightedHipRaiseWithKneeSqueeze,                 // 20
    InclineRearLegExtension,                         // 21
    WeightedInclineRearLegExtension,                 // 22
    KettlebellSwing,                                 // 23
    MarchingHipRaise,                                // 24
    WeightedMarchingHipRaise,                        // 25
    MarchingHipRaiseWithFeetOnASwissBall,            // 26
    WeightedMarchingHipRaiseWithFeetOnASwissBall,    // 27
    ReverseHipRaise,                                 // 28
    WeightedReverseHipRaise,                         // 29
    SingleLegHipRaise,                               // 30
    WeightedSingleLegHipRaise,                       // 31
    SingleLegHipRaiseWithFootOnBench,                // 32
    WeightedSingleLegHipRaiseWithFootOnBench,        // 33
    SingleLegHipRaiseWithFootOnBosuBall,             // 34
    WeightedSingleLegHipRaiseWithFootOnBosuBall,     // 35
    SingleLegHipRaiseWithFootOnFoamRoller,           // 36
    WeightedSingleLegHipRaiseWithFootOnFoamRoller,   // 37
    SingleLegHipRaiseWithFootOnMedicineBall,         // 38
    WeightedSingleLegHipRaiseWithFootOnMedicineBall, // 39
    SingleLegHipRaiseWithHeadOnBosuBall,             // 40
    WeightedSingleLegHipRaiseWithHeadOnBosuBall,     // 41
    WeightedClamBridge,                              // 42
    SingleLegSwissBallHipRaiseAndLegCurl,            // 43
    Clams,                                           // 44
    InnerThighCircles,                               // 45
    InnerThighSideLift,                              // 46
    LegCircles,                                      // 47
    LegLift,                                         // 48
    LegLiftInExternalRotation,                       // 49
    HipRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldHipRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldHipRaiseExerciseName::BarbellHipThrustOnFloor => {
                write!(f, "{}", "BarbellHipThrustOnFloor")
            }
            FitFieldHipRaiseExerciseName::BarbellHipThrustWithBench => {
                write!(f, "{}", "BarbellHipThrustWithBench")
            }
            FitFieldHipRaiseExerciseName::BentKneeSwissBallReverseHipRaise => {
                write!(f, "{}", "BentKneeSwissBallReverseHipRaise")
            }
            FitFieldHipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise => {
                write!(f, "{}", "WeightedBentKneeSwissBallReverseHipRaise")
            }
            FitFieldHipRaiseExerciseName::BridgeWithLegExtension => {
                write!(f, "{}", "BridgeWithLegExtension")
            }
            FitFieldHipRaiseExerciseName::WeightedBridgeWithLegExtension => {
                write!(f, "{}", "WeightedBridgeWithLegExtension")
            }
            FitFieldHipRaiseExerciseName::ClamBridge => write!(f, "{}", "ClamBridge"),
            FitFieldHipRaiseExerciseName::FrontKickTabletop => write!(f, "{}", "FrontKickTabletop"),
            FitFieldHipRaiseExerciseName::WeightedFrontKickTabletop => {
                write!(f, "{}", "WeightedFrontKickTabletop")
            }
            FitFieldHipRaiseExerciseName::HipExtensionAndCross => {
                write!(f, "{}", "HipExtensionAndCross")
            }
            FitFieldHipRaiseExerciseName::WeightedHipExtensionAndCross => {
                write!(f, "{}", "WeightedHipExtensionAndCross")
            }
            FitFieldHipRaiseExerciseName::HipRaise => write!(f, "{}", "HipRaise"),
            FitFieldHipRaiseExerciseName::WeightedHipRaise => write!(f, "{}", "WeightedHipRaise"),
            FitFieldHipRaiseExerciseName::HipRaiseWithFeetOnSwissBall => {
                write!(f, "{}", "HipRaiseWithFeetOnSwissBall")
            }
            FitFieldHipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall => {
                write!(f, "{}", "WeightedHipRaiseWithFeetOnSwissBall")
            }
            FitFieldHipRaiseExerciseName::HipRaiseWithHeadOnBosuBall => {
                write!(f, "{}", "HipRaiseWithHeadOnBosuBall")
            }
            FitFieldHipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall => {
                write!(f, "{}", "WeightedHipRaiseWithHeadOnBosuBall")
            }
            FitFieldHipRaiseExerciseName::HipRaiseWithHeadOnSwissBall => {
                write!(f, "{}", "HipRaiseWithHeadOnSwissBall")
            }
            FitFieldHipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall => {
                write!(f, "{}", "WeightedHipRaiseWithHeadOnSwissBall")
            }
            FitFieldHipRaiseExerciseName::HipRaiseWithKneeSqueeze => {
                write!(f, "{}", "HipRaiseWithKneeSqueeze")
            }
            FitFieldHipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze => {
                write!(f, "{}", "WeightedHipRaiseWithKneeSqueeze")
            }
            FitFieldHipRaiseExerciseName::InclineRearLegExtension => {
                write!(f, "{}", "InclineRearLegExtension")
            }
            FitFieldHipRaiseExerciseName::WeightedInclineRearLegExtension => {
                write!(f, "{}", "WeightedInclineRearLegExtension")
            }
            FitFieldHipRaiseExerciseName::KettlebellSwing => write!(f, "{}", "KettlebellSwing"),
            FitFieldHipRaiseExerciseName::MarchingHipRaise => write!(f, "{}", "MarchingHipRaise"),
            FitFieldHipRaiseExerciseName::WeightedMarchingHipRaise => {
                write!(f, "{}", "WeightedMarchingHipRaise")
            }
            FitFieldHipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall => {
                write!(f, "{}", "MarchingHipRaiseWithFeetOnASwissBall")
            }
            FitFieldHipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall => {
                write!(f, "{}", "WeightedMarchingHipRaiseWithFeetOnASwissBall")
            }
            FitFieldHipRaiseExerciseName::ReverseHipRaise => write!(f, "{}", "ReverseHipRaise"),
            FitFieldHipRaiseExerciseName::WeightedReverseHipRaise => {
                write!(f, "{}", "WeightedReverseHipRaise")
            }
            FitFieldHipRaiseExerciseName::SingleLegHipRaise => write!(f, "{}", "SingleLegHipRaise"),
            FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaise => {
                write!(f, "{}", "WeightedSingleLegHipRaise")
            }
            FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench => {
                write!(f, "{}", "SingleLegHipRaiseWithFootOnBench")
            }
            FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench => {
                write!(f, "{}", "WeightedSingleLegHipRaiseWithFootOnBench")
            }
            FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall => {
                write!(f, "{}", "SingleLegHipRaiseWithFootOnBosuBall")
            }
            FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall => {
                write!(f, "{}", "WeightedSingleLegHipRaiseWithFootOnBosuBall")
            }
            FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller => {
                write!(f, "{}", "SingleLegHipRaiseWithFootOnFoamRoller")
            }
            FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller => {
                write!(f, "{}", "WeightedSingleLegHipRaiseWithFootOnFoamRoller")
            }
            FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall => {
                write!(f, "{}", "SingleLegHipRaiseWithFootOnMedicineBall")
            }
            FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall => {
                write!(f, "{}", "WeightedSingleLegHipRaiseWithFootOnMedicineBall")
            }
            FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall => {
                write!(f, "{}", "SingleLegHipRaiseWithHeadOnBosuBall")
            }
            FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall => {
                write!(f, "{}", "WeightedSingleLegHipRaiseWithHeadOnBosuBall")
            }
            FitFieldHipRaiseExerciseName::WeightedClamBridge => {
                write!(f, "{}", "WeightedClamBridge")
            }
            FitFieldHipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl => {
                write!(f, "{}", "SingleLegSwissBallHipRaiseAndLegCurl")
            }
            FitFieldHipRaiseExerciseName::Clams => write!(f, "{}", "Clams"),
            FitFieldHipRaiseExerciseName::InnerThighCircles => write!(f, "{}", "InnerThighCircles"),
            FitFieldHipRaiseExerciseName::InnerThighSideLift => {
                write!(f, "{}", "InnerThighSideLift")
            }
            FitFieldHipRaiseExerciseName::LegCircles => write!(f, "{}", "LegCircles"),
            FitFieldHipRaiseExerciseName::LegLift => write!(f, "{}", "LegLift"),
            FitFieldHipRaiseExerciseName::LegLiftInExternalRotation => {
                write!(f, "{}", "LegLiftInExternalRotation")
            }
            FitFieldHipRaiseExerciseName::HipRaiseExerciseName(x) => {
                write!(f, "{}({})", "HipRaiseExerciseName", x)
            }
            FitFieldHipRaiseExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldHipRaiseExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldHipRaiseExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldHipRaiseExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldHipRaiseExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                1 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                2 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                3 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                4 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                5 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                6 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                7 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                8 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                9 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                10 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                11 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                12 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                13 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                14 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                15 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                16 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                17 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                18 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                19 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                20 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                21 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                22 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                23 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                24 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                25 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                26 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                27 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                28 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                29 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                30 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                31 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                32 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                33 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                34 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                35 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                36 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                37 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                38 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                39 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                40 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                41 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                42 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                43 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                44 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                45 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                46 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                47 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                48 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                49 => Ok(FitFieldHipRaiseExerciseName::from(v)),
                v => Ok(FitFieldHipRaiseExerciseName::HipRaiseExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldHipRaiseExerciseName);

impl From<u16> for FitFieldHipRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHipRaiseExerciseName::BarbellHipThrustOnFloor,
            1 => FitFieldHipRaiseExerciseName::BarbellHipThrustWithBench,
            2 => FitFieldHipRaiseExerciseName::BentKneeSwissBallReverseHipRaise,
            3 => FitFieldHipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise,
            4 => FitFieldHipRaiseExerciseName::BridgeWithLegExtension,
            5 => FitFieldHipRaiseExerciseName::WeightedBridgeWithLegExtension,
            6 => FitFieldHipRaiseExerciseName::ClamBridge,
            7 => FitFieldHipRaiseExerciseName::FrontKickTabletop,
            8 => FitFieldHipRaiseExerciseName::WeightedFrontKickTabletop,
            9 => FitFieldHipRaiseExerciseName::HipExtensionAndCross,
            10 => FitFieldHipRaiseExerciseName::WeightedHipExtensionAndCross,
            11 => FitFieldHipRaiseExerciseName::HipRaise,
            12 => FitFieldHipRaiseExerciseName::WeightedHipRaise,
            13 => FitFieldHipRaiseExerciseName::HipRaiseWithFeetOnSwissBall,
            14 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall,
            15 => FitFieldHipRaiseExerciseName::HipRaiseWithHeadOnBosuBall,
            16 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall,
            17 => FitFieldHipRaiseExerciseName::HipRaiseWithHeadOnSwissBall,
            18 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall,
            19 => FitFieldHipRaiseExerciseName::HipRaiseWithKneeSqueeze,
            20 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze,
            21 => FitFieldHipRaiseExerciseName::InclineRearLegExtension,
            22 => FitFieldHipRaiseExerciseName::WeightedInclineRearLegExtension,
            23 => FitFieldHipRaiseExerciseName::KettlebellSwing,
            24 => FitFieldHipRaiseExerciseName::MarchingHipRaise,
            25 => FitFieldHipRaiseExerciseName::WeightedMarchingHipRaise,
            26 => FitFieldHipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall,
            27 => FitFieldHipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall,
            28 => FitFieldHipRaiseExerciseName::ReverseHipRaise,
            29 => FitFieldHipRaiseExerciseName::WeightedReverseHipRaise,
            30 => FitFieldHipRaiseExerciseName::SingleLegHipRaise,
            31 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaise,
            32 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench,
            33 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench,
            34 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall,
            35 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall,
            36 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller,
            37 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller,
            38 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall,
            39 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall,
            40 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall,
            41 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall,
            42 => FitFieldHipRaiseExerciseName::WeightedClamBridge,
            43 => FitFieldHipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl,
            44 => FitFieldHipRaiseExerciseName::Clams,
            45 => FitFieldHipRaiseExerciseName::InnerThighCircles,
            46 => FitFieldHipRaiseExerciseName::InnerThighSideLift,
            47 => FitFieldHipRaiseExerciseName::LegCircles,
            48 => FitFieldHipRaiseExerciseName::LegLift,
            49 => FitFieldHipRaiseExerciseName::LegLiftInExternalRotation,
            _ => FitFieldHipRaiseExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldHipStabilityExerciseName {
    // fit base type: uint16
    BandSideLyingLegRaise,             // 0
    DeadBug,                           // 1
    WeightedDeadBug,                   // 2
    ExternalHipRaise,                  // 3
    WeightedExternalHipRaise,          // 4
    FireHydrantKicks,                  // 5
    WeightedFireHydrantKicks,          // 6
    HipCircles,                        // 7
    WeightedHipCircles,                // 8
    InnerThighLift,                    // 9
    WeightedInnerThighLift,            // 10
    LateralWalksWithBandAtAnkles,      // 11
    PretzelSideKick,                   // 12
    WeightedPretzelSideKick,           // 13
    ProneHipInternalRotation,          // 14
    WeightedProneHipInternalRotation,  // 15
    Quadruped,                         // 16
    QuadrupedHipExtension,             // 17
    WeightedQuadrupedHipExtension,     // 18
    QuadrupedWithLegLift,              // 19
    WeightedQuadrupedWithLegLift,      // 20
    SideLyingLegRaise,                 // 21
    WeightedSideLyingLegRaise,         // 22
    SlidingHipAdduction,               // 23
    WeightedSlidingHipAdduction,       // 24
    StandingAdduction,                 // 25
    WeightedStandingAdduction,         // 26
    StandingCableHipAbduction,         // 27
    StandingHipAbduction,              // 28
    WeightedStandingHipAbduction,      // 29
    StandingRearLegRaise,              // 30
    WeightedStandingRearLegRaise,      // 31
    SupineHipInternalRotation,         // 32
    WeightedSupineHipInternalRotation, // 33
    HipStabilityExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldHipStabilityExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldHipStabilityExerciseName::BandSideLyingLegRaise => {
                write!(f, "{}", "BandSideLyingLegRaise")
            }
            FitFieldHipStabilityExerciseName::DeadBug => write!(f, "{}", "DeadBug"),
            FitFieldHipStabilityExerciseName::WeightedDeadBug => write!(f, "{}", "WeightedDeadBug"),
            FitFieldHipStabilityExerciseName::ExternalHipRaise => {
                write!(f, "{}", "ExternalHipRaise")
            }
            FitFieldHipStabilityExerciseName::WeightedExternalHipRaise => {
                write!(f, "{}", "WeightedExternalHipRaise")
            }
            FitFieldHipStabilityExerciseName::FireHydrantKicks => {
                write!(f, "{}", "FireHydrantKicks")
            }
            FitFieldHipStabilityExerciseName::WeightedFireHydrantKicks => {
                write!(f, "{}", "WeightedFireHydrantKicks")
            }
            FitFieldHipStabilityExerciseName::HipCircles => write!(f, "{}", "HipCircles"),
            FitFieldHipStabilityExerciseName::WeightedHipCircles => {
                write!(f, "{}", "WeightedHipCircles")
            }
            FitFieldHipStabilityExerciseName::InnerThighLift => write!(f, "{}", "InnerThighLift"),
            FitFieldHipStabilityExerciseName::WeightedInnerThighLift => {
                write!(f, "{}", "WeightedInnerThighLift")
            }
            FitFieldHipStabilityExerciseName::LateralWalksWithBandAtAnkles => {
                write!(f, "{}", "LateralWalksWithBandAtAnkles")
            }
            FitFieldHipStabilityExerciseName::PretzelSideKick => write!(f, "{}", "PretzelSideKick"),
            FitFieldHipStabilityExerciseName::WeightedPretzelSideKick => {
                write!(f, "{}", "WeightedPretzelSideKick")
            }
            FitFieldHipStabilityExerciseName::ProneHipInternalRotation => {
                write!(f, "{}", "ProneHipInternalRotation")
            }
            FitFieldHipStabilityExerciseName::WeightedProneHipInternalRotation => {
                write!(f, "{}", "WeightedProneHipInternalRotation")
            }
            FitFieldHipStabilityExerciseName::Quadruped => write!(f, "{}", "Quadruped"),
            FitFieldHipStabilityExerciseName::QuadrupedHipExtension => {
                write!(f, "{}", "QuadrupedHipExtension")
            }
            FitFieldHipStabilityExerciseName::WeightedQuadrupedHipExtension => {
                write!(f, "{}", "WeightedQuadrupedHipExtension")
            }
            FitFieldHipStabilityExerciseName::QuadrupedWithLegLift => {
                write!(f, "{}", "QuadrupedWithLegLift")
            }
            FitFieldHipStabilityExerciseName::WeightedQuadrupedWithLegLift => {
                write!(f, "{}", "WeightedQuadrupedWithLegLift")
            }
            FitFieldHipStabilityExerciseName::SideLyingLegRaise => {
                write!(f, "{}", "SideLyingLegRaise")
            }
            FitFieldHipStabilityExerciseName::WeightedSideLyingLegRaise => {
                write!(f, "{}", "WeightedSideLyingLegRaise")
            }
            FitFieldHipStabilityExerciseName::SlidingHipAdduction => {
                write!(f, "{}", "SlidingHipAdduction")
            }
            FitFieldHipStabilityExerciseName::WeightedSlidingHipAdduction => {
                write!(f, "{}", "WeightedSlidingHipAdduction")
            }
            FitFieldHipStabilityExerciseName::StandingAdduction => {
                write!(f, "{}", "StandingAdduction")
            }
            FitFieldHipStabilityExerciseName::WeightedStandingAdduction => {
                write!(f, "{}", "WeightedStandingAdduction")
            }
            FitFieldHipStabilityExerciseName::StandingCableHipAbduction => {
                write!(f, "{}", "StandingCableHipAbduction")
            }
            FitFieldHipStabilityExerciseName::StandingHipAbduction => {
                write!(f, "{}", "StandingHipAbduction")
            }
            FitFieldHipStabilityExerciseName::WeightedStandingHipAbduction => {
                write!(f, "{}", "WeightedStandingHipAbduction")
            }
            FitFieldHipStabilityExerciseName::StandingRearLegRaise => {
                write!(f, "{}", "StandingRearLegRaise")
            }
            FitFieldHipStabilityExerciseName::WeightedStandingRearLegRaise => {
                write!(f, "{}", "WeightedStandingRearLegRaise")
            }
            FitFieldHipStabilityExerciseName::SupineHipInternalRotation => {
                write!(f, "{}", "SupineHipInternalRotation")
            }
            FitFieldHipStabilityExerciseName::WeightedSupineHipInternalRotation => {
                write!(f, "{}", "WeightedSupineHipInternalRotation")
            }
            FitFieldHipStabilityExerciseName::HipStabilityExerciseName(x) => {
                write!(f, "{}({})", "HipStabilityExerciseName", x)
            }
            FitFieldHipStabilityExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldHipStabilityExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldHipStabilityExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldHipStabilityExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldHipStabilityExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                1 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                2 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                3 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                4 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                5 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                6 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                7 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                8 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                9 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                10 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                11 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                12 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                13 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                14 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                15 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                16 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                17 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                18 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                19 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                20 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                21 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                22 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                23 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                24 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                25 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                26 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                27 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                28 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                29 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                30 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                31 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                32 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                33 => Ok(FitFieldHipStabilityExerciseName::from(v)),
                v => Ok(FitFieldHipStabilityExerciseName::HipStabilityExerciseName(
                    v,
                )),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldHipStabilityExerciseName);

impl From<u16> for FitFieldHipStabilityExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHipStabilityExerciseName::BandSideLyingLegRaise,
            1 => FitFieldHipStabilityExerciseName::DeadBug,
            2 => FitFieldHipStabilityExerciseName::WeightedDeadBug,
            3 => FitFieldHipStabilityExerciseName::ExternalHipRaise,
            4 => FitFieldHipStabilityExerciseName::WeightedExternalHipRaise,
            5 => FitFieldHipStabilityExerciseName::FireHydrantKicks,
            6 => FitFieldHipStabilityExerciseName::WeightedFireHydrantKicks,
            7 => FitFieldHipStabilityExerciseName::HipCircles,
            8 => FitFieldHipStabilityExerciseName::WeightedHipCircles,
            9 => FitFieldHipStabilityExerciseName::InnerThighLift,
            10 => FitFieldHipStabilityExerciseName::WeightedInnerThighLift,
            11 => FitFieldHipStabilityExerciseName::LateralWalksWithBandAtAnkles,
            12 => FitFieldHipStabilityExerciseName::PretzelSideKick,
            13 => FitFieldHipStabilityExerciseName::WeightedPretzelSideKick,
            14 => FitFieldHipStabilityExerciseName::ProneHipInternalRotation,
            15 => FitFieldHipStabilityExerciseName::WeightedProneHipInternalRotation,
            16 => FitFieldHipStabilityExerciseName::Quadruped,
            17 => FitFieldHipStabilityExerciseName::QuadrupedHipExtension,
            18 => FitFieldHipStabilityExerciseName::WeightedQuadrupedHipExtension,
            19 => FitFieldHipStabilityExerciseName::QuadrupedWithLegLift,
            20 => FitFieldHipStabilityExerciseName::WeightedQuadrupedWithLegLift,
            21 => FitFieldHipStabilityExerciseName::SideLyingLegRaise,
            22 => FitFieldHipStabilityExerciseName::WeightedSideLyingLegRaise,
            23 => FitFieldHipStabilityExerciseName::SlidingHipAdduction,
            24 => FitFieldHipStabilityExerciseName::WeightedSlidingHipAdduction,
            25 => FitFieldHipStabilityExerciseName::StandingAdduction,
            26 => FitFieldHipStabilityExerciseName::WeightedStandingAdduction,
            27 => FitFieldHipStabilityExerciseName::StandingCableHipAbduction,
            28 => FitFieldHipStabilityExerciseName::StandingHipAbduction,
            29 => FitFieldHipStabilityExerciseName::WeightedStandingHipAbduction,
            30 => FitFieldHipStabilityExerciseName::StandingRearLegRaise,
            31 => FitFieldHipStabilityExerciseName::WeightedStandingRearLegRaise,
            32 => FitFieldHipStabilityExerciseName::SupineHipInternalRotation,
            33 => FitFieldHipStabilityExerciseName::WeightedSupineHipInternalRotation,
            _ => FitFieldHipStabilityExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldHipSwingExerciseName {
    // fit base type: uint16
    SingleArmKettlebellSwing, // 0
    SingleArmDumbbellSwing,   // 1
    StepOutSwing,             // 2
    HipSwingExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldHipSwingExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldHipSwingExerciseName::SingleArmKettlebellSwing => {
                write!(f, "{}", "SingleArmKettlebellSwing")
            }
            FitFieldHipSwingExerciseName::SingleArmDumbbellSwing => {
                write!(f, "{}", "SingleArmDumbbellSwing")
            }
            FitFieldHipSwingExerciseName::StepOutSwing => write!(f, "{}", "StepOutSwing"),
            FitFieldHipSwingExerciseName::HipSwingExerciseName(x) => {
                write!(f, "{}({})", "HipSwingExerciseName", x)
            }
            FitFieldHipSwingExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldHipSwingExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldHipSwingExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldHipSwingExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldHipSwingExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldHipSwingExerciseName::from(v)),
                1 => Ok(FitFieldHipSwingExerciseName::from(v)),
                2 => Ok(FitFieldHipSwingExerciseName::from(v)),
                v => Ok(FitFieldHipSwingExerciseName::HipSwingExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldHipSwingExerciseName);

impl From<u16> for FitFieldHipSwingExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHipSwingExerciseName::SingleArmKettlebellSwing,
            1 => FitFieldHipSwingExerciseName::SingleArmDumbbellSwing,
            2 => FitFieldHipSwingExerciseName::StepOutSwing,
            _ => FitFieldHipSwingExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldHyperextensionExerciseName {
    // fit base type: uint16
    BackExtensionWithOppositeArmAndLegReach,         // 0
    WeightedBackExtensionWithOppositeArmAndLegReach, // 1
    BaseRotations,                                   // 2
    WeightedBaseRotations,                           // 3
    BentKneeReverseHyperextension,                   // 4
    WeightedBentKneeReverseHyperextension,           // 5
    HollowHoldAndRoll,                               // 6
    WeightedHollowHoldAndRoll,                       // 7
    Kicks,                                           // 8
    WeightedKicks,                                   // 9
    KneeRaises,                                      // 10
    WeightedKneeRaises,                              // 11
    KneelingSuperman,                                // 12
    WeightedKneelingSuperman,                        // 13
    LatPullDownWithRow,                              // 14
    MedicineBallDeadliftToReach,                     // 15
    OneArmOneLegRow,                                 // 16
    OneArmRowWithBand,                               // 17
    OverheadLungeWithMedicineBall,                   // 18
    PlankKneeTucks,                                  // 19
    WeightedPlankKneeTucks,                          // 20
    SideStep,                                        // 21
    WeightedSideStep,                                // 22
    SingleLegBackExtension,                          // 23
    WeightedSingleLegBackExtension,                  // 24
    SpineExtension,                                  // 25
    WeightedSpineExtension,                          // 26
    StaticBackExtension,                             // 27
    WeightedStaticBackExtension,                     // 28
    SupermanFromFloor,                               // 29
    WeightedSupermanFromFloor,                       // 30
    SwissBallBackExtension,                          // 31
    WeightedSwissBallBackExtension,                  // 32
    SwissBallHyperextension,                         // 33
    WeightedSwissBallHyperextension,                 // 34
    SwissBallOppositeArmAndLegLift,                  // 35
    WeightedSwissBallOppositeArmAndLegLift,          // 36
    SupermanOnSwissBall,                             // 37
    Cobra,                                           // 38
    SupineFloorBarre,                                // 39
    HyperextensionExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldHyperextensionExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldHyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach => {
                write!(f, "{}", "BackExtensionWithOppositeArmAndLegReach")
            }
            FitFieldHyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach => {
                write!(f, "{}", "WeightedBackExtensionWithOppositeArmAndLegReach")
            }
            FitFieldHyperextensionExerciseName::BaseRotations => write!(f, "{}", "BaseRotations"),
            FitFieldHyperextensionExerciseName::WeightedBaseRotations => {
                write!(f, "{}", "WeightedBaseRotations")
            }
            FitFieldHyperextensionExerciseName::BentKneeReverseHyperextension => {
                write!(f, "{}", "BentKneeReverseHyperextension")
            }
            FitFieldHyperextensionExerciseName::WeightedBentKneeReverseHyperextension => {
                write!(f, "{}", "WeightedBentKneeReverseHyperextension")
            }
            FitFieldHyperextensionExerciseName::HollowHoldAndRoll => {
                write!(f, "{}", "HollowHoldAndRoll")
            }
            FitFieldHyperextensionExerciseName::WeightedHollowHoldAndRoll => {
                write!(f, "{}", "WeightedHollowHoldAndRoll")
            }
            FitFieldHyperextensionExerciseName::Kicks => write!(f, "{}", "Kicks"),
            FitFieldHyperextensionExerciseName::WeightedKicks => write!(f, "{}", "WeightedKicks"),
            FitFieldHyperextensionExerciseName::KneeRaises => write!(f, "{}", "KneeRaises"),
            FitFieldHyperextensionExerciseName::WeightedKneeRaises => {
                write!(f, "{}", "WeightedKneeRaises")
            }
            FitFieldHyperextensionExerciseName::KneelingSuperman => {
                write!(f, "{}", "KneelingSuperman")
            }
            FitFieldHyperextensionExerciseName::WeightedKneelingSuperman => {
                write!(f, "{}", "WeightedKneelingSuperman")
            }
            FitFieldHyperextensionExerciseName::LatPullDownWithRow => {
                write!(f, "{}", "LatPullDownWithRow")
            }
            FitFieldHyperextensionExerciseName::MedicineBallDeadliftToReach => {
                write!(f, "{}", "MedicineBallDeadliftToReach")
            }
            FitFieldHyperextensionExerciseName::OneArmOneLegRow => {
                write!(f, "{}", "OneArmOneLegRow")
            }
            FitFieldHyperextensionExerciseName::OneArmRowWithBand => {
                write!(f, "{}", "OneArmRowWithBand")
            }
            FitFieldHyperextensionExerciseName::OverheadLungeWithMedicineBall => {
                write!(f, "{}", "OverheadLungeWithMedicineBall")
            }
            FitFieldHyperextensionExerciseName::PlankKneeTucks => write!(f, "{}", "PlankKneeTucks"),
            FitFieldHyperextensionExerciseName::WeightedPlankKneeTucks => {
                write!(f, "{}", "WeightedPlankKneeTucks")
            }
            FitFieldHyperextensionExerciseName::SideStep => write!(f, "{}", "SideStep"),
            FitFieldHyperextensionExerciseName::WeightedSideStep => {
                write!(f, "{}", "WeightedSideStep")
            }
            FitFieldHyperextensionExerciseName::SingleLegBackExtension => {
                write!(f, "{}", "SingleLegBackExtension")
            }
            FitFieldHyperextensionExerciseName::WeightedSingleLegBackExtension => {
                write!(f, "{}", "WeightedSingleLegBackExtension")
            }
            FitFieldHyperextensionExerciseName::SpineExtension => write!(f, "{}", "SpineExtension"),
            FitFieldHyperextensionExerciseName::WeightedSpineExtension => {
                write!(f, "{}", "WeightedSpineExtension")
            }
            FitFieldHyperextensionExerciseName::StaticBackExtension => {
                write!(f, "{}", "StaticBackExtension")
            }
            FitFieldHyperextensionExerciseName::WeightedStaticBackExtension => {
                write!(f, "{}", "WeightedStaticBackExtension")
            }
            FitFieldHyperextensionExerciseName::SupermanFromFloor => {
                write!(f, "{}", "SupermanFromFloor")
            }
            FitFieldHyperextensionExerciseName::WeightedSupermanFromFloor => {
                write!(f, "{}", "WeightedSupermanFromFloor")
            }
            FitFieldHyperextensionExerciseName::SwissBallBackExtension => {
                write!(f, "{}", "SwissBallBackExtension")
            }
            FitFieldHyperextensionExerciseName::WeightedSwissBallBackExtension => {
                write!(f, "{}", "WeightedSwissBallBackExtension")
            }
            FitFieldHyperextensionExerciseName::SwissBallHyperextension => {
                write!(f, "{}", "SwissBallHyperextension")
            }
            FitFieldHyperextensionExerciseName::WeightedSwissBallHyperextension => {
                write!(f, "{}", "WeightedSwissBallHyperextension")
            }
            FitFieldHyperextensionExerciseName::SwissBallOppositeArmAndLegLift => {
                write!(f, "{}", "SwissBallOppositeArmAndLegLift")
            }
            FitFieldHyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift => {
                write!(f, "{}", "WeightedSwissBallOppositeArmAndLegLift")
            }
            FitFieldHyperextensionExerciseName::SupermanOnSwissBall => {
                write!(f, "{}", "SupermanOnSwissBall")
            }
            FitFieldHyperextensionExerciseName::Cobra => write!(f, "{}", "Cobra"),
            FitFieldHyperextensionExerciseName::SupineFloorBarre => {
                write!(f, "{}", "SupineFloorBarre")
            }
            FitFieldHyperextensionExerciseName::HyperextensionExerciseName(x) => {
                write!(f, "{}({})", "HyperextensionExerciseName", x)
            }
            FitFieldHyperextensionExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldHyperextensionExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldHyperextensionExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldHyperextensionExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldHyperextensionExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                1 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                2 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                3 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                4 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                5 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                6 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                7 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                8 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                9 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                10 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                11 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                12 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                13 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                14 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                15 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                16 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                17 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                18 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                19 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                20 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                21 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                22 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                23 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                24 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                25 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                26 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                27 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                28 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                29 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                30 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                31 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                32 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                33 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                34 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                35 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                36 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                37 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                38 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                39 => Ok(FitFieldHyperextensionExerciseName::from(v)),
                v => Ok(FitFieldHyperextensionExerciseName::HyperextensionExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldHyperextensionExerciseName);

impl From<u16> for FitFieldHyperextensionExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach,
            1 => {
                FitFieldHyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach
            }
            2 => FitFieldHyperextensionExerciseName::BaseRotations,
            3 => FitFieldHyperextensionExerciseName::WeightedBaseRotations,
            4 => FitFieldHyperextensionExerciseName::BentKneeReverseHyperextension,
            5 => FitFieldHyperextensionExerciseName::WeightedBentKneeReverseHyperextension,
            6 => FitFieldHyperextensionExerciseName::HollowHoldAndRoll,
            7 => FitFieldHyperextensionExerciseName::WeightedHollowHoldAndRoll,
            8 => FitFieldHyperextensionExerciseName::Kicks,
            9 => FitFieldHyperextensionExerciseName::WeightedKicks,
            10 => FitFieldHyperextensionExerciseName::KneeRaises,
            11 => FitFieldHyperextensionExerciseName::WeightedKneeRaises,
            12 => FitFieldHyperextensionExerciseName::KneelingSuperman,
            13 => FitFieldHyperextensionExerciseName::WeightedKneelingSuperman,
            14 => FitFieldHyperextensionExerciseName::LatPullDownWithRow,
            15 => FitFieldHyperextensionExerciseName::MedicineBallDeadliftToReach,
            16 => FitFieldHyperextensionExerciseName::OneArmOneLegRow,
            17 => FitFieldHyperextensionExerciseName::OneArmRowWithBand,
            18 => FitFieldHyperextensionExerciseName::OverheadLungeWithMedicineBall,
            19 => FitFieldHyperextensionExerciseName::PlankKneeTucks,
            20 => FitFieldHyperextensionExerciseName::WeightedPlankKneeTucks,
            21 => FitFieldHyperextensionExerciseName::SideStep,
            22 => FitFieldHyperextensionExerciseName::WeightedSideStep,
            23 => FitFieldHyperextensionExerciseName::SingleLegBackExtension,
            24 => FitFieldHyperextensionExerciseName::WeightedSingleLegBackExtension,
            25 => FitFieldHyperextensionExerciseName::SpineExtension,
            26 => FitFieldHyperextensionExerciseName::WeightedSpineExtension,
            27 => FitFieldHyperextensionExerciseName::StaticBackExtension,
            28 => FitFieldHyperextensionExerciseName::WeightedStaticBackExtension,
            29 => FitFieldHyperextensionExerciseName::SupermanFromFloor,
            30 => FitFieldHyperextensionExerciseName::WeightedSupermanFromFloor,
            31 => FitFieldHyperextensionExerciseName::SwissBallBackExtension,
            32 => FitFieldHyperextensionExerciseName::WeightedSwissBallBackExtension,
            33 => FitFieldHyperextensionExerciseName::SwissBallHyperextension,
            34 => FitFieldHyperextensionExerciseName::WeightedSwissBallHyperextension,
            35 => FitFieldHyperextensionExerciseName::SwissBallOppositeArmAndLegLift,
            36 => FitFieldHyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift,
            37 => FitFieldHyperextensionExerciseName::SupermanOnSwissBall,
            38 => FitFieldHyperextensionExerciseName::Cobra,
            39 => FitFieldHyperextensionExerciseName::SupineFloorBarre,
            _ => FitFieldHyperextensionExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLateralRaiseExerciseName {
    // fit base type: uint16
    FortyFiveDegreeCableExternalRotation,  // 0
    AlternatingLateralRaiseWithStaticHold, // 1
    BarMuscleUp,                           // 2
    BentOverLateralRaise,                  // 3
    CableDiagonalRaise,                    // 4
    CableFrontRaise,                       // 5
    CalorieRow,                            // 6
    ComboShoulderRaise,                    // 7
    DumbbellDiagonalRaise,                 // 8
    DumbbellVRaise,                        // 9
    FrontRaise,                            // 10
    LeaningDumbbellLateralRaise,           // 11
    LyingDumbbellRaise,                    // 12
    MuscleUp,                              // 13
    OneArmCableLateralRaise,               // 14
    OverhandGripRearLateralRaise,          // 15
    PlateRaises,                           // 16
    RingDip,                               // 17
    WeightedRingDip,                       // 18
    RingMuscleUp,                          // 19
    WeightedRingMuscleUp,                  // 20
    RopeClimb,                             // 21
    WeightedRopeClimb,                     // 22
    Scaption,                              // 23
    SeatedLateralRaise,                    // 24
    SeatedRearLateralRaise,                // 25
    SideLyingLateralRaise,                 // 26
    StandingLift,                          // 27
    SuspendedRow,                          // 28
    UnderhandGripRearLateralRaise,         // 29
    WallSlide,                             // 30
    WeightedWallSlide,                     // 31
    ArmCircles,                            // 32
    ShavingTheHead,                        // 33
    LateralRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLateralRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLateralRaiseExerciseName::FortyFiveDegreeCableExternalRotation => {
                write!(f, "{}", "FortyFiveDegreeCableExternalRotation")
            }
            FitFieldLateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold => {
                write!(f, "{}", "AlternatingLateralRaiseWithStaticHold")
            }
            FitFieldLateralRaiseExerciseName::BarMuscleUp => write!(f, "{}", "BarMuscleUp"),
            FitFieldLateralRaiseExerciseName::BentOverLateralRaise => {
                write!(f, "{}", "BentOverLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::CableDiagonalRaise => {
                write!(f, "{}", "CableDiagonalRaise")
            }
            FitFieldLateralRaiseExerciseName::CableFrontRaise => write!(f, "{}", "CableFrontRaise"),
            FitFieldLateralRaiseExerciseName::CalorieRow => write!(f, "{}", "CalorieRow"),
            FitFieldLateralRaiseExerciseName::ComboShoulderRaise => {
                write!(f, "{}", "ComboShoulderRaise")
            }
            FitFieldLateralRaiseExerciseName::DumbbellDiagonalRaise => {
                write!(f, "{}", "DumbbellDiagonalRaise")
            }
            FitFieldLateralRaiseExerciseName::DumbbellVRaise => write!(f, "{}", "DumbbellVRaise"),
            FitFieldLateralRaiseExerciseName::FrontRaise => write!(f, "{}", "FrontRaise"),
            FitFieldLateralRaiseExerciseName::LeaningDumbbellLateralRaise => {
                write!(f, "{}", "LeaningDumbbellLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::LyingDumbbellRaise => {
                write!(f, "{}", "LyingDumbbellRaise")
            }
            FitFieldLateralRaiseExerciseName::MuscleUp => write!(f, "{}", "MuscleUp"),
            FitFieldLateralRaiseExerciseName::OneArmCableLateralRaise => {
                write!(f, "{}", "OneArmCableLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::OverhandGripRearLateralRaise => {
                write!(f, "{}", "OverhandGripRearLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::PlateRaises => write!(f, "{}", "PlateRaises"),
            FitFieldLateralRaiseExerciseName::RingDip => write!(f, "{}", "RingDip"),
            FitFieldLateralRaiseExerciseName::WeightedRingDip => write!(f, "{}", "WeightedRingDip"),
            FitFieldLateralRaiseExerciseName::RingMuscleUp => write!(f, "{}", "RingMuscleUp"),
            FitFieldLateralRaiseExerciseName::WeightedRingMuscleUp => {
                write!(f, "{}", "WeightedRingMuscleUp")
            }
            FitFieldLateralRaiseExerciseName::RopeClimb => write!(f, "{}", "RopeClimb"),
            FitFieldLateralRaiseExerciseName::WeightedRopeClimb => {
                write!(f, "{}", "WeightedRopeClimb")
            }
            FitFieldLateralRaiseExerciseName::Scaption => write!(f, "{}", "Scaption"),
            FitFieldLateralRaiseExerciseName::SeatedLateralRaise => {
                write!(f, "{}", "SeatedLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::SeatedRearLateralRaise => {
                write!(f, "{}", "SeatedRearLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::SideLyingLateralRaise => {
                write!(f, "{}", "SideLyingLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::StandingLift => write!(f, "{}", "StandingLift"),
            FitFieldLateralRaiseExerciseName::SuspendedRow => write!(f, "{}", "SuspendedRow"),
            FitFieldLateralRaiseExerciseName::UnderhandGripRearLateralRaise => {
                write!(f, "{}", "UnderhandGripRearLateralRaise")
            }
            FitFieldLateralRaiseExerciseName::WallSlide => write!(f, "{}", "WallSlide"),
            FitFieldLateralRaiseExerciseName::WeightedWallSlide => {
                write!(f, "{}", "WeightedWallSlide")
            }
            FitFieldLateralRaiseExerciseName::ArmCircles => write!(f, "{}", "ArmCircles"),
            FitFieldLateralRaiseExerciseName::ShavingTheHead => write!(f, "{}", "ShavingTheHead"),
            FitFieldLateralRaiseExerciseName::LateralRaiseExerciseName(x) => {
                write!(f, "{}({})", "LateralRaiseExerciseName", x)
            }
            FitFieldLateralRaiseExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLateralRaiseExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLateralRaiseExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldLateralRaiseExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLateralRaiseExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                1 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                2 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                3 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                4 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                5 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                6 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                7 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                8 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                9 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                10 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                11 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                12 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                13 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                14 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                15 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                16 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                17 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                18 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                19 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                20 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                21 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                22 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                23 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                24 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                25 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                26 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                27 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                28 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                29 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                30 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                31 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                32 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                33 => Ok(FitFieldLateralRaiseExerciseName::from(v)),
                v => Ok(FitFieldLateralRaiseExerciseName::LateralRaiseExerciseName(
                    v,
                )),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLateralRaiseExerciseName);

impl From<u16> for FitFieldLateralRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLateralRaiseExerciseName::FortyFiveDegreeCableExternalRotation,
            1 => FitFieldLateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold,
            2 => FitFieldLateralRaiseExerciseName::BarMuscleUp,
            3 => FitFieldLateralRaiseExerciseName::BentOverLateralRaise,
            4 => FitFieldLateralRaiseExerciseName::CableDiagonalRaise,
            5 => FitFieldLateralRaiseExerciseName::CableFrontRaise,
            6 => FitFieldLateralRaiseExerciseName::CalorieRow,
            7 => FitFieldLateralRaiseExerciseName::ComboShoulderRaise,
            8 => FitFieldLateralRaiseExerciseName::DumbbellDiagonalRaise,
            9 => FitFieldLateralRaiseExerciseName::DumbbellVRaise,
            10 => FitFieldLateralRaiseExerciseName::FrontRaise,
            11 => FitFieldLateralRaiseExerciseName::LeaningDumbbellLateralRaise,
            12 => FitFieldLateralRaiseExerciseName::LyingDumbbellRaise,
            13 => FitFieldLateralRaiseExerciseName::MuscleUp,
            14 => FitFieldLateralRaiseExerciseName::OneArmCableLateralRaise,
            15 => FitFieldLateralRaiseExerciseName::OverhandGripRearLateralRaise,
            16 => FitFieldLateralRaiseExerciseName::PlateRaises,
            17 => FitFieldLateralRaiseExerciseName::RingDip,
            18 => FitFieldLateralRaiseExerciseName::WeightedRingDip,
            19 => FitFieldLateralRaiseExerciseName::RingMuscleUp,
            20 => FitFieldLateralRaiseExerciseName::WeightedRingMuscleUp,
            21 => FitFieldLateralRaiseExerciseName::RopeClimb,
            22 => FitFieldLateralRaiseExerciseName::WeightedRopeClimb,
            23 => FitFieldLateralRaiseExerciseName::Scaption,
            24 => FitFieldLateralRaiseExerciseName::SeatedLateralRaise,
            25 => FitFieldLateralRaiseExerciseName::SeatedRearLateralRaise,
            26 => FitFieldLateralRaiseExerciseName::SideLyingLateralRaise,
            27 => FitFieldLateralRaiseExerciseName::StandingLift,
            28 => FitFieldLateralRaiseExerciseName::SuspendedRow,
            29 => FitFieldLateralRaiseExerciseName::UnderhandGripRearLateralRaise,
            30 => FitFieldLateralRaiseExerciseName::WallSlide,
            31 => FitFieldLateralRaiseExerciseName::WeightedWallSlide,
            32 => FitFieldLateralRaiseExerciseName::ArmCircles,
            33 => FitFieldLateralRaiseExerciseName::ShavingTheHead,
            _ => FitFieldLateralRaiseExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLegCurlExerciseName {
    // fit base type: uint16
    LegCurl,                     // 0
    WeightedLegCurl,             // 1
    GoodMorning,                 // 2
    SeatedBarbellGoodMorning,    // 3
    SingleLegBarbellGoodMorning, // 4
    SingleLegSlidingLegCurl,     // 5
    SlidingLegCurl,              // 6
    SplitBarbellGoodMorning,     // 7
    SplitStanceExtension,        // 8
    StaggeredStanceGoodMorning,  // 9
    SwissBallHipRaiseAndLegCurl, // 10
    ZercherGoodMorning,          // 11
    LegCurlExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLegCurlExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLegCurlExerciseName::LegCurl => write!(f, "{}", "LegCurl"),
            FitFieldLegCurlExerciseName::WeightedLegCurl => write!(f, "{}", "WeightedLegCurl"),
            FitFieldLegCurlExerciseName::GoodMorning => write!(f, "{}", "GoodMorning"),
            FitFieldLegCurlExerciseName::SeatedBarbellGoodMorning => {
                write!(f, "{}", "SeatedBarbellGoodMorning")
            }
            FitFieldLegCurlExerciseName::SingleLegBarbellGoodMorning => {
                write!(f, "{}", "SingleLegBarbellGoodMorning")
            }
            FitFieldLegCurlExerciseName::SingleLegSlidingLegCurl => {
                write!(f, "{}", "SingleLegSlidingLegCurl")
            }
            FitFieldLegCurlExerciseName::SlidingLegCurl => write!(f, "{}", "SlidingLegCurl"),
            FitFieldLegCurlExerciseName::SplitBarbellGoodMorning => {
                write!(f, "{}", "SplitBarbellGoodMorning")
            }
            FitFieldLegCurlExerciseName::SplitStanceExtension => {
                write!(f, "{}", "SplitStanceExtension")
            }
            FitFieldLegCurlExerciseName::StaggeredStanceGoodMorning => {
                write!(f, "{}", "StaggeredStanceGoodMorning")
            }
            FitFieldLegCurlExerciseName::SwissBallHipRaiseAndLegCurl => {
                write!(f, "{}", "SwissBallHipRaiseAndLegCurl")
            }
            FitFieldLegCurlExerciseName::ZercherGoodMorning => {
                write!(f, "{}", "ZercherGoodMorning")
            }
            FitFieldLegCurlExerciseName::LegCurlExerciseName(x) => {
                write!(f, "{}({})", "LegCurlExerciseName", x)
            }
            FitFieldLegCurlExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLegCurlExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLegCurlExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLegCurlExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLegCurlExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldLegCurlExerciseName::from(v)),
                1 => Ok(FitFieldLegCurlExerciseName::from(v)),
                2 => Ok(FitFieldLegCurlExerciseName::from(v)),
                3 => Ok(FitFieldLegCurlExerciseName::from(v)),
                4 => Ok(FitFieldLegCurlExerciseName::from(v)),
                5 => Ok(FitFieldLegCurlExerciseName::from(v)),
                6 => Ok(FitFieldLegCurlExerciseName::from(v)),
                7 => Ok(FitFieldLegCurlExerciseName::from(v)),
                8 => Ok(FitFieldLegCurlExerciseName::from(v)),
                9 => Ok(FitFieldLegCurlExerciseName::from(v)),
                10 => Ok(FitFieldLegCurlExerciseName::from(v)),
                11 => Ok(FitFieldLegCurlExerciseName::from(v)),
                v => Ok(FitFieldLegCurlExerciseName::LegCurlExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLegCurlExerciseName);

impl From<u16> for FitFieldLegCurlExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLegCurlExerciseName::LegCurl,
            1 => FitFieldLegCurlExerciseName::WeightedLegCurl,
            2 => FitFieldLegCurlExerciseName::GoodMorning,
            3 => FitFieldLegCurlExerciseName::SeatedBarbellGoodMorning,
            4 => FitFieldLegCurlExerciseName::SingleLegBarbellGoodMorning,
            5 => FitFieldLegCurlExerciseName::SingleLegSlidingLegCurl,
            6 => FitFieldLegCurlExerciseName::SlidingLegCurl,
            7 => FitFieldLegCurlExerciseName::SplitBarbellGoodMorning,
            8 => FitFieldLegCurlExerciseName::SplitStanceExtension,
            9 => FitFieldLegCurlExerciseName::StaggeredStanceGoodMorning,
            10 => FitFieldLegCurlExerciseName::SwissBallHipRaiseAndLegCurl,
            11 => FitFieldLegCurlExerciseName::ZercherGoodMorning,
            _ => FitFieldLegCurlExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLegRaiseExerciseName {
    // fit base type: uint16
    HangingKneeRaise,                   // 0
    HangingLegRaise,                    // 1
    WeightedHangingLegRaise,            // 2
    HangingSingleLegRaise,              // 3
    WeightedHangingSingleLegRaise,      // 4
    KettlebellLegRaises,                // 5
    LegLoweringDrill,                   // 6
    WeightedLegLoweringDrill,           // 7
    LyingStraightLegRaise,              // 8
    WeightedLyingStraightLegRaise,      // 9
    MedicineBallLegDrops,               // 10
    QuadrupedLegRaise,                  // 11
    WeightedQuadrupedLegRaise,          // 12
    ReverseLegRaise,                    // 13
    WeightedReverseLegRaise,            // 14
    ReverseLegRaiseOnSwissBall,         // 15
    WeightedReverseLegRaiseOnSwissBall, // 16
    SingleLegLoweringDrill,             // 17
    WeightedSingleLegLoweringDrill,     // 18
    WeightedHangingKneeRaise,           // 19
    LateralStepover,                    // 20
    WeightedLateralStepover,            // 21
    LegRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLegRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLegRaiseExerciseName::HangingKneeRaise => write!(f, "{}", "HangingKneeRaise"),
            FitFieldLegRaiseExerciseName::HangingLegRaise => write!(f, "{}", "HangingLegRaise"),
            FitFieldLegRaiseExerciseName::WeightedHangingLegRaise => {
                write!(f, "{}", "WeightedHangingLegRaise")
            }
            FitFieldLegRaiseExerciseName::HangingSingleLegRaise => {
                write!(f, "{}", "HangingSingleLegRaise")
            }
            FitFieldLegRaiseExerciseName::WeightedHangingSingleLegRaise => {
                write!(f, "{}", "WeightedHangingSingleLegRaise")
            }
            FitFieldLegRaiseExerciseName::KettlebellLegRaises => {
                write!(f, "{}", "KettlebellLegRaises")
            }
            FitFieldLegRaiseExerciseName::LegLoweringDrill => write!(f, "{}", "LegLoweringDrill"),
            FitFieldLegRaiseExerciseName::WeightedLegLoweringDrill => {
                write!(f, "{}", "WeightedLegLoweringDrill")
            }
            FitFieldLegRaiseExerciseName::LyingStraightLegRaise => {
                write!(f, "{}", "LyingStraightLegRaise")
            }
            FitFieldLegRaiseExerciseName::WeightedLyingStraightLegRaise => {
                write!(f, "{}", "WeightedLyingStraightLegRaise")
            }
            FitFieldLegRaiseExerciseName::MedicineBallLegDrops => {
                write!(f, "{}", "MedicineBallLegDrops")
            }
            FitFieldLegRaiseExerciseName::QuadrupedLegRaise => write!(f, "{}", "QuadrupedLegRaise"),
            FitFieldLegRaiseExerciseName::WeightedQuadrupedLegRaise => {
                write!(f, "{}", "WeightedQuadrupedLegRaise")
            }
            FitFieldLegRaiseExerciseName::ReverseLegRaise => write!(f, "{}", "ReverseLegRaise"),
            FitFieldLegRaiseExerciseName::WeightedReverseLegRaise => {
                write!(f, "{}", "WeightedReverseLegRaise")
            }
            FitFieldLegRaiseExerciseName::ReverseLegRaiseOnSwissBall => {
                write!(f, "{}", "ReverseLegRaiseOnSwissBall")
            }
            FitFieldLegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall => {
                write!(f, "{}", "WeightedReverseLegRaiseOnSwissBall")
            }
            FitFieldLegRaiseExerciseName::SingleLegLoweringDrill => {
                write!(f, "{}", "SingleLegLoweringDrill")
            }
            FitFieldLegRaiseExerciseName::WeightedSingleLegLoweringDrill => {
                write!(f, "{}", "WeightedSingleLegLoweringDrill")
            }
            FitFieldLegRaiseExerciseName::WeightedHangingKneeRaise => {
                write!(f, "{}", "WeightedHangingKneeRaise")
            }
            FitFieldLegRaiseExerciseName::LateralStepover => write!(f, "{}", "LateralStepover"),
            FitFieldLegRaiseExerciseName::WeightedLateralStepover => {
                write!(f, "{}", "WeightedLateralStepover")
            }
            FitFieldLegRaiseExerciseName::LegRaiseExerciseName(x) => {
                write!(f, "{}({})", "LegRaiseExerciseName", x)
            }
            FitFieldLegRaiseExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLegRaiseExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLegRaiseExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLegRaiseExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLegRaiseExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                1 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                2 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                3 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                4 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                5 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                6 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                7 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                8 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                9 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                10 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                11 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                12 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                13 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                14 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                15 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                16 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                17 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                18 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                19 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                20 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                21 => Ok(FitFieldLegRaiseExerciseName::from(v)),
                v => Ok(FitFieldLegRaiseExerciseName::LegRaiseExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLegRaiseExerciseName);

impl From<u16> for FitFieldLegRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLegRaiseExerciseName::HangingKneeRaise,
            1 => FitFieldLegRaiseExerciseName::HangingLegRaise,
            2 => FitFieldLegRaiseExerciseName::WeightedHangingLegRaise,
            3 => FitFieldLegRaiseExerciseName::HangingSingleLegRaise,
            4 => FitFieldLegRaiseExerciseName::WeightedHangingSingleLegRaise,
            5 => FitFieldLegRaiseExerciseName::KettlebellLegRaises,
            6 => FitFieldLegRaiseExerciseName::LegLoweringDrill,
            7 => FitFieldLegRaiseExerciseName::WeightedLegLoweringDrill,
            8 => FitFieldLegRaiseExerciseName::LyingStraightLegRaise,
            9 => FitFieldLegRaiseExerciseName::WeightedLyingStraightLegRaise,
            10 => FitFieldLegRaiseExerciseName::MedicineBallLegDrops,
            11 => FitFieldLegRaiseExerciseName::QuadrupedLegRaise,
            12 => FitFieldLegRaiseExerciseName::WeightedQuadrupedLegRaise,
            13 => FitFieldLegRaiseExerciseName::ReverseLegRaise,
            14 => FitFieldLegRaiseExerciseName::WeightedReverseLegRaise,
            15 => FitFieldLegRaiseExerciseName::ReverseLegRaiseOnSwissBall,
            16 => FitFieldLegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall,
            17 => FitFieldLegRaiseExerciseName::SingleLegLoweringDrill,
            18 => FitFieldLegRaiseExerciseName::WeightedSingleLegLoweringDrill,
            19 => FitFieldLegRaiseExerciseName::WeightedHangingKneeRaise,
            20 => FitFieldLegRaiseExerciseName::LateralStepover,
            21 => FitFieldLegRaiseExerciseName::WeightedLateralStepover,
            _ => FitFieldLegRaiseExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldLungeExerciseName {
    // fit base type: uint16
    OverheadLunge,                                 // 0
    LungeMatrix,                                   // 1
    WeightedLungeMatrix,                           // 2
    AlternatingBarbellForwardLunge,                // 3
    AlternatingDumbbellLungeWithReach,             // 4
    BackFootElevatedDumbbellSplitSquat,            // 5
    BarbellBoxLunge,                               // 6
    BarbellBulgarianSplitSquat,                    // 7
    BarbellCrossoverLunge,                         // 8
    BarbellFrontSplitSquat,                        // 9
    BarbellLunge,                                  // 10
    BarbellReverseLunge,                           // 11
    BarbellSideLunge,                              // 12
    BarbellSplitSquat,                             // 13
    CoreControlRearLunge,                          // 14
    DiagonalLunge,                                 // 15
    DropLunge,                                     // 16
    DumbbellBoxLunge,                              // 17
    DumbbellBulgarianSplitSquat,                   // 18
    DumbbellCrossoverLunge,                        // 19
    DumbbellDiagonalLunge,                         // 20
    DumbbellLunge,                                 // 21
    DumbbellLungeAndRotation,                      // 22
    DumbbellOverheadBulgarianSplitSquat,           // 23
    DumbbellReverseLungeToHighKneeAndPress,        // 24
    DumbbellSideLunge,                             // 25
    ElevatedFrontFootBarbellSplitSquat,            // 26
    FrontFootElevatedDumbbellSplitSquat,           // 27
    GunslingerLunge,                               // 28
    LawnmowerLunge,                                // 29
    LowLungeWithIsometricAdduction,                // 30
    LowSideToSideLunge,                            // 31
    Lunge,                                         // 32
    WeightedLunge,                                 // 33
    LungeWithArmReach,                             // 34
    LungeWithDiagonalReach,                        // 35
    LungeWithSideBend,                             // 36
    OffsetDumbbellLunge,                           // 37
    OffsetDumbbellReverseLunge,                    // 38
    OverheadBulgarianSplitSquat,                   // 39
    OverheadDumbbellReverseLunge,                  // 40
    OverheadDumbbellSplitSquat,                    // 41
    OverheadLungeWithRotation,                     // 42
    ReverseBarbellBoxLunge,                        // 43
    ReverseBoxLunge,                               // 44
    ReverseDumbbellBoxLunge,                       // 45
    ReverseDumbbellCrossoverLunge,                 // 46
    ReverseDumbbellDiagonalLunge,                  // 47
    ReverseLungeWithReachBack,                     // 48
    WeightedReverseLungeWithReachBack,             // 49
    ReverseLungeWithTwistAndOverheadReach,         // 50
    WeightedReverseLungeWithTwistAndOverheadReach, // 51
    ReverseSlidingBoxLunge,                        // 52
    WeightedReverseSlidingBoxLunge,                // 53
    ReverseSlidingLunge,                           // 54
    WeightedReverseSlidingLunge,                   // 55
    RunnersLungeToBalance,                         // 56
    WeightedRunnersLungeToBalance,                 // 57
    ShiftingSideLunge,                             // 58
    SideAndCrossoverLunge,                         // 59
    WeightedSideAndCrossoverLunge,                 // 60
    SideLunge,                                     // 61
    WeightedSideLunge,                             // 62
    SideLungeAndPress,                             // 63
    SideLungeJumpOff,                              // 64
    SideLungeSweep,                                // 65
    WeightedSideLungeSweep,                        // 66
    SideLungeToCrossoverTap,                       // 67
    WeightedSideLungeToCrossoverTap,               // 68
    SideToSideLungeChops,                          // 69
    WeightedSideToSideLungeChops,                  // 70
    SiffJumpLunge,                                 // 71
    WeightedSiffJumpLunge,                         // 72
    SingleArmReverseLungeAndPress,                 // 73
    SlidingLateralLunge,                           // 74
    WeightedSlidingLateralLunge,                   // 75
    WalkingBarbellLunge,                           // 76
    WalkingDumbbellLunge,                          // 77
    WalkingLunge,                                  // 78
    WeightedWalkingLunge,                          // 79
    WideGripOverheadBarbellSplitSquat,             // 80
    LungeExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldLungeExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldLungeExerciseName::OverheadLunge => write!(f, "{}", "OverheadLunge"),
            FitFieldLungeExerciseName::LungeMatrix => write!(f, "{}", "LungeMatrix"),
            FitFieldLungeExerciseName::WeightedLungeMatrix => {
                write!(f, "{}", "WeightedLungeMatrix")
            }
            FitFieldLungeExerciseName::AlternatingBarbellForwardLunge => {
                write!(f, "{}", "AlternatingBarbellForwardLunge")
            }
            FitFieldLungeExerciseName::AlternatingDumbbellLungeWithReach => {
                write!(f, "{}", "AlternatingDumbbellLungeWithReach")
            }
            FitFieldLungeExerciseName::BackFootElevatedDumbbellSplitSquat => {
                write!(f, "{}", "BackFootElevatedDumbbellSplitSquat")
            }
            FitFieldLungeExerciseName::BarbellBoxLunge => write!(f, "{}", "BarbellBoxLunge"),
            FitFieldLungeExerciseName::BarbellBulgarianSplitSquat => {
                write!(f, "{}", "BarbellBulgarianSplitSquat")
            }
            FitFieldLungeExerciseName::BarbellCrossoverLunge => {
                write!(f, "{}", "BarbellCrossoverLunge")
            }
            FitFieldLungeExerciseName::BarbellFrontSplitSquat => {
                write!(f, "{}", "BarbellFrontSplitSquat")
            }
            FitFieldLungeExerciseName::BarbellLunge => write!(f, "{}", "BarbellLunge"),
            FitFieldLungeExerciseName::BarbellReverseLunge => {
                write!(f, "{}", "BarbellReverseLunge")
            }
            FitFieldLungeExerciseName::BarbellSideLunge => write!(f, "{}", "BarbellSideLunge"),
            FitFieldLungeExerciseName::BarbellSplitSquat => write!(f, "{}", "BarbellSplitSquat"),
            FitFieldLungeExerciseName::CoreControlRearLunge => {
                write!(f, "{}", "CoreControlRearLunge")
            }
            FitFieldLungeExerciseName::DiagonalLunge => write!(f, "{}", "DiagonalLunge"),
            FitFieldLungeExerciseName::DropLunge => write!(f, "{}", "DropLunge"),
            FitFieldLungeExerciseName::DumbbellBoxLunge => write!(f, "{}", "DumbbellBoxLunge"),
            FitFieldLungeExerciseName::DumbbellBulgarianSplitSquat => {
                write!(f, "{}", "DumbbellBulgarianSplitSquat")
            }
            FitFieldLungeExerciseName::DumbbellCrossoverLunge => {
                write!(f, "{}", "DumbbellCrossoverLunge")
            }
            FitFieldLungeExerciseName::DumbbellDiagonalLunge => {
                write!(f, "{}", "DumbbellDiagonalLunge")
            }
            FitFieldLungeExerciseName::DumbbellLunge => write!(f, "{}", "DumbbellLunge"),
            FitFieldLungeExerciseName::DumbbellLungeAndRotation => {
                write!(f, "{}", "DumbbellLungeAndRotation")
            }
            FitFieldLungeExerciseName::DumbbellOverheadBulgarianSplitSquat => {
                write!(f, "{}", "DumbbellOverheadBulgarianSplitSquat")
            }
            FitFieldLungeExerciseName::DumbbellReverseLungeToHighKneeAndPress => {
                write!(f, "{}", "DumbbellReverseLungeToHighKneeAndPress")
            }
            FitFieldLungeExerciseName::DumbbellSideLunge => write!(f, "{}", "DumbbellSideLunge"),
            FitFieldLungeExerciseName::ElevatedFrontFootBarbellSplitSquat => {
                write!(f, "{}", "ElevatedFrontFootBarbellSplitSquat")
            }
            FitFieldLungeExerciseName::FrontFootElevatedDumbbellSplitSquat => {
                write!(f, "{}", "FrontFootElevatedDumbbellSplitSquat")
            }
            FitFieldLungeExerciseName::GunslingerLunge => write!(f, "{}", "GunslingerLunge"),
            FitFieldLungeExerciseName::LawnmowerLunge => write!(f, "{}", "LawnmowerLunge"),
            FitFieldLungeExerciseName::LowLungeWithIsometricAdduction => {
                write!(f, "{}", "LowLungeWithIsometricAdduction")
            }
            FitFieldLungeExerciseName::LowSideToSideLunge => write!(f, "{}", "LowSideToSideLunge"),
            FitFieldLungeExerciseName::Lunge => write!(f, "{}", "Lunge"),
            FitFieldLungeExerciseName::WeightedLunge => write!(f, "{}", "WeightedLunge"),
            FitFieldLungeExerciseName::LungeWithArmReach => write!(f, "{}", "LungeWithArmReach"),
            FitFieldLungeExerciseName::LungeWithDiagonalReach => {
                write!(f, "{}", "LungeWithDiagonalReach")
            }
            FitFieldLungeExerciseName::LungeWithSideBend => write!(f, "{}", "LungeWithSideBend"),
            FitFieldLungeExerciseName::OffsetDumbbellLunge => {
                write!(f, "{}", "OffsetDumbbellLunge")
            }
            FitFieldLungeExerciseName::OffsetDumbbellReverseLunge => {
                write!(f, "{}", "OffsetDumbbellReverseLunge")
            }
            FitFieldLungeExerciseName::OverheadBulgarianSplitSquat => {
                write!(f, "{}", "OverheadBulgarianSplitSquat")
            }
            FitFieldLungeExerciseName::OverheadDumbbellReverseLunge => {
                write!(f, "{}", "OverheadDumbbellReverseLunge")
            }
            FitFieldLungeExerciseName::OverheadDumbbellSplitSquat => {
                write!(f, "{}", "OverheadDumbbellSplitSquat")
            }
            FitFieldLungeExerciseName::OverheadLungeWithRotation => {
                write!(f, "{}", "OverheadLungeWithRotation")
            }
            FitFieldLungeExerciseName::ReverseBarbellBoxLunge => {
                write!(f, "{}", "ReverseBarbellBoxLunge")
            }
            FitFieldLungeExerciseName::ReverseBoxLunge => write!(f, "{}", "ReverseBoxLunge"),
            FitFieldLungeExerciseName::ReverseDumbbellBoxLunge => {
                write!(f, "{}", "ReverseDumbbellBoxLunge")
            }
            FitFieldLungeExerciseName::ReverseDumbbellCrossoverLunge => {
                write!(f, "{}", "ReverseDumbbellCrossoverLunge")
            }
            FitFieldLungeExerciseName::ReverseDumbbellDiagonalLunge => {
                write!(f, "{}", "ReverseDumbbellDiagonalLunge")
            }
            FitFieldLungeExerciseName::ReverseLungeWithReachBack => {
                write!(f, "{}", "ReverseLungeWithReachBack")
            }
            FitFieldLungeExerciseName::WeightedReverseLungeWithReachBack => {
                write!(f, "{}", "WeightedReverseLungeWithReachBack")
            }
            FitFieldLungeExerciseName::ReverseLungeWithTwistAndOverheadReach => {
                write!(f, "{}", "ReverseLungeWithTwistAndOverheadReach")
            }
            FitFieldLungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach => {
                write!(f, "{}", "WeightedReverseLungeWithTwistAndOverheadReach")
            }
            FitFieldLungeExerciseName::ReverseSlidingBoxLunge => {
                write!(f, "{}", "ReverseSlidingBoxLunge")
            }
            FitFieldLungeExerciseName::WeightedReverseSlidingBoxLunge => {
                write!(f, "{}", "WeightedReverseSlidingBoxLunge")
            }
            FitFieldLungeExerciseName::ReverseSlidingLunge => {
                write!(f, "{}", "ReverseSlidingLunge")
            }
            FitFieldLungeExerciseName::WeightedReverseSlidingLunge => {
                write!(f, "{}", "WeightedReverseSlidingLunge")
            }
            FitFieldLungeExerciseName::RunnersLungeToBalance => {
                write!(f, "{}", "RunnersLungeToBalance")
            }
            FitFieldLungeExerciseName::WeightedRunnersLungeToBalance => {
                write!(f, "{}", "WeightedRunnersLungeToBalance")
            }
            FitFieldLungeExerciseName::ShiftingSideLunge => write!(f, "{}", "ShiftingSideLunge"),
            FitFieldLungeExerciseName::SideAndCrossoverLunge => {
                write!(f, "{}", "SideAndCrossoverLunge")
            }
            FitFieldLungeExerciseName::WeightedSideAndCrossoverLunge => {
                write!(f, "{}", "WeightedSideAndCrossoverLunge")
            }
            FitFieldLungeExerciseName::SideLunge => write!(f, "{}", "SideLunge"),
            FitFieldLungeExerciseName::WeightedSideLunge => write!(f, "{}", "WeightedSideLunge"),
            FitFieldLungeExerciseName::SideLungeAndPress => write!(f, "{}", "SideLungeAndPress"),
            FitFieldLungeExerciseName::SideLungeJumpOff => write!(f, "{}", "SideLungeJumpOff"),
            FitFieldLungeExerciseName::SideLungeSweep => write!(f, "{}", "SideLungeSweep"),
            FitFieldLungeExerciseName::WeightedSideLungeSweep => {
                write!(f, "{}", "WeightedSideLungeSweep")
            }
            FitFieldLungeExerciseName::SideLungeToCrossoverTap => {
                write!(f, "{}", "SideLungeToCrossoverTap")
            }
            FitFieldLungeExerciseName::WeightedSideLungeToCrossoverTap => {
                write!(f, "{}", "WeightedSideLungeToCrossoverTap")
            }
            FitFieldLungeExerciseName::SideToSideLungeChops => {
                write!(f, "{}", "SideToSideLungeChops")
            }
            FitFieldLungeExerciseName::WeightedSideToSideLungeChops => {
                write!(f, "{}", "WeightedSideToSideLungeChops")
            }
            FitFieldLungeExerciseName::SiffJumpLunge => write!(f, "{}", "SiffJumpLunge"),
            FitFieldLungeExerciseName::WeightedSiffJumpLunge => {
                write!(f, "{}", "WeightedSiffJumpLunge")
            }
            FitFieldLungeExerciseName::SingleArmReverseLungeAndPress => {
                write!(f, "{}", "SingleArmReverseLungeAndPress")
            }
            FitFieldLungeExerciseName::SlidingLateralLunge => {
                write!(f, "{}", "SlidingLateralLunge")
            }
            FitFieldLungeExerciseName::WeightedSlidingLateralLunge => {
                write!(f, "{}", "WeightedSlidingLateralLunge")
            }
            FitFieldLungeExerciseName::WalkingBarbellLunge => {
                write!(f, "{}", "WalkingBarbellLunge")
            }
            FitFieldLungeExerciseName::WalkingDumbbellLunge => {
                write!(f, "{}", "WalkingDumbbellLunge")
            }
            FitFieldLungeExerciseName::WalkingLunge => write!(f, "{}", "WalkingLunge"),
            FitFieldLungeExerciseName::WeightedWalkingLunge => {
                write!(f, "{}", "WeightedWalkingLunge")
            }
            FitFieldLungeExerciseName::WideGripOverheadBarbellSplitSquat => {
                write!(f, "{}", "WideGripOverheadBarbellSplitSquat")
            }
            FitFieldLungeExerciseName::LungeExerciseName(x) => {
                write!(f, "{}({})", "LungeExerciseName", x)
            }
            FitFieldLungeExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldLungeExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldLungeExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldLungeExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldLungeExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldLungeExerciseName::from(v)),
                1 => Ok(FitFieldLungeExerciseName::from(v)),
                2 => Ok(FitFieldLungeExerciseName::from(v)),
                3 => Ok(FitFieldLungeExerciseName::from(v)),
                4 => Ok(FitFieldLungeExerciseName::from(v)),
                5 => Ok(FitFieldLungeExerciseName::from(v)),
                6 => Ok(FitFieldLungeExerciseName::from(v)),
                7 => Ok(FitFieldLungeExerciseName::from(v)),
                8 => Ok(FitFieldLungeExerciseName::from(v)),
                9 => Ok(FitFieldLungeExerciseName::from(v)),
                10 => Ok(FitFieldLungeExerciseName::from(v)),
                11 => Ok(FitFieldLungeExerciseName::from(v)),
                12 => Ok(FitFieldLungeExerciseName::from(v)),
                13 => Ok(FitFieldLungeExerciseName::from(v)),
                14 => Ok(FitFieldLungeExerciseName::from(v)),
                15 => Ok(FitFieldLungeExerciseName::from(v)),
                16 => Ok(FitFieldLungeExerciseName::from(v)),
                17 => Ok(FitFieldLungeExerciseName::from(v)),
                18 => Ok(FitFieldLungeExerciseName::from(v)),
                19 => Ok(FitFieldLungeExerciseName::from(v)),
                20 => Ok(FitFieldLungeExerciseName::from(v)),
                21 => Ok(FitFieldLungeExerciseName::from(v)),
                22 => Ok(FitFieldLungeExerciseName::from(v)),
                23 => Ok(FitFieldLungeExerciseName::from(v)),
                24 => Ok(FitFieldLungeExerciseName::from(v)),
                25 => Ok(FitFieldLungeExerciseName::from(v)),
                26 => Ok(FitFieldLungeExerciseName::from(v)),
                27 => Ok(FitFieldLungeExerciseName::from(v)),
                28 => Ok(FitFieldLungeExerciseName::from(v)),
                29 => Ok(FitFieldLungeExerciseName::from(v)),
                30 => Ok(FitFieldLungeExerciseName::from(v)),
                31 => Ok(FitFieldLungeExerciseName::from(v)),
                32 => Ok(FitFieldLungeExerciseName::from(v)),
                33 => Ok(FitFieldLungeExerciseName::from(v)),
                34 => Ok(FitFieldLungeExerciseName::from(v)),
                35 => Ok(FitFieldLungeExerciseName::from(v)),
                36 => Ok(FitFieldLungeExerciseName::from(v)),
                37 => Ok(FitFieldLungeExerciseName::from(v)),
                38 => Ok(FitFieldLungeExerciseName::from(v)),
                39 => Ok(FitFieldLungeExerciseName::from(v)),
                40 => Ok(FitFieldLungeExerciseName::from(v)),
                41 => Ok(FitFieldLungeExerciseName::from(v)),
                42 => Ok(FitFieldLungeExerciseName::from(v)),
                43 => Ok(FitFieldLungeExerciseName::from(v)),
                44 => Ok(FitFieldLungeExerciseName::from(v)),
                45 => Ok(FitFieldLungeExerciseName::from(v)),
                46 => Ok(FitFieldLungeExerciseName::from(v)),
                47 => Ok(FitFieldLungeExerciseName::from(v)),
                48 => Ok(FitFieldLungeExerciseName::from(v)),
                49 => Ok(FitFieldLungeExerciseName::from(v)),
                50 => Ok(FitFieldLungeExerciseName::from(v)),
                51 => Ok(FitFieldLungeExerciseName::from(v)),
                52 => Ok(FitFieldLungeExerciseName::from(v)),
                53 => Ok(FitFieldLungeExerciseName::from(v)),
                54 => Ok(FitFieldLungeExerciseName::from(v)),
                55 => Ok(FitFieldLungeExerciseName::from(v)),
                56 => Ok(FitFieldLungeExerciseName::from(v)),
                57 => Ok(FitFieldLungeExerciseName::from(v)),
                58 => Ok(FitFieldLungeExerciseName::from(v)),
                59 => Ok(FitFieldLungeExerciseName::from(v)),
                60 => Ok(FitFieldLungeExerciseName::from(v)),
                61 => Ok(FitFieldLungeExerciseName::from(v)),
                62 => Ok(FitFieldLungeExerciseName::from(v)),
                63 => Ok(FitFieldLungeExerciseName::from(v)),
                64 => Ok(FitFieldLungeExerciseName::from(v)),
                65 => Ok(FitFieldLungeExerciseName::from(v)),
                66 => Ok(FitFieldLungeExerciseName::from(v)),
                67 => Ok(FitFieldLungeExerciseName::from(v)),
                68 => Ok(FitFieldLungeExerciseName::from(v)),
                69 => Ok(FitFieldLungeExerciseName::from(v)),
                70 => Ok(FitFieldLungeExerciseName::from(v)),
                71 => Ok(FitFieldLungeExerciseName::from(v)),
                72 => Ok(FitFieldLungeExerciseName::from(v)),
                73 => Ok(FitFieldLungeExerciseName::from(v)),
                74 => Ok(FitFieldLungeExerciseName::from(v)),
                75 => Ok(FitFieldLungeExerciseName::from(v)),
                76 => Ok(FitFieldLungeExerciseName::from(v)),
                77 => Ok(FitFieldLungeExerciseName::from(v)),
                78 => Ok(FitFieldLungeExerciseName::from(v)),
                79 => Ok(FitFieldLungeExerciseName::from(v)),
                80 => Ok(FitFieldLungeExerciseName::from(v)),
                v => Ok(FitFieldLungeExerciseName::LungeExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldLungeExerciseName);

impl From<u16> for FitFieldLungeExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLungeExerciseName::OverheadLunge,
            1 => FitFieldLungeExerciseName::LungeMatrix,
            2 => FitFieldLungeExerciseName::WeightedLungeMatrix,
            3 => FitFieldLungeExerciseName::AlternatingBarbellForwardLunge,
            4 => FitFieldLungeExerciseName::AlternatingDumbbellLungeWithReach,
            5 => FitFieldLungeExerciseName::BackFootElevatedDumbbellSplitSquat,
            6 => FitFieldLungeExerciseName::BarbellBoxLunge,
            7 => FitFieldLungeExerciseName::BarbellBulgarianSplitSquat,
            8 => FitFieldLungeExerciseName::BarbellCrossoverLunge,
            9 => FitFieldLungeExerciseName::BarbellFrontSplitSquat,
            10 => FitFieldLungeExerciseName::BarbellLunge,
            11 => FitFieldLungeExerciseName::BarbellReverseLunge,
            12 => FitFieldLungeExerciseName::BarbellSideLunge,
            13 => FitFieldLungeExerciseName::BarbellSplitSquat,
            14 => FitFieldLungeExerciseName::CoreControlRearLunge,
            15 => FitFieldLungeExerciseName::DiagonalLunge,
            16 => FitFieldLungeExerciseName::DropLunge,
            17 => FitFieldLungeExerciseName::DumbbellBoxLunge,
            18 => FitFieldLungeExerciseName::DumbbellBulgarianSplitSquat,
            19 => FitFieldLungeExerciseName::DumbbellCrossoverLunge,
            20 => FitFieldLungeExerciseName::DumbbellDiagonalLunge,
            21 => FitFieldLungeExerciseName::DumbbellLunge,
            22 => FitFieldLungeExerciseName::DumbbellLungeAndRotation,
            23 => FitFieldLungeExerciseName::DumbbellOverheadBulgarianSplitSquat,
            24 => FitFieldLungeExerciseName::DumbbellReverseLungeToHighKneeAndPress,
            25 => FitFieldLungeExerciseName::DumbbellSideLunge,
            26 => FitFieldLungeExerciseName::ElevatedFrontFootBarbellSplitSquat,
            27 => FitFieldLungeExerciseName::FrontFootElevatedDumbbellSplitSquat,
            28 => FitFieldLungeExerciseName::GunslingerLunge,
            29 => FitFieldLungeExerciseName::LawnmowerLunge,
            30 => FitFieldLungeExerciseName::LowLungeWithIsometricAdduction,
            31 => FitFieldLungeExerciseName::LowSideToSideLunge,
            32 => FitFieldLungeExerciseName::Lunge,
            33 => FitFieldLungeExerciseName::WeightedLunge,
            34 => FitFieldLungeExerciseName::LungeWithArmReach,
            35 => FitFieldLungeExerciseName::LungeWithDiagonalReach,
            36 => FitFieldLungeExerciseName::LungeWithSideBend,
            37 => FitFieldLungeExerciseName::OffsetDumbbellLunge,
            38 => FitFieldLungeExerciseName::OffsetDumbbellReverseLunge,
            39 => FitFieldLungeExerciseName::OverheadBulgarianSplitSquat,
            40 => FitFieldLungeExerciseName::OverheadDumbbellReverseLunge,
            41 => FitFieldLungeExerciseName::OverheadDumbbellSplitSquat,
            42 => FitFieldLungeExerciseName::OverheadLungeWithRotation,
            43 => FitFieldLungeExerciseName::ReverseBarbellBoxLunge,
            44 => FitFieldLungeExerciseName::ReverseBoxLunge,
            45 => FitFieldLungeExerciseName::ReverseDumbbellBoxLunge,
            46 => FitFieldLungeExerciseName::ReverseDumbbellCrossoverLunge,
            47 => FitFieldLungeExerciseName::ReverseDumbbellDiagonalLunge,
            48 => FitFieldLungeExerciseName::ReverseLungeWithReachBack,
            49 => FitFieldLungeExerciseName::WeightedReverseLungeWithReachBack,
            50 => FitFieldLungeExerciseName::ReverseLungeWithTwistAndOverheadReach,
            51 => FitFieldLungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach,
            52 => FitFieldLungeExerciseName::ReverseSlidingBoxLunge,
            53 => FitFieldLungeExerciseName::WeightedReverseSlidingBoxLunge,
            54 => FitFieldLungeExerciseName::ReverseSlidingLunge,
            55 => FitFieldLungeExerciseName::WeightedReverseSlidingLunge,
            56 => FitFieldLungeExerciseName::RunnersLungeToBalance,
            57 => FitFieldLungeExerciseName::WeightedRunnersLungeToBalance,
            58 => FitFieldLungeExerciseName::ShiftingSideLunge,
            59 => FitFieldLungeExerciseName::SideAndCrossoverLunge,
            60 => FitFieldLungeExerciseName::WeightedSideAndCrossoverLunge,
            61 => FitFieldLungeExerciseName::SideLunge,
            62 => FitFieldLungeExerciseName::WeightedSideLunge,
            63 => FitFieldLungeExerciseName::SideLungeAndPress,
            64 => FitFieldLungeExerciseName::SideLungeJumpOff,
            65 => FitFieldLungeExerciseName::SideLungeSweep,
            66 => FitFieldLungeExerciseName::WeightedSideLungeSweep,
            67 => FitFieldLungeExerciseName::SideLungeToCrossoverTap,
            68 => FitFieldLungeExerciseName::WeightedSideLungeToCrossoverTap,
            69 => FitFieldLungeExerciseName::SideToSideLungeChops,
            70 => FitFieldLungeExerciseName::WeightedSideToSideLungeChops,
            71 => FitFieldLungeExerciseName::SiffJumpLunge,
            72 => FitFieldLungeExerciseName::WeightedSiffJumpLunge,
            73 => FitFieldLungeExerciseName::SingleArmReverseLungeAndPress,
            74 => FitFieldLungeExerciseName::SlidingLateralLunge,
            75 => FitFieldLungeExerciseName::WeightedSlidingLateralLunge,
            76 => FitFieldLungeExerciseName::WalkingBarbellLunge,
            77 => FitFieldLungeExerciseName::WalkingDumbbellLunge,
            78 => FitFieldLungeExerciseName::WalkingLunge,
            79 => FitFieldLungeExerciseName::WeightedWalkingLunge,
            80 => FitFieldLungeExerciseName::WideGripOverheadBarbellSplitSquat,
            _ => FitFieldLungeExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldOlympicLiftExerciseName {
    // fit base type: uint16
    BarbellHangPowerClean,      // 0
    BarbellHangSquatClean,      // 1
    BarbellPowerClean,          // 2
    BarbellPowerSnatch,         // 3
    BarbellSquatClean,          // 4
    CleanAndJerk,               // 5
    BarbellHangPowerSnatch,     // 6
    BarbellHangPull,            // 7
    BarbellHighPull,            // 8
    BarbellSnatch,              // 9
    BarbellSplitJerk,           // 10
    Clean,                      // 11
    DumbbellClean,              // 12
    DumbbellHangPull,           // 13
    OneHandDumbbellSplitSnatch, // 14
    PushJerk,                   // 15
    SingleArmDumbbellSnatch,    // 16
    SingleArmHangSnatch,        // 17
    SingleArmKettlebellSnatch,  // 18
    SplitJerk,                  // 19
    SquatCleanAndJerk,          // 20
    OlympicLiftExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldOlympicLiftExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldOlympicLiftExerciseName::BarbellHangPowerClean => {
                write!(f, "{}", "BarbellHangPowerClean")
            }
            FitFieldOlympicLiftExerciseName::BarbellHangSquatClean => {
                write!(f, "{}", "BarbellHangSquatClean")
            }
            FitFieldOlympicLiftExerciseName::BarbellPowerClean => {
                write!(f, "{}", "BarbellPowerClean")
            }
            FitFieldOlympicLiftExerciseName::BarbellPowerSnatch => {
                write!(f, "{}", "BarbellPowerSnatch")
            }
            FitFieldOlympicLiftExerciseName::BarbellSquatClean => {
                write!(f, "{}", "BarbellSquatClean")
            }
            FitFieldOlympicLiftExerciseName::CleanAndJerk => write!(f, "{}", "CleanAndJerk"),
            FitFieldOlympicLiftExerciseName::BarbellHangPowerSnatch => {
                write!(f, "{}", "BarbellHangPowerSnatch")
            }
            FitFieldOlympicLiftExerciseName::BarbellHangPull => write!(f, "{}", "BarbellHangPull"),
            FitFieldOlympicLiftExerciseName::BarbellHighPull => write!(f, "{}", "BarbellHighPull"),
            FitFieldOlympicLiftExerciseName::BarbellSnatch => write!(f, "{}", "BarbellSnatch"),
            FitFieldOlympicLiftExerciseName::BarbellSplitJerk => {
                write!(f, "{}", "BarbellSplitJerk")
            }
            FitFieldOlympicLiftExerciseName::Clean => write!(f, "{}", "Clean"),
            FitFieldOlympicLiftExerciseName::DumbbellClean => write!(f, "{}", "DumbbellClean"),
            FitFieldOlympicLiftExerciseName::DumbbellHangPull => {
                write!(f, "{}", "DumbbellHangPull")
            }
            FitFieldOlympicLiftExerciseName::OneHandDumbbellSplitSnatch => {
                write!(f, "{}", "OneHandDumbbellSplitSnatch")
            }
            FitFieldOlympicLiftExerciseName::PushJerk => write!(f, "{}", "PushJerk"),
            FitFieldOlympicLiftExerciseName::SingleArmDumbbellSnatch => {
                write!(f, "{}", "SingleArmDumbbellSnatch")
            }
            FitFieldOlympicLiftExerciseName::SingleArmHangSnatch => {
                write!(f, "{}", "SingleArmHangSnatch")
            }
            FitFieldOlympicLiftExerciseName::SingleArmKettlebellSnatch => {
                write!(f, "{}", "SingleArmKettlebellSnatch")
            }
            FitFieldOlympicLiftExerciseName::SplitJerk => write!(f, "{}", "SplitJerk"),
            FitFieldOlympicLiftExerciseName::SquatCleanAndJerk => {
                write!(f, "{}", "SquatCleanAndJerk")
            }
            FitFieldOlympicLiftExerciseName::OlympicLiftExerciseName(x) => {
                write!(f, "{}({})", "OlympicLiftExerciseName", x)
            }
            FitFieldOlympicLiftExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldOlympicLiftExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldOlympicLiftExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldOlympicLiftExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldOlympicLiftExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                1 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                2 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                3 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                4 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                5 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                6 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                7 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                8 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                9 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                10 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                11 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                12 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                13 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                14 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                15 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                16 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                17 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                18 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                19 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                20 => Ok(FitFieldOlympicLiftExerciseName::from(v)),
                v => Ok(FitFieldOlympicLiftExerciseName::OlympicLiftExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldOlympicLiftExerciseName);

impl From<u16> for FitFieldOlympicLiftExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldOlympicLiftExerciseName::BarbellHangPowerClean,
            1 => FitFieldOlympicLiftExerciseName::BarbellHangSquatClean,
            2 => FitFieldOlympicLiftExerciseName::BarbellPowerClean,
            3 => FitFieldOlympicLiftExerciseName::BarbellPowerSnatch,
            4 => FitFieldOlympicLiftExerciseName::BarbellSquatClean,
            5 => FitFieldOlympicLiftExerciseName::CleanAndJerk,
            6 => FitFieldOlympicLiftExerciseName::BarbellHangPowerSnatch,
            7 => FitFieldOlympicLiftExerciseName::BarbellHangPull,
            8 => FitFieldOlympicLiftExerciseName::BarbellHighPull,
            9 => FitFieldOlympicLiftExerciseName::BarbellSnatch,
            10 => FitFieldOlympicLiftExerciseName::BarbellSplitJerk,
            11 => FitFieldOlympicLiftExerciseName::Clean,
            12 => FitFieldOlympicLiftExerciseName::DumbbellClean,
            13 => FitFieldOlympicLiftExerciseName::DumbbellHangPull,
            14 => FitFieldOlympicLiftExerciseName::OneHandDumbbellSplitSnatch,
            15 => FitFieldOlympicLiftExerciseName::PushJerk,
            16 => FitFieldOlympicLiftExerciseName::SingleArmDumbbellSnatch,
            17 => FitFieldOlympicLiftExerciseName::SingleArmHangSnatch,
            18 => FitFieldOlympicLiftExerciseName::SingleArmKettlebellSnatch,
            19 => FitFieldOlympicLiftExerciseName::SplitJerk,
            20 => FitFieldOlympicLiftExerciseName::SquatCleanAndJerk,
            _ => FitFieldOlympicLiftExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldPlankExerciseName {
    // fit base type: uint16
    FortyFiveDegreePlank,                             // 0
    Weighted45DegreePlank,                            // 1
    NinetyDegreeStaticHold,                           // 2
    Weighted90DegreeStaticHold,                       // 3
    BearCrawl,                                        // 4
    WeightedBearCrawl,                                // 5
    CrossBodyMountainClimber,                         // 6
    WeightedCrossBodyMountainClimber,                 // 7
    ElbowPlankPikeJacks,                              // 8
    WeightedElbowPlankPikeJacks,                      // 9
    ElevatedFeetPlank,                                // 10
    WeightedElevatedFeetPlank,                        // 11
    ElevatorAbs,                                      // 12
    WeightedElevatorAbs,                              // 13
    ExtendedPlank,                                    // 14
    WeightedExtendedPlank,                            // 15
    FullPlankPasseTwist,                              // 16
    WeightedFullPlankPasseTwist,                      // 17
    InchingElbowPlank,                                // 18
    WeightedInchingElbowPlank,                        // 19
    InchwormToSidePlank,                              // 20
    WeightedInchwormToSidePlank,                      // 21
    KneelingPlank,                                    // 22
    WeightedKneelingPlank,                            // 23
    KneelingSidePlankWithLegLift,                     // 24
    WeightedKneelingSidePlankWithLegLift,             // 25
    LateralRoll,                                      // 26
    WeightedLateralRoll,                              // 27
    LyingReversePlank,                                // 28
    WeightedLyingReversePlank,                        // 29
    MedicineBallMountainClimber,                      // 30
    WeightedMedicineBallMountainClimber,              // 31
    ModifiedMountainClimberAndExtension,              // 32
    WeightedModifiedMountainClimberAndExtension,      // 33
    MountainClimber,                                  // 34
    WeightedMountainClimber,                          // 35
    MountainClimberOnSlidingDiscs,                    // 36
    WeightedMountainClimberOnSlidingDiscs,            // 37
    MountainClimberWithFeetOnBosuBall,                // 38
    WeightedMountainClimberWithFeetOnBosuBall,        // 39
    MountainClimberWithHandsOnBench,                  // 40
    MountainClimberWithHandsOnSwissBall,              // 41
    WeightedMountainClimberWithHandsOnSwissBall,      // 42
    Plank,                                            // 43
    PlankJacksWithFeetOnSlidingDiscs,                 // 44
    WeightedPlankJacksWithFeetOnSlidingDiscs,         // 45
    PlankKneeTwist,                                   // 46
    WeightedPlankKneeTwist,                           // 47
    PlankPikeJumps,                                   // 48
    WeightedPlankPikeJumps,                           // 49
    PlankPikes,                                       // 50
    WeightedPlankPikes,                               // 51
    PlankToStandUp,                                   // 52
    WeightedPlankToStandUp,                           // 53
    PlankWithArmRaise,                                // 54
    WeightedPlankWithArmRaise,                        // 55
    PlankWithKneeToElbow,                             // 56
    WeightedPlankWithKneeToElbow,                     // 57
    PlankWithObliqueCrunch,                           // 58
    WeightedPlankWithObliqueCrunch,                   // 59
    PlyometricSidePlank,                              // 60
    WeightedPlyometricSidePlank,                      // 61
    RollingSidePlank,                                 // 62
    WeightedRollingSidePlank,                         // 63
    SideKickPlank,                                    // 64
    WeightedSideKickPlank,                            // 65
    SidePlank,                                        // 66
    WeightedSidePlank,                                // 67
    SidePlankAndRow,                                  // 68
    WeightedSidePlankAndRow,                          // 69
    SidePlankLift,                                    // 70
    WeightedSidePlankLift,                            // 71
    SidePlankWithElbowOnBosuBall,                     // 72
    WeightedSidePlankWithElbowOnBosuBall,             // 73
    SidePlankWithFeetOnBench,                         // 74
    WeightedSidePlankWithFeetOnBench,                 // 75
    SidePlankWithKneeCircle,                          // 76
    WeightedSidePlankWithKneeCircle,                  // 77
    SidePlankWithKneeTuck,                            // 78
    WeightedSidePlankWithKneeTuck,                    // 79
    SidePlankWithLegLift,                             // 80
    WeightedSidePlankWithLegLift,                     // 81
    SidePlankWithReachUnder,                          // 82
    WeightedSidePlankWithReachUnder,                  // 83
    SingleLegElevatedFeetPlank,                       // 84
    WeightedSingleLegElevatedFeetPlank,               // 85
    SingleLegFlexAndExtend,                           // 86
    WeightedSingleLegFlexAndExtend,                   // 87
    SingleLegSidePlank,                               // 88
    WeightedSingleLegSidePlank,                       // 89
    SpidermanPlank,                                   // 90
    WeightedSpidermanPlank,                           // 91
    StraightArmPlank,                                 // 92
    WeightedStraightArmPlank,                         // 93
    StraightArmPlankWithShoulderTouch,                // 94
    WeightedStraightArmPlankWithShoulderTouch,        // 95
    SwissBallPlank,                                   // 96
    WeightedSwissBallPlank,                           // 97
    SwissBallPlankLegLift,                            // 98
    WeightedSwissBallPlankLegLift,                    // 99
    SwissBallPlankLegLiftAndHold,                     // 100
    SwissBallPlankWithFeetOnBench,                    // 101
    WeightedSwissBallPlankWithFeetOnBench,            // 102
    SwissBallProneJackknife,                          // 103
    WeightedSwissBallProneJackknife,                  // 104
    SwissBallSidePlank,                               // 105
    WeightedSwissBallSidePlank,                       // 106
    ThreeWayPlank,                                    // 107
    WeightedThreeWayPlank,                            // 108
    TowelPlankAndKneeIn,                              // 109
    WeightedTowelPlankAndKneeIn,                      // 110
    TStabilization,                                   // 111
    WeightedTStabilization,                           // 112
    TurkishGetUpToSidePlank,                          // 113
    WeightedTurkishGetUpToSidePlank,                  // 114
    TwoPointPlank,                                    // 115
    WeightedTwoPointPlank,                            // 116
    WeightedPlank,                                    // 117
    WideStancePlankWithDiagonalArmLift,               // 118
    WeightedWideStancePlankWithDiagonalArmLift,       // 119
    WideStancePlankWithDiagonalLegLift,               // 120
    WeightedWideStancePlankWithDiagonalLegLift,       // 121
    WideStancePlankWithLegLift,                       // 122
    WeightedWideStancePlankWithLegLift,               // 123
    WideStancePlankWithOppositeArmAndLegLift,         // 124
    WeightedMountainClimberWithHandsOnBench,          // 125
    WeightedSwissBallPlankLegLiftAndHold,             // 126
    WeightedWideStancePlankWithOppositeArmAndLegLift, // 127
    PlankWithFeetOnSwissBall,                         // 128
    SidePlankToPlankWithReachUnder,                   // 129
    BridgeWithGluteLowerLift,                         // 130
    BridgeOneLegBridge,                               // 131
    PlankWithArmVariations,                           // 132
    PlankWithLegLift,                                 // 133
    ReversePlankWithLegPull,                          // 134
    PlankExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldPlankExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldPlankExerciseName::FortyFiveDegreePlank => {
                write!(f, "{}", "FortyFiveDegreePlank")
            }
            FitFieldPlankExerciseName::Weighted45DegreePlank => {
                write!(f, "{}", "Weighted45DegreePlank")
            }
            FitFieldPlankExerciseName::NinetyDegreeStaticHold => {
                write!(f, "{}", "NinetyDegreeStaticHold")
            }
            FitFieldPlankExerciseName::Weighted90DegreeStaticHold => {
                write!(f, "{}", "Weighted90DegreeStaticHold")
            }
            FitFieldPlankExerciseName::BearCrawl => write!(f, "{}", "BearCrawl"),
            FitFieldPlankExerciseName::WeightedBearCrawl => write!(f, "{}", "WeightedBearCrawl"),
            FitFieldPlankExerciseName::CrossBodyMountainClimber => {
                write!(f, "{}", "CrossBodyMountainClimber")
            }
            FitFieldPlankExerciseName::WeightedCrossBodyMountainClimber => {
                write!(f, "{}", "WeightedCrossBodyMountainClimber")
            }
            FitFieldPlankExerciseName::ElbowPlankPikeJacks => {
                write!(f, "{}", "ElbowPlankPikeJacks")
            }
            FitFieldPlankExerciseName::WeightedElbowPlankPikeJacks => {
                write!(f, "{}", "WeightedElbowPlankPikeJacks")
            }
            FitFieldPlankExerciseName::ElevatedFeetPlank => write!(f, "{}", "ElevatedFeetPlank"),
            FitFieldPlankExerciseName::WeightedElevatedFeetPlank => {
                write!(f, "{}", "WeightedElevatedFeetPlank")
            }
            FitFieldPlankExerciseName::ElevatorAbs => write!(f, "{}", "ElevatorAbs"),
            FitFieldPlankExerciseName::WeightedElevatorAbs => {
                write!(f, "{}", "WeightedElevatorAbs")
            }
            FitFieldPlankExerciseName::ExtendedPlank => write!(f, "{}", "ExtendedPlank"),
            FitFieldPlankExerciseName::WeightedExtendedPlank => {
                write!(f, "{}", "WeightedExtendedPlank")
            }
            FitFieldPlankExerciseName::FullPlankPasseTwist => {
                write!(f, "{}", "FullPlankPasseTwist")
            }
            FitFieldPlankExerciseName::WeightedFullPlankPasseTwist => {
                write!(f, "{}", "WeightedFullPlankPasseTwist")
            }
            FitFieldPlankExerciseName::InchingElbowPlank => write!(f, "{}", "InchingElbowPlank"),
            FitFieldPlankExerciseName::WeightedInchingElbowPlank => {
                write!(f, "{}", "WeightedInchingElbowPlank")
            }
            FitFieldPlankExerciseName::InchwormToSidePlank => {
                write!(f, "{}", "InchwormToSidePlank")
            }
            FitFieldPlankExerciseName::WeightedInchwormToSidePlank => {
                write!(f, "{}", "WeightedInchwormToSidePlank")
            }
            FitFieldPlankExerciseName::KneelingPlank => write!(f, "{}", "KneelingPlank"),
            FitFieldPlankExerciseName::WeightedKneelingPlank => {
                write!(f, "{}", "WeightedKneelingPlank")
            }
            FitFieldPlankExerciseName::KneelingSidePlankWithLegLift => {
                write!(f, "{}", "KneelingSidePlankWithLegLift")
            }
            FitFieldPlankExerciseName::WeightedKneelingSidePlankWithLegLift => {
                write!(f, "{}", "WeightedKneelingSidePlankWithLegLift")
            }
            FitFieldPlankExerciseName::LateralRoll => write!(f, "{}", "LateralRoll"),
            FitFieldPlankExerciseName::WeightedLateralRoll => {
                write!(f, "{}", "WeightedLateralRoll")
            }
            FitFieldPlankExerciseName::LyingReversePlank => write!(f, "{}", "LyingReversePlank"),
            FitFieldPlankExerciseName::WeightedLyingReversePlank => {
                write!(f, "{}", "WeightedLyingReversePlank")
            }
            FitFieldPlankExerciseName::MedicineBallMountainClimber => {
                write!(f, "{}", "MedicineBallMountainClimber")
            }
            FitFieldPlankExerciseName::WeightedMedicineBallMountainClimber => {
                write!(f, "{}", "WeightedMedicineBallMountainClimber")
            }
            FitFieldPlankExerciseName::ModifiedMountainClimberAndExtension => {
                write!(f, "{}", "ModifiedMountainClimberAndExtension")
            }
            FitFieldPlankExerciseName::WeightedModifiedMountainClimberAndExtension => {
                write!(f, "{}", "WeightedModifiedMountainClimberAndExtension")
            }
            FitFieldPlankExerciseName::MountainClimber => write!(f, "{}", "MountainClimber"),
            FitFieldPlankExerciseName::WeightedMountainClimber => {
                write!(f, "{}", "WeightedMountainClimber")
            }
            FitFieldPlankExerciseName::MountainClimberOnSlidingDiscs => {
                write!(f, "{}", "MountainClimberOnSlidingDiscs")
            }
            FitFieldPlankExerciseName::WeightedMountainClimberOnSlidingDiscs => {
                write!(f, "{}", "WeightedMountainClimberOnSlidingDiscs")
            }
            FitFieldPlankExerciseName::MountainClimberWithFeetOnBosuBall => {
                write!(f, "{}", "MountainClimberWithFeetOnBosuBall")
            }
            FitFieldPlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall => {
                write!(f, "{}", "WeightedMountainClimberWithFeetOnBosuBall")
            }
            FitFieldPlankExerciseName::MountainClimberWithHandsOnBench => {
                write!(f, "{}", "MountainClimberWithHandsOnBench")
            }
            FitFieldPlankExerciseName::MountainClimberWithHandsOnSwissBall => {
                write!(f, "{}", "MountainClimberWithHandsOnSwissBall")
            }
            FitFieldPlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall => {
                write!(f, "{}", "WeightedMountainClimberWithHandsOnSwissBall")
            }
            FitFieldPlankExerciseName::Plank => write!(f, "{}", "Plank"),
            FitFieldPlankExerciseName::PlankJacksWithFeetOnSlidingDiscs => {
                write!(f, "{}", "PlankJacksWithFeetOnSlidingDiscs")
            }
            FitFieldPlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs => {
                write!(f, "{}", "WeightedPlankJacksWithFeetOnSlidingDiscs")
            }
            FitFieldPlankExerciseName::PlankKneeTwist => write!(f, "{}", "PlankKneeTwist"),
            FitFieldPlankExerciseName::WeightedPlankKneeTwist => {
                write!(f, "{}", "WeightedPlankKneeTwist")
            }
            FitFieldPlankExerciseName::PlankPikeJumps => write!(f, "{}", "PlankPikeJumps"),
            FitFieldPlankExerciseName::WeightedPlankPikeJumps => {
                write!(f, "{}", "WeightedPlankPikeJumps")
            }
            FitFieldPlankExerciseName::PlankPikes => write!(f, "{}", "PlankPikes"),
            FitFieldPlankExerciseName::WeightedPlankPikes => write!(f, "{}", "WeightedPlankPikes"),
            FitFieldPlankExerciseName::PlankToStandUp => write!(f, "{}", "PlankToStandUp"),
            FitFieldPlankExerciseName::WeightedPlankToStandUp => {
                write!(f, "{}", "WeightedPlankToStandUp")
            }
            FitFieldPlankExerciseName::PlankWithArmRaise => write!(f, "{}", "PlankWithArmRaise"),
            FitFieldPlankExerciseName::WeightedPlankWithArmRaise => {
                write!(f, "{}", "WeightedPlankWithArmRaise")
            }
            FitFieldPlankExerciseName::PlankWithKneeToElbow => {
                write!(f, "{}", "PlankWithKneeToElbow")
            }
            FitFieldPlankExerciseName::WeightedPlankWithKneeToElbow => {
                write!(f, "{}", "WeightedPlankWithKneeToElbow")
            }
            FitFieldPlankExerciseName::PlankWithObliqueCrunch => {
                write!(f, "{}", "PlankWithObliqueCrunch")
            }
            FitFieldPlankExerciseName::WeightedPlankWithObliqueCrunch => {
                write!(f, "{}", "WeightedPlankWithObliqueCrunch")
            }
            FitFieldPlankExerciseName::PlyometricSidePlank => {
                write!(f, "{}", "PlyometricSidePlank")
            }
            FitFieldPlankExerciseName::WeightedPlyometricSidePlank => {
                write!(f, "{}", "WeightedPlyometricSidePlank")
            }
            FitFieldPlankExerciseName::RollingSidePlank => write!(f, "{}", "RollingSidePlank"),
            FitFieldPlankExerciseName::WeightedRollingSidePlank => {
                write!(f, "{}", "WeightedRollingSidePlank")
            }
            FitFieldPlankExerciseName::SideKickPlank => write!(f, "{}", "SideKickPlank"),
            FitFieldPlankExerciseName::WeightedSideKickPlank => {
                write!(f, "{}", "WeightedSideKickPlank")
            }
            FitFieldPlankExerciseName::SidePlank => write!(f, "{}", "SidePlank"),
            FitFieldPlankExerciseName::WeightedSidePlank => write!(f, "{}", "WeightedSidePlank"),
            FitFieldPlankExerciseName::SidePlankAndRow => write!(f, "{}", "SidePlankAndRow"),
            FitFieldPlankExerciseName::WeightedSidePlankAndRow => {
                write!(f, "{}", "WeightedSidePlankAndRow")
            }
            FitFieldPlankExerciseName::SidePlankLift => write!(f, "{}", "SidePlankLift"),
            FitFieldPlankExerciseName::WeightedSidePlankLift => {
                write!(f, "{}", "WeightedSidePlankLift")
            }
            FitFieldPlankExerciseName::SidePlankWithElbowOnBosuBall => {
                write!(f, "{}", "SidePlankWithElbowOnBosuBall")
            }
            FitFieldPlankExerciseName::WeightedSidePlankWithElbowOnBosuBall => {
                write!(f, "{}", "WeightedSidePlankWithElbowOnBosuBall")
            }
            FitFieldPlankExerciseName::SidePlankWithFeetOnBench => {
                write!(f, "{}", "SidePlankWithFeetOnBench")
            }
            FitFieldPlankExerciseName::WeightedSidePlankWithFeetOnBench => {
                write!(f, "{}", "WeightedSidePlankWithFeetOnBench")
            }
            FitFieldPlankExerciseName::SidePlankWithKneeCircle => {
                write!(f, "{}", "SidePlankWithKneeCircle")
            }
            FitFieldPlankExerciseName::WeightedSidePlankWithKneeCircle => {
                write!(f, "{}", "WeightedSidePlankWithKneeCircle")
            }
            FitFieldPlankExerciseName::SidePlankWithKneeTuck => {
                write!(f, "{}", "SidePlankWithKneeTuck")
            }
            FitFieldPlankExerciseName::WeightedSidePlankWithKneeTuck => {
                write!(f, "{}", "WeightedSidePlankWithKneeTuck")
            }
            FitFieldPlankExerciseName::SidePlankWithLegLift => {
                write!(f, "{}", "SidePlankWithLegLift")
            }
            FitFieldPlankExerciseName::WeightedSidePlankWithLegLift => {
                write!(f, "{}", "WeightedSidePlankWithLegLift")
            }
            FitFieldPlankExerciseName::SidePlankWithReachUnder => {
                write!(f, "{}", "SidePlankWithReachUnder")
            }
            FitFieldPlankExerciseName::WeightedSidePlankWithReachUnder => {
                write!(f, "{}", "WeightedSidePlankWithReachUnder")
            }
            FitFieldPlankExerciseName::SingleLegElevatedFeetPlank => {
                write!(f, "{}", "SingleLegElevatedFeetPlank")
            }
            FitFieldPlankExerciseName::WeightedSingleLegElevatedFeetPlank => {
                write!(f, "{}", "WeightedSingleLegElevatedFeetPlank")
            }
            FitFieldPlankExerciseName::SingleLegFlexAndExtend => {
                write!(f, "{}", "SingleLegFlexAndExtend")
            }
            FitFieldPlankExerciseName::WeightedSingleLegFlexAndExtend => {
                write!(f, "{}", "WeightedSingleLegFlexAndExtend")
            }
            FitFieldPlankExerciseName::SingleLegSidePlank => write!(f, "{}", "SingleLegSidePlank"),
            FitFieldPlankExerciseName::WeightedSingleLegSidePlank => {
                write!(f, "{}", "WeightedSingleLegSidePlank")
            }
            FitFieldPlankExerciseName::SpidermanPlank => write!(f, "{}", "SpidermanPlank"),
            FitFieldPlankExerciseName::WeightedSpidermanPlank => {
                write!(f, "{}", "WeightedSpidermanPlank")
            }
            FitFieldPlankExerciseName::StraightArmPlank => write!(f, "{}", "StraightArmPlank"),
            FitFieldPlankExerciseName::WeightedStraightArmPlank => {
                write!(f, "{}", "WeightedStraightArmPlank")
            }
            FitFieldPlankExerciseName::StraightArmPlankWithShoulderTouch => {
                write!(f, "{}", "StraightArmPlankWithShoulderTouch")
            }
            FitFieldPlankExerciseName::WeightedStraightArmPlankWithShoulderTouch => {
                write!(f, "{}", "WeightedStraightArmPlankWithShoulderTouch")
            }
            FitFieldPlankExerciseName::SwissBallPlank => write!(f, "{}", "SwissBallPlank"),
            FitFieldPlankExerciseName::WeightedSwissBallPlank => {
                write!(f, "{}", "WeightedSwissBallPlank")
            }
            FitFieldPlankExerciseName::SwissBallPlankLegLift => {
                write!(f, "{}", "SwissBallPlankLegLift")
            }
            FitFieldPlankExerciseName::WeightedSwissBallPlankLegLift => {
                write!(f, "{}", "WeightedSwissBallPlankLegLift")
            }
            FitFieldPlankExerciseName::SwissBallPlankLegLiftAndHold => {
                write!(f, "{}", "SwissBallPlankLegLiftAndHold")
            }
            FitFieldPlankExerciseName::SwissBallPlankWithFeetOnBench => {
                write!(f, "{}", "SwissBallPlankWithFeetOnBench")
            }
            FitFieldPlankExerciseName::WeightedSwissBallPlankWithFeetOnBench => {
                write!(f, "{}", "WeightedSwissBallPlankWithFeetOnBench")
            }
            FitFieldPlankExerciseName::SwissBallProneJackknife => {
                write!(f, "{}", "SwissBallProneJackknife")
            }
            FitFieldPlankExerciseName::WeightedSwissBallProneJackknife => {
                write!(f, "{}", "WeightedSwissBallProneJackknife")
            }
            FitFieldPlankExerciseName::SwissBallSidePlank => write!(f, "{}", "SwissBallSidePlank"),
            FitFieldPlankExerciseName::WeightedSwissBallSidePlank => {
                write!(f, "{}", "WeightedSwissBallSidePlank")
            }
            FitFieldPlankExerciseName::ThreeWayPlank => write!(f, "{}", "ThreeWayPlank"),
            FitFieldPlankExerciseName::WeightedThreeWayPlank => {
                write!(f, "{}", "WeightedThreeWayPlank")
            }
            FitFieldPlankExerciseName::TowelPlankAndKneeIn => {
                write!(f, "{}", "TowelPlankAndKneeIn")
            }
            FitFieldPlankExerciseName::WeightedTowelPlankAndKneeIn => {
                write!(f, "{}", "WeightedTowelPlankAndKneeIn")
            }
            FitFieldPlankExerciseName::TStabilization => write!(f, "{}", "TStabilization"),
            FitFieldPlankExerciseName::WeightedTStabilization => {
                write!(f, "{}", "WeightedTStabilization")
            }
            FitFieldPlankExerciseName::TurkishGetUpToSidePlank => {
                write!(f, "{}", "TurkishGetUpToSidePlank")
            }
            FitFieldPlankExerciseName::WeightedTurkishGetUpToSidePlank => {
                write!(f, "{}", "WeightedTurkishGetUpToSidePlank")
            }
            FitFieldPlankExerciseName::TwoPointPlank => write!(f, "{}", "TwoPointPlank"),
            FitFieldPlankExerciseName::WeightedTwoPointPlank => {
                write!(f, "{}", "WeightedTwoPointPlank")
            }
            FitFieldPlankExerciseName::WeightedPlank => write!(f, "{}", "WeightedPlank"),
            FitFieldPlankExerciseName::WideStancePlankWithDiagonalArmLift => {
                write!(f, "{}", "WideStancePlankWithDiagonalArmLift")
            }
            FitFieldPlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift => {
                write!(f, "{}", "WeightedWideStancePlankWithDiagonalArmLift")
            }
            FitFieldPlankExerciseName::WideStancePlankWithDiagonalLegLift => {
                write!(f, "{}", "WideStancePlankWithDiagonalLegLift")
            }
            FitFieldPlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift => {
                write!(f, "{}", "WeightedWideStancePlankWithDiagonalLegLift")
            }
            FitFieldPlankExerciseName::WideStancePlankWithLegLift => {
                write!(f, "{}", "WideStancePlankWithLegLift")
            }
            FitFieldPlankExerciseName::WeightedWideStancePlankWithLegLift => {
                write!(f, "{}", "WeightedWideStancePlankWithLegLift")
            }
            FitFieldPlankExerciseName::WideStancePlankWithOppositeArmAndLegLift => {
                write!(f, "{}", "WideStancePlankWithOppositeArmAndLegLift")
            }
            FitFieldPlankExerciseName::WeightedMountainClimberWithHandsOnBench => {
                write!(f, "{}", "WeightedMountainClimberWithHandsOnBench")
            }
            FitFieldPlankExerciseName::WeightedSwissBallPlankLegLiftAndHold => {
                write!(f, "{}", "WeightedSwissBallPlankLegLiftAndHold")
            }
            FitFieldPlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift => {
                write!(f, "{}", "WeightedWideStancePlankWithOppositeArmAndLegLift")
            }
            FitFieldPlankExerciseName::PlankWithFeetOnSwissBall => {
                write!(f, "{}", "PlankWithFeetOnSwissBall")
            }
            FitFieldPlankExerciseName::SidePlankToPlankWithReachUnder => {
                write!(f, "{}", "SidePlankToPlankWithReachUnder")
            }
            FitFieldPlankExerciseName::BridgeWithGluteLowerLift => {
                write!(f, "{}", "BridgeWithGluteLowerLift")
            }
            FitFieldPlankExerciseName::BridgeOneLegBridge => write!(f, "{}", "BridgeOneLegBridge"),
            FitFieldPlankExerciseName::PlankWithArmVariations => {
                write!(f, "{}", "PlankWithArmVariations")
            }
            FitFieldPlankExerciseName::PlankWithLegLift => write!(f, "{}", "PlankWithLegLift"),
            FitFieldPlankExerciseName::ReversePlankWithLegPull => {
                write!(f, "{}", "ReversePlankWithLegPull")
            }
            FitFieldPlankExerciseName::PlankExerciseName(x) => {
                write!(f, "{}({})", "PlankExerciseName", x)
            }
            FitFieldPlankExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldPlankExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldPlankExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldPlankExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldPlankExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldPlankExerciseName::from(v)),
                1 => Ok(FitFieldPlankExerciseName::from(v)),
                2 => Ok(FitFieldPlankExerciseName::from(v)),
                3 => Ok(FitFieldPlankExerciseName::from(v)),
                4 => Ok(FitFieldPlankExerciseName::from(v)),
                5 => Ok(FitFieldPlankExerciseName::from(v)),
                6 => Ok(FitFieldPlankExerciseName::from(v)),
                7 => Ok(FitFieldPlankExerciseName::from(v)),
                8 => Ok(FitFieldPlankExerciseName::from(v)),
                9 => Ok(FitFieldPlankExerciseName::from(v)),
                10 => Ok(FitFieldPlankExerciseName::from(v)),
                11 => Ok(FitFieldPlankExerciseName::from(v)),
                12 => Ok(FitFieldPlankExerciseName::from(v)),
                13 => Ok(FitFieldPlankExerciseName::from(v)),
                14 => Ok(FitFieldPlankExerciseName::from(v)),
                15 => Ok(FitFieldPlankExerciseName::from(v)),
                16 => Ok(FitFieldPlankExerciseName::from(v)),
                17 => Ok(FitFieldPlankExerciseName::from(v)),
                18 => Ok(FitFieldPlankExerciseName::from(v)),
                19 => Ok(FitFieldPlankExerciseName::from(v)),
                20 => Ok(FitFieldPlankExerciseName::from(v)),
                21 => Ok(FitFieldPlankExerciseName::from(v)),
                22 => Ok(FitFieldPlankExerciseName::from(v)),
                23 => Ok(FitFieldPlankExerciseName::from(v)),
                24 => Ok(FitFieldPlankExerciseName::from(v)),
                25 => Ok(FitFieldPlankExerciseName::from(v)),
                26 => Ok(FitFieldPlankExerciseName::from(v)),
                27 => Ok(FitFieldPlankExerciseName::from(v)),
                28 => Ok(FitFieldPlankExerciseName::from(v)),
                29 => Ok(FitFieldPlankExerciseName::from(v)),
                30 => Ok(FitFieldPlankExerciseName::from(v)),
                31 => Ok(FitFieldPlankExerciseName::from(v)),
                32 => Ok(FitFieldPlankExerciseName::from(v)),
                33 => Ok(FitFieldPlankExerciseName::from(v)),
                34 => Ok(FitFieldPlankExerciseName::from(v)),
                35 => Ok(FitFieldPlankExerciseName::from(v)),
                36 => Ok(FitFieldPlankExerciseName::from(v)),
                37 => Ok(FitFieldPlankExerciseName::from(v)),
                38 => Ok(FitFieldPlankExerciseName::from(v)),
                39 => Ok(FitFieldPlankExerciseName::from(v)),
                40 => Ok(FitFieldPlankExerciseName::from(v)),
                41 => Ok(FitFieldPlankExerciseName::from(v)),
                42 => Ok(FitFieldPlankExerciseName::from(v)),
                43 => Ok(FitFieldPlankExerciseName::from(v)),
                44 => Ok(FitFieldPlankExerciseName::from(v)),
                45 => Ok(FitFieldPlankExerciseName::from(v)),
                46 => Ok(FitFieldPlankExerciseName::from(v)),
                47 => Ok(FitFieldPlankExerciseName::from(v)),
                48 => Ok(FitFieldPlankExerciseName::from(v)),
                49 => Ok(FitFieldPlankExerciseName::from(v)),
                50 => Ok(FitFieldPlankExerciseName::from(v)),
                51 => Ok(FitFieldPlankExerciseName::from(v)),
                52 => Ok(FitFieldPlankExerciseName::from(v)),
                53 => Ok(FitFieldPlankExerciseName::from(v)),
                54 => Ok(FitFieldPlankExerciseName::from(v)),
                55 => Ok(FitFieldPlankExerciseName::from(v)),
                56 => Ok(FitFieldPlankExerciseName::from(v)),
                57 => Ok(FitFieldPlankExerciseName::from(v)),
                58 => Ok(FitFieldPlankExerciseName::from(v)),
                59 => Ok(FitFieldPlankExerciseName::from(v)),
                60 => Ok(FitFieldPlankExerciseName::from(v)),
                61 => Ok(FitFieldPlankExerciseName::from(v)),
                62 => Ok(FitFieldPlankExerciseName::from(v)),
                63 => Ok(FitFieldPlankExerciseName::from(v)),
                64 => Ok(FitFieldPlankExerciseName::from(v)),
                65 => Ok(FitFieldPlankExerciseName::from(v)),
                66 => Ok(FitFieldPlankExerciseName::from(v)),
                67 => Ok(FitFieldPlankExerciseName::from(v)),
                68 => Ok(FitFieldPlankExerciseName::from(v)),
                69 => Ok(FitFieldPlankExerciseName::from(v)),
                70 => Ok(FitFieldPlankExerciseName::from(v)),
                71 => Ok(FitFieldPlankExerciseName::from(v)),
                72 => Ok(FitFieldPlankExerciseName::from(v)),
                73 => Ok(FitFieldPlankExerciseName::from(v)),
                74 => Ok(FitFieldPlankExerciseName::from(v)),
                75 => Ok(FitFieldPlankExerciseName::from(v)),
                76 => Ok(FitFieldPlankExerciseName::from(v)),
                77 => Ok(FitFieldPlankExerciseName::from(v)),
                78 => Ok(FitFieldPlankExerciseName::from(v)),
                79 => Ok(FitFieldPlankExerciseName::from(v)),
                80 => Ok(FitFieldPlankExerciseName::from(v)),
                81 => Ok(FitFieldPlankExerciseName::from(v)),
                82 => Ok(FitFieldPlankExerciseName::from(v)),
                83 => Ok(FitFieldPlankExerciseName::from(v)),
                84 => Ok(FitFieldPlankExerciseName::from(v)),
                85 => Ok(FitFieldPlankExerciseName::from(v)),
                86 => Ok(FitFieldPlankExerciseName::from(v)),
                87 => Ok(FitFieldPlankExerciseName::from(v)),
                88 => Ok(FitFieldPlankExerciseName::from(v)),
                89 => Ok(FitFieldPlankExerciseName::from(v)),
                90 => Ok(FitFieldPlankExerciseName::from(v)),
                91 => Ok(FitFieldPlankExerciseName::from(v)),
                92 => Ok(FitFieldPlankExerciseName::from(v)),
                93 => Ok(FitFieldPlankExerciseName::from(v)),
                94 => Ok(FitFieldPlankExerciseName::from(v)),
                95 => Ok(FitFieldPlankExerciseName::from(v)),
                96 => Ok(FitFieldPlankExerciseName::from(v)),
                97 => Ok(FitFieldPlankExerciseName::from(v)),
                98 => Ok(FitFieldPlankExerciseName::from(v)),
                99 => Ok(FitFieldPlankExerciseName::from(v)),
                100 => Ok(FitFieldPlankExerciseName::from(v)),
                101 => Ok(FitFieldPlankExerciseName::from(v)),
                102 => Ok(FitFieldPlankExerciseName::from(v)),
                103 => Ok(FitFieldPlankExerciseName::from(v)),
                104 => Ok(FitFieldPlankExerciseName::from(v)),
                105 => Ok(FitFieldPlankExerciseName::from(v)),
                106 => Ok(FitFieldPlankExerciseName::from(v)),
                107 => Ok(FitFieldPlankExerciseName::from(v)),
                108 => Ok(FitFieldPlankExerciseName::from(v)),
                109 => Ok(FitFieldPlankExerciseName::from(v)),
                110 => Ok(FitFieldPlankExerciseName::from(v)),
                111 => Ok(FitFieldPlankExerciseName::from(v)),
                112 => Ok(FitFieldPlankExerciseName::from(v)),
                113 => Ok(FitFieldPlankExerciseName::from(v)),
                114 => Ok(FitFieldPlankExerciseName::from(v)),
                115 => Ok(FitFieldPlankExerciseName::from(v)),
                116 => Ok(FitFieldPlankExerciseName::from(v)),
                117 => Ok(FitFieldPlankExerciseName::from(v)),
                118 => Ok(FitFieldPlankExerciseName::from(v)),
                119 => Ok(FitFieldPlankExerciseName::from(v)),
                120 => Ok(FitFieldPlankExerciseName::from(v)),
                121 => Ok(FitFieldPlankExerciseName::from(v)),
                122 => Ok(FitFieldPlankExerciseName::from(v)),
                123 => Ok(FitFieldPlankExerciseName::from(v)),
                124 => Ok(FitFieldPlankExerciseName::from(v)),
                125 => Ok(FitFieldPlankExerciseName::from(v)),
                126 => Ok(FitFieldPlankExerciseName::from(v)),
                127 => Ok(FitFieldPlankExerciseName::from(v)),
                128 => Ok(FitFieldPlankExerciseName::from(v)),
                129 => Ok(FitFieldPlankExerciseName::from(v)),
                130 => Ok(FitFieldPlankExerciseName::from(v)),
                131 => Ok(FitFieldPlankExerciseName::from(v)),
                132 => Ok(FitFieldPlankExerciseName::from(v)),
                133 => Ok(FitFieldPlankExerciseName::from(v)),
                134 => Ok(FitFieldPlankExerciseName::from(v)),
                v => Ok(FitFieldPlankExerciseName::PlankExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldPlankExerciseName);

impl From<u16> for FitFieldPlankExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPlankExerciseName::FortyFiveDegreePlank,
            1 => FitFieldPlankExerciseName::Weighted45DegreePlank,
            2 => FitFieldPlankExerciseName::NinetyDegreeStaticHold,
            3 => FitFieldPlankExerciseName::Weighted90DegreeStaticHold,
            4 => FitFieldPlankExerciseName::BearCrawl,
            5 => FitFieldPlankExerciseName::WeightedBearCrawl,
            6 => FitFieldPlankExerciseName::CrossBodyMountainClimber,
            7 => FitFieldPlankExerciseName::WeightedCrossBodyMountainClimber,
            8 => FitFieldPlankExerciseName::ElbowPlankPikeJacks,
            9 => FitFieldPlankExerciseName::WeightedElbowPlankPikeJacks,
            10 => FitFieldPlankExerciseName::ElevatedFeetPlank,
            11 => FitFieldPlankExerciseName::WeightedElevatedFeetPlank,
            12 => FitFieldPlankExerciseName::ElevatorAbs,
            13 => FitFieldPlankExerciseName::WeightedElevatorAbs,
            14 => FitFieldPlankExerciseName::ExtendedPlank,
            15 => FitFieldPlankExerciseName::WeightedExtendedPlank,
            16 => FitFieldPlankExerciseName::FullPlankPasseTwist,
            17 => FitFieldPlankExerciseName::WeightedFullPlankPasseTwist,
            18 => FitFieldPlankExerciseName::InchingElbowPlank,
            19 => FitFieldPlankExerciseName::WeightedInchingElbowPlank,
            20 => FitFieldPlankExerciseName::InchwormToSidePlank,
            21 => FitFieldPlankExerciseName::WeightedInchwormToSidePlank,
            22 => FitFieldPlankExerciseName::KneelingPlank,
            23 => FitFieldPlankExerciseName::WeightedKneelingPlank,
            24 => FitFieldPlankExerciseName::KneelingSidePlankWithLegLift,
            25 => FitFieldPlankExerciseName::WeightedKneelingSidePlankWithLegLift,
            26 => FitFieldPlankExerciseName::LateralRoll,
            27 => FitFieldPlankExerciseName::WeightedLateralRoll,
            28 => FitFieldPlankExerciseName::LyingReversePlank,
            29 => FitFieldPlankExerciseName::WeightedLyingReversePlank,
            30 => FitFieldPlankExerciseName::MedicineBallMountainClimber,
            31 => FitFieldPlankExerciseName::WeightedMedicineBallMountainClimber,
            32 => FitFieldPlankExerciseName::ModifiedMountainClimberAndExtension,
            33 => FitFieldPlankExerciseName::WeightedModifiedMountainClimberAndExtension,
            34 => FitFieldPlankExerciseName::MountainClimber,
            35 => FitFieldPlankExerciseName::WeightedMountainClimber,
            36 => FitFieldPlankExerciseName::MountainClimberOnSlidingDiscs,
            37 => FitFieldPlankExerciseName::WeightedMountainClimberOnSlidingDiscs,
            38 => FitFieldPlankExerciseName::MountainClimberWithFeetOnBosuBall,
            39 => FitFieldPlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall,
            40 => FitFieldPlankExerciseName::MountainClimberWithHandsOnBench,
            41 => FitFieldPlankExerciseName::MountainClimberWithHandsOnSwissBall,
            42 => FitFieldPlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall,
            43 => FitFieldPlankExerciseName::Plank,
            44 => FitFieldPlankExerciseName::PlankJacksWithFeetOnSlidingDiscs,
            45 => FitFieldPlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs,
            46 => FitFieldPlankExerciseName::PlankKneeTwist,
            47 => FitFieldPlankExerciseName::WeightedPlankKneeTwist,
            48 => FitFieldPlankExerciseName::PlankPikeJumps,
            49 => FitFieldPlankExerciseName::WeightedPlankPikeJumps,
            50 => FitFieldPlankExerciseName::PlankPikes,
            51 => FitFieldPlankExerciseName::WeightedPlankPikes,
            52 => FitFieldPlankExerciseName::PlankToStandUp,
            53 => FitFieldPlankExerciseName::WeightedPlankToStandUp,
            54 => FitFieldPlankExerciseName::PlankWithArmRaise,
            55 => FitFieldPlankExerciseName::WeightedPlankWithArmRaise,
            56 => FitFieldPlankExerciseName::PlankWithKneeToElbow,
            57 => FitFieldPlankExerciseName::WeightedPlankWithKneeToElbow,
            58 => FitFieldPlankExerciseName::PlankWithObliqueCrunch,
            59 => FitFieldPlankExerciseName::WeightedPlankWithObliqueCrunch,
            60 => FitFieldPlankExerciseName::PlyometricSidePlank,
            61 => FitFieldPlankExerciseName::WeightedPlyometricSidePlank,
            62 => FitFieldPlankExerciseName::RollingSidePlank,
            63 => FitFieldPlankExerciseName::WeightedRollingSidePlank,
            64 => FitFieldPlankExerciseName::SideKickPlank,
            65 => FitFieldPlankExerciseName::WeightedSideKickPlank,
            66 => FitFieldPlankExerciseName::SidePlank,
            67 => FitFieldPlankExerciseName::WeightedSidePlank,
            68 => FitFieldPlankExerciseName::SidePlankAndRow,
            69 => FitFieldPlankExerciseName::WeightedSidePlankAndRow,
            70 => FitFieldPlankExerciseName::SidePlankLift,
            71 => FitFieldPlankExerciseName::WeightedSidePlankLift,
            72 => FitFieldPlankExerciseName::SidePlankWithElbowOnBosuBall,
            73 => FitFieldPlankExerciseName::WeightedSidePlankWithElbowOnBosuBall,
            74 => FitFieldPlankExerciseName::SidePlankWithFeetOnBench,
            75 => FitFieldPlankExerciseName::WeightedSidePlankWithFeetOnBench,
            76 => FitFieldPlankExerciseName::SidePlankWithKneeCircle,
            77 => FitFieldPlankExerciseName::WeightedSidePlankWithKneeCircle,
            78 => FitFieldPlankExerciseName::SidePlankWithKneeTuck,
            79 => FitFieldPlankExerciseName::WeightedSidePlankWithKneeTuck,
            80 => FitFieldPlankExerciseName::SidePlankWithLegLift,
            81 => FitFieldPlankExerciseName::WeightedSidePlankWithLegLift,
            82 => FitFieldPlankExerciseName::SidePlankWithReachUnder,
            83 => FitFieldPlankExerciseName::WeightedSidePlankWithReachUnder,
            84 => FitFieldPlankExerciseName::SingleLegElevatedFeetPlank,
            85 => FitFieldPlankExerciseName::WeightedSingleLegElevatedFeetPlank,
            86 => FitFieldPlankExerciseName::SingleLegFlexAndExtend,
            87 => FitFieldPlankExerciseName::WeightedSingleLegFlexAndExtend,
            88 => FitFieldPlankExerciseName::SingleLegSidePlank,
            89 => FitFieldPlankExerciseName::WeightedSingleLegSidePlank,
            90 => FitFieldPlankExerciseName::SpidermanPlank,
            91 => FitFieldPlankExerciseName::WeightedSpidermanPlank,
            92 => FitFieldPlankExerciseName::StraightArmPlank,
            93 => FitFieldPlankExerciseName::WeightedStraightArmPlank,
            94 => FitFieldPlankExerciseName::StraightArmPlankWithShoulderTouch,
            95 => FitFieldPlankExerciseName::WeightedStraightArmPlankWithShoulderTouch,
            96 => FitFieldPlankExerciseName::SwissBallPlank,
            97 => FitFieldPlankExerciseName::WeightedSwissBallPlank,
            98 => FitFieldPlankExerciseName::SwissBallPlankLegLift,
            99 => FitFieldPlankExerciseName::WeightedSwissBallPlankLegLift,
            100 => FitFieldPlankExerciseName::SwissBallPlankLegLiftAndHold,
            101 => FitFieldPlankExerciseName::SwissBallPlankWithFeetOnBench,
            102 => FitFieldPlankExerciseName::WeightedSwissBallPlankWithFeetOnBench,
            103 => FitFieldPlankExerciseName::SwissBallProneJackknife,
            104 => FitFieldPlankExerciseName::WeightedSwissBallProneJackknife,
            105 => FitFieldPlankExerciseName::SwissBallSidePlank,
            106 => FitFieldPlankExerciseName::WeightedSwissBallSidePlank,
            107 => FitFieldPlankExerciseName::ThreeWayPlank,
            108 => FitFieldPlankExerciseName::WeightedThreeWayPlank,
            109 => FitFieldPlankExerciseName::TowelPlankAndKneeIn,
            110 => FitFieldPlankExerciseName::WeightedTowelPlankAndKneeIn,
            111 => FitFieldPlankExerciseName::TStabilization,
            112 => FitFieldPlankExerciseName::WeightedTStabilization,
            113 => FitFieldPlankExerciseName::TurkishGetUpToSidePlank,
            114 => FitFieldPlankExerciseName::WeightedTurkishGetUpToSidePlank,
            115 => FitFieldPlankExerciseName::TwoPointPlank,
            116 => FitFieldPlankExerciseName::WeightedTwoPointPlank,
            117 => FitFieldPlankExerciseName::WeightedPlank,
            118 => FitFieldPlankExerciseName::WideStancePlankWithDiagonalArmLift,
            119 => FitFieldPlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift,
            120 => FitFieldPlankExerciseName::WideStancePlankWithDiagonalLegLift,
            121 => FitFieldPlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift,
            122 => FitFieldPlankExerciseName::WideStancePlankWithLegLift,
            123 => FitFieldPlankExerciseName::WeightedWideStancePlankWithLegLift,
            124 => FitFieldPlankExerciseName::WideStancePlankWithOppositeArmAndLegLift,
            125 => FitFieldPlankExerciseName::WeightedMountainClimberWithHandsOnBench,
            126 => FitFieldPlankExerciseName::WeightedSwissBallPlankLegLiftAndHold,
            127 => FitFieldPlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift,
            128 => FitFieldPlankExerciseName::PlankWithFeetOnSwissBall,
            129 => FitFieldPlankExerciseName::SidePlankToPlankWithReachUnder,
            130 => FitFieldPlankExerciseName::BridgeWithGluteLowerLift,
            131 => FitFieldPlankExerciseName::BridgeOneLegBridge,
            132 => FitFieldPlankExerciseName::PlankWithArmVariations,
            133 => FitFieldPlankExerciseName::PlankWithLegLift,
            134 => FitFieldPlankExerciseName::ReversePlankWithLegPull,
            _ => FitFieldPlankExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldPlyoExerciseName {
    // fit base type: uint16
    AlternatingJumpLunge,                  // 0
    WeightedAlternatingJumpLunge,          // 1
    BarbellJumpSquat,                      // 2
    BodyWeightJumpSquat,                   // 3
    WeightedJumpSquat,                     // 4
    CrossKneeStrike,                       // 5
    WeightedCrossKneeStrike,               // 6
    DepthJump,                             // 7
    WeightedDepthJump,                     // 8
    DumbbellJumpSquat,                     // 9
    DumbbellSplitJump,                     // 10
    FrontKneeStrike,                       // 11
    WeightedFrontKneeStrike,               // 12
    HighBoxJump,                           // 13
    WeightedHighBoxJump,                   // 14
    IsometricExplosiveBodyWeightJumpSquat, // 15
    WeightedIsometricExplosiveJumpSquat,   // 16
    LateralLeapAndHop,                     // 17
    WeightedLateralLeapAndHop,             // 18
    LateralPlyoSquats,                     // 19
    WeightedLateralPlyoSquats,             // 20
    LateralSlide,                          // 21
    WeightedLateralSlide,                  // 22
    MedicineBallOverheadThrows,            // 23
    MedicineBallSideThrow,                 // 24
    MedicineBallSlam,                      // 25
    SideToSideMedicineBallThrows,          // 26
    SideToSideShuffleJump,                 // 27
    WeightedSideToSideShuffleJump,         // 28
    SquatJumpOntoBox,                      // 29
    WeightedSquatJumpOntoBox,              // 30
    SquatJumpsInAndOut,                    // 31
    WeightedSquatJumpsInAndOut,            // 32
    PlyoExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldPlyoExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldPlyoExerciseName::AlternatingJumpLunge => {
                write!(f, "{}", "AlternatingJumpLunge")
            }
            FitFieldPlyoExerciseName::WeightedAlternatingJumpLunge => {
                write!(f, "{}", "WeightedAlternatingJumpLunge")
            }
            FitFieldPlyoExerciseName::BarbellJumpSquat => write!(f, "{}", "BarbellJumpSquat"),
            FitFieldPlyoExerciseName::BodyWeightJumpSquat => write!(f, "{}", "BodyWeightJumpSquat"),
            FitFieldPlyoExerciseName::WeightedJumpSquat => write!(f, "{}", "WeightedJumpSquat"),
            FitFieldPlyoExerciseName::CrossKneeStrike => write!(f, "{}", "CrossKneeStrike"),
            FitFieldPlyoExerciseName::WeightedCrossKneeStrike => {
                write!(f, "{}", "WeightedCrossKneeStrike")
            }
            FitFieldPlyoExerciseName::DepthJump => write!(f, "{}", "DepthJump"),
            FitFieldPlyoExerciseName::WeightedDepthJump => write!(f, "{}", "WeightedDepthJump"),
            FitFieldPlyoExerciseName::DumbbellJumpSquat => write!(f, "{}", "DumbbellJumpSquat"),
            FitFieldPlyoExerciseName::DumbbellSplitJump => write!(f, "{}", "DumbbellSplitJump"),
            FitFieldPlyoExerciseName::FrontKneeStrike => write!(f, "{}", "FrontKneeStrike"),
            FitFieldPlyoExerciseName::WeightedFrontKneeStrike => {
                write!(f, "{}", "WeightedFrontKneeStrike")
            }
            FitFieldPlyoExerciseName::HighBoxJump => write!(f, "{}", "HighBoxJump"),
            FitFieldPlyoExerciseName::WeightedHighBoxJump => write!(f, "{}", "WeightedHighBoxJump"),
            FitFieldPlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat => {
                write!(f, "{}", "IsometricExplosiveBodyWeightJumpSquat")
            }
            FitFieldPlyoExerciseName::WeightedIsometricExplosiveJumpSquat => {
                write!(f, "{}", "WeightedIsometricExplosiveJumpSquat")
            }
            FitFieldPlyoExerciseName::LateralLeapAndHop => write!(f, "{}", "LateralLeapAndHop"),
            FitFieldPlyoExerciseName::WeightedLateralLeapAndHop => {
                write!(f, "{}", "WeightedLateralLeapAndHop")
            }
            FitFieldPlyoExerciseName::LateralPlyoSquats => write!(f, "{}", "LateralPlyoSquats"),
            FitFieldPlyoExerciseName::WeightedLateralPlyoSquats => {
                write!(f, "{}", "WeightedLateralPlyoSquats")
            }
            FitFieldPlyoExerciseName::LateralSlide => write!(f, "{}", "LateralSlide"),
            FitFieldPlyoExerciseName::WeightedLateralSlide => {
                write!(f, "{}", "WeightedLateralSlide")
            }
            FitFieldPlyoExerciseName::MedicineBallOverheadThrows => {
                write!(f, "{}", "MedicineBallOverheadThrows")
            }
            FitFieldPlyoExerciseName::MedicineBallSideThrow => {
                write!(f, "{}", "MedicineBallSideThrow")
            }
            FitFieldPlyoExerciseName::MedicineBallSlam => write!(f, "{}", "MedicineBallSlam"),
            FitFieldPlyoExerciseName::SideToSideMedicineBallThrows => {
                write!(f, "{}", "SideToSideMedicineBallThrows")
            }
            FitFieldPlyoExerciseName::SideToSideShuffleJump => {
                write!(f, "{}", "SideToSideShuffleJump")
            }
            FitFieldPlyoExerciseName::WeightedSideToSideShuffleJump => {
                write!(f, "{}", "WeightedSideToSideShuffleJump")
            }
            FitFieldPlyoExerciseName::SquatJumpOntoBox => write!(f, "{}", "SquatJumpOntoBox"),
            FitFieldPlyoExerciseName::WeightedSquatJumpOntoBox => {
                write!(f, "{}", "WeightedSquatJumpOntoBox")
            }
            FitFieldPlyoExerciseName::SquatJumpsInAndOut => write!(f, "{}", "SquatJumpsInAndOut"),
            FitFieldPlyoExerciseName::WeightedSquatJumpsInAndOut => {
                write!(f, "{}", "WeightedSquatJumpsInAndOut")
            }
            FitFieldPlyoExerciseName::PlyoExerciseName(x) => {
                write!(f, "{}({})", "PlyoExerciseName", x)
            }
            FitFieldPlyoExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldPlyoExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldPlyoExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldPlyoExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldPlyoExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldPlyoExerciseName::from(v)),
                1 => Ok(FitFieldPlyoExerciseName::from(v)),
                2 => Ok(FitFieldPlyoExerciseName::from(v)),
                3 => Ok(FitFieldPlyoExerciseName::from(v)),
                4 => Ok(FitFieldPlyoExerciseName::from(v)),
                5 => Ok(FitFieldPlyoExerciseName::from(v)),
                6 => Ok(FitFieldPlyoExerciseName::from(v)),
                7 => Ok(FitFieldPlyoExerciseName::from(v)),
                8 => Ok(FitFieldPlyoExerciseName::from(v)),
                9 => Ok(FitFieldPlyoExerciseName::from(v)),
                10 => Ok(FitFieldPlyoExerciseName::from(v)),
                11 => Ok(FitFieldPlyoExerciseName::from(v)),
                12 => Ok(FitFieldPlyoExerciseName::from(v)),
                13 => Ok(FitFieldPlyoExerciseName::from(v)),
                14 => Ok(FitFieldPlyoExerciseName::from(v)),
                15 => Ok(FitFieldPlyoExerciseName::from(v)),
                16 => Ok(FitFieldPlyoExerciseName::from(v)),
                17 => Ok(FitFieldPlyoExerciseName::from(v)),
                18 => Ok(FitFieldPlyoExerciseName::from(v)),
                19 => Ok(FitFieldPlyoExerciseName::from(v)),
                20 => Ok(FitFieldPlyoExerciseName::from(v)),
                21 => Ok(FitFieldPlyoExerciseName::from(v)),
                22 => Ok(FitFieldPlyoExerciseName::from(v)),
                23 => Ok(FitFieldPlyoExerciseName::from(v)),
                24 => Ok(FitFieldPlyoExerciseName::from(v)),
                25 => Ok(FitFieldPlyoExerciseName::from(v)),
                26 => Ok(FitFieldPlyoExerciseName::from(v)),
                27 => Ok(FitFieldPlyoExerciseName::from(v)),
                28 => Ok(FitFieldPlyoExerciseName::from(v)),
                29 => Ok(FitFieldPlyoExerciseName::from(v)),
                30 => Ok(FitFieldPlyoExerciseName::from(v)),
                31 => Ok(FitFieldPlyoExerciseName::from(v)),
                32 => Ok(FitFieldPlyoExerciseName::from(v)),
                v => Ok(FitFieldPlyoExerciseName::PlyoExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldPlyoExerciseName);

impl From<u16> for FitFieldPlyoExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPlyoExerciseName::AlternatingJumpLunge,
            1 => FitFieldPlyoExerciseName::WeightedAlternatingJumpLunge,
            2 => FitFieldPlyoExerciseName::BarbellJumpSquat,
            3 => FitFieldPlyoExerciseName::BodyWeightJumpSquat,
            4 => FitFieldPlyoExerciseName::WeightedJumpSquat,
            5 => FitFieldPlyoExerciseName::CrossKneeStrike,
            6 => FitFieldPlyoExerciseName::WeightedCrossKneeStrike,
            7 => FitFieldPlyoExerciseName::DepthJump,
            8 => FitFieldPlyoExerciseName::WeightedDepthJump,
            9 => FitFieldPlyoExerciseName::DumbbellJumpSquat,
            10 => FitFieldPlyoExerciseName::DumbbellSplitJump,
            11 => FitFieldPlyoExerciseName::FrontKneeStrike,
            12 => FitFieldPlyoExerciseName::WeightedFrontKneeStrike,
            13 => FitFieldPlyoExerciseName::HighBoxJump,
            14 => FitFieldPlyoExerciseName::WeightedHighBoxJump,
            15 => FitFieldPlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat,
            16 => FitFieldPlyoExerciseName::WeightedIsometricExplosiveJumpSquat,
            17 => FitFieldPlyoExerciseName::LateralLeapAndHop,
            18 => FitFieldPlyoExerciseName::WeightedLateralLeapAndHop,
            19 => FitFieldPlyoExerciseName::LateralPlyoSquats,
            20 => FitFieldPlyoExerciseName::WeightedLateralPlyoSquats,
            21 => FitFieldPlyoExerciseName::LateralSlide,
            22 => FitFieldPlyoExerciseName::WeightedLateralSlide,
            23 => FitFieldPlyoExerciseName::MedicineBallOverheadThrows,
            24 => FitFieldPlyoExerciseName::MedicineBallSideThrow,
            25 => FitFieldPlyoExerciseName::MedicineBallSlam,
            26 => FitFieldPlyoExerciseName::SideToSideMedicineBallThrows,
            27 => FitFieldPlyoExerciseName::SideToSideShuffleJump,
            28 => FitFieldPlyoExerciseName::WeightedSideToSideShuffleJump,
            29 => FitFieldPlyoExerciseName::SquatJumpOntoBox,
            30 => FitFieldPlyoExerciseName::WeightedSquatJumpOntoBox,
            31 => FitFieldPlyoExerciseName::SquatJumpsInAndOut,
            32 => FitFieldPlyoExerciseName::WeightedSquatJumpsInAndOut,
            _ => FitFieldPlyoExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldPullUpExerciseName {
    // fit base type: uint16
    BandedPullUps,                    // 0
    ThirtyDegreeLatPulldown,          // 1
    BandAssistedChinUp,               // 2
    CloseGripChinUp,                  // 3
    WeightedCloseGripChinUp,          // 4
    CloseGripLatPulldown,             // 5
    CrossoverChinUp,                  // 6
    WeightedCrossoverChinUp,          // 7
    EzBarPullover,                    // 8
    HangingHurdle,                    // 9
    WeightedHangingHurdle,            // 10
    KneelingLatPulldown,              // 11
    KneelingUnderhandGripLatPulldown, // 12
    LatPulldown,                      // 13
    MixedGripChinUp,                  // 14
    WeightedMixedGripChinUp,          // 15
    MixedGripPullUp,                  // 16
    WeightedMixedGripPullUp,          // 17
    ReverseGripPulldown,              // 18
    StandingCablePullover,            // 19
    StraightArmPulldown,              // 20
    SwissBallEzBarPullover,           // 21
    TowelPullUp,                      // 22
    WeightedTowelPullUp,              // 23
    WeightedPullUp,                   // 24
    WideGripLatPulldown,              // 25
    WideGripPullUp,                   // 26
    WeightedWideGripPullUp,           // 27
    BurpeePullUp,                     // 28
    WeightedBurpeePullUp,             // 29
    JumpingPullUps,                   // 30
    WeightedJumpingPullUps,           // 31
    KippingPullUp,                    // 32
    WeightedKippingPullUp,            // 33
    LPullUp,                          // 34
    WeightedLPullUp,                  // 35
    SuspendedChinUp,                  // 36
    WeightedSuspendedChinUp,          // 37
    PullUp,                           // 38
    PullUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldPullUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldPullUpExerciseName::BandedPullUps => write!(f, "{}", "BandedPullUps"),
            FitFieldPullUpExerciseName::ThirtyDegreeLatPulldown => {
                write!(f, "{}", "ThirtyDegreeLatPulldown")
            }
            FitFieldPullUpExerciseName::BandAssistedChinUp => write!(f, "{}", "BandAssistedChinUp"),
            FitFieldPullUpExerciseName::CloseGripChinUp => write!(f, "{}", "CloseGripChinUp"),
            FitFieldPullUpExerciseName::WeightedCloseGripChinUp => {
                write!(f, "{}", "WeightedCloseGripChinUp")
            }
            FitFieldPullUpExerciseName::CloseGripLatPulldown => {
                write!(f, "{}", "CloseGripLatPulldown")
            }
            FitFieldPullUpExerciseName::CrossoverChinUp => write!(f, "{}", "CrossoverChinUp"),
            FitFieldPullUpExerciseName::WeightedCrossoverChinUp => {
                write!(f, "{}", "WeightedCrossoverChinUp")
            }
            FitFieldPullUpExerciseName::EzBarPullover => write!(f, "{}", "EzBarPullover"),
            FitFieldPullUpExerciseName::HangingHurdle => write!(f, "{}", "HangingHurdle"),
            FitFieldPullUpExerciseName::WeightedHangingHurdle => {
                write!(f, "{}", "WeightedHangingHurdle")
            }
            FitFieldPullUpExerciseName::KneelingLatPulldown => {
                write!(f, "{}", "KneelingLatPulldown")
            }
            FitFieldPullUpExerciseName::KneelingUnderhandGripLatPulldown => {
                write!(f, "{}", "KneelingUnderhandGripLatPulldown")
            }
            FitFieldPullUpExerciseName::LatPulldown => write!(f, "{}", "LatPulldown"),
            FitFieldPullUpExerciseName::MixedGripChinUp => write!(f, "{}", "MixedGripChinUp"),
            FitFieldPullUpExerciseName::WeightedMixedGripChinUp => {
                write!(f, "{}", "WeightedMixedGripChinUp")
            }
            FitFieldPullUpExerciseName::MixedGripPullUp => write!(f, "{}", "MixedGripPullUp"),
            FitFieldPullUpExerciseName::WeightedMixedGripPullUp => {
                write!(f, "{}", "WeightedMixedGripPullUp")
            }
            FitFieldPullUpExerciseName::ReverseGripPulldown => {
                write!(f, "{}", "ReverseGripPulldown")
            }
            FitFieldPullUpExerciseName::StandingCablePullover => {
                write!(f, "{}", "StandingCablePullover")
            }
            FitFieldPullUpExerciseName::StraightArmPulldown => {
                write!(f, "{}", "StraightArmPulldown")
            }
            FitFieldPullUpExerciseName::SwissBallEzBarPullover => {
                write!(f, "{}", "SwissBallEzBarPullover")
            }
            FitFieldPullUpExerciseName::TowelPullUp => write!(f, "{}", "TowelPullUp"),
            FitFieldPullUpExerciseName::WeightedTowelPullUp => {
                write!(f, "{}", "WeightedTowelPullUp")
            }
            FitFieldPullUpExerciseName::WeightedPullUp => write!(f, "{}", "WeightedPullUp"),
            FitFieldPullUpExerciseName::WideGripLatPulldown => {
                write!(f, "{}", "WideGripLatPulldown")
            }
            FitFieldPullUpExerciseName::WideGripPullUp => write!(f, "{}", "WideGripPullUp"),
            FitFieldPullUpExerciseName::WeightedWideGripPullUp => {
                write!(f, "{}", "WeightedWideGripPullUp")
            }
            FitFieldPullUpExerciseName::BurpeePullUp => write!(f, "{}", "BurpeePullUp"),
            FitFieldPullUpExerciseName::WeightedBurpeePullUp => {
                write!(f, "{}", "WeightedBurpeePullUp")
            }
            FitFieldPullUpExerciseName::JumpingPullUps => write!(f, "{}", "JumpingPullUps"),
            FitFieldPullUpExerciseName::WeightedJumpingPullUps => {
                write!(f, "{}", "WeightedJumpingPullUps")
            }
            FitFieldPullUpExerciseName::KippingPullUp => write!(f, "{}", "KippingPullUp"),
            FitFieldPullUpExerciseName::WeightedKippingPullUp => {
                write!(f, "{}", "WeightedKippingPullUp")
            }
            FitFieldPullUpExerciseName::LPullUp => write!(f, "{}", "LPullUp"),
            FitFieldPullUpExerciseName::WeightedLPullUp => write!(f, "{}", "WeightedLPullUp"),
            FitFieldPullUpExerciseName::SuspendedChinUp => write!(f, "{}", "SuspendedChinUp"),
            FitFieldPullUpExerciseName::WeightedSuspendedChinUp => {
                write!(f, "{}", "WeightedSuspendedChinUp")
            }
            FitFieldPullUpExerciseName::PullUp => write!(f, "{}", "PullUp"),
            FitFieldPullUpExerciseName::PullUpExerciseName(x) => {
                write!(f, "{}({})", "PullUpExerciseName", x)
            }
            FitFieldPullUpExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldPullUpExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldPullUpExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldPullUpExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldPullUpExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldPullUpExerciseName::from(v)),
                1 => Ok(FitFieldPullUpExerciseName::from(v)),
                2 => Ok(FitFieldPullUpExerciseName::from(v)),
                3 => Ok(FitFieldPullUpExerciseName::from(v)),
                4 => Ok(FitFieldPullUpExerciseName::from(v)),
                5 => Ok(FitFieldPullUpExerciseName::from(v)),
                6 => Ok(FitFieldPullUpExerciseName::from(v)),
                7 => Ok(FitFieldPullUpExerciseName::from(v)),
                8 => Ok(FitFieldPullUpExerciseName::from(v)),
                9 => Ok(FitFieldPullUpExerciseName::from(v)),
                10 => Ok(FitFieldPullUpExerciseName::from(v)),
                11 => Ok(FitFieldPullUpExerciseName::from(v)),
                12 => Ok(FitFieldPullUpExerciseName::from(v)),
                13 => Ok(FitFieldPullUpExerciseName::from(v)),
                14 => Ok(FitFieldPullUpExerciseName::from(v)),
                15 => Ok(FitFieldPullUpExerciseName::from(v)),
                16 => Ok(FitFieldPullUpExerciseName::from(v)),
                17 => Ok(FitFieldPullUpExerciseName::from(v)),
                18 => Ok(FitFieldPullUpExerciseName::from(v)),
                19 => Ok(FitFieldPullUpExerciseName::from(v)),
                20 => Ok(FitFieldPullUpExerciseName::from(v)),
                21 => Ok(FitFieldPullUpExerciseName::from(v)),
                22 => Ok(FitFieldPullUpExerciseName::from(v)),
                23 => Ok(FitFieldPullUpExerciseName::from(v)),
                24 => Ok(FitFieldPullUpExerciseName::from(v)),
                25 => Ok(FitFieldPullUpExerciseName::from(v)),
                26 => Ok(FitFieldPullUpExerciseName::from(v)),
                27 => Ok(FitFieldPullUpExerciseName::from(v)),
                28 => Ok(FitFieldPullUpExerciseName::from(v)),
                29 => Ok(FitFieldPullUpExerciseName::from(v)),
                30 => Ok(FitFieldPullUpExerciseName::from(v)),
                31 => Ok(FitFieldPullUpExerciseName::from(v)),
                32 => Ok(FitFieldPullUpExerciseName::from(v)),
                33 => Ok(FitFieldPullUpExerciseName::from(v)),
                34 => Ok(FitFieldPullUpExerciseName::from(v)),
                35 => Ok(FitFieldPullUpExerciseName::from(v)),
                36 => Ok(FitFieldPullUpExerciseName::from(v)),
                37 => Ok(FitFieldPullUpExerciseName::from(v)),
                38 => Ok(FitFieldPullUpExerciseName::from(v)),
                v => Ok(FitFieldPullUpExerciseName::PullUpExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldPullUpExerciseName);

impl From<u16> for FitFieldPullUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPullUpExerciseName::BandedPullUps,
            1 => FitFieldPullUpExerciseName::ThirtyDegreeLatPulldown,
            2 => FitFieldPullUpExerciseName::BandAssistedChinUp,
            3 => FitFieldPullUpExerciseName::CloseGripChinUp,
            4 => FitFieldPullUpExerciseName::WeightedCloseGripChinUp,
            5 => FitFieldPullUpExerciseName::CloseGripLatPulldown,
            6 => FitFieldPullUpExerciseName::CrossoverChinUp,
            7 => FitFieldPullUpExerciseName::WeightedCrossoverChinUp,
            8 => FitFieldPullUpExerciseName::EzBarPullover,
            9 => FitFieldPullUpExerciseName::HangingHurdle,
            10 => FitFieldPullUpExerciseName::WeightedHangingHurdle,
            11 => FitFieldPullUpExerciseName::KneelingLatPulldown,
            12 => FitFieldPullUpExerciseName::KneelingUnderhandGripLatPulldown,
            13 => FitFieldPullUpExerciseName::LatPulldown,
            14 => FitFieldPullUpExerciseName::MixedGripChinUp,
            15 => FitFieldPullUpExerciseName::WeightedMixedGripChinUp,
            16 => FitFieldPullUpExerciseName::MixedGripPullUp,
            17 => FitFieldPullUpExerciseName::WeightedMixedGripPullUp,
            18 => FitFieldPullUpExerciseName::ReverseGripPulldown,
            19 => FitFieldPullUpExerciseName::StandingCablePullover,
            20 => FitFieldPullUpExerciseName::StraightArmPulldown,
            21 => FitFieldPullUpExerciseName::SwissBallEzBarPullover,
            22 => FitFieldPullUpExerciseName::TowelPullUp,
            23 => FitFieldPullUpExerciseName::WeightedTowelPullUp,
            24 => FitFieldPullUpExerciseName::WeightedPullUp,
            25 => FitFieldPullUpExerciseName::WideGripLatPulldown,
            26 => FitFieldPullUpExerciseName::WideGripPullUp,
            27 => FitFieldPullUpExerciseName::WeightedWideGripPullUp,
            28 => FitFieldPullUpExerciseName::BurpeePullUp,
            29 => FitFieldPullUpExerciseName::WeightedBurpeePullUp,
            30 => FitFieldPullUpExerciseName::JumpingPullUps,
            31 => FitFieldPullUpExerciseName::WeightedJumpingPullUps,
            32 => FitFieldPullUpExerciseName::KippingPullUp,
            33 => FitFieldPullUpExerciseName::WeightedKippingPullUp,
            34 => FitFieldPullUpExerciseName::LPullUp,
            35 => FitFieldPullUpExerciseName::WeightedLPullUp,
            36 => FitFieldPullUpExerciseName::SuspendedChinUp,
            37 => FitFieldPullUpExerciseName::WeightedSuspendedChinUp,
            38 => FitFieldPullUpExerciseName::PullUp,
            _ => FitFieldPullUpExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldPushUpExerciseName {
    // fit base type: uint16
    ChestPressWithBand,                         // 0
    AlternatingStaggeredPushUp,                 // 1
    WeightedAlternatingStaggeredPushUp,         // 2
    AlternatingHandsMedicineBallPushUp,         // 3
    WeightedAlternatingHandsMedicineBallPushUp, // 4
    BosuBallPushUp,                             // 5
    WeightedBosuBallPushUp,                     // 6
    ClappingPushUp,                             // 7
    WeightedClappingPushUp,                     // 8
    CloseGripMedicineBallPushUp,                // 9
    WeightedCloseGripMedicineBallPushUp,        // 10
    CloseHandsPushUp,                           // 11
    WeightedCloseHandsPushUp,                   // 12
    DeclinePushUp,                              // 13
    WeightedDeclinePushUp,                      // 14
    DiamondPushUp,                              // 15
    WeightedDiamondPushUp,                      // 16
    ExplosiveCrossoverPushUp,                   // 17
    WeightedExplosiveCrossoverPushUp,           // 18
    ExplosivePushUp,                            // 19
    WeightedExplosivePushUp,                    // 20
    FeetElevatedSideToSidePushUp,               // 21
    WeightedFeetElevatedSideToSidePushUp,       // 22
    HandReleasePushUp,                          // 23
    WeightedHandReleasePushUp,                  // 24
    HandstandPushUp,                            // 25
    WeightedHandstandPushUp,                    // 26
    InclinePushUp,                              // 27
    WeightedInclinePushUp,                      // 28
    IsometricExplosivePushUp,                   // 29
    WeightedIsometricExplosivePushUp,           // 30
    JudoPushUp,                                 // 31
    WeightedJudoPushUp,                         // 32
    KneelingPushUp,                             // 33
    WeightedKneelingPushUp,                     // 34
    MedicineBallChestPass,                      // 35
    MedicineBallPushUp,                         // 36
    WeightedMedicineBallPushUp,                 // 37
    OneArmPushUp,                               // 38
    WeightedOneArmPushUp,                       // 39
    WeightedPushUp,                             // 40
    PushUpAndRow,                               // 41
    WeightedPushUpAndRow,                       // 42
    PushUpPlus,                                 // 43
    WeightedPushUpPlus,                         // 44
    PushUpWithFeetOnSwissBall,                  // 45
    WeightedPushUpWithFeetOnSwissBall,          // 46
    PushUpWithOneHandOnMedicineBall,            // 47
    WeightedPushUpWithOneHandOnMedicineBall,    // 48
    ShoulderPushUp,                             // 49
    WeightedShoulderPushUp,                     // 50
    SingleArmMedicineBallPushUp,                // 51
    WeightedSingleArmMedicineBallPushUp,        // 52
    SpidermanPushUp,                            // 53
    WeightedSpidermanPushUp,                    // 54
    StackedFeetPushUp,                          // 55
    WeightedStackedFeetPushUp,                  // 56
    StaggeredHandsPushUp,                       // 57
    WeightedStaggeredHandsPushUp,               // 58
    SuspendedPushUp,                            // 59
    WeightedSuspendedPushUp,                    // 60
    SwissBallPushUp,                            // 61
    WeightedSwissBallPushUp,                    // 62
    SwissBallPushUpPlus,                        // 63
    WeightedSwissBallPushUpPlus,                // 64
    TPushUp,                                    // 65
    WeightedTPushUp,                            // 66
    TripleStopPushUp,                           // 67
    WeightedTripleStopPushUp,                   // 68
    WideHandsPushUp,                            // 69
    WeightedWideHandsPushUp,                    // 70
    ParalletteHandstandPushUp,                  // 71
    WeightedParalletteHandstandPushUp,          // 72
    RingHandstandPushUp,                        // 73
    WeightedRingHandstandPushUp,                // 74
    RingPushUp,                                 // 75
    WeightedRingPushUp,                         // 76
    PushUp,                                     // 77
    PilatesPushup,                              // 78
    PushUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldPushUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldPushUpExerciseName::ChestPressWithBand => write!(f, "{}", "ChestPressWithBand"),
            FitFieldPushUpExerciseName::AlternatingStaggeredPushUp => {
                write!(f, "{}", "AlternatingStaggeredPushUp")
            }
            FitFieldPushUpExerciseName::WeightedAlternatingStaggeredPushUp => {
                write!(f, "{}", "WeightedAlternatingStaggeredPushUp")
            }
            FitFieldPushUpExerciseName::AlternatingHandsMedicineBallPushUp => {
                write!(f, "{}", "AlternatingHandsMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp => {
                write!(f, "{}", "WeightedAlternatingHandsMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::BosuBallPushUp => write!(f, "{}", "BosuBallPushUp"),
            FitFieldPushUpExerciseName::WeightedBosuBallPushUp => {
                write!(f, "{}", "WeightedBosuBallPushUp")
            }
            FitFieldPushUpExerciseName::ClappingPushUp => write!(f, "{}", "ClappingPushUp"),
            FitFieldPushUpExerciseName::WeightedClappingPushUp => {
                write!(f, "{}", "WeightedClappingPushUp")
            }
            FitFieldPushUpExerciseName::CloseGripMedicineBallPushUp => {
                write!(f, "{}", "CloseGripMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::WeightedCloseGripMedicineBallPushUp => {
                write!(f, "{}", "WeightedCloseGripMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::CloseHandsPushUp => write!(f, "{}", "CloseHandsPushUp"),
            FitFieldPushUpExerciseName::WeightedCloseHandsPushUp => {
                write!(f, "{}", "WeightedCloseHandsPushUp")
            }
            FitFieldPushUpExerciseName::DeclinePushUp => write!(f, "{}", "DeclinePushUp"),
            FitFieldPushUpExerciseName::WeightedDeclinePushUp => {
                write!(f, "{}", "WeightedDeclinePushUp")
            }
            FitFieldPushUpExerciseName::DiamondPushUp => write!(f, "{}", "DiamondPushUp"),
            FitFieldPushUpExerciseName::WeightedDiamondPushUp => {
                write!(f, "{}", "WeightedDiamondPushUp")
            }
            FitFieldPushUpExerciseName::ExplosiveCrossoverPushUp => {
                write!(f, "{}", "ExplosiveCrossoverPushUp")
            }
            FitFieldPushUpExerciseName::WeightedExplosiveCrossoverPushUp => {
                write!(f, "{}", "WeightedExplosiveCrossoverPushUp")
            }
            FitFieldPushUpExerciseName::ExplosivePushUp => write!(f, "{}", "ExplosivePushUp"),
            FitFieldPushUpExerciseName::WeightedExplosivePushUp => {
                write!(f, "{}", "WeightedExplosivePushUp")
            }
            FitFieldPushUpExerciseName::FeetElevatedSideToSidePushUp => {
                write!(f, "{}", "FeetElevatedSideToSidePushUp")
            }
            FitFieldPushUpExerciseName::WeightedFeetElevatedSideToSidePushUp => {
                write!(f, "{}", "WeightedFeetElevatedSideToSidePushUp")
            }
            FitFieldPushUpExerciseName::HandReleasePushUp => write!(f, "{}", "HandReleasePushUp"),
            FitFieldPushUpExerciseName::WeightedHandReleasePushUp => {
                write!(f, "{}", "WeightedHandReleasePushUp")
            }
            FitFieldPushUpExerciseName::HandstandPushUp => write!(f, "{}", "HandstandPushUp"),
            FitFieldPushUpExerciseName::WeightedHandstandPushUp => {
                write!(f, "{}", "WeightedHandstandPushUp")
            }
            FitFieldPushUpExerciseName::InclinePushUp => write!(f, "{}", "InclinePushUp"),
            FitFieldPushUpExerciseName::WeightedInclinePushUp => {
                write!(f, "{}", "WeightedInclinePushUp")
            }
            FitFieldPushUpExerciseName::IsometricExplosivePushUp => {
                write!(f, "{}", "IsometricExplosivePushUp")
            }
            FitFieldPushUpExerciseName::WeightedIsometricExplosivePushUp => {
                write!(f, "{}", "WeightedIsometricExplosivePushUp")
            }
            FitFieldPushUpExerciseName::JudoPushUp => write!(f, "{}", "JudoPushUp"),
            FitFieldPushUpExerciseName::WeightedJudoPushUp => write!(f, "{}", "WeightedJudoPushUp"),
            FitFieldPushUpExerciseName::KneelingPushUp => write!(f, "{}", "KneelingPushUp"),
            FitFieldPushUpExerciseName::WeightedKneelingPushUp => {
                write!(f, "{}", "WeightedKneelingPushUp")
            }
            FitFieldPushUpExerciseName::MedicineBallChestPass => {
                write!(f, "{}", "MedicineBallChestPass")
            }
            FitFieldPushUpExerciseName::MedicineBallPushUp => write!(f, "{}", "MedicineBallPushUp"),
            FitFieldPushUpExerciseName::WeightedMedicineBallPushUp => {
                write!(f, "{}", "WeightedMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::OneArmPushUp => write!(f, "{}", "OneArmPushUp"),
            FitFieldPushUpExerciseName::WeightedOneArmPushUp => {
                write!(f, "{}", "WeightedOneArmPushUp")
            }
            FitFieldPushUpExerciseName::WeightedPushUp => write!(f, "{}", "WeightedPushUp"),
            FitFieldPushUpExerciseName::PushUpAndRow => write!(f, "{}", "PushUpAndRow"),
            FitFieldPushUpExerciseName::WeightedPushUpAndRow => {
                write!(f, "{}", "WeightedPushUpAndRow")
            }
            FitFieldPushUpExerciseName::PushUpPlus => write!(f, "{}", "PushUpPlus"),
            FitFieldPushUpExerciseName::WeightedPushUpPlus => write!(f, "{}", "WeightedPushUpPlus"),
            FitFieldPushUpExerciseName::PushUpWithFeetOnSwissBall => {
                write!(f, "{}", "PushUpWithFeetOnSwissBall")
            }
            FitFieldPushUpExerciseName::WeightedPushUpWithFeetOnSwissBall => {
                write!(f, "{}", "WeightedPushUpWithFeetOnSwissBall")
            }
            FitFieldPushUpExerciseName::PushUpWithOneHandOnMedicineBall => {
                write!(f, "{}", "PushUpWithOneHandOnMedicineBall")
            }
            FitFieldPushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall => {
                write!(f, "{}", "WeightedPushUpWithOneHandOnMedicineBall")
            }
            FitFieldPushUpExerciseName::ShoulderPushUp => write!(f, "{}", "ShoulderPushUp"),
            FitFieldPushUpExerciseName::WeightedShoulderPushUp => {
                write!(f, "{}", "WeightedShoulderPushUp")
            }
            FitFieldPushUpExerciseName::SingleArmMedicineBallPushUp => {
                write!(f, "{}", "SingleArmMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::WeightedSingleArmMedicineBallPushUp => {
                write!(f, "{}", "WeightedSingleArmMedicineBallPushUp")
            }
            FitFieldPushUpExerciseName::SpidermanPushUp => write!(f, "{}", "SpidermanPushUp"),
            FitFieldPushUpExerciseName::WeightedSpidermanPushUp => {
                write!(f, "{}", "WeightedSpidermanPushUp")
            }
            FitFieldPushUpExerciseName::StackedFeetPushUp => write!(f, "{}", "StackedFeetPushUp"),
            FitFieldPushUpExerciseName::WeightedStackedFeetPushUp => {
                write!(f, "{}", "WeightedStackedFeetPushUp")
            }
            FitFieldPushUpExerciseName::StaggeredHandsPushUp => {
                write!(f, "{}", "StaggeredHandsPushUp")
            }
            FitFieldPushUpExerciseName::WeightedStaggeredHandsPushUp => {
                write!(f, "{}", "WeightedStaggeredHandsPushUp")
            }
            FitFieldPushUpExerciseName::SuspendedPushUp => write!(f, "{}", "SuspendedPushUp"),
            FitFieldPushUpExerciseName::WeightedSuspendedPushUp => {
                write!(f, "{}", "WeightedSuspendedPushUp")
            }
            FitFieldPushUpExerciseName::SwissBallPushUp => write!(f, "{}", "SwissBallPushUp"),
            FitFieldPushUpExerciseName::WeightedSwissBallPushUp => {
                write!(f, "{}", "WeightedSwissBallPushUp")
            }
            FitFieldPushUpExerciseName::SwissBallPushUpPlus => {
                write!(f, "{}", "SwissBallPushUpPlus")
            }
            FitFieldPushUpExerciseName::WeightedSwissBallPushUpPlus => {
                write!(f, "{}", "WeightedSwissBallPushUpPlus")
            }
            FitFieldPushUpExerciseName::TPushUp => write!(f, "{}", "TPushUp"),
            FitFieldPushUpExerciseName::WeightedTPushUp => write!(f, "{}", "WeightedTPushUp"),
            FitFieldPushUpExerciseName::TripleStopPushUp => write!(f, "{}", "TripleStopPushUp"),
            FitFieldPushUpExerciseName::WeightedTripleStopPushUp => {
                write!(f, "{}", "WeightedTripleStopPushUp")
            }
            FitFieldPushUpExerciseName::WideHandsPushUp => write!(f, "{}", "WideHandsPushUp"),
            FitFieldPushUpExerciseName::WeightedWideHandsPushUp => {
                write!(f, "{}", "WeightedWideHandsPushUp")
            }
            FitFieldPushUpExerciseName::ParalletteHandstandPushUp => {
                write!(f, "{}", "ParalletteHandstandPushUp")
            }
            FitFieldPushUpExerciseName::WeightedParalletteHandstandPushUp => {
                write!(f, "{}", "WeightedParalletteHandstandPushUp")
            }
            FitFieldPushUpExerciseName::RingHandstandPushUp => {
                write!(f, "{}", "RingHandstandPushUp")
            }
            FitFieldPushUpExerciseName::WeightedRingHandstandPushUp => {
                write!(f, "{}", "WeightedRingHandstandPushUp")
            }
            FitFieldPushUpExerciseName::RingPushUp => write!(f, "{}", "RingPushUp"),
            FitFieldPushUpExerciseName::WeightedRingPushUp => write!(f, "{}", "WeightedRingPushUp"),
            FitFieldPushUpExerciseName::PushUp => write!(f, "{}", "PushUp"),
            FitFieldPushUpExerciseName::PilatesPushup => write!(f, "{}", "PilatesPushup"),
            FitFieldPushUpExerciseName::PushUpExerciseName(x) => {
                write!(f, "{}({})", "PushUpExerciseName", x)
            }
            FitFieldPushUpExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldPushUpExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldPushUpExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldPushUpExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldPushUpExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldPushUpExerciseName::from(v)),
                1 => Ok(FitFieldPushUpExerciseName::from(v)),
                2 => Ok(FitFieldPushUpExerciseName::from(v)),
                3 => Ok(FitFieldPushUpExerciseName::from(v)),
                4 => Ok(FitFieldPushUpExerciseName::from(v)),
                5 => Ok(FitFieldPushUpExerciseName::from(v)),
                6 => Ok(FitFieldPushUpExerciseName::from(v)),
                7 => Ok(FitFieldPushUpExerciseName::from(v)),
                8 => Ok(FitFieldPushUpExerciseName::from(v)),
                9 => Ok(FitFieldPushUpExerciseName::from(v)),
                10 => Ok(FitFieldPushUpExerciseName::from(v)),
                11 => Ok(FitFieldPushUpExerciseName::from(v)),
                12 => Ok(FitFieldPushUpExerciseName::from(v)),
                13 => Ok(FitFieldPushUpExerciseName::from(v)),
                14 => Ok(FitFieldPushUpExerciseName::from(v)),
                15 => Ok(FitFieldPushUpExerciseName::from(v)),
                16 => Ok(FitFieldPushUpExerciseName::from(v)),
                17 => Ok(FitFieldPushUpExerciseName::from(v)),
                18 => Ok(FitFieldPushUpExerciseName::from(v)),
                19 => Ok(FitFieldPushUpExerciseName::from(v)),
                20 => Ok(FitFieldPushUpExerciseName::from(v)),
                21 => Ok(FitFieldPushUpExerciseName::from(v)),
                22 => Ok(FitFieldPushUpExerciseName::from(v)),
                23 => Ok(FitFieldPushUpExerciseName::from(v)),
                24 => Ok(FitFieldPushUpExerciseName::from(v)),
                25 => Ok(FitFieldPushUpExerciseName::from(v)),
                26 => Ok(FitFieldPushUpExerciseName::from(v)),
                27 => Ok(FitFieldPushUpExerciseName::from(v)),
                28 => Ok(FitFieldPushUpExerciseName::from(v)),
                29 => Ok(FitFieldPushUpExerciseName::from(v)),
                30 => Ok(FitFieldPushUpExerciseName::from(v)),
                31 => Ok(FitFieldPushUpExerciseName::from(v)),
                32 => Ok(FitFieldPushUpExerciseName::from(v)),
                33 => Ok(FitFieldPushUpExerciseName::from(v)),
                34 => Ok(FitFieldPushUpExerciseName::from(v)),
                35 => Ok(FitFieldPushUpExerciseName::from(v)),
                36 => Ok(FitFieldPushUpExerciseName::from(v)),
                37 => Ok(FitFieldPushUpExerciseName::from(v)),
                38 => Ok(FitFieldPushUpExerciseName::from(v)),
                39 => Ok(FitFieldPushUpExerciseName::from(v)),
                40 => Ok(FitFieldPushUpExerciseName::from(v)),
                41 => Ok(FitFieldPushUpExerciseName::from(v)),
                42 => Ok(FitFieldPushUpExerciseName::from(v)),
                43 => Ok(FitFieldPushUpExerciseName::from(v)),
                44 => Ok(FitFieldPushUpExerciseName::from(v)),
                45 => Ok(FitFieldPushUpExerciseName::from(v)),
                46 => Ok(FitFieldPushUpExerciseName::from(v)),
                47 => Ok(FitFieldPushUpExerciseName::from(v)),
                48 => Ok(FitFieldPushUpExerciseName::from(v)),
                49 => Ok(FitFieldPushUpExerciseName::from(v)),
                50 => Ok(FitFieldPushUpExerciseName::from(v)),
                51 => Ok(FitFieldPushUpExerciseName::from(v)),
                52 => Ok(FitFieldPushUpExerciseName::from(v)),
                53 => Ok(FitFieldPushUpExerciseName::from(v)),
                54 => Ok(FitFieldPushUpExerciseName::from(v)),
                55 => Ok(FitFieldPushUpExerciseName::from(v)),
                56 => Ok(FitFieldPushUpExerciseName::from(v)),
                57 => Ok(FitFieldPushUpExerciseName::from(v)),
                58 => Ok(FitFieldPushUpExerciseName::from(v)),
                59 => Ok(FitFieldPushUpExerciseName::from(v)),
                60 => Ok(FitFieldPushUpExerciseName::from(v)),
                61 => Ok(FitFieldPushUpExerciseName::from(v)),
                62 => Ok(FitFieldPushUpExerciseName::from(v)),
                63 => Ok(FitFieldPushUpExerciseName::from(v)),
                64 => Ok(FitFieldPushUpExerciseName::from(v)),
                65 => Ok(FitFieldPushUpExerciseName::from(v)),
                66 => Ok(FitFieldPushUpExerciseName::from(v)),
                67 => Ok(FitFieldPushUpExerciseName::from(v)),
                68 => Ok(FitFieldPushUpExerciseName::from(v)),
                69 => Ok(FitFieldPushUpExerciseName::from(v)),
                70 => Ok(FitFieldPushUpExerciseName::from(v)),
                71 => Ok(FitFieldPushUpExerciseName::from(v)),
                72 => Ok(FitFieldPushUpExerciseName::from(v)),
                73 => Ok(FitFieldPushUpExerciseName::from(v)),
                74 => Ok(FitFieldPushUpExerciseName::from(v)),
                75 => Ok(FitFieldPushUpExerciseName::from(v)),
                76 => Ok(FitFieldPushUpExerciseName::from(v)),
                77 => Ok(FitFieldPushUpExerciseName::from(v)),
                78 => Ok(FitFieldPushUpExerciseName::from(v)),
                v => Ok(FitFieldPushUpExerciseName::PushUpExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldPushUpExerciseName);

impl From<u16> for FitFieldPushUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPushUpExerciseName::ChestPressWithBand,
            1 => FitFieldPushUpExerciseName::AlternatingStaggeredPushUp,
            2 => FitFieldPushUpExerciseName::WeightedAlternatingStaggeredPushUp,
            3 => FitFieldPushUpExerciseName::AlternatingHandsMedicineBallPushUp,
            4 => FitFieldPushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp,
            5 => FitFieldPushUpExerciseName::BosuBallPushUp,
            6 => FitFieldPushUpExerciseName::WeightedBosuBallPushUp,
            7 => FitFieldPushUpExerciseName::ClappingPushUp,
            8 => FitFieldPushUpExerciseName::WeightedClappingPushUp,
            9 => FitFieldPushUpExerciseName::CloseGripMedicineBallPushUp,
            10 => FitFieldPushUpExerciseName::WeightedCloseGripMedicineBallPushUp,
            11 => FitFieldPushUpExerciseName::CloseHandsPushUp,
            12 => FitFieldPushUpExerciseName::WeightedCloseHandsPushUp,
            13 => FitFieldPushUpExerciseName::DeclinePushUp,
            14 => FitFieldPushUpExerciseName::WeightedDeclinePushUp,
            15 => FitFieldPushUpExerciseName::DiamondPushUp,
            16 => FitFieldPushUpExerciseName::WeightedDiamondPushUp,
            17 => FitFieldPushUpExerciseName::ExplosiveCrossoverPushUp,
            18 => FitFieldPushUpExerciseName::WeightedExplosiveCrossoverPushUp,
            19 => FitFieldPushUpExerciseName::ExplosivePushUp,
            20 => FitFieldPushUpExerciseName::WeightedExplosivePushUp,
            21 => FitFieldPushUpExerciseName::FeetElevatedSideToSidePushUp,
            22 => FitFieldPushUpExerciseName::WeightedFeetElevatedSideToSidePushUp,
            23 => FitFieldPushUpExerciseName::HandReleasePushUp,
            24 => FitFieldPushUpExerciseName::WeightedHandReleasePushUp,
            25 => FitFieldPushUpExerciseName::HandstandPushUp,
            26 => FitFieldPushUpExerciseName::WeightedHandstandPushUp,
            27 => FitFieldPushUpExerciseName::InclinePushUp,
            28 => FitFieldPushUpExerciseName::WeightedInclinePushUp,
            29 => FitFieldPushUpExerciseName::IsometricExplosivePushUp,
            30 => FitFieldPushUpExerciseName::WeightedIsometricExplosivePushUp,
            31 => FitFieldPushUpExerciseName::JudoPushUp,
            32 => FitFieldPushUpExerciseName::WeightedJudoPushUp,
            33 => FitFieldPushUpExerciseName::KneelingPushUp,
            34 => FitFieldPushUpExerciseName::WeightedKneelingPushUp,
            35 => FitFieldPushUpExerciseName::MedicineBallChestPass,
            36 => FitFieldPushUpExerciseName::MedicineBallPushUp,
            37 => FitFieldPushUpExerciseName::WeightedMedicineBallPushUp,
            38 => FitFieldPushUpExerciseName::OneArmPushUp,
            39 => FitFieldPushUpExerciseName::WeightedOneArmPushUp,
            40 => FitFieldPushUpExerciseName::WeightedPushUp,
            41 => FitFieldPushUpExerciseName::PushUpAndRow,
            42 => FitFieldPushUpExerciseName::WeightedPushUpAndRow,
            43 => FitFieldPushUpExerciseName::PushUpPlus,
            44 => FitFieldPushUpExerciseName::WeightedPushUpPlus,
            45 => FitFieldPushUpExerciseName::PushUpWithFeetOnSwissBall,
            46 => FitFieldPushUpExerciseName::WeightedPushUpWithFeetOnSwissBall,
            47 => FitFieldPushUpExerciseName::PushUpWithOneHandOnMedicineBall,
            48 => FitFieldPushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall,
            49 => FitFieldPushUpExerciseName::ShoulderPushUp,
            50 => FitFieldPushUpExerciseName::WeightedShoulderPushUp,
            51 => FitFieldPushUpExerciseName::SingleArmMedicineBallPushUp,
            52 => FitFieldPushUpExerciseName::WeightedSingleArmMedicineBallPushUp,
            53 => FitFieldPushUpExerciseName::SpidermanPushUp,
            54 => FitFieldPushUpExerciseName::WeightedSpidermanPushUp,
            55 => FitFieldPushUpExerciseName::StackedFeetPushUp,
            56 => FitFieldPushUpExerciseName::WeightedStackedFeetPushUp,
            57 => FitFieldPushUpExerciseName::StaggeredHandsPushUp,
            58 => FitFieldPushUpExerciseName::WeightedStaggeredHandsPushUp,
            59 => FitFieldPushUpExerciseName::SuspendedPushUp,
            60 => FitFieldPushUpExerciseName::WeightedSuspendedPushUp,
            61 => FitFieldPushUpExerciseName::SwissBallPushUp,
            62 => FitFieldPushUpExerciseName::WeightedSwissBallPushUp,
            63 => FitFieldPushUpExerciseName::SwissBallPushUpPlus,
            64 => FitFieldPushUpExerciseName::WeightedSwissBallPushUpPlus,
            65 => FitFieldPushUpExerciseName::TPushUp,
            66 => FitFieldPushUpExerciseName::WeightedTPushUp,
            67 => FitFieldPushUpExerciseName::TripleStopPushUp,
            68 => FitFieldPushUpExerciseName::WeightedTripleStopPushUp,
            69 => FitFieldPushUpExerciseName::WideHandsPushUp,
            70 => FitFieldPushUpExerciseName::WeightedWideHandsPushUp,
            71 => FitFieldPushUpExerciseName::ParalletteHandstandPushUp,
            72 => FitFieldPushUpExerciseName::WeightedParalletteHandstandPushUp,
            73 => FitFieldPushUpExerciseName::RingHandstandPushUp,
            74 => FitFieldPushUpExerciseName::WeightedRingHandstandPushUp,
            75 => FitFieldPushUpExerciseName::RingPushUp,
            76 => FitFieldPushUpExerciseName::WeightedRingPushUp,
            77 => FitFieldPushUpExerciseName::PushUp,
            78 => FitFieldPushUpExerciseName::PilatesPushup,
            _ => FitFieldPushUpExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldRowExerciseName {
    // fit base type: uint16
    BarbellStraightLegDeadliftToRow,            // 0
    CableRowStanding,                           // 1
    DumbbellRow,                                // 2
    ElevatedFeetInvertedRow,                    // 3
    WeightedElevatedFeetInvertedRow,            // 4
    FacePull,                                   // 5
    FacePullWithExternalRotation,               // 6
    InvertedRowWithFeetOnSwissBall,             // 7
    WeightedInvertedRowWithFeetOnSwissBall,     // 8
    KettlebellRow,                              // 9
    ModifiedInvertedRow,                        // 10
    WeightedModifiedInvertedRow,                // 11
    NeutralGripAlternatingDumbbellRow,          // 12
    OneArmBentOverRow,                          // 13
    OneLeggedDumbbellRow,                       // 14
    RenegadeRow,                                // 15
    ReverseGripBarbellRow,                      // 16
    RopeHandleCableRow,                         // 17
    SeatedCableRow,                             // 18
    SeatedDumbbellRow,                          // 19
    SingleArmCableRow,                          // 20
    SingleArmCableRowAndRotation,               // 21
    SingleArmInvertedRow,                       // 22
    WeightedSingleArmInvertedRow,               // 23
    SingleArmNeutralGripDumbbellRow,            // 24
    SingleArmNeutralGripDumbbellRowAndRotation, // 25
    SuspendedInvertedRow,                       // 26
    WeightedSuspendedInvertedRow,               // 27
    TBarRow,                                    // 28
    TowelGripInvertedRow,                       // 29
    WeightedTowelGripInvertedRow,               // 30
    UnderhandGripCableRow,                      // 31
    VGripCableRow,                              // 32
    WideGripSeatedCableRow,                     // 33
    RowExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldRowExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldRowExerciseName::BarbellStraightLegDeadliftToRow => {
                write!(f, "{}", "BarbellStraightLegDeadliftToRow")
            }
            FitFieldRowExerciseName::CableRowStanding => write!(f, "{}", "CableRowStanding"),
            FitFieldRowExerciseName::DumbbellRow => write!(f, "{}", "DumbbellRow"),
            FitFieldRowExerciseName::ElevatedFeetInvertedRow => {
                write!(f, "{}", "ElevatedFeetInvertedRow")
            }
            FitFieldRowExerciseName::WeightedElevatedFeetInvertedRow => {
                write!(f, "{}", "WeightedElevatedFeetInvertedRow")
            }
            FitFieldRowExerciseName::FacePull => write!(f, "{}", "FacePull"),
            FitFieldRowExerciseName::FacePullWithExternalRotation => {
                write!(f, "{}", "FacePullWithExternalRotation")
            }
            FitFieldRowExerciseName::InvertedRowWithFeetOnSwissBall => {
                write!(f, "{}", "InvertedRowWithFeetOnSwissBall")
            }
            FitFieldRowExerciseName::WeightedInvertedRowWithFeetOnSwissBall => {
                write!(f, "{}", "WeightedInvertedRowWithFeetOnSwissBall")
            }
            FitFieldRowExerciseName::KettlebellRow => write!(f, "{}", "KettlebellRow"),
            FitFieldRowExerciseName::ModifiedInvertedRow => write!(f, "{}", "ModifiedInvertedRow"),
            FitFieldRowExerciseName::WeightedModifiedInvertedRow => {
                write!(f, "{}", "WeightedModifiedInvertedRow")
            }
            FitFieldRowExerciseName::NeutralGripAlternatingDumbbellRow => {
                write!(f, "{}", "NeutralGripAlternatingDumbbellRow")
            }
            FitFieldRowExerciseName::OneArmBentOverRow => write!(f, "{}", "OneArmBentOverRow"),
            FitFieldRowExerciseName::OneLeggedDumbbellRow => {
                write!(f, "{}", "OneLeggedDumbbellRow")
            }
            FitFieldRowExerciseName::RenegadeRow => write!(f, "{}", "RenegadeRow"),
            FitFieldRowExerciseName::ReverseGripBarbellRow => {
                write!(f, "{}", "ReverseGripBarbellRow")
            }
            FitFieldRowExerciseName::RopeHandleCableRow => write!(f, "{}", "RopeHandleCableRow"),
            FitFieldRowExerciseName::SeatedCableRow => write!(f, "{}", "SeatedCableRow"),
            FitFieldRowExerciseName::SeatedDumbbellRow => write!(f, "{}", "SeatedDumbbellRow"),
            FitFieldRowExerciseName::SingleArmCableRow => write!(f, "{}", "SingleArmCableRow"),
            FitFieldRowExerciseName::SingleArmCableRowAndRotation => {
                write!(f, "{}", "SingleArmCableRowAndRotation")
            }
            FitFieldRowExerciseName::SingleArmInvertedRow => {
                write!(f, "{}", "SingleArmInvertedRow")
            }
            FitFieldRowExerciseName::WeightedSingleArmInvertedRow => {
                write!(f, "{}", "WeightedSingleArmInvertedRow")
            }
            FitFieldRowExerciseName::SingleArmNeutralGripDumbbellRow => {
                write!(f, "{}", "SingleArmNeutralGripDumbbellRow")
            }
            FitFieldRowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation => {
                write!(f, "{}", "SingleArmNeutralGripDumbbellRowAndRotation")
            }
            FitFieldRowExerciseName::SuspendedInvertedRow => {
                write!(f, "{}", "SuspendedInvertedRow")
            }
            FitFieldRowExerciseName::WeightedSuspendedInvertedRow => {
                write!(f, "{}", "WeightedSuspendedInvertedRow")
            }
            FitFieldRowExerciseName::TBarRow => write!(f, "{}", "TBarRow"),
            FitFieldRowExerciseName::TowelGripInvertedRow => {
                write!(f, "{}", "TowelGripInvertedRow")
            }
            FitFieldRowExerciseName::WeightedTowelGripInvertedRow => {
                write!(f, "{}", "WeightedTowelGripInvertedRow")
            }
            FitFieldRowExerciseName::UnderhandGripCableRow => {
                write!(f, "{}", "UnderhandGripCableRow")
            }
            FitFieldRowExerciseName::VGripCableRow => write!(f, "{}", "VGripCableRow"),
            FitFieldRowExerciseName::WideGripSeatedCableRow => {
                write!(f, "{}", "WideGripSeatedCableRow")
            }
            FitFieldRowExerciseName::RowExerciseName(x) => {
                write!(f, "{}({})", "RowExerciseName", x)
            }
            FitFieldRowExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldRowExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldRowExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldRowExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldRowExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldRowExerciseName::from(v)),
                1 => Ok(FitFieldRowExerciseName::from(v)),
                2 => Ok(FitFieldRowExerciseName::from(v)),
                3 => Ok(FitFieldRowExerciseName::from(v)),
                4 => Ok(FitFieldRowExerciseName::from(v)),
                5 => Ok(FitFieldRowExerciseName::from(v)),
                6 => Ok(FitFieldRowExerciseName::from(v)),
                7 => Ok(FitFieldRowExerciseName::from(v)),
                8 => Ok(FitFieldRowExerciseName::from(v)),
                9 => Ok(FitFieldRowExerciseName::from(v)),
                10 => Ok(FitFieldRowExerciseName::from(v)),
                11 => Ok(FitFieldRowExerciseName::from(v)),
                12 => Ok(FitFieldRowExerciseName::from(v)),
                13 => Ok(FitFieldRowExerciseName::from(v)),
                14 => Ok(FitFieldRowExerciseName::from(v)),
                15 => Ok(FitFieldRowExerciseName::from(v)),
                16 => Ok(FitFieldRowExerciseName::from(v)),
                17 => Ok(FitFieldRowExerciseName::from(v)),
                18 => Ok(FitFieldRowExerciseName::from(v)),
                19 => Ok(FitFieldRowExerciseName::from(v)),
                20 => Ok(FitFieldRowExerciseName::from(v)),
                21 => Ok(FitFieldRowExerciseName::from(v)),
                22 => Ok(FitFieldRowExerciseName::from(v)),
                23 => Ok(FitFieldRowExerciseName::from(v)),
                24 => Ok(FitFieldRowExerciseName::from(v)),
                25 => Ok(FitFieldRowExerciseName::from(v)),
                26 => Ok(FitFieldRowExerciseName::from(v)),
                27 => Ok(FitFieldRowExerciseName::from(v)),
                28 => Ok(FitFieldRowExerciseName::from(v)),
                29 => Ok(FitFieldRowExerciseName::from(v)),
                30 => Ok(FitFieldRowExerciseName::from(v)),
                31 => Ok(FitFieldRowExerciseName::from(v)),
                32 => Ok(FitFieldRowExerciseName::from(v)),
                33 => Ok(FitFieldRowExerciseName::from(v)),
                v => Ok(FitFieldRowExerciseName::RowExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldRowExerciseName);

impl From<u16> for FitFieldRowExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldRowExerciseName::BarbellStraightLegDeadliftToRow,
            1 => FitFieldRowExerciseName::CableRowStanding,
            2 => FitFieldRowExerciseName::DumbbellRow,
            3 => FitFieldRowExerciseName::ElevatedFeetInvertedRow,
            4 => FitFieldRowExerciseName::WeightedElevatedFeetInvertedRow,
            5 => FitFieldRowExerciseName::FacePull,
            6 => FitFieldRowExerciseName::FacePullWithExternalRotation,
            7 => FitFieldRowExerciseName::InvertedRowWithFeetOnSwissBall,
            8 => FitFieldRowExerciseName::WeightedInvertedRowWithFeetOnSwissBall,
            9 => FitFieldRowExerciseName::KettlebellRow,
            10 => FitFieldRowExerciseName::ModifiedInvertedRow,
            11 => FitFieldRowExerciseName::WeightedModifiedInvertedRow,
            12 => FitFieldRowExerciseName::NeutralGripAlternatingDumbbellRow,
            13 => FitFieldRowExerciseName::OneArmBentOverRow,
            14 => FitFieldRowExerciseName::OneLeggedDumbbellRow,
            15 => FitFieldRowExerciseName::RenegadeRow,
            16 => FitFieldRowExerciseName::ReverseGripBarbellRow,
            17 => FitFieldRowExerciseName::RopeHandleCableRow,
            18 => FitFieldRowExerciseName::SeatedCableRow,
            19 => FitFieldRowExerciseName::SeatedDumbbellRow,
            20 => FitFieldRowExerciseName::SingleArmCableRow,
            21 => FitFieldRowExerciseName::SingleArmCableRowAndRotation,
            22 => FitFieldRowExerciseName::SingleArmInvertedRow,
            23 => FitFieldRowExerciseName::WeightedSingleArmInvertedRow,
            24 => FitFieldRowExerciseName::SingleArmNeutralGripDumbbellRow,
            25 => FitFieldRowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation,
            26 => FitFieldRowExerciseName::SuspendedInvertedRow,
            27 => FitFieldRowExerciseName::WeightedSuspendedInvertedRow,
            28 => FitFieldRowExerciseName::TBarRow,
            29 => FitFieldRowExerciseName::TowelGripInvertedRow,
            30 => FitFieldRowExerciseName::WeightedTowelGripInvertedRow,
            31 => FitFieldRowExerciseName::UnderhandGripCableRow,
            32 => FitFieldRowExerciseName::VGripCableRow,
            33 => FitFieldRowExerciseName::WideGripSeatedCableRow,
            _ => FitFieldRowExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldShoulderPressExerciseName {
    // fit base type: uint16
    AlternatingDumbbellShoulderPress,         // 0
    ArnoldPress,                              // 1
    BarbellFrontSquatToPushPress,             // 2
    BarbellPushPress,                         // 3
    BarbellShoulderPress,                     // 4
    DeadCurlPress,                            // 5
    DumbbellAlternatingShoulderPressAndTwist, // 6
    DumbbellHammerCurlToLungeToPress,         // 7
    DumbbellPushPress,                        // 8
    FloorInvertedShoulderPress,               // 9
    WeightedFloorInvertedShoulderPress,       // 10
    InvertedShoulderPress,                    // 11
    WeightedInvertedShoulderPress,            // 12
    OneArmPushPress,                          // 13
    OverheadBarbellPress,                     // 14
    OverheadDumbbellPress,                    // 15
    SeatedBarbellShoulderPress,               // 16
    SeatedDumbbellShoulderPress,              // 17
    SingleArmDumbbellShoulderPress,           // 18
    SingleArmStepUpAndPress,                  // 19
    SmithMachineOverheadPress,                // 20
    SplitStanceHammerCurlToPress,             // 21
    SwissBallDumbbellShoulderPress,           // 22
    WeightPlateFrontRaise,                    // 23
    ShoulderPressExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldShoulderPressExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldShoulderPressExerciseName::AlternatingDumbbellShoulderPress => {
                write!(f, "{}", "AlternatingDumbbellShoulderPress")
            }
            FitFieldShoulderPressExerciseName::ArnoldPress => write!(f, "{}", "ArnoldPress"),
            FitFieldShoulderPressExerciseName::BarbellFrontSquatToPushPress => {
                write!(f, "{}", "BarbellFrontSquatToPushPress")
            }
            FitFieldShoulderPressExerciseName::BarbellPushPress => {
                write!(f, "{}", "BarbellPushPress")
            }
            FitFieldShoulderPressExerciseName::BarbellShoulderPress => {
                write!(f, "{}", "BarbellShoulderPress")
            }
            FitFieldShoulderPressExerciseName::DeadCurlPress => write!(f, "{}", "DeadCurlPress"),
            FitFieldShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist => {
                write!(f, "{}", "DumbbellAlternatingShoulderPressAndTwist")
            }
            FitFieldShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress => {
                write!(f, "{}", "DumbbellHammerCurlToLungeToPress")
            }
            FitFieldShoulderPressExerciseName::DumbbellPushPress => {
                write!(f, "{}", "DumbbellPushPress")
            }
            FitFieldShoulderPressExerciseName::FloorInvertedShoulderPress => {
                write!(f, "{}", "FloorInvertedShoulderPress")
            }
            FitFieldShoulderPressExerciseName::WeightedFloorInvertedShoulderPress => {
                write!(f, "{}", "WeightedFloorInvertedShoulderPress")
            }
            FitFieldShoulderPressExerciseName::InvertedShoulderPress => {
                write!(f, "{}", "InvertedShoulderPress")
            }
            FitFieldShoulderPressExerciseName::WeightedInvertedShoulderPress => {
                write!(f, "{}", "WeightedInvertedShoulderPress")
            }
            FitFieldShoulderPressExerciseName::OneArmPushPress => {
                write!(f, "{}", "OneArmPushPress")
            }
            FitFieldShoulderPressExerciseName::OverheadBarbellPress => {
                write!(f, "{}", "OverheadBarbellPress")
            }
            FitFieldShoulderPressExerciseName::OverheadDumbbellPress => {
                write!(f, "{}", "OverheadDumbbellPress")
            }
            FitFieldShoulderPressExerciseName::SeatedBarbellShoulderPress => {
                write!(f, "{}", "SeatedBarbellShoulderPress")
            }
            FitFieldShoulderPressExerciseName::SeatedDumbbellShoulderPress => {
                write!(f, "{}", "SeatedDumbbellShoulderPress")
            }
            FitFieldShoulderPressExerciseName::SingleArmDumbbellShoulderPress => {
                write!(f, "{}", "SingleArmDumbbellShoulderPress")
            }
            FitFieldShoulderPressExerciseName::SingleArmStepUpAndPress => {
                write!(f, "{}", "SingleArmStepUpAndPress")
            }
            FitFieldShoulderPressExerciseName::SmithMachineOverheadPress => {
                write!(f, "{}", "SmithMachineOverheadPress")
            }
            FitFieldShoulderPressExerciseName::SplitStanceHammerCurlToPress => {
                write!(f, "{}", "SplitStanceHammerCurlToPress")
            }
            FitFieldShoulderPressExerciseName::SwissBallDumbbellShoulderPress => {
                write!(f, "{}", "SwissBallDumbbellShoulderPress")
            }
            FitFieldShoulderPressExerciseName::WeightPlateFrontRaise => {
                write!(f, "{}", "WeightPlateFrontRaise")
            }
            FitFieldShoulderPressExerciseName::ShoulderPressExerciseName(x) => {
                write!(f, "{}({})", "ShoulderPressExerciseName", x)
            }
            FitFieldShoulderPressExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldShoulderPressExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldShoulderPressExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldShoulderPressExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldShoulderPressExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                1 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                2 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                3 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                4 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                5 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                6 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                7 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                8 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                9 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                10 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                11 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                12 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                13 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                14 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                15 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                16 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                17 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                18 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                19 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                20 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                21 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                22 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                23 => Ok(FitFieldShoulderPressExerciseName::from(v)),
                v => Ok(FitFieldShoulderPressExerciseName::ShoulderPressExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldShoulderPressExerciseName);

impl From<u16> for FitFieldShoulderPressExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldShoulderPressExerciseName::AlternatingDumbbellShoulderPress,
            1 => FitFieldShoulderPressExerciseName::ArnoldPress,
            2 => FitFieldShoulderPressExerciseName::BarbellFrontSquatToPushPress,
            3 => FitFieldShoulderPressExerciseName::BarbellPushPress,
            4 => FitFieldShoulderPressExerciseName::BarbellShoulderPress,
            5 => FitFieldShoulderPressExerciseName::DeadCurlPress,
            6 => FitFieldShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist,
            7 => FitFieldShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress,
            8 => FitFieldShoulderPressExerciseName::DumbbellPushPress,
            9 => FitFieldShoulderPressExerciseName::FloorInvertedShoulderPress,
            10 => FitFieldShoulderPressExerciseName::WeightedFloorInvertedShoulderPress,
            11 => FitFieldShoulderPressExerciseName::InvertedShoulderPress,
            12 => FitFieldShoulderPressExerciseName::WeightedInvertedShoulderPress,
            13 => FitFieldShoulderPressExerciseName::OneArmPushPress,
            14 => FitFieldShoulderPressExerciseName::OverheadBarbellPress,
            15 => FitFieldShoulderPressExerciseName::OverheadDumbbellPress,
            16 => FitFieldShoulderPressExerciseName::SeatedBarbellShoulderPress,
            17 => FitFieldShoulderPressExerciseName::SeatedDumbbellShoulderPress,
            18 => FitFieldShoulderPressExerciseName::SingleArmDumbbellShoulderPress,
            19 => FitFieldShoulderPressExerciseName::SingleArmStepUpAndPress,
            20 => FitFieldShoulderPressExerciseName::SmithMachineOverheadPress,
            21 => FitFieldShoulderPressExerciseName::SplitStanceHammerCurlToPress,
            22 => FitFieldShoulderPressExerciseName::SwissBallDumbbellShoulderPress,
            23 => FitFieldShoulderPressExerciseName::WeightPlateFrontRaise,
            _ => FitFieldShoulderPressExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldShoulderStabilityExerciseName {
    // fit base type: uint16
    NinetyDegreeCableExternalRotation,      // 0
    BandExternalRotation,                   // 1
    BandInternalRotation,                   // 2
    BentArmLateralRaiseAndExternalRotation, // 3
    CableExternalRotation,                  // 4
    DumbbellFacePullWithExternalRotation,   // 5
    FloorIRaise,                            // 6
    WeightedFloorIRaise,                    // 7
    FloorTRaise,                            // 8
    WeightedFloorTRaise,                    // 9
    FloorYRaise,                            // 10
    WeightedFloorYRaise,                    // 11
    InclineIRaise,                          // 12
    WeightedInclineIRaise,                  // 13
    InclineLRaise,                          // 14
    WeightedInclineLRaise,                  // 15
    InclineTRaise,                          // 16
    WeightedInclineTRaise,                  // 17
    InclineWRaise,                          // 18
    WeightedInclineWRaise,                  // 19
    InclineYRaise,                          // 20
    WeightedInclineYRaise,                  // 21
    LyingExternalRotation,                  // 22
    SeatedDumbbellExternalRotation,         // 23
    StandingLRaise,                         // 24
    SwissBallIRaise,                        // 25
    WeightedSwissBallIRaise,                // 26
    SwissBallTRaise,                        // 27
    WeightedSwissBallTRaise,                // 28
    SwissBallWRaise,                        // 29
    WeightedSwissBallWRaise,                // 30
    SwissBallYRaise,                        // 31
    WeightedSwissBallYRaise,                // 32
    ShoulderStabilityExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldShoulderStabilityExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldShoulderStabilityExerciseName::NinetyDegreeCableExternalRotation => {
                write!(f, "{}", "NinetyDegreeCableExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::BandExternalRotation => {
                write!(f, "{}", "BandExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::BandInternalRotation => {
                write!(f, "{}", "BandInternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation => {
                write!(f, "{}", "BentArmLateralRaiseAndExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::CableExternalRotation => {
                write!(f, "{}", "CableExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation => {
                write!(f, "{}", "DumbbellFacePullWithExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::FloorIRaise => write!(f, "{}", "FloorIRaise"),
            FitFieldShoulderStabilityExerciseName::WeightedFloorIRaise => {
                write!(f, "{}", "WeightedFloorIRaise")
            }
            FitFieldShoulderStabilityExerciseName::FloorTRaise => write!(f, "{}", "FloorTRaise"),
            FitFieldShoulderStabilityExerciseName::WeightedFloorTRaise => {
                write!(f, "{}", "WeightedFloorTRaise")
            }
            FitFieldShoulderStabilityExerciseName::FloorYRaise => write!(f, "{}", "FloorYRaise"),
            FitFieldShoulderStabilityExerciseName::WeightedFloorYRaise => {
                write!(f, "{}", "WeightedFloorYRaise")
            }
            FitFieldShoulderStabilityExerciseName::InclineIRaise => {
                write!(f, "{}", "InclineIRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedInclineIRaise => {
                write!(f, "{}", "WeightedInclineIRaise")
            }
            FitFieldShoulderStabilityExerciseName::InclineLRaise => {
                write!(f, "{}", "InclineLRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedInclineLRaise => {
                write!(f, "{}", "WeightedInclineLRaise")
            }
            FitFieldShoulderStabilityExerciseName::InclineTRaise => {
                write!(f, "{}", "InclineTRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedInclineTRaise => {
                write!(f, "{}", "WeightedInclineTRaise")
            }
            FitFieldShoulderStabilityExerciseName::InclineWRaise => {
                write!(f, "{}", "InclineWRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedInclineWRaise => {
                write!(f, "{}", "WeightedInclineWRaise")
            }
            FitFieldShoulderStabilityExerciseName::InclineYRaise => {
                write!(f, "{}", "InclineYRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedInclineYRaise => {
                write!(f, "{}", "WeightedInclineYRaise")
            }
            FitFieldShoulderStabilityExerciseName::LyingExternalRotation => {
                write!(f, "{}", "LyingExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::SeatedDumbbellExternalRotation => {
                write!(f, "{}", "SeatedDumbbellExternalRotation")
            }
            FitFieldShoulderStabilityExerciseName::StandingLRaise => {
                write!(f, "{}", "StandingLRaise")
            }
            FitFieldShoulderStabilityExerciseName::SwissBallIRaise => {
                write!(f, "{}", "SwissBallIRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedSwissBallIRaise => {
                write!(f, "{}", "WeightedSwissBallIRaise")
            }
            FitFieldShoulderStabilityExerciseName::SwissBallTRaise => {
                write!(f, "{}", "SwissBallTRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedSwissBallTRaise => {
                write!(f, "{}", "WeightedSwissBallTRaise")
            }
            FitFieldShoulderStabilityExerciseName::SwissBallWRaise => {
                write!(f, "{}", "SwissBallWRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedSwissBallWRaise => {
                write!(f, "{}", "WeightedSwissBallWRaise")
            }
            FitFieldShoulderStabilityExerciseName::SwissBallYRaise => {
                write!(f, "{}", "SwissBallYRaise")
            }
            FitFieldShoulderStabilityExerciseName::WeightedSwissBallYRaise => {
                write!(f, "{}", "WeightedSwissBallYRaise")
            }
            FitFieldShoulderStabilityExerciseName::ShoulderStabilityExerciseName(x) => {
                write!(f, "{}({})", "ShoulderStabilityExerciseName", x)
            }
            FitFieldShoulderStabilityExerciseName::InvalidFieldValue => {
                write!(f, "InvalidFieldValue")
            }
            FitFieldShoulderStabilityExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldShoulderStabilityExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldShoulderStabilityExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldShoulderStabilityExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                1 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                2 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                3 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                4 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                5 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                6 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                7 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                8 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                9 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                10 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                11 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                12 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                13 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                14 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                15 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                16 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                17 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                18 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                19 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                20 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                21 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                22 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                23 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                24 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                25 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                26 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                27 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                28 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                29 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                30 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                31 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                32 => Ok(FitFieldShoulderStabilityExerciseName::from(v)),
                v => Ok(FitFieldShoulderStabilityExerciseName::ShoulderStabilityExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldShoulderStabilityExerciseName);

impl From<u16> for FitFieldShoulderStabilityExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldShoulderStabilityExerciseName::NinetyDegreeCableExternalRotation,
            1 => FitFieldShoulderStabilityExerciseName::BandExternalRotation,
            2 => FitFieldShoulderStabilityExerciseName::BandInternalRotation,
            3 => FitFieldShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation,
            4 => FitFieldShoulderStabilityExerciseName::CableExternalRotation,
            5 => FitFieldShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation,
            6 => FitFieldShoulderStabilityExerciseName::FloorIRaise,
            7 => FitFieldShoulderStabilityExerciseName::WeightedFloorIRaise,
            8 => FitFieldShoulderStabilityExerciseName::FloorTRaise,
            9 => FitFieldShoulderStabilityExerciseName::WeightedFloorTRaise,
            10 => FitFieldShoulderStabilityExerciseName::FloorYRaise,
            11 => FitFieldShoulderStabilityExerciseName::WeightedFloorYRaise,
            12 => FitFieldShoulderStabilityExerciseName::InclineIRaise,
            13 => FitFieldShoulderStabilityExerciseName::WeightedInclineIRaise,
            14 => FitFieldShoulderStabilityExerciseName::InclineLRaise,
            15 => FitFieldShoulderStabilityExerciseName::WeightedInclineLRaise,
            16 => FitFieldShoulderStabilityExerciseName::InclineTRaise,
            17 => FitFieldShoulderStabilityExerciseName::WeightedInclineTRaise,
            18 => FitFieldShoulderStabilityExerciseName::InclineWRaise,
            19 => FitFieldShoulderStabilityExerciseName::WeightedInclineWRaise,
            20 => FitFieldShoulderStabilityExerciseName::InclineYRaise,
            21 => FitFieldShoulderStabilityExerciseName::WeightedInclineYRaise,
            22 => FitFieldShoulderStabilityExerciseName::LyingExternalRotation,
            23 => FitFieldShoulderStabilityExerciseName::SeatedDumbbellExternalRotation,
            24 => FitFieldShoulderStabilityExerciseName::StandingLRaise,
            25 => FitFieldShoulderStabilityExerciseName::SwissBallIRaise,
            26 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallIRaise,
            27 => FitFieldShoulderStabilityExerciseName::SwissBallTRaise,
            28 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallTRaise,
            29 => FitFieldShoulderStabilityExerciseName::SwissBallWRaise,
            30 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallWRaise,
            31 => FitFieldShoulderStabilityExerciseName::SwissBallYRaise,
            32 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallYRaise,
            _ => FitFieldShoulderStabilityExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldShrugExerciseName {
    // fit base type: uint16
    BarbellJumpShrug,               // 0
    BarbellShrug,                   // 1
    BarbellUprightRow,              // 2
    BehindTheBackSmithMachineShrug, // 3
    DumbbellJumpShrug,              // 4
    DumbbellShrug,                  // 5
    DumbbellUprightRow,             // 6
    InclineDumbbellShrug,           // 7
    OverheadBarbellShrug,           // 8
    OverheadDumbbellShrug,          // 9
    ScaptionAndShrug,               // 10
    ScapularRetraction,             // 11
    SerratusChairShrug,             // 12
    WeightedSerratusChairShrug,     // 13
    SerratusShrug,                  // 14
    WeightedSerratusShrug,          // 15
    WideGripJumpShrug,              // 16
    ShrugExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldShrugExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldShrugExerciseName::BarbellJumpShrug => write!(f, "{}", "BarbellJumpShrug"),
            FitFieldShrugExerciseName::BarbellShrug => write!(f, "{}", "BarbellShrug"),
            FitFieldShrugExerciseName::BarbellUprightRow => write!(f, "{}", "BarbellUprightRow"),
            FitFieldShrugExerciseName::BehindTheBackSmithMachineShrug => {
                write!(f, "{}", "BehindTheBackSmithMachineShrug")
            }
            FitFieldShrugExerciseName::DumbbellJumpShrug => write!(f, "{}", "DumbbellJumpShrug"),
            FitFieldShrugExerciseName::DumbbellShrug => write!(f, "{}", "DumbbellShrug"),
            FitFieldShrugExerciseName::DumbbellUprightRow => write!(f, "{}", "DumbbellUprightRow"),
            FitFieldShrugExerciseName::InclineDumbbellShrug => {
                write!(f, "{}", "InclineDumbbellShrug")
            }
            FitFieldShrugExerciseName::OverheadBarbellShrug => {
                write!(f, "{}", "OverheadBarbellShrug")
            }
            FitFieldShrugExerciseName::OverheadDumbbellShrug => {
                write!(f, "{}", "OverheadDumbbellShrug")
            }
            FitFieldShrugExerciseName::ScaptionAndShrug => write!(f, "{}", "ScaptionAndShrug"),
            FitFieldShrugExerciseName::ScapularRetraction => write!(f, "{}", "ScapularRetraction"),
            FitFieldShrugExerciseName::SerratusChairShrug => write!(f, "{}", "SerratusChairShrug"),
            FitFieldShrugExerciseName::WeightedSerratusChairShrug => {
                write!(f, "{}", "WeightedSerratusChairShrug")
            }
            FitFieldShrugExerciseName::SerratusShrug => write!(f, "{}", "SerratusShrug"),
            FitFieldShrugExerciseName::WeightedSerratusShrug => {
                write!(f, "{}", "WeightedSerratusShrug")
            }
            FitFieldShrugExerciseName::WideGripJumpShrug => write!(f, "{}", "WideGripJumpShrug"),
            FitFieldShrugExerciseName::ShrugExerciseName(x) => {
                write!(f, "{}({})", "ShrugExerciseName", x)
            }
            FitFieldShrugExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldShrugExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldShrugExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldShrugExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldShrugExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldShrugExerciseName::from(v)),
                1 => Ok(FitFieldShrugExerciseName::from(v)),
                2 => Ok(FitFieldShrugExerciseName::from(v)),
                3 => Ok(FitFieldShrugExerciseName::from(v)),
                4 => Ok(FitFieldShrugExerciseName::from(v)),
                5 => Ok(FitFieldShrugExerciseName::from(v)),
                6 => Ok(FitFieldShrugExerciseName::from(v)),
                7 => Ok(FitFieldShrugExerciseName::from(v)),
                8 => Ok(FitFieldShrugExerciseName::from(v)),
                9 => Ok(FitFieldShrugExerciseName::from(v)),
                10 => Ok(FitFieldShrugExerciseName::from(v)),
                11 => Ok(FitFieldShrugExerciseName::from(v)),
                12 => Ok(FitFieldShrugExerciseName::from(v)),
                13 => Ok(FitFieldShrugExerciseName::from(v)),
                14 => Ok(FitFieldShrugExerciseName::from(v)),
                15 => Ok(FitFieldShrugExerciseName::from(v)),
                16 => Ok(FitFieldShrugExerciseName::from(v)),
                v => Ok(FitFieldShrugExerciseName::ShrugExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldShrugExerciseName);

impl From<u16> for FitFieldShrugExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldShrugExerciseName::BarbellJumpShrug,
            1 => FitFieldShrugExerciseName::BarbellShrug,
            2 => FitFieldShrugExerciseName::BarbellUprightRow,
            3 => FitFieldShrugExerciseName::BehindTheBackSmithMachineShrug,
            4 => FitFieldShrugExerciseName::DumbbellJumpShrug,
            5 => FitFieldShrugExerciseName::DumbbellShrug,
            6 => FitFieldShrugExerciseName::DumbbellUprightRow,
            7 => FitFieldShrugExerciseName::InclineDumbbellShrug,
            8 => FitFieldShrugExerciseName::OverheadBarbellShrug,
            9 => FitFieldShrugExerciseName::OverheadDumbbellShrug,
            10 => FitFieldShrugExerciseName::ScaptionAndShrug,
            11 => FitFieldShrugExerciseName::ScapularRetraction,
            12 => FitFieldShrugExerciseName::SerratusChairShrug,
            13 => FitFieldShrugExerciseName::WeightedSerratusChairShrug,
            14 => FitFieldShrugExerciseName::SerratusShrug,
            15 => FitFieldShrugExerciseName::WeightedSerratusShrug,
            16 => FitFieldShrugExerciseName::WideGripJumpShrug,
            _ => FitFieldShrugExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSitUpExerciseName {
    // fit base type: uint16
    AlternatingSitUp,                    // 0
    WeightedAlternatingSitUp,            // 1
    BentKneeVUp,                         // 2
    WeightedBentKneeVUp,                 // 3
    ButterflySitUp,                      // 4
    WeightedButterflySitup,              // 5
    CrossPunchRollUp,                    // 6
    WeightedCrossPunchRollUp,            // 7
    CrossedArmsSitUp,                    // 8
    WeightedCrossedArmsSitUp,            // 9
    GetUpSitUp,                          // 10
    WeightedGetUpSitUp,                  // 11
    HoveringSitUp,                       // 12
    WeightedHoveringSitUp,               // 13
    KettlebellSitUp,                     // 14
    MedicineBallAlternatingVUp,          // 15
    MedicineBallSitUp,                   // 16
    MedicineBallVUp,                     // 17
    ModifiedSitUp,                       // 18
    NegativeSitUp,                       // 19
    OneArmFullSitUp,                     // 20
    RecliningCircle,                     // 21
    WeightedRecliningCircle,             // 22
    ReverseCurlUp,                       // 23
    WeightedReverseCurlUp,               // 24
    SingleLegSwissBallJackknife,         // 25
    WeightedSingleLegSwissBallJackknife, // 26
    TheTeaser,                           // 27
    TheTeaserWeighted,                   // 28
    ThreePartRollDown,                   // 29
    WeightedThreePartRollDown,           // 30
    VUp,                                 // 31
    WeightedVUp,                         // 32
    WeightedRussianTwistOnSwissBall,     // 33
    WeightedSitUp,                       // 34
    XAbs,                                // 35
    WeightedXAbs,                        // 36
    SitUp,                               // 37
    SitUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSitUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSitUpExerciseName::AlternatingSitUp => write!(f, "{}", "AlternatingSitUp"),
            FitFieldSitUpExerciseName::WeightedAlternatingSitUp => {
                write!(f, "{}", "WeightedAlternatingSitUp")
            }
            FitFieldSitUpExerciseName::BentKneeVUp => write!(f, "{}", "BentKneeVUp"),
            FitFieldSitUpExerciseName::WeightedBentKneeVUp => {
                write!(f, "{}", "WeightedBentKneeVUp")
            }
            FitFieldSitUpExerciseName::ButterflySitUp => write!(f, "{}", "ButterflySitUp"),
            FitFieldSitUpExerciseName::WeightedButterflySitup => {
                write!(f, "{}", "WeightedButterflySitup")
            }
            FitFieldSitUpExerciseName::CrossPunchRollUp => write!(f, "{}", "CrossPunchRollUp"),
            FitFieldSitUpExerciseName::WeightedCrossPunchRollUp => {
                write!(f, "{}", "WeightedCrossPunchRollUp")
            }
            FitFieldSitUpExerciseName::CrossedArmsSitUp => write!(f, "{}", "CrossedArmsSitUp"),
            FitFieldSitUpExerciseName::WeightedCrossedArmsSitUp => {
                write!(f, "{}", "WeightedCrossedArmsSitUp")
            }
            FitFieldSitUpExerciseName::GetUpSitUp => write!(f, "{}", "GetUpSitUp"),
            FitFieldSitUpExerciseName::WeightedGetUpSitUp => write!(f, "{}", "WeightedGetUpSitUp"),
            FitFieldSitUpExerciseName::HoveringSitUp => write!(f, "{}", "HoveringSitUp"),
            FitFieldSitUpExerciseName::WeightedHoveringSitUp => {
                write!(f, "{}", "WeightedHoveringSitUp")
            }
            FitFieldSitUpExerciseName::KettlebellSitUp => write!(f, "{}", "KettlebellSitUp"),
            FitFieldSitUpExerciseName::MedicineBallAlternatingVUp => {
                write!(f, "{}", "MedicineBallAlternatingVUp")
            }
            FitFieldSitUpExerciseName::MedicineBallSitUp => write!(f, "{}", "MedicineBallSitUp"),
            FitFieldSitUpExerciseName::MedicineBallVUp => write!(f, "{}", "MedicineBallVUp"),
            FitFieldSitUpExerciseName::ModifiedSitUp => write!(f, "{}", "ModifiedSitUp"),
            FitFieldSitUpExerciseName::NegativeSitUp => write!(f, "{}", "NegativeSitUp"),
            FitFieldSitUpExerciseName::OneArmFullSitUp => write!(f, "{}", "OneArmFullSitUp"),
            FitFieldSitUpExerciseName::RecliningCircle => write!(f, "{}", "RecliningCircle"),
            FitFieldSitUpExerciseName::WeightedRecliningCircle => {
                write!(f, "{}", "WeightedRecliningCircle")
            }
            FitFieldSitUpExerciseName::ReverseCurlUp => write!(f, "{}", "ReverseCurlUp"),
            FitFieldSitUpExerciseName::WeightedReverseCurlUp => {
                write!(f, "{}", "WeightedReverseCurlUp")
            }
            FitFieldSitUpExerciseName::SingleLegSwissBallJackknife => {
                write!(f, "{}", "SingleLegSwissBallJackknife")
            }
            FitFieldSitUpExerciseName::WeightedSingleLegSwissBallJackknife => {
                write!(f, "{}", "WeightedSingleLegSwissBallJackknife")
            }
            FitFieldSitUpExerciseName::TheTeaser => write!(f, "{}", "TheTeaser"),
            FitFieldSitUpExerciseName::TheTeaserWeighted => write!(f, "{}", "TheTeaserWeighted"),
            FitFieldSitUpExerciseName::ThreePartRollDown => write!(f, "{}", "ThreePartRollDown"),
            FitFieldSitUpExerciseName::WeightedThreePartRollDown => {
                write!(f, "{}", "WeightedThreePartRollDown")
            }
            FitFieldSitUpExerciseName::VUp => write!(f, "{}", "VUp"),
            FitFieldSitUpExerciseName::WeightedVUp => write!(f, "{}", "WeightedVUp"),
            FitFieldSitUpExerciseName::WeightedRussianTwistOnSwissBall => {
                write!(f, "{}", "WeightedRussianTwistOnSwissBall")
            }
            FitFieldSitUpExerciseName::WeightedSitUp => write!(f, "{}", "WeightedSitUp"),
            FitFieldSitUpExerciseName::XAbs => write!(f, "{}", "XAbs"),
            FitFieldSitUpExerciseName::WeightedXAbs => write!(f, "{}", "WeightedXAbs"),
            FitFieldSitUpExerciseName::SitUp => write!(f, "{}", "SitUp"),
            FitFieldSitUpExerciseName::SitUpExerciseName(x) => {
                write!(f, "{}({})", "SitUpExerciseName", x)
            }
            FitFieldSitUpExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSitUpExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSitUpExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSitUpExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSitUpExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldSitUpExerciseName::from(v)),
                1 => Ok(FitFieldSitUpExerciseName::from(v)),
                2 => Ok(FitFieldSitUpExerciseName::from(v)),
                3 => Ok(FitFieldSitUpExerciseName::from(v)),
                4 => Ok(FitFieldSitUpExerciseName::from(v)),
                5 => Ok(FitFieldSitUpExerciseName::from(v)),
                6 => Ok(FitFieldSitUpExerciseName::from(v)),
                7 => Ok(FitFieldSitUpExerciseName::from(v)),
                8 => Ok(FitFieldSitUpExerciseName::from(v)),
                9 => Ok(FitFieldSitUpExerciseName::from(v)),
                10 => Ok(FitFieldSitUpExerciseName::from(v)),
                11 => Ok(FitFieldSitUpExerciseName::from(v)),
                12 => Ok(FitFieldSitUpExerciseName::from(v)),
                13 => Ok(FitFieldSitUpExerciseName::from(v)),
                14 => Ok(FitFieldSitUpExerciseName::from(v)),
                15 => Ok(FitFieldSitUpExerciseName::from(v)),
                16 => Ok(FitFieldSitUpExerciseName::from(v)),
                17 => Ok(FitFieldSitUpExerciseName::from(v)),
                18 => Ok(FitFieldSitUpExerciseName::from(v)),
                19 => Ok(FitFieldSitUpExerciseName::from(v)),
                20 => Ok(FitFieldSitUpExerciseName::from(v)),
                21 => Ok(FitFieldSitUpExerciseName::from(v)),
                22 => Ok(FitFieldSitUpExerciseName::from(v)),
                23 => Ok(FitFieldSitUpExerciseName::from(v)),
                24 => Ok(FitFieldSitUpExerciseName::from(v)),
                25 => Ok(FitFieldSitUpExerciseName::from(v)),
                26 => Ok(FitFieldSitUpExerciseName::from(v)),
                27 => Ok(FitFieldSitUpExerciseName::from(v)),
                28 => Ok(FitFieldSitUpExerciseName::from(v)),
                29 => Ok(FitFieldSitUpExerciseName::from(v)),
                30 => Ok(FitFieldSitUpExerciseName::from(v)),
                31 => Ok(FitFieldSitUpExerciseName::from(v)),
                32 => Ok(FitFieldSitUpExerciseName::from(v)),
                33 => Ok(FitFieldSitUpExerciseName::from(v)),
                34 => Ok(FitFieldSitUpExerciseName::from(v)),
                35 => Ok(FitFieldSitUpExerciseName::from(v)),
                36 => Ok(FitFieldSitUpExerciseName::from(v)),
                37 => Ok(FitFieldSitUpExerciseName::from(v)),
                v => Ok(FitFieldSitUpExerciseName::SitUpExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSitUpExerciseName);

impl From<u16> for FitFieldSitUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldSitUpExerciseName::AlternatingSitUp,
            1 => FitFieldSitUpExerciseName::WeightedAlternatingSitUp,
            2 => FitFieldSitUpExerciseName::BentKneeVUp,
            3 => FitFieldSitUpExerciseName::WeightedBentKneeVUp,
            4 => FitFieldSitUpExerciseName::ButterflySitUp,
            5 => FitFieldSitUpExerciseName::WeightedButterflySitup,
            6 => FitFieldSitUpExerciseName::CrossPunchRollUp,
            7 => FitFieldSitUpExerciseName::WeightedCrossPunchRollUp,
            8 => FitFieldSitUpExerciseName::CrossedArmsSitUp,
            9 => FitFieldSitUpExerciseName::WeightedCrossedArmsSitUp,
            10 => FitFieldSitUpExerciseName::GetUpSitUp,
            11 => FitFieldSitUpExerciseName::WeightedGetUpSitUp,
            12 => FitFieldSitUpExerciseName::HoveringSitUp,
            13 => FitFieldSitUpExerciseName::WeightedHoveringSitUp,
            14 => FitFieldSitUpExerciseName::KettlebellSitUp,
            15 => FitFieldSitUpExerciseName::MedicineBallAlternatingVUp,
            16 => FitFieldSitUpExerciseName::MedicineBallSitUp,
            17 => FitFieldSitUpExerciseName::MedicineBallVUp,
            18 => FitFieldSitUpExerciseName::ModifiedSitUp,
            19 => FitFieldSitUpExerciseName::NegativeSitUp,
            20 => FitFieldSitUpExerciseName::OneArmFullSitUp,
            21 => FitFieldSitUpExerciseName::RecliningCircle,
            22 => FitFieldSitUpExerciseName::WeightedRecliningCircle,
            23 => FitFieldSitUpExerciseName::ReverseCurlUp,
            24 => FitFieldSitUpExerciseName::WeightedReverseCurlUp,
            25 => FitFieldSitUpExerciseName::SingleLegSwissBallJackknife,
            26 => FitFieldSitUpExerciseName::WeightedSingleLegSwissBallJackknife,
            27 => FitFieldSitUpExerciseName::TheTeaser,
            28 => FitFieldSitUpExerciseName::TheTeaserWeighted,
            29 => FitFieldSitUpExerciseName::ThreePartRollDown,
            30 => FitFieldSitUpExerciseName::WeightedThreePartRollDown,
            31 => FitFieldSitUpExerciseName::VUp,
            32 => FitFieldSitUpExerciseName::WeightedVUp,
            33 => FitFieldSitUpExerciseName::WeightedRussianTwistOnSwissBall,
            34 => FitFieldSitUpExerciseName::WeightedSitUp,
            35 => FitFieldSitUpExerciseName::XAbs,
            36 => FitFieldSitUpExerciseName::WeightedXAbs,
            37 => FitFieldSitUpExerciseName::SitUp,
            _ => FitFieldSitUpExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldSquatExerciseName {
    // fit base type: uint16
    LegPress,                                        // 0
    BackSquatWithBodyBar,                            // 1
    BackSquats,                                      // 2
    WeightedBackSquats,                              // 3
    BalancingSquat,                                  // 4
    WeightedBalancingSquat,                          // 5
    BarbellBackSquat,                                // 6
    BarbellBoxSquat,                                 // 7
    BarbellFrontSquat,                               // 8
    BarbellHackSquat,                                // 9
    BarbellHangSquatSnatch,                          // 10
    BarbellLateralStepUp,                            // 11
    BarbellQuarterSquat,                             // 12
    BarbellSiffSquat,                                // 13
    BarbellSquatSnatch,                              // 14
    BarbellSquatWithHeelsRaised,                     // 15
    BarbellStepover,                                 // 16
    BarbellStepUp,                                   // 17
    BenchSquatWithRotationalChop,                    // 18
    WeightedBenchSquatWithRotationalChop,            // 19
    BodyWeightWallSquat,                             // 20
    WeightedWallSquat,                               // 21
    BoxStepSquat,                                    // 22
    WeightedBoxStepSquat,                            // 23
    BracedSquat,                                     // 24
    CrossedArmBarbellFrontSquat,                     // 25
    CrossoverDumbbellStepUp,                         // 26
    DumbbellFrontSquat,                              // 27
    DumbbellSplitSquat,                              // 28
    DumbbellSquat,                                   // 29
    DumbbellSquatClean,                              // 30
    DumbbellStepover,                                // 31
    DumbbellStepUp,                                  // 32
    ElevatedSingleLegSquat,                          // 33
    WeightedElevatedSingleLegSquat,                  // 34
    FigureFourSquats,                                // 35
    WeightedFigureFourSquats,                        // 36
    GobletSquat,                                     // 37
    KettlebellSquat,                                 // 38
    KettlebellSwingOverhead,                         // 39
    KettlebellSwingWithFlipToSquat,                  // 40
    LateralDumbbellStepUp,                           // 41
    OneLeggedSquat,                                  // 42
    OverheadDumbbellSquat,                           // 43
    OverheadSquat,                                   // 44
    PartialSingleLegSquat,                           // 45
    WeightedPartialSingleLegSquat,                   // 46
    PistolSquat,                                     // 47
    WeightedPistolSquat,                             // 48
    PlieSlides,                                      // 49
    WeightedPlieSlides,                              // 50
    PlieSquat,                                       // 51
    WeightedPlieSquat,                               // 52
    PrisonerSquat,                                   // 53
    WeightedPrisonerSquat,                           // 54
    SingleLegBenchGetUp,                             // 55
    WeightedSingleLegBenchGetUp,                     // 56
    SingleLegBenchSquat,                             // 57
    WeightedSingleLegBenchSquat,                     // 58
    SingleLegSquatOnSwissBall,                       // 59
    WeightedSingleLegSquatOnSwissBall,               // 60
    Squat,                                           // 61
    WeightedSquat,                                   // 62
    SquatsWithBand,                                  // 63
    StaggeredSquat,                                  // 64
    WeightedStaggeredSquat,                          // 65
    StepUp,                                          // 66
    WeightedStepUp,                                  // 67
    SuitcaseSquats,                                  // 68
    SumoSquat,                                       // 69
    SumoSquatSlideIn,                                // 70
    WeightedSumoSquatSlideIn,                        // 71
    SumoSquatToHighPull,                             // 72
    SumoSquatToStand,                                // 73
    WeightedSumoSquatToStand,                        // 74
    SumoSquatWithRotation,                           // 75
    WeightedSumoSquatWithRotation,                   // 76
    SwissBallBodyWeightWallSquat,                    // 77
    WeightedSwissBallWallSquat,                      // 78
    Thrusters,                                       // 79
    UnevenSquat,                                     // 80
    WeightedUnevenSquat,                             // 81
    WaistSlimmingSquat,                              // 82
    WallBall,                                        // 83
    WideStanceBarbellSquat,                          // 84
    WideStanceGobletSquat,                           // 85
    ZercherSquat,                                    // 86
    KbsOverhead,                                     // 87
    SquatAndSideKick,                                // 88
    SquatJumpsInNOut,                                // 89
    PilatesPlieSquatsParallelTurnedOutFlatAndHeels,  // 90
    ReleveStraightLegAndKneeBentWithOneLegVariation, // 91
    SquatExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldSquatExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldSquatExerciseName::LegPress => write!(f, "{}", "LegPress"),
            FitFieldSquatExerciseName::BackSquatWithBodyBar => {
                write!(f, "{}", "BackSquatWithBodyBar")
            }
            FitFieldSquatExerciseName::BackSquats => write!(f, "{}", "BackSquats"),
            FitFieldSquatExerciseName::WeightedBackSquats => write!(f, "{}", "WeightedBackSquats"),
            FitFieldSquatExerciseName::BalancingSquat => write!(f, "{}", "BalancingSquat"),
            FitFieldSquatExerciseName::WeightedBalancingSquat => {
                write!(f, "{}", "WeightedBalancingSquat")
            }
            FitFieldSquatExerciseName::BarbellBackSquat => write!(f, "{}", "BarbellBackSquat"),
            FitFieldSquatExerciseName::BarbellBoxSquat => write!(f, "{}", "BarbellBoxSquat"),
            FitFieldSquatExerciseName::BarbellFrontSquat => write!(f, "{}", "BarbellFrontSquat"),
            FitFieldSquatExerciseName::BarbellHackSquat => write!(f, "{}", "BarbellHackSquat"),
            FitFieldSquatExerciseName::BarbellHangSquatSnatch => {
                write!(f, "{}", "BarbellHangSquatSnatch")
            }
            FitFieldSquatExerciseName::BarbellLateralStepUp => {
                write!(f, "{}", "BarbellLateralStepUp")
            }
            FitFieldSquatExerciseName::BarbellQuarterSquat => {
                write!(f, "{}", "BarbellQuarterSquat")
            }
            FitFieldSquatExerciseName::BarbellSiffSquat => write!(f, "{}", "BarbellSiffSquat"),
            FitFieldSquatExerciseName::BarbellSquatSnatch => write!(f, "{}", "BarbellSquatSnatch"),
            FitFieldSquatExerciseName::BarbellSquatWithHeelsRaised => {
                write!(f, "{}", "BarbellSquatWithHeelsRaised")
            }
            FitFieldSquatExerciseName::BarbellStepover => write!(f, "{}", "BarbellStepover"),
            FitFieldSquatExerciseName::BarbellStepUp => write!(f, "{}", "BarbellStepUp"),
            FitFieldSquatExerciseName::BenchSquatWithRotationalChop => {
                write!(f, "{}", "BenchSquatWithRotationalChop")
            }
            FitFieldSquatExerciseName::WeightedBenchSquatWithRotationalChop => {
                write!(f, "{}", "WeightedBenchSquatWithRotationalChop")
            }
            FitFieldSquatExerciseName::BodyWeightWallSquat => {
                write!(f, "{}", "BodyWeightWallSquat")
            }
            FitFieldSquatExerciseName::WeightedWallSquat => write!(f, "{}", "WeightedWallSquat"),
            FitFieldSquatExerciseName::BoxStepSquat => write!(f, "{}", "BoxStepSquat"),
            FitFieldSquatExerciseName::WeightedBoxStepSquat => {
                write!(f, "{}", "WeightedBoxStepSquat")
            }
            FitFieldSquatExerciseName::BracedSquat => write!(f, "{}", "BracedSquat"),
            FitFieldSquatExerciseName::CrossedArmBarbellFrontSquat => {
                write!(f, "{}", "CrossedArmBarbellFrontSquat")
            }
            FitFieldSquatExerciseName::CrossoverDumbbellStepUp => {
                write!(f, "{}", "CrossoverDumbbellStepUp")
            }
            FitFieldSquatExerciseName::DumbbellFrontSquat => write!(f, "{}", "DumbbellFrontSquat"),
            FitFieldSquatExerciseName::DumbbellSplitSquat => write!(f, "{}", "DumbbellSplitSquat"),
            FitFieldSquatExerciseName::DumbbellSquat => write!(f, "{}", "DumbbellSquat"),
            FitFieldSquatExerciseName::DumbbellSquatClean => write!(f, "{}", "DumbbellSquatClean"),
            FitFieldSquatExerciseName::DumbbellStepover => write!(f, "{}", "DumbbellStepover"),
            FitFieldSquatExerciseName::DumbbellStepUp => write!(f, "{}", "DumbbellStepUp"),
            FitFieldSquatExerciseName::ElevatedSingleLegSquat => {
                write!(f, "{}", "ElevatedSingleLegSquat")
            }
            FitFieldSquatExerciseName::WeightedElevatedSingleLegSquat => {
                write!(f, "{}", "WeightedElevatedSingleLegSquat")
            }
            FitFieldSquatExerciseName::FigureFourSquats => write!(f, "{}", "FigureFourSquats"),
            FitFieldSquatExerciseName::WeightedFigureFourSquats => {
                write!(f, "{}", "WeightedFigureFourSquats")
            }
            FitFieldSquatExerciseName::GobletSquat => write!(f, "{}", "GobletSquat"),
            FitFieldSquatExerciseName::KettlebellSquat => write!(f, "{}", "KettlebellSquat"),
            FitFieldSquatExerciseName::KettlebellSwingOverhead => {
                write!(f, "{}", "KettlebellSwingOverhead")
            }
            FitFieldSquatExerciseName::KettlebellSwingWithFlipToSquat => {
                write!(f, "{}", "KettlebellSwingWithFlipToSquat")
            }
            FitFieldSquatExerciseName::LateralDumbbellStepUp => {
                write!(f, "{}", "LateralDumbbellStepUp")
            }
            FitFieldSquatExerciseName::OneLeggedSquat => write!(f, "{}", "OneLeggedSquat"),
            FitFieldSquatExerciseName::OverheadDumbbellSquat => {
                write!(f, "{}", "OverheadDumbbellSquat")
            }
            FitFieldSquatExerciseName::OverheadSquat => write!(f, "{}", "OverheadSquat"),
            FitFieldSquatExerciseName::PartialSingleLegSquat => {
                write!(f, "{}", "PartialSingleLegSquat")
            }
            FitFieldSquatExerciseName::WeightedPartialSingleLegSquat => {
                write!(f, "{}", "WeightedPartialSingleLegSquat")
            }
            FitFieldSquatExerciseName::PistolSquat => write!(f, "{}", "PistolSquat"),
            FitFieldSquatExerciseName::WeightedPistolSquat => {
                write!(f, "{}", "WeightedPistolSquat")
            }
            FitFieldSquatExerciseName::PlieSlides => write!(f, "{}", "PlieSlides"),
            FitFieldSquatExerciseName::WeightedPlieSlides => write!(f, "{}", "WeightedPlieSlides"),
            FitFieldSquatExerciseName::PlieSquat => write!(f, "{}", "PlieSquat"),
            FitFieldSquatExerciseName::WeightedPlieSquat => write!(f, "{}", "WeightedPlieSquat"),
            FitFieldSquatExerciseName::PrisonerSquat => write!(f, "{}", "PrisonerSquat"),
            FitFieldSquatExerciseName::WeightedPrisonerSquat => {
                write!(f, "{}", "WeightedPrisonerSquat")
            }
            FitFieldSquatExerciseName::SingleLegBenchGetUp => {
                write!(f, "{}", "SingleLegBenchGetUp")
            }
            FitFieldSquatExerciseName::WeightedSingleLegBenchGetUp => {
                write!(f, "{}", "WeightedSingleLegBenchGetUp")
            }
            FitFieldSquatExerciseName::SingleLegBenchSquat => {
                write!(f, "{}", "SingleLegBenchSquat")
            }
            FitFieldSquatExerciseName::WeightedSingleLegBenchSquat => {
                write!(f, "{}", "WeightedSingleLegBenchSquat")
            }
            FitFieldSquatExerciseName::SingleLegSquatOnSwissBall => {
                write!(f, "{}", "SingleLegSquatOnSwissBall")
            }
            FitFieldSquatExerciseName::WeightedSingleLegSquatOnSwissBall => {
                write!(f, "{}", "WeightedSingleLegSquatOnSwissBall")
            }
            FitFieldSquatExerciseName::Squat => write!(f, "{}", "Squat"),
            FitFieldSquatExerciseName::WeightedSquat => write!(f, "{}", "WeightedSquat"),
            FitFieldSquatExerciseName::SquatsWithBand => write!(f, "{}", "SquatsWithBand"),
            FitFieldSquatExerciseName::StaggeredSquat => write!(f, "{}", "StaggeredSquat"),
            FitFieldSquatExerciseName::WeightedStaggeredSquat => {
                write!(f, "{}", "WeightedStaggeredSquat")
            }
            FitFieldSquatExerciseName::StepUp => write!(f, "{}", "StepUp"),
            FitFieldSquatExerciseName::WeightedStepUp => write!(f, "{}", "WeightedStepUp"),
            FitFieldSquatExerciseName::SuitcaseSquats => write!(f, "{}", "SuitcaseSquats"),
            FitFieldSquatExerciseName::SumoSquat => write!(f, "{}", "SumoSquat"),
            FitFieldSquatExerciseName::SumoSquatSlideIn => write!(f, "{}", "SumoSquatSlideIn"),
            FitFieldSquatExerciseName::WeightedSumoSquatSlideIn => {
                write!(f, "{}", "WeightedSumoSquatSlideIn")
            }
            FitFieldSquatExerciseName::SumoSquatToHighPull => {
                write!(f, "{}", "SumoSquatToHighPull")
            }
            FitFieldSquatExerciseName::SumoSquatToStand => write!(f, "{}", "SumoSquatToStand"),
            FitFieldSquatExerciseName::WeightedSumoSquatToStand => {
                write!(f, "{}", "WeightedSumoSquatToStand")
            }
            FitFieldSquatExerciseName::SumoSquatWithRotation => {
                write!(f, "{}", "SumoSquatWithRotation")
            }
            FitFieldSquatExerciseName::WeightedSumoSquatWithRotation => {
                write!(f, "{}", "WeightedSumoSquatWithRotation")
            }
            FitFieldSquatExerciseName::SwissBallBodyWeightWallSquat => {
                write!(f, "{}", "SwissBallBodyWeightWallSquat")
            }
            FitFieldSquatExerciseName::WeightedSwissBallWallSquat => {
                write!(f, "{}", "WeightedSwissBallWallSquat")
            }
            FitFieldSquatExerciseName::Thrusters => write!(f, "{}", "Thrusters"),
            FitFieldSquatExerciseName::UnevenSquat => write!(f, "{}", "UnevenSquat"),
            FitFieldSquatExerciseName::WeightedUnevenSquat => {
                write!(f, "{}", "WeightedUnevenSquat")
            }
            FitFieldSquatExerciseName::WaistSlimmingSquat => write!(f, "{}", "WaistSlimmingSquat"),
            FitFieldSquatExerciseName::WallBall => write!(f, "{}", "WallBall"),
            FitFieldSquatExerciseName::WideStanceBarbellSquat => {
                write!(f, "{}", "WideStanceBarbellSquat")
            }
            FitFieldSquatExerciseName::WideStanceGobletSquat => {
                write!(f, "{}", "WideStanceGobletSquat")
            }
            FitFieldSquatExerciseName::ZercherSquat => write!(f, "{}", "ZercherSquat"),
            FitFieldSquatExerciseName::KbsOverhead => write!(f, "{}", "KbsOverhead"),
            FitFieldSquatExerciseName::SquatAndSideKick => write!(f, "{}", "SquatAndSideKick"),
            FitFieldSquatExerciseName::SquatJumpsInNOut => write!(f, "{}", "SquatJumpsInNOut"),
            FitFieldSquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels => {
                write!(f, "{}", "PilatesPlieSquatsParallelTurnedOutFlatAndHeels")
            }
            FitFieldSquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation => {
                write!(f, "{}", "ReleveStraightLegAndKneeBentWithOneLegVariation")
            }
            FitFieldSquatExerciseName::SquatExerciseName(x) => {
                write!(f, "{}({})", "SquatExerciseName", x)
            }
            FitFieldSquatExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldSquatExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldSquatExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldSquatExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldSquatExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldSquatExerciseName::from(v)),
                1 => Ok(FitFieldSquatExerciseName::from(v)),
                2 => Ok(FitFieldSquatExerciseName::from(v)),
                3 => Ok(FitFieldSquatExerciseName::from(v)),
                4 => Ok(FitFieldSquatExerciseName::from(v)),
                5 => Ok(FitFieldSquatExerciseName::from(v)),
                6 => Ok(FitFieldSquatExerciseName::from(v)),
                7 => Ok(FitFieldSquatExerciseName::from(v)),
                8 => Ok(FitFieldSquatExerciseName::from(v)),
                9 => Ok(FitFieldSquatExerciseName::from(v)),
                10 => Ok(FitFieldSquatExerciseName::from(v)),
                11 => Ok(FitFieldSquatExerciseName::from(v)),
                12 => Ok(FitFieldSquatExerciseName::from(v)),
                13 => Ok(FitFieldSquatExerciseName::from(v)),
                14 => Ok(FitFieldSquatExerciseName::from(v)),
                15 => Ok(FitFieldSquatExerciseName::from(v)),
                16 => Ok(FitFieldSquatExerciseName::from(v)),
                17 => Ok(FitFieldSquatExerciseName::from(v)),
                18 => Ok(FitFieldSquatExerciseName::from(v)),
                19 => Ok(FitFieldSquatExerciseName::from(v)),
                20 => Ok(FitFieldSquatExerciseName::from(v)),
                21 => Ok(FitFieldSquatExerciseName::from(v)),
                22 => Ok(FitFieldSquatExerciseName::from(v)),
                23 => Ok(FitFieldSquatExerciseName::from(v)),
                24 => Ok(FitFieldSquatExerciseName::from(v)),
                25 => Ok(FitFieldSquatExerciseName::from(v)),
                26 => Ok(FitFieldSquatExerciseName::from(v)),
                27 => Ok(FitFieldSquatExerciseName::from(v)),
                28 => Ok(FitFieldSquatExerciseName::from(v)),
                29 => Ok(FitFieldSquatExerciseName::from(v)),
                30 => Ok(FitFieldSquatExerciseName::from(v)),
                31 => Ok(FitFieldSquatExerciseName::from(v)),
                32 => Ok(FitFieldSquatExerciseName::from(v)),
                33 => Ok(FitFieldSquatExerciseName::from(v)),
                34 => Ok(FitFieldSquatExerciseName::from(v)),
                35 => Ok(FitFieldSquatExerciseName::from(v)),
                36 => Ok(FitFieldSquatExerciseName::from(v)),
                37 => Ok(FitFieldSquatExerciseName::from(v)),
                38 => Ok(FitFieldSquatExerciseName::from(v)),
                39 => Ok(FitFieldSquatExerciseName::from(v)),
                40 => Ok(FitFieldSquatExerciseName::from(v)),
                41 => Ok(FitFieldSquatExerciseName::from(v)),
                42 => Ok(FitFieldSquatExerciseName::from(v)),
                43 => Ok(FitFieldSquatExerciseName::from(v)),
                44 => Ok(FitFieldSquatExerciseName::from(v)),
                45 => Ok(FitFieldSquatExerciseName::from(v)),
                46 => Ok(FitFieldSquatExerciseName::from(v)),
                47 => Ok(FitFieldSquatExerciseName::from(v)),
                48 => Ok(FitFieldSquatExerciseName::from(v)),
                49 => Ok(FitFieldSquatExerciseName::from(v)),
                50 => Ok(FitFieldSquatExerciseName::from(v)),
                51 => Ok(FitFieldSquatExerciseName::from(v)),
                52 => Ok(FitFieldSquatExerciseName::from(v)),
                53 => Ok(FitFieldSquatExerciseName::from(v)),
                54 => Ok(FitFieldSquatExerciseName::from(v)),
                55 => Ok(FitFieldSquatExerciseName::from(v)),
                56 => Ok(FitFieldSquatExerciseName::from(v)),
                57 => Ok(FitFieldSquatExerciseName::from(v)),
                58 => Ok(FitFieldSquatExerciseName::from(v)),
                59 => Ok(FitFieldSquatExerciseName::from(v)),
                60 => Ok(FitFieldSquatExerciseName::from(v)),
                61 => Ok(FitFieldSquatExerciseName::from(v)),
                62 => Ok(FitFieldSquatExerciseName::from(v)),
                63 => Ok(FitFieldSquatExerciseName::from(v)),
                64 => Ok(FitFieldSquatExerciseName::from(v)),
                65 => Ok(FitFieldSquatExerciseName::from(v)),
                66 => Ok(FitFieldSquatExerciseName::from(v)),
                67 => Ok(FitFieldSquatExerciseName::from(v)),
                68 => Ok(FitFieldSquatExerciseName::from(v)),
                69 => Ok(FitFieldSquatExerciseName::from(v)),
                70 => Ok(FitFieldSquatExerciseName::from(v)),
                71 => Ok(FitFieldSquatExerciseName::from(v)),
                72 => Ok(FitFieldSquatExerciseName::from(v)),
                73 => Ok(FitFieldSquatExerciseName::from(v)),
                74 => Ok(FitFieldSquatExerciseName::from(v)),
                75 => Ok(FitFieldSquatExerciseName::from(v)),
                76 => Ok(FitFieldSquatExerciseName::from(v)),
                77 => Ok(FitFieldSquatExerciseName::from(v)),
                78 => Ok(FitFieldSquatExerciseName::from(v)),
                79 => Ok(FitFieldSquatExerciseName::from(v)),
                80 => Ok(FitFieldSquatExerciseName::from(v)),
                81 => Ok(FitFieldSquatExerciseName::from(v)),
                82 => Ok(FitFieldSquatExerciseName::from(v)),
                83 => Ok(FitFieldSquatExerciseName::from(v)),
                84 => Ok(FitFieldSquatExerciseName::from(v)),
                85 => Ok(FitFieldSquatExerciseName::from(v)),
                86 => Ok(FitFieldSquatExerciseName::from(v)),
                87 => Ok(FitFieldSquatExerciseName::from(v)),
                88 => Ok(FitFieldSquatExerciseName::from(v)),
                89 => Ok(FitFieldSquatExerciseName::from(v)),
                90 => Ok(FitFieldSquatExerciseName::from(v)),
                91 => Ok(FitFieldSquatExerciseName::from(v)),
                v => Ok(FitFieldSquatExerciseName::SquatExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldSquatExerciseName);

impl From<u16> for FitFieldSquatExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldSquatExerciseName::LegPress,
            1 => FitFieldSquatExerciseName::BackSquatWithBodyBar,
            2 => FitFieldSquatExerciseName::BackSquats,
            3 => FitFieldSquatExerciseName::WeightedBackSquats,
            4 => FitFieldSquatExerciseName::BalancingSquat,
            5 => FitFieldSquatExerciseName::WeightedBalancingSquat,
            6 => FitFieldSquatExerciseName::BarbellBackSquat,
            7 => FitFieldSquatExerciseName::BarbellBoxSquat,
            8 => FitFieldSquatExerciseName::BarbellFrontSquat,
            9 => FitFieldSquatExerciseName::BarbellHackSquat,
            10 => FitFieldSquatExerciseName::BarbellHangSquatSnatch,
            11 => FitFieldSquatExerciseName::BarbellLateralStepUp,
            12 => FitFieldSquatExerciseName::BarbellQuarterSquat,
            13 => FitFieldSquatExerciseName::BarbellSiffSquat,
            14 => FitFieldSquatExerciseName::BarbellSquatSnatch,
            15 => FitFieldSquatExerciseName::BarbellSquatWithHeelsRaised,
            16 => FitFieldSquatExerciseName::BarbellStepover,
            17 => FitFieldSquatExerciseName::BarbellStepUp,
            18 => FitFieldSquatExerciseName::BenchSquatWithRotationalChop,
            19 => FitFieldSquatExerciseName::WeightedBenchSquatWithRotationalChop,
            20 => FitFieldSquatExerciseName::BodyWeightWallSquat,
            21 => FitFieldSquatExerciseName::WeightedWallSquat,
            22 => FitFieldSquatExerciseName::BoxStepSquat,
            23 => FitFieldSquatExerciseName::WeightedBoxStepSquat,
            24 => FitFieldSquatExerciseName::BracedSquat,
            25 => FitFieldSquatExerciseName::CrossedArmBarbellFrontSquat,
            26 => FitFieldSquatExerciseName::CrossoverDumbbellStepUp,
            27 => FitFieldSquatExerciseName::DumbbellFrontSquat,
            28 => FitFieldSquatExerciseName::DumbbellSplitSquat,
            29 => FitFieldSquatExerciseName::DumbbellSquat,
            30 => FitFieldSquatExerciseName::DumbbellSquatClean,
            31 => FitFieldSquatExerciseName::DumbbellStepover,
            32 => FitFieldSquatExerciseName::DumbbellStepUp,
            33 => FitFieldSquatExerciseName::ElevatedSingleLegSquat,
            34 => FitFieldSquatExerciseName::WeightedElevatedSingleLegSquat,
            35 => FitFieldSquatExerciseName::FigureFourSquats,
            36 => FitFieldSquatExerciseName::WeightedFigureFourSquats,
            37 => FitFieldSquatExerciseName::GobletSquat,
            38 => FitFieldSquatExerciseName::KettlebellSquat,
            39 => FitFieldSquatExerciseName::KettlebellSwingOverhead,
            40 => FitFieldSquatExerciseName::KettlebellSwingWithFlipToSquat,
            41 => FitFieldSquatExerciseName::LateralDumbbellStepUp,
            42 => FitFieldSquatExerciseName::OneLeggedSquat,
            43 => FitFieldSquatExerciseName::OverheadDumbbellSquat,
            44 => FitFieldSquatExerciseName::OverheadSquat,
            45 => FitFieldSquatExerciseName::PartialSingleLegSquat,
            46 => FitFieldSquatExerciseName::WeightedPartialSingleLegSquat,
            47 => FitFieldSquatExerciseName::PistolSquat,
            48 => FitFieldSquatExerciseName::WeightedPistolSquat,
            49 => FitFieldSquatExerciseName::PlieSlides,
            50 => FitFieldSquatExerciseName::WeightedPlieSlides,
            51 => FitFieldSquatExerciseName::PlieSquat,
            52 => FitFieldSquatExerciseName::WeightedPlieSquat,
            53 => FitFieldSquatExerciseName::PrisonerSquat,
            54 => FitFieldSquatExerciseName::WeightedPrisonerSquat,
            55 => FitFieldSquatExerciseName::SingleLegBenchGetUp,
            56 => FitFieldSquatExerciseName::WeightedSingleLegBenchGetUp,
            57 => FitFieldSquatExerciseName::SingleLegBenchSquat,
            58 => FitFieldSquatExerciseName::WeightedSingleLegBenchSquat,
            59 => FitFieldSquatExerciseName::SingleLegSquatOnSwissBall,
            60 => FitFieldSquatExerciseName::WeightedSingleLegSquatOnSwissBall,
            61 => FitFieldSquatExerciseName::Squat,
            62 => FitFieldSquatExerciseName::WeightedSquat,
            63 => FitFieldSquatExerciseName::SquatsWithBand,
            64 => FitFieldSquatExerciseName::StaggeredSquat,
            65 => FitFieldSquatExerciseName::WeightedStaggeredSquat,
            66 => FitFieldSquatExerciseName::StepUp,
            67 => FitFieldSquatExerciseName::WeightedStepUp,
            68 => FitFieldSquatExerciseName::SuitcaseSquats,
            69 => FitFieldSquatExerciseName::SumoSquat,
            70 => FitFieldSquatExerciseName::SumoSquatSlideIn,
            71 => FitFieldSquatExerciseName::WeightedSumoSquatSlideIn,
            72 => FitFieldSquatExerciseName::SumoSquatToHighPull,
            73 => FitFieldSquatExerciseName::SumoSquatToStand,
            74 => FitFieldSquatExerciseName::WeightedSumoSquatToStand,
            75 => FitFieldSquatExerciseName::SumoSquatWithRotation,
            76 => FitFieldSquatExerciseName::WeightedSumoSquatWithRotation,
            77 => FitFieldSquatExerciseName::SwissBallBodyWeightWallSquat,
            78 => FitFieldSquatExerciseName::WeightedSwissBallWallSquat,
            79 => FitFieldSquatExerciseName::Thrusters,
            80 => FitFieldSquatExerciseName::UnevenSquat,
            81 => FitFieldSquatExerciseName::WeightedUnevenSquat,
            82 => FitFieldSquatExerciseName::WaistSlimmingSquat,
            83 => FitFieldSquatExerciseName::WallBall,
            84 => FitFieldSquatExerciseName::WideStanceBarbellSquat,
            85 => FitFieldSquatExerciseName::WideStanceGobletSquat,
            86 => FitFieldSquatExerciseName::ZercherSquat,
            87 => FitFieldSquatExerciseName::KbsOverhead,
            88 => FitFieldSquatExerciseName::SquatAndSideKick,
            89 => FitFieldSquatExerciseName::SquatJumpsInNOut,
            90 => FitFieldSquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels,
            91 => FitFieldSquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation,
            _ => FitFieldSquatExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTotalBodyExerciseName {
    // fit base type: uint16
    Burpee,                           // 0
    WeightedBurpee,                   // 1
    BurpeeBoxJump,                    // 2
    WeightedBurpeeBoxJump,            // 3
    HighPullBurpee,                   // 4
    ManMakers,                        // 5
    OneArmBurpee,                     // 6
    SquatThrusts,                     // 7
    WeightedSquatThrusts,             // 8
    SquatPlankPushUp,                 // 9
    WeightedSquatPlankPushUp,         // 10
    StandingTRotationBalance,         // 11
    WeightedStandingTRotationBalance, // 12
    TotalBodyExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldTotalBodyExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTotalBodyExerciseName::Burpee => write!(f, "{}", "Burpee"),
            FitFieldTotalBodyExerciseName::WeightedBurpee => write!(f, "{}", "WeightedBurpee"),
            FitFieldTotalBodyExerciseName::BurpeeBoxJump => write!(f, "{}", "BurpeeBoxJump"),
            FitFieldTotalBodyExerciseName::WeightedBurpeeBoxJump => {
                write!(f, "{}", "WeightedBurpeeBoxJump")
            }
            FitFieldTotalBodyExerciseName::HighPullBurpee => write!(f, "{}", "HighPullBurpee"),
            FitFieldTotalBodyExerciseName::ManMakers => write!(f, "{}", "ManMakers"),
            FitFieldTotalBodyExerciseName::OneArmBurpee => write!(f, "{}", "OneArmBurpee"),
            FitFieldTotalBodyExerciseName::SquatThrusts => write!(f, "{}", "SquatThrusts"),
            FitFieldTotalBodyExerciseName::WeightedSquatThrusts => {
                write!(f, "{}", "WeightedSquatThrusts")
            }
            FitFieldTotalBodyExerciseName::SquatPlankPushUp => write!(f, "{}", "SquatPlankPushUp"),
            FitFieldTotalBodyExerciseName::WeightedSquatPlankPushUp => {
                write!(f, "{}", "WeightedSquatPlankPushUp")
            }
            FitFieldTotalBodyExerciseName::StandingTRotationBalance => {
                write!(f, "{}", "StandingTRotationBalance")
            }
            FitFieldTotalBodyExerciseName::WeightedStandingTRotationBalance => {
                write!(f, "{}", "WeightedStandingTRotationBalance")
            }
            FitFieldTotalBodyExerciseName::TotalBodyExerciseName(x) => {
                write!(f, "{}({})", "TotalBodyExerciseName", x)
            }
            FitFieldTotalBodyExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTotalBodyExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTotalBodyExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTotalBodyExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldTotalBodyExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                1 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                2 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                3 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                4 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                5 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                6 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                7 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                8 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                9 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                10 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                11 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                12 => Ok(FitFieldTotalBodyExerciseName::from(v)),
                v => Ok(FitFieldTotalBodyExerciseName::TotalBodyExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldTotalBodyExerciseName);

impl From<u16> for FitFieldTotalBodyExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldTotalBodyExerciseName::Burpee,
            1 => FitFieldTotalBodyExerciseName::WeightedBurpee,
            2 => FitFieldTotalBodyExerciseName::BurpeeBoxJump,
            3 => FitFieldTotalBodyExerciseName::WeightedBurpeeBoxJump,
            4 => FitFieldTotalBodyExerciseName::HighPullBurpee,
            5 => FitFieldTotalBodyExerciseName::ManMakers,
            6 => FitFieldTotalBodyExerciseName::OneArmBurpee,
            7 => FitFieldTotalBodyExerciseName::SquatThrusts,
            8 => FitFieldTotalBodyExerciseName::WeightedSquatThrusts,
            9 => FitFieldTotalBodyExerciseName::SquatPlankPushUp,
            10 => FitFieldTotalBodyExerciseName::WeightedSquatPlankPushUp,
            11 => FitFieldTotalBodyExerciseName::StandingTRotationBalance,
            12 => FitFieldTotalBodyExerciseName::WeightedStandingTRotationBalance,
            _ => FitFieldTotalBodyExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTricepsExtensionExerciseName {
    // fit base type: uint16
    BenchDip,                                     // 0
    WeightedBenchDip,                             // 1
    BodyWeightDip,                                // 2
    CableKickback,                                // 3
    CableLyingTricepsExtension,                   // 4
    CableOverheadTricepsExtension,                // 5
    DumbbellKickback,                             // 6
    DumbbellLyingTricepsExtension,                // 7
    EzBarOverheadTricepsExtension,                // 8
    InclineDip,                                   // 9
    WeightedInclineDip,                           // 10
    InclineEzBarLyingTricepsExtension,            // 11
    LyingDumbbellPulloverToExtension,             // 12
    LyingEzBarTricepsExtension,                   // 13
    LyingTricepsExtensionToCloseGripBenchPress,   // 14
    OverheadDumbbellTricepsExtension,             // 15
    RecliningTricepsPress,                        // 16
    ReverseGripPressdown,                         // 17
    ReverseGripTricepsPressdown,                  // 18
    RopePressdown,                                // 19
    SeatedBarbellOverheadTricepsExtension,        // 20
    SeatedDumbbellOverheadTricepsExtension,       // 21
    SeatedEzBarOverheadTricepsExtension,          // 22
    SeatedSingleArmOverheadDumbbellExtension,     // 23
    SingleArmDumbbellOverheadTricepsExtension,    // 24
    SingleDumbbellSeatedOverheadTricepsExtension, // 25
    SingleLegBenchDipAndKick,                     // 26
    WeightedSingleLegBenchDipAndKick,             // 27
    SingleLegDip,                                 // 28
    WeightedSingleLegDip,                         // 29
    StaticLyingTricepsExtension,                  // 30
    SuspendedDip,                                 // 31
    WeightedSuspendedDip,                         // 32
    SwissBallDumbbellLyingTricepsExtension,       // 33
    SwissBallEzBarLyingTricepsExtension,          // 34
    SwissBallEzBarOverheadTricepsExtension,       // 35
    TabletopDip,                                  // 36
    WeightedTabletopDip,                          // 37
    TricepsExtensionOnFloor,                      // 38
    TricepsPressdown,                             // 39
    WeightedDip,                                  // 40
    TricepsExtensionExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldTricepsExtensionExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTricepsExtensionExerciseName::BenchDip => write!(f, "{}", "BenchDip"),
            FitFieldTricepsExtensionExerciseName::WeightedBenchDip => {
                write!(f, "{}", "WeightedBenchDip")
            }
            FitFieldTricepsExtensionExerciseName::BodyWeightDip => write!(f, "{}", "BodyWeightDip"),
            FitFieldTricepsExtensionExerciseName::CableKickback => write!(f, "{}", "CableKickback"),
            FitFieldTricepsExtensionExerciseName::CableLyingTricepsExtension => {
                write!(f, "{}", "CableLyingTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::CableOverheadTricepsExtension => {
                write!(f, "{}", "CableOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::DumbbellKickback => {
                write!(f, "{}", "DumbbellKickback")
            }
            FitFieldTricepsExtensionExerciseName::DumbbellLyingTricepsExtension => {
                write!(f, "{}", "DumbbellLyingTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::EzBarOverheadTricepsExtension => {
                write!(f, "{}", "EzBarOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::InclineDip => write!(f, "{}", "InclineDip"),
            FitFieldTricepsExtensionExerciseName::WeightedInclineDip => {
                write!(f, "{}", "WeightedInclineDip")
            }
            FitFieldTricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension => {
                write!(f, "{}", "InclineEzBarLyingTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::LyingDumbbellPulloverToExtension => {
                write!(f, "{}", "LyingDumbbellPulloverToExtension")
            }
            FitFieldTricepsExtensionExerciseName::LyingEzBarTricepsExtension => {
                write!(f, "{}", "LyingEzBarTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress => {
                write!(f, "{}", "LyingTricepsExtensionToCloseGripBenchPress")
            }
            FitFieldTricepsExtensionExerciseName::OverheadDumbbellTricepsExtension => {
                write!(f, "{}", "OverheadDumbbellTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::RecliningTricepsPress => {
                write!(f, "{}", "RecliningTricepsPress")
            }
            FitFieldTricepsExtensionExerciseName::ReverseGripPressdown => {
                write!(f, "{}", "ReverseGripPressdown")
            }
            FitFieldTricepsExtensionExerciseName::ReverseGripTricepsPressdown => {
                write!(f, "{}", "ReverseGripTricepsPressdown")
            }
            FitFieldTricepsExtensionExerciseName::RopePressdown => write!(f, "{}", "RopePressdown"),
            FitFieldTricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension => {
                write!(f, "{}", "SeatedBarbellOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension => {
                write!(f, "{}", "SeatedDumbbellOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension => {
                write!(f, "{}", "SeatedEzBarOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension => {
                write!(f, "{}", "SeatedSingleArmOverheadDumbbellExtension")
            }
            FitFieldTricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension => {
                write!(f, "{}", "SingleArmDumbbellOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension => {
                write!(f, "{}", "SingleDumbbellSeatedOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SingleLegBenchDipAndKick => {
                write!(f, "{}", "SingleLegBenchDipAndKick")
            }
            FitFieldTricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick => {
                write!(f, "{}", "WeightedSingleLegBenchDipAndKick")
            }
            FitFieldTricepsExtensionExerciseName::SingleLegDip => write!(f, "{}", "SingleLegDip"),
            FitFieldTricepsExtensionExerciseName::WeightedSingleLegDip => {
                write!(f, "{}", "WeightedSingleLegDip")
            }
            FitFieldTricepsExtensionExerciseName::StaticLyingTricepsExtension => {
                write!(f, "{}", "StaticLyingTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SuspendedDip => write!(f, "{}", "SuspendedDip"),
            FitFieldTricepsExtensionExerciseName::WeightedSuspendedDip => {
                write!(f, "{}", "WeightedSuspendedDip")
            }
            FitFieldTricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension => {
                write!(f, "{}", "SwissBallDumbbellLyingTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension => {
                write!(f, "{}", "SwissBallEzBarLyingTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension => {
                write!(f, "{}", "SwissBallEzBarOverheadTricepsExtension")
            }
            FitFieldTricepsExtensionExerciseName::TabletopDip => write!(f, "{}", "TabletopDip"),
            FitFieldTricepsExtensionExerciseName::WeightedTabletopDip => {
                write!(f, "{}", "WeightedTabletopDip")
            }
            FitFieldTricepsExtensionExerciseName::TricepsExtensionOnFloor => {
                write!(f, "{}", "TricepsExtensionOnFloor")
            }
            FitFieldTricepsExtensionExerciseName::TricepsPressdown => {
                write!(f, "{}", "TricepsPressdown")
            }
            FitFieldTricepsExtensionExerciseName::WeightedDip => write!(f, "{}", "WeightedDip"),
            FitFieldTricepsExtensionExerciseName::TricepsExtensionExerciseName(x) => {
                write!(f, "{}({})", "TricepsExtensionExerciseName", x)
            }
            FitFieldTricepsExtensionExerciseName::InvalidFieldValue => {
                write!(f, "InvalidFieldValue")
            }
            FitFieldTricepsExtensionExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTricepsExtensionExerciseName {
    fn parse(
        input: &[u8],
        parse_config: &FitParseConfig,
    ) -> Result<FitFieldTricepsExtensionExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldTricepsExtensionExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                1 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                2 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                3 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                4 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                5 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                6 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                7 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                8 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                9 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                10 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                11 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                12 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                13 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                14 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                15 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                16 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                17 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                18 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                19 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                20 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                21 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                22 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                23 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                24 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                25 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                26 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                27 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                28 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                29 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                30 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                31 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                32 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                33 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                34 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                35 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                36 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                37 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                38 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                39 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                40 => Ok(FitFieldTricepsExtensionExerciseName::from(v)),
                v => Ok(FitFieldTricepsExtensionExerciseName::TricepsExtensionExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldTricepsExtensionExerciseName);

impl From<u16> for FitFieldTricepsExtensionExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldTricepsExtensionExerciseName::BenchDip,
            1 => FitFieldTricepsExtensionExerciseName::WeightedBenchDip,
            2 => FitFieldTricepsExtensionExerciseName::BodyWeightDip,
            3 => FitFieldTricepsExtensionExerciseName::CableKickback,
            4 => FitFieldTricepsExtensionExerciseName::CableLyingTricepsExtension,
            5 => FitFieldTricepsExtensionExerciseName::CableOverheadTricepsExtension,
            6 => FitFieldTricepsExtensionExerciseName::DumbbellKickback,
            7 => FitFieldTricepsExtensionExerciseName::DumbbellLyingTricepsExtension,
            8 => FitFieldTricepsExtensionExerciseName::EzBarOverheadTricepsExtension,
            9 => FitFieldTricepsExtensionExerciseName::InclineDip,
            10 => FitFieldTricepsExtensionExerciseName::WeightedInclineDip,
            11 => FitFieldTricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension,
            12 => FitFieldTricepsExtensionExerciseName::LyingDumbbellPulloverToExtension,
            13 => FitFieldTricepsExtensionExerciseName::LyingEzBarTricepsExtension,
            14 => FitFieldTricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress,
            15 => FitFieldTricepsExtensionExerciseName::OverheadDumbbellTricepsExtension,
            16 => FitFieldTricepsExtensionExerciseName::RecliningTricepsPress,
            17 => FitFieldTricepsExtensionExerciseName::ReverseGripPressdown,
            18 => FitFieldTricepsExtensionExerciseName::ReverseGripTricepsPressdown,
            19 => FitFieldTricepsExtensionExerciseName::RopePressdown,
            20 => FitFieldTricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension,
            21 => FitFieldTricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension,
            22 => FitFieldTricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension,
            23 => FitFieldTricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension,
            24 => FitFieldTricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension,
            25 => {
                FitFieldTricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension
            }
            26 => FitFieldTricepsExtensionExerciseName::SingleLegBenchDipAndKick,
            27 => FitFieldTricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick,
            28 => FitFieldTricepsExtensionExerciseName::SingleLegDip,
            29 => FitFieldTricepsExtensionExerciseName::WeightedSingleLegDip,
            30 => FitFieldTricepsExtensionExerciseName::StaticLyingTricepsExtension,
            31 => FitFieldTricepsExtensionExerciseName::SuspendedDip,
            32 => FitFieldTricepsExtensionExerciseName::WeightedSuspendedDip,
            33 => FitFieldTricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension,
            34 => FitFieldTricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension,
            35 => FitFieldTricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension,
            36 => FitFieldTricepsExtensionExerciseName::TabletopDip,
            37 => FitFieldTricepsExtensionExerciseName::WeightedTabletopDip,
            38 => FitFieldTricepsExtensionExerciseName::TricepsExtensionOnFloor,
            39 => FitFieldTricepsExtensionExerciseName::TricepsPressdown,
            40 => FitFieldTricepsExtensionExerciseName::WeightedDip,
            _ => FitFieldTricepsExtensionExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWarmUpExerciseName {
    // fit base type: uint16
    QuadrupedRocking,            // 0
    NeckTilts,                   // 1
    AnkleCircles,                // 2
    AnkleDorsiflexionWithBand,   // 3
    AnkleInternalRotation,       // 4
    ArmCircles,                  // 5
    BentOverReachToSky,          // 6
    CatCamel,                    // 7
    ElbowToFootLunge,            // 8
    ForwardAndBackwardLegSwings, // 9
    Groiners,                    // 10
    InvertedHamstringStretch,    // 11
    LateralDuckUnder,            // 12
    NeckRotations,               // 13
    OppositeArmAndLegBalance,    // 14
    ReachRollAndLift,            // 15
    Scorpion,                    // 16
    ShoulderCircles,             // 17
    SideToSideLegSwings,         // 18
    SleeperStretch,              // 19
    SlideOut,                    // 20
    SwissBallHipCrossover,       // 21
    SwissBallReachRollAndLift,   // 22
    SwissBallWindshieldWipers,   // 23
    ThoracicRotation,            // 24
    WalkingHighKicks,            // 25
    WalkingHighKnees,            // 26
    WalkingKneeHugs,             // 27
    WalkingLegCradles,           // 28
    Walkout,                     // 29
    WalkoutFromPushUpPosition,   // 30
    WarmUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldWarmUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWarmUpExerciseName::QuadrupedRocking => write!(f, "{}", "QuadrupedRocking"),
            FitFieldWarmUpExerciseName::NeckTilts => write!(f, "{}", "NeckTilts"),
            FitFieldWarmUpExerciseName::AnkleCircles => write!(f, "{}", "AnkleCircles"),
            FitFieldWarmUpExerciseName::AnkleDorsiflexionWithBand => {
                write!(f, "{}", "AnkleDorsiflexionWithBand")
            }
            FitFieldWarmUpExerciseName::AnkleInternalRotation => {
                write!(f, "{}", "AnkleInternalRotation")
            }
            FitFieldWarmUpExerciseName::ArmCircles => write!(f, "{}", "ArmCircles"),
            FitFieldWarmUpExerciseName::BentOverReachToSky => write!(f, "{}", "BentOverReachToSky"),
            FitFieldWarmUpExerciseName::CatCamel => write!(f, "{}", "CatCamel"),
            FitFieldWarmUpExerciseName::ElbowToFootLunge => write!(f, "{}", "ElbowToFootLunge"),
            FitFieldWarmUpExerciseName::ForwardAndBackwardLegSwings => {
                write!(f, "{}", "ForwardAndBackwardLegSwings")
            }
            FitFieldWarmUpExerciseName::Groiners => write!(f, "{}", "Groiners"),
            FitFieldWarmUpExerciseName::InvertedHamstringStretch => {
                write!(f, "{}", "InvertedHamstringStretch")
            }
            FitFieldWarmUpExerciseName::LateralDuckUnder => write!(f, "{}", "LateralDuckUnder"),
            FitFieldWarmUpExerciseName::NeckRotations => write!(f, "{}", "NeckRotations"),
            FitFieldWarmUpExerciseName::OppositeArmAndLegBalance => {
                write!(f, "{}", "OppositeArmAndLegBalance")
            }
            FitFieldWarmUpExerciseName::ReachRollAndLift => write!(f, "{}", "ReachRollAndLift"),
            FitFieldWarmUpExerciseName::Scorpion => write!(f, "{}", "Scorpion"),
            FitFieldWarmUpExerciseName::ShoulderCircles => write!(f, "{}", "ShoulderCircles"),
            FitFieldWarmUpExerciseName::SideToSideLegSwings => {
                write!(f, "{}", "SideToSideLegSwings")
            }
            FitFieldWarmUpExerciseName::SleeperStretch => write!(f, "{}", "SleeperStretch"),
            FitFieldWarmUpExerciseName::SlideOut => write!(f, "{}", "SlideOut"),
            FitFieldWarmUpExerciseName::SwissBallHipCrossover => {
                write!(f, "{}", "SwissBallHipCrossover")
            }
            FitFieldWarmUpExerciseName::SwissBallReachRollAndLift => {
                write!(f, "{}", "SwissBallReachRollAndLift")
            }
            FitFieldWarmUpExerciseName::SwissBallWindshieldWipers => {
                write!(f, "{}", "SwissBallWindshieldWipers")
            }
            FitFieldWarmUpExerciseName::ThoracicRotation => write!(f, "{}", "ThoracicRotation"),
            FitFieldWarmUpExerciseName::WalkingHighKicks => write!(f, "{}", "WalkingHighKicks"),
            FitFieldWarmUpExerciseName::WalkingHighKnees => write!(f, "{}", "WalkingHighKnees"),
            FitFieldWarmUpExerciseName::WalkingKneeHugs => write!(f, "{}", "WalkingKneeHugs"),
            FitFieldWarmUpExerciseName::WalkingLegCradles => write!(f, "{}", "WalkingLegCradles"),
            FitFieldWarmUpExerciseName::Walkout => write!(f, "{}", "Walkout"),
            FitFieldWarmUpExerciseName::WalkoutFromPushUpPosition => {
                write!(f, "{}", "WalkoutFromPushUpPosition")
            }
            FitFieldWarmUpExerciseName::WarmUpExerciseName(x) => {
                write!(f, "{}({})", "WarmUpExerciseName", x)
            }
            FitFieldWarmUpExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWarmUpExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWarmUpExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWarmUpExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldWarmUpExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldWarmUpExerciseName::from(v)),
                1 => Ok(FitFieldWarmUpExerciseName::from(v)),
                2 => Ok(FitFieldWarmUpExerciseName::from(v)),
                3 => Ok(FitFieldWarmUpExerciseName::from(v)),
                4 => Ok(FitFieldWarmUpExerciseName::from(v)),
                5 => Ok(FitFieldWarmUpExerciseName::from(v)),
                6 => Ok(FitFieldWarmUpExerciseName::from(v)),
                7 => Ok(FitFieldWarmUpExerciseName::from(v)),
                8 => Ok(FitFieldWarmUpExerciseName::from(v)),
                9 => Ok(FitFieldWarmUpExerciseName::from(v)),
                10 => Ok(FitFieldWarmUpExerciseName::from(v)),
                11 => Ok(FitFieldWarmUpExerciseName::from(v)),
                12 => Ok(FitFieldWarmUpExerciseName::from(v)),
                13 => Ok(FitFieldWarmUpExerciseName::from(v)),
                14 => Ok(FitFieldWarmUpExerciseName::from(v)),
                15 => Ok(FitFieldWarmUpExerciseName::from(v)),
                16 => Ok(FitFieldWarmUpExerciseName::from(v)),
                17 => Ok(FitFieldWarmUpExerciseName::from(v)),
                18 => Ok(FitFieldWarmUpExerciseName::from(v)),
                19 => Ok(FitFieldWarmUpExerciseName::from(v)),
                20 => Ok(FitFieldWarmUpExerciseName::from(v)),
                21 => Ok(FitFieldWarmUpExerciseName::from(v)),
                22 => Ok(FitFieldWarmUpExerciseName::from(v)),
                23 => Ok(FitFieldWarmUpExerciseName::from(v)),
                24 => Ok(FitFieldWarmUpExerciseName::from(v)),
                25 => Ok(FitFieldWarmUpExerciseName::from(v)),
                26 => Ok(FitFieldWarmUpExerciseName::from(v)),
                27 => Ok(FitFieldWarmUpExerciseName::from(v)),
                28 => Ok(FitFieldWarmUpExerciseName::from(v)),
                29 => Ok(FitFieldWarmUpExerciseName::from(v)),
                30 => Ok(FitFieldWarmUpExerciseName::from(v)),
                v => Ok(FitFieldWarmUpExerciseName::WarmUpExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldWarmUpExerciseName);

impl From<u16> for FitFieldWarmUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldWarmUpExerciseName::QuadrupedRocking,
            1 => FitFieldWarmUpExerciseName::NeckTilts,
            2 => FitFieldWarmUpExerciseName::AnkleCircles,
            3 => FitFieldWarmUpExerciseName::AnkleDorsiflexionWithBand,
            4 => FitFieldWarmUpExerciseName::AnkleInternalRotation,
            5 => FitFieldWarmUpExerciseName::ArmCircles,
            6 => FitFieldWarmUpExerciseName::BentOverReachToSky,
            7 => FitFieldWarmUpExerciseName::CatCamel,
            8 => FitFieldWarmUpExerciseName::ElbowToFootLunge,
            9 => FitFieldWarmUpExerciseName::ForwardAndBackwardLegSwings,
            10 => FitFieldWarmUpExerciseName::Groiners,
            11 => FitFieldWarmUpExerciseName::InvertedHamstringStretch,
            12 => FitFieldWarmUpExerciseName::LateralDuckUnder,
            13 => FitFieldWarmUpExerciseName::NeckRotations,
            14 => FitFieldWarmUpExerciseName::OppositeArmAndLegBalance,
            15 => FitFieldWarmUpExerciseName::ReachRollAndLift,
            16 => FitFieldWarmUpExerciseName::Scorpion,
            17 => FitFieldWarmUpExerciseName::ShoulderCircles,
            18 => FitFieldWarmUpExerciseName::SideToSideLegSwings,
            19 => FitFieldWarmUpExerciseName::SleeperStretch,
            20 => FitFieldWarmUpExerciseName::SlideOut,
            21 => FitFieldWarmUpExerciseName::SwissBallHipCrossover,
            22 => FitFieldWarmUpExerciseName::SwissBallReachRollAndLift,
            23 => FitFieldWarmUpExerciseName::SwissBallWindshieldWipers,
            24 => FitFieldWarmUpExerciseName::ThoracicRotation,
            25 => FitFieldWarmUpExerciseName::WalkingHighKicks,
            26 => FitFieldWarmUpExerciseName::WalkingHighKnees,
            27 => FitFieldWarmUpExerciseName::WalkingKneeHugs,
            28 => FitFieldWarmUpExerciseName::WalkingLegCradles,
            29 => FitFieldWarmUpExerciseName::Walkout,
            30 => FitFieldWarmUpExerciseName::WalkoutFromPushUpPosition,
            _ => FitFieldWarmUpExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldRunExerciseName {
    // fit base type: uint16
    Run,    // 0
    Walk,   // 1
    Jog,    // 2
    Sprint, // 3
    RunExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldRunExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldRunExerciseName::Run => write!(f, "{}", "Run"),
            FitFieldRunExerciseName::Walk => write!(f, "{}", "Walk"),
            FitFieldRunExerciseName::Jog => write!(f, "{}", "Jog"),
            FitFieldRunExerciseName::Sprint => write!(f, "{}", "Sprint"),
            FitFieldRunExerciseName::RunExerciseName(x) => {
                write!(f, "{}({})", "RunExerciseName", x)
            }
            FitFieldRunExerciseName::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldRunExerciseName::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldRunExerciseName {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldRunExerciseName> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldRunExerciseName::InvalidFieldValue),
            Ok(v) => match v {
                0 => Ok(FitFieldRunExerciseName::from(v)),
                1 => Ok(FitFieldRunExerciseName::from(v)),
                2 => Ok(FitFieldRunExerciseName::from(v)),
                3 => Ok(FitFieldRunExerciseName::from(v)),
                v => Ok(FitFieldRunExerciseName::RunExerciseName(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldRunExerciseName);

impl From<u16> for FitFieldRunExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldRunExerciseName::Run,
            1 => FitFieldRunExerciseName::Walk,
            2 => FitFieldRunExerciseName::Jog,
            3 => FitFieldRunExerciseName::Sprint,
            _ => FitFieldRunExerciseName::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldWaterType {
    // fit base type: enum
    Fresh = 0,
    Salt = 1,
    En13319 = 2,
    Custom = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldWaterType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldWaterType::Fresh => write!(f, "{}", "Fresh"),
            FitFieldWaterType::Salt => write!(f, "{}", "Salt"),
            FitFieldWaterType::En13319 => write!(f, "{}", "En13319"),
            FitFieldWaterType::Custom => write!(f, "{}", "Custom"),
            FitFieldWaterType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldWaterType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldWaterType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldWaterType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldWaterType::from(v)),
            Err(_) => Ok(FitFieldWaterType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldWaterType);

impl From<u8> for FitFieldWaterType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWaterType::Fresh,
            1 => FitFieldWaterType::Salt,
            2 => FitFieldWaterType::En13319,
            3 => FitFieldWaterType::Custom,
            _ => FitFieldWaterType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldTissueModelType {
    // fit base type: enum
    Zhl16c = 0, // Buhlmann's decompression algorithm, version C
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldTissueModelType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldTissueModelType::Zhl16c => write!(f, "{}", "Zhl16c"),
            FitFieldTissueModelType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldTissueModelType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldTissueModelType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldTissueModelType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldTissueModelType::from(v)),
            Err(_) => Ok(FitFieldTissueModelType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldTissueModelType);

impl From<u8> for FitFieldTissueModelType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTissueModelType::Zhl16c,
            _ => FitFieldTissueModelType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDiveGasStatus {
    // fit base type: enum
    Disabled = 0,
    Enabled = 1,
    BackupOnly = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDiveGasStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDiveGasStatus::Disabled => write!(f, "{}", "Disabled"),
            FitFieldDiveGasStatus::Enabled => write!(f, "{}", "Enabled"),
            FitFieldDiveGasStatus::BackupOnly => write!(f, "{}", "BackupOnly"),
            FitFieldDiveGasStatus::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDiveGasStatus::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDiveGasStatus {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDiveGasStatus> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDiveGasStatus::from(v)),
            Err(_) => Ok(FitFieldDiveGasStatus::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDiveGasStatus);

impl From<u8> for FitFieldDiveGasStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDiveGasStatus::Disabled,
            1 => FitFieldDiveGasStatus::Enabled,
            2 => FitFieldDiveGasStatus::BackupOnly,
            _ => FitFieldDiveGasStatus::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDiveAlarmType {
    // fit base type: enum
    Depth = 0,
    Time = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDiveAlarmType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDiveAlarmType::Depth => write!(f, "{}", "Depth"),
            FitFieldDiveAlarmType::Time => write!(f, "{}", "Time"),
            FitFieldDiveAlarmType::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDiveAlarmType::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDiveAlarmType {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDiveAlarmType> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDiveAlarmType::from(v)),
            Err(_) => Ok(FitFieldDiveAlarmType::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDiveAlarmType);

impl From<u8> for FitFieldDiveAlarmType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDiveAlarmType::Depth,
            1 => FitFieldDiveAlarmType::Time,
            _ => FitFieldDiveAlarmType::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldDiveBacklightMode {
    // fit base type: enum
    AtDepth = 0,
    AlwaysOn = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl fmt::Display for FitFieldDiveBacklightMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldDiveBacklightMode::AtDepth => write!(f, "{}", "AtDepth"),
            FitFieldDiveBacklightMode::AlwaysOn => write!(f, "{}", "AlwaysOn"),
            FitFieldDiveBacklightMode::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldDiveBacklightMode::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldDiveBacklightMode {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldDiveBacklightMode> {
        let val = parse_enum(input, parse_config);
        match val {
            Ok(v) => Ok(FitFieldDiveBacklightMode::from(v)),
            Err(_) => Ok(FitFieldDiveBacklightMode::InvalidFieldValue),
        }
    }
}

vec_fit_field_parseable!(FitFieldDiveBacklightMode);

impl From<u8> for FitFieldDiveBacklightMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDiveBacklightMode::AtDepth,
            1 => FitFieldDiveBacklightMode::AlwaysOn,
            _ => FitFieldDiveBacklightMode::UnknownToSdk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum FitFieldFaveroProduct {
    // fit base type: uint16
    AssiomaUno, // 10
    AssiomaDuo, // 12
    FaveroProduct(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl fmt::Display for FitFieldFaveroProduct {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitFieldFaveroProduct::AssiomaUno => write!(f, "{}", "AssiomaUno"),
            FitFieldFaveroProduct::AssiomaDuo => write!(f, "{}", "AssiomaDuo"),
            FitFieldFaveroProduct::FaveroProduct(x) => write!(f, "{}({})", "FaveroProduct", x),
            FitFieldFaveroProduct::InvalidFieldValue => write!(f, "InvalidFieldValue"),
            FitFieldFaveroProduct::UnknownToSdk => write!(f, "UnknownToSdk"),
        }
    }
}

impl FitFieldParseable for FitFieldFaveroProduct {
    fn parse(input: &[u8], parse_config: &FitParseConfig) -> Result<FitFieldFaveroProduct> {
        let val = parse_uint16(input, parse_config);
        match val {
            Err(_) => Ok(FitFieldFaveroProduct::InvalidFieldValue),
            Ok(v) => match v {
                10 => Ok(FitFieldFaveroProduct::from(v)),
                12 => Ok(FitFieldFaveroProduct::from(v)),
                v => Ok(FitFieldFaveroProduct::FaveroProduct(v)),
            },
        }
    }
}

vec_fit_field_parseable!(FitFieldFaveroProduct);

impl From<u16> for FitFieldFaveroProduct {
    fn from(code: u16) -> Self {
        match code {
            10 => FitFieldFaveroProduct::AssiomaUno,
            12 => FitFieldFaveroProduct::AssiomaDuo,
            _ => FitFieldFaveroProduct::UnknownToSdk,
        }
    }
}
#[derive(Debug)]
pub struct FitMessageAccelerometerData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub sample_time_offset: FitFieldBasicValue<FitUint16>, // Each time in the array describes the time at which the accelerometer sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in accel_x and accel_y and accel_z
    pub accel_x: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub accel_y: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub accel_z: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub calibrated_accel_x: FitFieldBasicValue<FitFloat32>, // Calibrated accel reading
    pub calibrated_accel_y: FitFieldBasicValue<FitFloat32>, // Calibrated accel reading
    pub calibrated_accel_z: FitFieldBasicValue<FitFloat32>, // Calibrated accel reading
    pub compressed_calibrated_accel_x: FitFieldBasicValue<FitSint16>, // Calibrated accel reading
    pub compressed_calibrated_accel_y: FitFieldBasicValue<FitSint16>, // Calibrated accel reading
    pub compressed_calibrated_accel_z: FitFieldBasicValue<FitSint16>, // Calibrated accel reading
}

impl fmt::Display for FitMessageAccelerometerData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAccelerometerData")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.sample_time_offset, "sample_time_offset", false, f)?;
        fmt_message_field!(self.accel_x, "accel_x", false, f)?;
        fmt_message_field!(self.accel_y, "accel_y", false, f)?;
        fmt_message_field!(self.accel_z, "accel_z", false, f)?;
        fmt_message_field!(self.calibrated_accel_x, "calibrated_accel_x", false, f)?;
        fmt_message_field!(self.calibrated_accel_y, "calibrated_accel_y", false, f)?;
        fmt_message_field!(self.calibrated_accel_z, "calibrated_accel_z", false, f)?;
        fmt_message_field!(
            self.compressed_calibrated_accel_x,
            "compressed_calibrated_accel_x",
            false,
            f
        )?;
        fmt_message_field!(
            self.compressed_calibrated_accel_y,
            "compressed_calibrated_accel_y",
            false,
            f
        )?;
        fmt_message_field!(
            self.compressed_calibrated_accel_z,
            "compressed_calibrated_accel_z",
            false,
            f
        )?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAccelerometerData {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "sample_time_offset",
            2 => "accel_x",
            3 => "accel_y",
            4 => "accel_z",
            5 => "calibrated_accel_x",
            6 => "calibrated_accel_y",
            7 => "calibrated_accel_z",
            8 => "compressed_calibrated_accel_x",
            9 => "compressed_calibrated_accel_y",
            10 => "compressed_calibrated_accel_z",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageAccelerometerData> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageAccelerometerData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageAccelerometerData",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            sample_time_offset: FitFieldBasicValue::new_vec("ms".to_string()),
            accel_x: FitFieldBasicValue::new_vec("counts".to_string()),
            accel_y: FitFieldBasicValue::new_vec("counts".to_string()),
            accel_z: FitFieldBasicValue::new_vec("counts".to_string()),
            calibrated_accel_x: FitFieldBasicValue::new_vec("g".to_string()),
            calibrated_accel_y: FitFieldBasicValue::new_vec("g".to_string()),
            calibrated_accel_z: FitFieldBasicValue::new_vec("g".to_string()),
            compressed_calibrated_accel_x: FitFieldBasicValue::new_vec("mG".to_string()),
            compressed_calibrated_accel_y: FitFieldBasicValue::new_vec("mG".to_string()),
            compressed_calibrated_accel_z: FitFieldBasicValue::new_vec("mG".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageAccelerometerData),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // sample_time_offset
                self.sample_time_offset.parse(parse_input, parse_config)?
            }
            2 => {
                // accel_x
                self.accel_x.parse(parse_input, parse_config)?
            }
            3 => {
                // accel_y
                self.accel_y.parse(parse_input, parse_config)?
            }
            4 => {
                // accel_z
                self.accel_z.parse(parse_input, parse_config)?
            }
            5 => {
                // calibrated_accel_x
                self.calibrated_accel_x.parse(parse_input, parse_config)?
            }
            6 => {
                // calibrated_accel_y
                self.calibrated_accel_y.parse(parse_input, parse_config)?
            }
            7 => {
                // calibrated_accel_z
                self.calibrated_accel_z.parse(parse_input, parse_config)?
            }
            8 => {
                // compressed_calibrated_accel_x
                self.compressed_calibrated_accel_x
                    .parse(parse_input, parse_config)?
            }
            9 => {
                // compressed_calibrated_accel_y
                self.compressed_calibrated_accel_y
                    .parse(parse_input, parse_config)?
            }
            10 => {
                // compressed_calibrated_accel_z
                self.compressed_calibrated_accel_z
                    .parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageAccelerometerData {
    fn message_name(&self) -> &'static str {
        return "FitMessageAccelerometerData";
    }
}

#[derive(Debug)]
pub struct FitMessageActivity {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub total_timer_time: FitFieldAdjustedValue<FitUint32>, // Exclude pauses
    pub num_sessions: FitFieldBasicValue<FitUint16>,
    pub ftype: FitFieldBasicValue<FitFieldActivity>,
    pub event: FitFieldBasicValue<FitFieldEvent>,
    pub event_type: FitFieldBasicValue<FitFieldEventType>,
    pub local_timestamp: FitFieldBasicValue<FitFieldLocalDateTime>, // timestamp epoch expressed in local time, used to convert activity timestamps to local time
    pub event_group: FitFieldBasicValue<FitUint8>,
}

impl fmt::Display for FitMessageActivity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageActivity")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.total_timer_time, "total_timer_time", true, f)?;
        fmt_message_field!(self.num_sessions, "num_sessions", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.event, "event", false, f)?;
        fmt_message_field!(self.event_type, "event_type", false, f)?;
        fmt_message_field!(self.local_timestamp, "local_timestamp", false, f)?;
        fmt_message_field!(self.event_group, "event_group", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageActivity {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "total_timer_time",
            1 => "num_sessions",
            2 => "ftype",
            3 => "event",
            4 => "event_type",
            5 => "local_timestamp",
            6 => "event_group",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageActivity> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageActivity {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageActivity",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            total_timer_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            num_sessions: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            event: FitFieldBasicValue::new_single("".to_string()),
            event_type: FitFieldBasicValue::new_single("".to_string()),
            local_timestamp: FitFieldBasicValue::new_single("".to_string()),
            event_group: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageActivity),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // total_timer_time
                self.total_timer_time.parse(parse_input, parse_config)?
            }
            1 => {
                // num_sessions
                self.num_sessions.parse(parse_input, parse_config)?
            }
            2 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            3 => {
                // event
                self.event.parse(parse_input, parse_config)?
            }
            4 => {
                // event_type
                self.event_type.parse(parse_input, parse_config)?
            }
            5 => {
                // local_timestamp
                self.local_timestamp.parse(parse_input, parse_config)?
            }
            6 => {
                // event_group
                self.event_group.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageActivity {
    fn message_name(&self) -> &'static str {
        return "FitMessageActivity";
    }
}

#[derive(Debug)]
pub struct FitMessageAntChannelId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub channel_number: FitFieldBasicValue<FitUint8>,
    pub device_type: FitFieldBasicValue<FitUint8z>,
    pub device_number: FitFieldBasicValue<FitUint16z>,
    pub transmission_type: FitFieldBasicValue<FitUint8z>,
    pub device_index: FitFieldBasicValue<FitFieldDeviceIndex>,
}

impl fmt::Display for FitMessageAntChannelId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAntChannelId")?;
        fmt_message_field!(self.channel_number, "channel_number", false, f)?;
        fmt_message_field!(self.device_type, "device_type", false, f)?;
        fmt_message_field!(self.device_number, "device_number", false, f)?;
        fmt_message_field!(self.transmission_type, "transmission_type", false, f)?;
        fmt_message_field!(self.device_index, "device_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAntChannelId {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "channel_number",
            1 => "device_type",
            2 => "device_number",
            3 => "transmission_type",
            4 => "device_index",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageAntChannelId> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageAntChannelId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageAntChannelId",
            channel_number: FitFieldBasicValue::new_single("".to_string()),
            device_type: FitFieldBasicValue::new_single("".to_string()),
            device_number: FitFieldBasicValue::new_single("".to_string()),
            transmission_type: FitFieldBasicValue::new_single("".to_string()),
            device_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageAntChannelId),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // channel_number
                self.channel_number.parse(parse_input, parse_config)?
            }
            1 => {
                // device_type
                self.device_type.parse(parse_input, parse_config)?
            }
            2 => {
                // device_number
                self.device_number.parse(parse_input, parse_config)?
            }
            3 => {
                // transmission_type
                self.transmission_type.parse(parse_input, parse_config)?
            }
            4 => {
                // device_index
                self.device_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageAntChannelId {
    fn message_name(&self) -> &'static str {
        return "FitMessageAntChannelId";
    }
}

#[derive(Debug)]
pub struct FitMessageAntRx {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub fractional_timestamp: FitFieldAdjustedValue<FitUint16>,
    pub mesg_id: FitFieldBasicValue<FitByte>,
    pub mesg_data: FitFieldBasicValue<FitByte>,
    pub channel_number: FitFieldBasicValue<FitUint8>,
    pub data: FitFieldBasicValue<FitByte>,
}

impl fmt::Display for FitMessageAntRx {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAntRx")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.fractional_timestamp, "fractional_timestamp", true, f)?;
        fmt_message_field!(self.mesg_id, "mesg_id", false, f)?;
        fmt_message_field!(self.mesg_data, "mesg_data", false, f)?;
        fmt_message_field!(self.channel_number, "channel_number", false, f)?;
        fmt_message_field!(self.data, "data", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAntRx {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "fractional_timestamp",
            1 => "mesg_id",
            2 => "mesg_data",
            3 => "channel_number",
            4 => "data",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageAntRx> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageAntRx {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageAntRx",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            fractional_timestamp: FitFieldAdjustedValue::new_single("s".to_string(), 32768.0, 0.0),
            mesg_id: FitFieldBasicValue::new_single("".to_string()),
            mesg_data: FitFieldBasicValue::new_single("".to_string()).add_components(vec![
                FitParseConfig::new_from_component(
                    3,
                    1,
                    2,
                    endianness,
                    0,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    8,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    16,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    24,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    32,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    40,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    48,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    56,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    64,
                    8,
                    None,
                    Some("".to_string()),
                ),
            ]),
            channel_number: FitFieldBasicValue::new_single("".to_string()),
            data: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageAntRx), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // fractional_timestamp
                self.fractional_timestamp.parse(parse_input, parse_config)?
            }
            1 => {
                // mesg_id
                self.mesg_id.parse(parse_input, parse_config)?
            }
            2 => {
                // mesg_data
                self.mesg_data.parse(parse_input, parse_config)?
            }
            3 => {
                // channel_number
                self.channel_number.parse(parse_input, parse_config)?
            }
            4 => {
                // data
                self.data.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageAntRx {
    fn message_name(&self) -> &'static str {
        return "FitMessageAntRx";
    }
}

#[derive(Debug)]
pub struct FitMessageAntTx {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub fractional_timestamp: FitFieldAdjustedValue<FitUint16>,
    pub mesg_id: FitFieldBasicValue<FitByte>,
    pub mesg_data: FitFieldBasicValue<FitByte>,
    pub channel_number: FitFieldBasicValue<FitUint8>,
    pub data: FitFieldBasicValue<FitByte>,
}

impl fmt::Display for FitMessageAntTx {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAntTx")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.fractional_timestamp, "fractional_timestamp", true, f)?;
        fmt_message_field!(self.mesg_id, "mesg_id", false, f)?;
        fmt_message_field!(self.mesg_data, "mesg_data", false, f)?;
        fmt_message_field!(self.channel_number, "channel_number", false, f)?;
        fmt_message_field!(self.data, "data", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAntTx {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "fractional_timestamp",
            1 => "mesg_id",
            2 => "mesg_data",
            3 => "channel_number",
            4 => "data",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageAntTx> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageAntTx {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageAntTx",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            fractional_timestamp: FitFieldAdjustedValue::new_single("s".to_string(), 32768.0, 0.0),
            mesg_id: FitFieldBasicValue::new_single("".to_string()),
            mesg_data: FitFieldBasicValue::new_single("".to_string()).add_components(vec![
                FitParseConfig::new_from_component(
                    3,
                    1,
                    2,
                    endianness,
                    0,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    8,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    16,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    24,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    32,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    40,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    48,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    56,
                    8,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    4,
                    1,
                    13,
                    endianness,
                    64,
                    8,
                    None,
                    Some("".to_string()),
                ),
            ]),
            channel_number: FitFieldBasicValue::new_single("".to_string()),
            data: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageAntTx), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // fractional_timestamp
                self.fractional_timestamp.parse(parse_input, parse_config)?
            }
            1 => {
                // mesg_id
                self.mesg_id.parse(parse_input, parse_config)?
            }
            2 => {
                // mesg_data
                self.mesg_data.parse(parse_input, parse_config)?
            }
            3 => {
                // channel_number
                self.channel_number.parse(parse_input, parse_config)?
            }
            4 => {
                // data
                self.data.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageAntTx {
    fn message_name(&self) -> &'static str {
        return "FitMessageAntTx";
    }
}

#[derive(Debug)]
pub struct FitMessageAviationAttitude {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Timestamp message was output
    pub timestamp_ms: FitFieldBasicValue<FitUint16>, // Fractional part of timestamp, added to timestamp
    pub system_time: FitFieldBasicValue<FitUint32>, // System time associated with sample expressed in ms.
    pub pitch: FitFieldAdjustedValue<FitSint16>,    // Range -PI/2 to +PI/2
    pub roll: FitFieldAdjustedValue<FitSint16>,     // Range -PI to +PI
    pub accel_lateral: FitFieldAdjustedValue<FitSint16>, // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
    pub accel_normal: FitFieldAdjustedValue<FitSint16>, // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
    pub turn_rate: FitFieldAdjustedValue<FitSint16>, // Range -8.727 to +8.727 (-500 degs/sec to +500 degs/sec)
    pub stage: FitFieldBasicValue<FitFieldAttitudeStage>,
    pub attitude_stage_complete: FitFieldBasicValue<FitUint8>, // The percent complete of the current attitude stage.  Set to 0 for attitude stages 0, 1 and 2 and to 100 for attitude stage 3 by AHRS modules that do not support it.  Range - 100
    pub track: FitFieldAdjustedValue<FitUint16>,               // Track Angle/Heading Range 0 - 2pi
    pub validity: FitFieldBasicValue<FitFieldAttitudeValidity>,
}

impl fmt::Display for FitMessageAviationAttitude {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAviationAttitude")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.system_time, "system_time", false, f)?;
        fmt_message_field!(self.pitch, "pitch", true, f)?;
        fmt_message_field!(self.roll, "roll", true, f)?;
        fmt_message_field!(self.accel_lateral, "accel_lateral", true, f)?;
        fmt_message_field!(self.accel_normal, "accel_normal", true, f)?;
        fmt_message_field!(self.turn_rate, "turn_rate", true, f)?;
        fmt_message_field!(self.stage, "stage", false, f)?;
        fmt_message_field!(
            self.attitude_stage_complete,
            "attitude_stage_complete",
            false,
            f
        )?;
        fmt_message_field!(self.track, "track", true, f)?;
        fmt_message_field!(self.validity, "validity", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAviationAttitude {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "system_time",
            2 => "pitch",
            3 => "roll",
            4 => "accel_lateral",
            5 => "accel_normal",
            6 => "turn_rate",
            7 => "stage",
            8 => "attitude_stage_complete",
            9 => "track",
            10 => "validity",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageAviationAttitude> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageAviationAttitude {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageAviationAttitude",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            system_time: FitFieldBasicValue::new_vec("ms".to_string()),
            pitch: FitFieldAdjustedValue::new_vec("radians".to_string(), 10430.38, 0.0),
            roll: FitFieldAdjustedValue::new_vec("radians".to_string(), 10430.38, 0.0),
            accel_lateral: FitFieldAdjustedValue::new_vec("m/s^2".to_string(), 100.0, 0.0),
            accel_normal: FitFieldAdjustedValue::new_vec("m/s^2".to_string(), 100.0, 0.0),
            turn_rate: FitFieldAdjustedValue::new_vec("radians/second".to_string(), 1024.0, 0.0),
            stage: FitFieldBasicValue::new_vec("".to_string()),
            attitude_stage_complete: FitFieldBasicValue::new_vec("%".to_string()),
            track: FitFieldAdjustedValue::new_vec("radians".to_string(), 10430.38, 0.0),
            validity: FitFieldBasicValue::new_vec("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageAviationAttitude),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // system_time
                self.system_time.parse(parse_input, parse_config)?
            }
            2 => {
                // pitch
                self.pitch.parse(parse_input, parse_config)?
            }
            3 => {
                // roll
                self.roll.parse(parse_input, parse_config)?
            }
            4 => {
                // accel_lateral
                self.accel_lateral.parse(parse_input, parse_config)?
            }
            5 => {
                // accel_normal
                self.accel_normal.parse(parse_input, parse_config)?
            }
            6 => {
                // turn_rate
                self.turn_rate.parse(parse_input, parse_config)?
            }
            7 => {
                // stage
                self.stage.parse(parse_input, parse_config)?
            }
            8 => {
                // attitude_stage_complete
                self.attitude_stage_complete
                    .parse(parse_input, parse_config)?
            }
            9 => {
                // track
                self.track.parse(parse_input, parse_config)?
            }
            10 => {
                // validity
                self.validity.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageAviationAttitude {
    fn message_name(&self) -> &'static str {
        return "FitMessageAviationAttitude";
    }
}

#[derive(Debug)]
pub struct FitMessageBarometerData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub sample_time_offset: FitFieldBasicValue<FitUint16>, // Each time in the array describes the time at which the barometer sample with the corrosponding index was taken. The samples may span across seconds. Array size must match the number of samples in baro_cal
    pub baro_pres: FitFieldBasicValue<FitUint32>, // These are the raw ADC reading. The samples may span across seconds. A conversion will need to be done on this data once read.
}

impl fmt::Display for FitMessageBarometerData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageBarometerData")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.sample_time_offset, "sample_time_offset", false, f)?;
        fmt_message_field!(self.baro_pres, "baro_pres", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageBarometerData {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "sample_time_offset",
            2 => "baro_pres",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageBarometerData> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageBarometerData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageBarometerData",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            sample_time_offset: FitFieldBasicValue::new_vec("ms".to_string()),
            baro_pres: FitFieldBasicValue::new_vec("Pa".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageBarometerData),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // sample_time_offset
                self.sample_time_offset.parse(parse_input, parse_config)?
            }
            2 => {
                // baro_pres
                self.baro_pres.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageBarometerData {
    fn message_name(&self) -> &'static str {
        return "FitMessageBarometerData";
    }
}

#[derive(Debug)]
pub struct FitMessageBikeProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub name: FitFieldBasicValue<FitString>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub odometer: FitFieldAdjustedValue<FitUint32>,
    pub bike_spd_ant_id: FitFieldBasicValue<FitUint16z>,
    pub bike_cad_ant_id: FitFieldBasicValue<FitUint16z>,
    pub bike_spdcad_ant_id: FitFieldBasicValue<FitUint16z>,
    pub bike_power_ant_id: FitFieldBasicValue<FitUint16z>,
    pub custom_wheelsize: FitFieldAdjustedValue<FitUint16>,
    pub auto_wheelsize: FitFieldAdjustedValue<FitUint16>,
    pub bike_weight: FitFieldAdjustedValue<FitUint16>,
    pub power_cal_factor: FitFieldAdjustedValue<FitUint16>,
    pub auto_wheel_cal: FitFieldBasicValue<FitBool>,
    pub auto_power_zero: FitFieldBasicValue<FitBool>,
    pub id: FitFieldBasicValue<FitUint8>,
    pub spd_enabled: FitFieldBasicValue<FitBool>,
    pub cad_enabled: FitFieldBasicValue<FitBool>,
    pub spdcad_enabled: FitFieldBasicValue<FitBool>,
    pub power_enabled: FitFieldBasicValue<FitBool>,
    pub crank_length: FitFieldAdjustedValue<FitUint8>,
    pub enabled: FitFieldBasicValue<FitBool>,
    pub bike_spd_ant_id_trans_type: FitFieldBasicValue<FitUint8z>,
    pub bike_cad_ant_id_trans_type: FitFieldBasicValue<FitUint8z>,
    pub bike_spdcad_ant_id_trans_type: FitFieldBasicValue<FitUint8z>,
    pub bike_power_ant_id_trans_type: FitFieldBasicValue<FitUint8z>,
    pub odometer_rollover: FitFieldBasicValue<FitUint8>, // Rollover counter that can be used to extend the odometer
    pub front_gear_num: FitFieldBasicValue<FitUint8z>,   // Number of front gears
    pub front_gear: FitFieldBasicValue<FitUint8z>, // Number of teeth on each gear 0 is innermost
    pub rear_gear_num: FitFieldBasicValue<FitUint8z>, // Number of rear gears
    pub rear_gear: FitFieldBasicValue<FitUint8z>,  // Number of teeth on each gear 0 is innermost
    pub shimano_di2_enabled: FitFieldBasicValue<FitBool>,
}

impl fmt::Display for FitMessageBikeProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageBikeProfile")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.odometer, "odometer", true, f)?;
        fmt_message_field!(self.bike_spd_ant_id, "bike_spd_ant_id", false, f)?;
        fmt_message_field!(self.bike_cad_ant_id, "bike_cad_ant_id", false, f)?;
        fmt_message_field!(self.bike_spdcad_ant_id, "bike_spdcad_ant_id", false, f)?;
        fmt_message_field!(self.bike_power_ant_id, "bike_power_ant_id", false, f)?;
        fmt_message_field!(self.custom_wheelsize, "custom_wheelsize", true, f)?;
        fmt_message_field!(self.auto_wheelsize, "auto_wheelsize", true, f)?;
        fmt_message_field!(self.bike_weight, "bike_weight", true, f)?;
        fmt_message_field!(self.power_cal_factor, "power_cal_factor", true, f)?;
        fmt_message_field!(self.auto_wheel_cal, "auto_wheel_cal", false, f)?;
        fmt_message_field!(self.auto_power_zero, "auto_power_zero", false, f)?;
        fmt_message_field!(self.id, "id", false, f)?;
        fmt_message_field!(self.spd_enabled, "spd_enabled", false, f)?;
        fmt_message_field!(self.cad_enabled, "cad_enabled", false, f)?;
        fmt_message_field!(self.spdcad_enabled, "spdcad_enabled", false, f)?;
        fmt_message_field!(self.power_enabled, "power_enabled", false, f)?;
        fmt_message_field!(self.crank_length, "crank_length", true, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(
            self.bike_spd_ant_id_trans_type,
            "bike_spd_ant_id_trans_type",
            false,
            f
        )?;
        fmt_message_field!(
            self.bike_cad_ant_id_trans_type,
            "bike_cad_ant_id_trans_type",
            false,
            f
        )?;
        fmt_message_field!(
            self.bike_spdcad_ant_id_trans_type,
            "bike_spdcad_ant_id_trans_type",
            false,
            f
        )?;
        fmt_message_field!(
            self.bike_power_ant_id_trans_type,
            "bike_power_ant_id_trans_type",
            false,
            f
        )?;
        fmt_message_field!(self.odometer_rollover, "odometer_rollover", false, f)?;
        fmt_message_field!(self.front_gear_num, "front_gear_num", false, f)?;
        fmt_message_field!(self.front_gear, "front_gear", false, f)?;
        fmt_message_field!(self.rear_gear_num, "rear_gear_num", false, f)?;
        fmt_message_field!(self.rear_gear, "rear_gear", false, f)?;
        fmt_message_field!(self.shimano_di2_enabled, "shimano_di2_enabled", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageBikeProfile {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "name",
            1 => "sport",
            2 => "sub_sport",
            3 => "odometer",
            4 => "bike_spd_ant_id",
            5 => "bike_cad_ant_id",
            6 => "bike_spdcad_ant_id",
            7 => "bike_power_ant_id",
            8 => "custom_wheelsize",
            9 => "auto_wheelsize",
            10 => "bike_weight",
            11 => "power_cal_factor",
            12 => "auto_wheel_cal",
            13 => "auto_power_zero",
            14 => "id",
            15 => "spd_enabled",
            16 => "cad_enabled",
            17 => "spdcad_enabled",
            18 => "power_enabled",
            19 => "crank_length",
            20 => "enabled",
            21 => "bike_spd_ant_id_trans_type",
            22 => "bike_cad_ant_id_trans_type",
            23 => "bike_spdcad_ant_id_trans_type",
            24 => "bike_power_ant_id_trans_type",
            37 => "odometer_rollover",
            38 => "front_gear_num",
            39 => "front_gear",
            40 => "rear_gear_num",
            41 => "rear_gear",
            44 => "shimano_di2_enabled",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageBikeProfile> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageBikeProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageBikeProfile",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            odometer: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            bike_spd_ant_id: FitFieldBasicValue::new_single("".to_string()),
            bike_cad_ant_id: FitFieldBasicValue::new_single("".to_string()),
            bike_spdcad_ant_id: FitFieldBasicValue::new_single("".to_string()),
            bike_power_ant_id: FitFieldBasicValue::new_single("".to_string()),
            custom_wheelsize: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            auto_wheelsize: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            bike_weight: FitFieldAdjustedValue::new_single("kg".to_string(), 10.0, 0.0),
            power_cal_factor: FitFieldAdjustedValue::new_single("%".to_string(), 10.0, 0.0),
            auto_wheel_cal: FitFieldBasicValue::new_single("".to_string()),
            auto_power_zero: FitFieldBasicValue::new_single("".to_string()),
            id: FitFieldBasicValue::new_single("".to_string()),
            spd_enabled: FitFieldBasicValue::new_single("".to_string()),
            cad_enabled: FitFieldBasicValue::new_single("".to_string()),
            spdcad_enabled: FitFieldBasicValue::new_single("".to_string()),
            power_enabled: FitFieldBasicValue::new_single("".to_string()),
            crank_length: FitFieldAdjustedValue::new_single("mm".to_string(), 2.0, -110.0),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            bike_spd_ant_id_trans_type: FitFieldBasicValue::new_single("".to_string()),
            bike_cad_ant_id_trans_type: FitFieldBasicValue::new_single("".to_string()),
            bike_spdcad_ant_id_trans_type: FitFieldBasicValue::new_single("".to_string()),
            bike_power_ant_id_trans_type: FitFieldBasicValue::new_single("".to_string()),
            odometer_rollover: FitFieldBasicValue::new_single("".to_string()),
            front_gear_num: FitFieldBasicValue::new_single("".to_string()),
            front_gear: FitFieldBasicValue::new_vec("".to_string()),
            rear_gear_num: FitFieldBasicValue::new_single("".to_string()),
            rear_gear: FitFieldBasicValue::new_vec("".to_string()),
            shimano_di2_enabled: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageBikeProfile),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            1 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            2 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            3 => {
                // odometer
                self.odometer.parse(parse_input, parse_config)?
            }
            4 => {
                // bike_spd_ant_id
                self.bike_spd_ant_id.parse(parse_input, parse_config)?
            }
            5 => {
                // bike_cad_ant_id
                self.bike_cad_ant_id.parse(parse_input, parse_config)?
            }
            6 => {
                // bike_spdcad_ant_id
                self.bike_spdcad_ant_id.parse(parse_input, parse_config)?
            }
            7 => {
                // bike_power_ant_id
                self.bike_power_ant_id.parse(parse_input, parse_config)?
            }
            8 => {
                // custom_wheelsize
                self.custom_wheelsize.parse(parse_input, parse_config)?
            }
            9 => {
                // auto_wheelsize
                self.auto_wheelsize.parse(parse_input, parse_config)?
            }
            10 => {
                // bike_weight
                self.bike_weight.parse(parse_input, parse_config)?
            }
            11 => {
                // power_cal_factor
                self.power_cal_factor.parse(parse_input, parse_config)?
            }
            12 => {
                // auto_wheel_cal
                self.auto_wheel_cal.parse(parse_input, parse_config)?
            }
            13 => {
                // auto_power_zero
                self.auto_power_zero.parse(parse_input, parse_config)?
            }
            14 => {
                // id
                self.id.parse(parse_input, parse_config)?
            }
            15 => {
                // spd_enabled
                self.spd_enabled.parse(parse_input, parse_config)?
            }
            16 => {
                // cad_enabled
                self.cad_enabled.parse(parse_input, parse_config)?
            }
            17 => {
                // spdcad_enabled
                self.spdcad_enabled.parse(parse_input, parse_config)?
            }
            18 => {
                // power_enabled
                self.power_enabled.parse(parse_input, parse_config)?
            }
            19 => {
                // crank_length
                self.crank_length.parse(parse_input, parse_config)?
            }
            20 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            21 => {
                // bike_spd_ant_id_trans_type
                self.bike_spd_ant_id_trans_type
                    .parse(parse_input, parse_config)?
            }
            22 => {
                // bike_cad_ant_id_trans_type
                self.bike_cad_ant_id_trans_type
                    .parse(parse_input, parse_config)?
            }
            23 => {
                // bike_spdcad_ant_id_trans_type
                self.bike_spdcad_ant_id_trans_type
                    .parse(parse_input, parse_config)?
            }
            24 => {
                // bike_power_ant_id_trans_type
                self.bike_power_ant_id_trans_type
                    .parse(parse_input, parse_config)?
            }
            37 => {
                // odometer_rollover
                self.odometer_rollover.parse(parse_input, parse_config)?
            }
            38 => {
                // front_gear_num
                self.front_gear_num.parse(parse_input, parse_config)?
            }
            39 => {
                // front_gear
                self.front_gear.parse(parse_input, parse_config)?
            }
            40 => {
                // rear_gear_num
                self.rear_gear_num.parse(parse_input, parse_config)?
            }
            41 => {
                // rear_gear
                self.rear_gear.parse(parse_input, parse_config)?
            }
            44 => {
                // shimano_di2_enabled
                self.shimano_di2_enabled.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageBikeProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageBikeProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageBloodPressure {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub systolic_pressure: FitFieldBasicValue<FitUint16>,
    pub diastolic_pressure: FitFieldBasicValue<FitUint16>,
    pub mean_arterial_pressure: FitFieldBasicValue<FitUint16>,
    pub map_3_sample_mean: FitFieldBasicValue<FitUint16>,
    pub map_morning_values: FitFieldBasicValue<FitUint16>,
    pub map_evening_values: FitFieldBasicValue<FitUint16>,
    pub heart_rate: FitFieldBasicValue<FitUint8>,
    pub heart_rate_type: FitFieldBasicValue<FitFieldHrType>,
    pub status: FitFieldBasicValue<FitFieldBpStatus>,
    pub user_profile_index: FitFieldBasicValue<FitFieldMessageIndex>, // Associates this blood pressure message to a user.  This corresponds to the index of the user profile message in the blood pressure file.
}

impl fmt::Display for FitMessageBloodPressure {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageBloodPressure")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.systolic_pressure, "systolic_pressure", false, f)?;
        fmt_message_field!(self.diastolic_pressure, "diastolic_pressure", false, f)?;
        fmt_message_field!(
            self.mean_arterial_pressure,
            "mean_arterial_pressure",
            false,
            f
        )?;
        fmt_message_field!(self.map_3_sample_mean, "map_3_sample_mean", false, f)?;
        fmt_message_field!(self.map_morning_values, "map_morning_values", false, f)?;
        fmt_message_field!(self.map_evening_values, "map_evening_values", false, f)?;
        fmt_message_field!(self.heart_rate, "heart_rate", false, f)?;
        fmt_message_field!(self.heart_rate_type, "heart_rate_type", false, f)?;
        fmt_message_field!(self.status, "status", false, f)?;
        fmt_message_field!(self.user_profile_index, "user_profile_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageBloodPressure {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "systolic_pressure",
            1 => "diastolic_pressure",
            2 => "mean_arterial_pressure",
            3 => "map_3_sample_mean",
            4 => "map_morning_values",
            5 => "map_evening_values",
            6 => "heart_rate",
            7 => "heart_rate_type",
            8 => "status",
            9 => "user_profile_index",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageBloodPressure> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageBloodPressure {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageBloodPressure",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            systolic_pressure: FitFieldBasicValue::new_single("mmHg".to_string()),
            diastolic_pressure: FitFieldBasicValue::new_single("mmHg".to_string()),
            mean_arterial_pressure: FitFieldBasicValue::new_single("mmHg".to_string()),
            map_3_sample_mean: FitFieldBasicValue::new_single("mmHg".to_string()),
            map_morning_values: FitFieldBasicValue::new_single("mmHg".to_string()),
            map_evening_values: FitFieldBasicValue::new_single("mmHg".to_string()),
            heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            heart_rate_type: FitFieldBasicValue::new_single("".to_string()),
            status: FitFieldBasicValue::new_single("".to_string()),
            user_profile_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageBloodPressure),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // systolic_pressure
                self.systolic_pressure.parse(parse_input, parse_config)?
            }
            1 => {
                // diastolic_pressure
                self.diastolic_pressure.parse(parse_input, parse_config)?
            }
            2 => {
                // mean_arterial_pressure
                self.mean_arterial_pressure
                    .parse(parse_input, parse_config)?
            }
            3 => {
                // map_3_sample_mean
                self.map_3_sample_mean.parse(parse_input, parse_config)?
            }
            4 => {
                // map_morning_values
                self.map_morning_values.parse(parse_input, parse_config)?
            }
            5 => {
                // map_evening_values
                self.map_evening_values.parse(parse_input, parse_config)?
            }
            6 => {
                // heart_rate
                self.heart_rate.parse(parse_input, parse_config)?
            }
            7 => {
                // heart_rate_type
                self.heart_rate_type.parse(parse_input, parse_config)?
            }
            8 => {
                // status
                self.status.parse(parse_input, parse_config)?
            }
            9 => {
                // user_profile_index
                self.user_profile_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageBloodPressure {
    fn message_name(&self) -> &'static str {
        return "FitMessageBloodPressure";
    }
}

#[derive(Debug)]
pub struct FitMessageCadenceZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub high_value: FitFieldBasicValue<FitUint8>,
    pub name: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageCadenceZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCadenceZone")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.high_value, "high_value", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCadenceZone {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "high_value",
            1 => "name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageCadenceZone> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageCadenceZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageCadenceZone",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            high_value: FitFieldBasicValue::new_single("rpm".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageCadenceZone),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // high_value
                self.high_value.parse(parse_input, parse_config)?
            }
            1 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageCadenceZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageCadenceZone";
    }
}

#[derive(Debug)]
pub struct FitMessageCameraEvent {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp.
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub camera_event_type: FitFieldBasicValue<FitFieldCameraEventType>,
    pub camera_file_uuid: FitFieldBasicValue<FitString>,
    pub camera_orientation: FitFieldBasicValue<FitFieldCameraOrientationType>,
}

impl fmt::Display for FitMessageCameraEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCameraEvent")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.camera_event_type, "camera_event_type", false, f)?;
        fmt_message_field!(self.camera_file_uuid, "camera_file_uuid", false, f)?;
        fmt_message_field!(self.camera_orientation, "camera_orientation", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCameraEvent {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "camera_event_type",
            2 => "camera_file_uuid",
            3 => "camera_orientation",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageCameraEvent> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageCameraEvent {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageCameraEvent",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            camera_event_type: FitFieldBasicValue::new_single("".to_string()),
            camera_file_uuid: FitFieldBasicValue::new_single("".to_string()),
            camera_orientation: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageCameraEvent),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // camera_event_type
                self.camera_event_type.parse(parse_input, parse_config)?
            }
            2 => {
                // camera_file_uuid
                self.camera_file_uuid.parse(parse_input, parse_config)?
            }
            3 => {
                // camera_orientation
                self.camera_orientation.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageCameraEvent {
    fn message_name(&self) -> &'static str {
        return "FitMessageCameraEvent";
    }
}

#[derive(Debug)]
pub struct FitMessageCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub languages: FitFieldBasicValue<FitUint8z>, // Use language_bits_x types where x is index of array.
    pub sports: FitFieldBasicValue<FitFieldSportBits0>, // Use sport_bits_x types where x is index of array.
    pub workouts_supported: FitFieldBasicValue<FitFieldWorkoutCapabilities>,
    pub connectivity_supported: FitFieldBasicValue<FitFieldConnectivityCapabilities>,
}

impl fmt::Display for FitMessageCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCapabilities")?;
        fmt_message_field!(self.languages, "languages", false, f)?;
        fmt_message_field!(self.sports, "sports", false, f)?;
        fmt_message_field!(self.workouts_supported, "workouts_supported", false, f)?;
        fmt_message_field!(
            self.connectivity_supported,
            "connectivity_supported",
            false,
            f
        )?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCapabilities {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "languages",
            1 => "sports",
            21 => "workouts_supported",
            23 => "connectivity_supported",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageCapabilities> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageCapabilities",
            languages: FitFieldBasicValue::new_vec("".to_string()),
            sports: FitFieldBasicValue::new_vec("".to_string()),
            workouts_supported: FitFieldBasicValue::new_single("".to_string()),
            connectivity_supported: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageCapabilities),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // languages
                self.languages.parse(parse_input, parse_config)?
            }
            1 => {
                // sports
                self.sports.parse(parse_input, parse_config)?
            }
            21 => {
                // workouts_supported
                self.workouts_supported.parse(parse_input, parse_config)?
            }
            23 => {
                // connectivity_supported
                self.connectivity_supported
                    .parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageConnectivity {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub bluetooth_enabled: FitFieldBasicValue<FitBool>, // Use Bluetooth for connectivity features
    pub bluetooth_le_enabled: FitFieldBasicValue<FitBool>, // Use Bluetooth Low Energy for connectivity features
    pub ant_enabled: FitFieldBasicValue<FitBool>,          // Use ANT for connectivity features
    pub name: FitFieldBasicValue<FitString>,
    pub live_tracking_enabled: FitFieldBasicValue<FitBool>,
    pub weather_conditions_enabled: FitFieldBasicValue<FitBool>,
    pub weather_alerts_enabled: FitFieldBasicValue<FitBool>,
    pub auto_activity_upload_enabled: FitFieldBasicValue<FitBool>,
    pub course_download_enabled: FitFieldBasicValue<FitBool>,
    pub workout_download_enabled: FitFieldBasicValue<FitBool>,
    pub gps_ephemeris_download_enabled: FitFieldBasicValue<FitBool>,
    pub incident_detection_enabled: FitFieldBasicValue<FitBool>,
    pub grouptrack_enabled: FitFieldBasicValue<FitBool>,
}

impl fmt::Display for FitMessageConnectivity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageConnectivity")?;
        fmt_message_field!(self.bluetooth_enabled, "bluetooth_enabled", false, f)?;
        fmt_message_field!(self.bluetooth_le_enabled, "bluetooth_le_enabled", false, f)?;
        fmt_message_field!(self.ant_enabled, "ant_enabled", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(
            self.live_tracking_enabled,
            "live_tracking_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.weather_conditions_enabled,
            "weather_conditions_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.weather_alerts_enabled,
            "weather_alerts_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.auto_activity_upload_enabled,
            "auto_activity_upload_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.course_download_enabled,
            "course_download_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.workout_download_enabled,
            "workout_download_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.gps_ephemeris_download_enabled,
            "gps_ephemeris_download_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.incident_detection_enabled,
            "incident_detection_enabled",
            false,
            f
        )?;
        fmt_message_field!(self.grouptrack_enabled, "grouptrack_enabled", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageConnectivity {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "bluetooth_enabled",
            1 => "bluetooth_le_enabled",
            2 => "ant_enabled",
            3 => "name",
            4 => "live_tracking_enabled",
            5 => "weather_conditions_enabled",
            6 => "weather_alerts_enabled",
            7 => "auto_activity_upload_enabled",
            8 => "course_download_enabled",
            9 => "workout_download_enabled",
            10 => "gps_ephemeris_download_enabled",
            11 => "incident_detection_enabled",
            12 => "grouptrack_enabled",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageConnectivity> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageConnectivity {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageConnectivity",
            bluetooth_enabled: FitFieldBasicValue::new_single("".to_string()),
            bluetooth_le_enabled: FitFieldBasicValue::new_single("".to_string()),
            ant_enabled: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
            live_tracking_enabled: FitFieldBasicValue::new_single("".to_string()),
            weather_conditions_enabled: FitFieldBasicValue::new_single("".to_string()),
            weather_alerts_enabled: FitFieldBasicValue::new_single("".to_string()),
            auto_activity_upload_enabled: FitFieldBasicValue::new_single("".to_string()),
            course_download_enabled: FitFieldBasicValue::new_single("".to_string()),
            workout_download_enabled: FitFieldBasicValue::new_single("".to_string()),
            gps_ephemeris_download_enabled: FitFieldBasicValue::new_single("".to_string()),
            incident_detection_enabled: FitFieldBasicValue::new_single("".to_string()),
            grouptrack_enabled: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageConnectivity),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // bluetooth_enabled
                self.bluetooth_enabled.parse(parse_input, parse_config)?
            }
            1 => {
                // bluetooth_le_enabled
                self.bluetooth_le_enabled.parse(parse_input, parse_config)?
            }
            2 => {
                // ant_enabled
                self.ant_enabled.parse(parse_input, parse_config)?
            }
            3 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            4 => {
                // live_tracking_enabled
                self.live_tracking_enabled
                    .parse(parse_input, parse_config)?
            }
            5 => {
                // weather_conditions_enabled
                self.weather_conditions_enabled
                    .parse(parse_input, parse_config)?
            }
            6 => {
                // weather_alerts_enabled
                self.weather_alerts_enabled
                    .parse(parse_input, parse_config)?
            }
            7 => {
                // auto_activity_upload_enabled
                self.auto_activity_upload_enabled
                    .parse(parse_input, parse_config)?
            }
            8 => {
                // course_download_enabled
                self.course_download_enabled
                    .parse(parse_input, parse_config)?
            }
            9 => {
                // workout_download_enabled
                self.workout_download_enabled
                    .parse(parse_input, parse_config)?
            }
            10 => {
                // gps_ephemeris_download_enabled
                self.gps_ephemeris_download_enabled
                    .parse(parse_input, parse_config)?
            }
            11 => {
                // incident_detection_enabled
                self.incident_detection_enabled
                    .parse(parse_input, parse_config)?
            }
            12 => {
                // grouptrack_enabled
                self.grouptrack_enabled.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageConnectivity {
    fn message_name(&self) -> &'static str {
        return "FitMessageConnectivity";
    }
}

#[derive(Debug)]
pub struct FitMessageCourse {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub name: FitFieldBasicValue<FitString>,
    pub capabilities: FitFieldBasicValue<FitFieldCourseCapabilities>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
}

impl fmt::Display for FitMessageCourse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCourse")?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.capabilities, "capabilities", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCourse {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            4 => "sport",
            5 => "name",
            6 => "capabilities",
            7 => "sub_sport",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageCourse> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageCourse {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageCourse",
            sport: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
            capabilities: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageCourse), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            4 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            5 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            6 => {
                // capabilities
                self.capabilities.parse(parse_input, parse_config)?
            }
            7 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageCourse {
    fn message_name(&self) -> &'static str {
        return "FitMessageCourse";
    }
}

#[derive(Debug)]
pub struct FitMessageCoursePoint {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub position_lat: FitFieldAdjustedValue<FitSint32>,
    pub position_long: FitFieldAdjustedValue<FitSint32>,
    pub distance: FitFieldAdjustedValue<FitUint32>,
    pub ftype: FitFieldBasicValue<FitFieldCoursePoint>,
    pub name: FitFieldBasicValue<FitString>,
    pub favorite: FitFieldBasicValue<FitBool>,
}

impl fmt::Display for FitMessageCoursePoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCoursePoint")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.position_lat, "position_lat", true, f)?;
        fmt_message_field!(self.position_long, "position_long", true, f)?;
        fmt_message_field!(self.distance, "distance", true, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.favorite, "favorite", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCoursePoint {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            1 => "timestamp",
            2 => "position_lat",
            3 => "position_long",
            4 => "distance",
            5 => "ftype",
            6 => "name",
            8 => "favorite",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageCoursePoint> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageCoursePoint {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageCoursePoint",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
            favorite: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageCoursePoint),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            1 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            2 => {
                // position_lat
                self.position_lat.parse(parse_input, parse_config)?
            }
            3 => {
                // position_long
                self.position_long.parse(parse_input, parse_config)?
            }
            4 => {
                // distance
                self.distance.parse(parse_input, parse_config)?
            }
            5 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            6 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            8 => {
                // favorite
                self.favorite.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageCoursePoint {
    fn message_name(&self) -> &'static str {
        return "FitMessageCoursePoint";
    }
}

#[derive(Debug)]
pub struct FitMessageDeveloperDataId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub developer_id: FitFieldBasicValue<FitByte>,
    pub application_id: FitFieldBasicValue<FitByte>,
    pub manufacturer_id: FitFieldBasicValue<FitFieldManufacturer>,
    pub developer_data_index: FitFieldBasicValue<FitUint8>,
    pub application_version: FitFieldBasicValue<FitUint32>,
}

impl fmt::Display for FitMessageDeveloperDataId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDeveloperDataId")?;
        fmt_message_field!(self.developer_id, "developer_id", false, f)?;
        fmt_message_field!(self.application_id, "application_id", false, f)?;
        fmt_message_field!(self.manufacturer_id, "manufacturer_id", false, f)?;
        fmt_message_field!(self.developer_data_index, "developer_data_index", false, f)?;
        fmt_message_field!(self.application_version, "application_version", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDeveloperDataId {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "developer_id",
            1 => "application_id",
            2 => "manufacturer_id",
            3 => "developer_data_index",
            4 => "application_version",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDeveloperDataId> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDeveloperDataId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageDeveloperDataId",
            developer_id: FitFieldBasicValue::new_single("".to_string()),
            application_id: FitFieldBasicValue::new_single("".to_string()),
            manufacturer_id: FitFieldBasicValue::new_single("".to_string()),
            developer_data_index: FitFieldBasicValue::new_single("".to_string()),
            application_version: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDeveloperDataId),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // developer_id
                self.developer_id.parse(parse_input, parse_config)?
            }
            1 => {
                // application_id
                self.application_id.parse(parse_input, parse_config)?
            }
            2 => {
                // manufacturer_id
                self.manufacturer_id.parse(parse_input, parse_config)?
            }
            3 => {
                // developer_data_index
                self.developer_data_index.parse(parse_input, parse_config)?
            }
            4 => {
                // application_version
                self.application_version.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDeveloperDataId {
    fn message_name(&self) -> &'static str {
        return "FitMessageDeveloperDataId";
    }
}

#[derive(Debug)]
pub enum FitMessageDeviceInfoSubfieldDeviceType {
    NotYetParsed,
    Default(FitUint8),
    AntplusDeviceType(FitFieldAntplusDeviceType),
    AntDeviceType(FitUint8),
}

impl FitMessageDeviceInfoSubfieldDeviceType {
    fn parse<'a>(
        message: &FitMessageDeviceInfo,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageDeviceInfoSubfieldDeviceType, Vec<FitParseConfig>)> {
        match message.source_type.get_single()? {
            FitFieldSourceType::Antplus => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldAntplusDeviceType>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDeviceInfoSubfieldDeviceType::AntplusDeviceType(val),
                    new_actions,
                ));
            }

            FitFieldSourceType::Ant => {
                let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDeviceInfoSubfieldDeviceType::AntDeviceType(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageDeviceInfoSubfieldDeviceType::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub enum FitMessageDeviceInfoSubfieldProduct {
    NotYetParsed,
    Default(FitUint16),
    GarminProduct(FitFieldGarminProduct),
    FaveroProduct(FitFieldFaveroProduct),
}

impl FitMessageDeviceInfoSubfieldProduct {
    fn parse<'a>(
        message: &FitMessageDeviceInfo,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageDeviceInfoSubfieldProduct, Vec<FitParseConfig>)> {
        match message.manufacturer.get_single()? {
            FitFieldManufacturer::FaveroElectronics => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldFaveroProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDeviceInfoSubfieldProduct::FaveroProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Garmin => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDeviceInfoSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Dynastream => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDeviceInfoSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::DynastreamOem => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDeviceInfoSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageDeviceInfoSubfieldProduct::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageDeviceInfo {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub device_index: FitFieldBasicValue<FitFieldDeviceIndex>,
    pub device_type_subfield_bytes: Vec<u8>,
    pub device_type: FitMessageDeviceInfoSubfieldDeviceType,
    pub manufacturer: FitFieldBasicValue<FitFieldManufacturer>,
    pub serial_number: FitFieldBasicValue<FitUint32z>,
    pub product_subfield_bytes: Vec<u8>,
    pub product: FitMessageDeviceInfoSubfieldProduct,
    pub software_version: FitFieldAdjustedValue<FitUint16>,
    pub hardware_version: FitFieldBasicValue<FitUint8>,
    pub cum_operating_time: FitFieldBasicValue<FitUint32>, // Reset by new battery or charge.
    pub battery_voltage: FitFieldAdjustedValue<FitUint16>,
    pub battery_status: FitFieldBasicValue<FitFieldBatteryStatus>,
    pub sensor_position: FitFieldBasicValue<FitFieldBodyLocation>, // Indicates the location of the sensor
    pub descriptor: FitFieldBasicValue<FitString>, // Used to describe the sensor or location
    pub ant_transmission_type: FitFieldBasicValue<FitUint8z>,
    pub ant_device_number: FitFieldBasicValue<FitUint16z>,
    pub ant_network: FitFieldBasicValue<FitFieldAntNetwork>,
    pub source_type: FitFieldBasicValue<FitFieldSourceType>,
    pub product_name: FitFieldBasicValue<FitString>, // Optional free form string to indicate the devices name or model
}

impl fmt::Display for FitMessageDeviceInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDeviceInfo")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.device_index, "device_index", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "device_type_subfield_bytes", self.device_type_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "device_type", self.device_type)?;
        fmt_message_field!(self.manufacturer, "manufacturer", false, f)?;
        fmt_message_field!(self.serial_number, "serial_number", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "product_subfield_bytes", self.product_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "product", self.product)?;
        fmt_message_field!(self.software_version, "software_version", true, f)?;
        fmt_message_field!(self.hardware_version, "hardware_version", false, f)?;
        fmt_message_field!(self.cum_operating_time, "cum_operating_time", false, f)?;
        fmt_message_field!(self.battery_voltage, "battery_voltage", true, f)?;
        fmt_message_field!(self.battery_status, "battery_status", false, f)?;
        fmt_message_field!(self.sensor_position, "sensor_position", false, f)?;
        fmt_message_field!(self.descriptor, "descriptor", false, f)?;
        fmt_message_field!(
            self.ant_transmission_type,
            "ant_transmission_type",
            false,
            f
        )?;
        fmt_message_field!(self.ant_device_number, "ant_device_number", false, f)?;
        fmt_message_field!(self.ant_network, "ant_network", false, f)?;
        fmt_message_field!(self.source_type, "source_type", false, f)?;
        fmt_message_field!(self.product_name, "product_name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDeviceInfo {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "device_index",
            1 => "device_type",
            2 => "manufacturer",
            3 => "serial_number",
            4 => "product",
            5 => "software_version",
            6 => "hardware_version",
            7 => "cum_operating_time",
            10 => "battery_voltage",
            11 => "battery_status",
            18 => "sensor_position",
            19 => "descriptor",
            20 => "ant_transmission_type",
            21 => "ant_device_number",
            22 => "ant_network",
            25 => "source_type",
            27 => "product_name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDeviceInfo> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDeviceInfo {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![1, 4],
            message_name: "FitMessageDeviceInfo",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            device_index: FitFieldBasicValue::new_single("".to_string()),
            device_type_subfield_bytes: vec![],
            device_type: FitMessageDeviceInfoSubfieldDeviceType::NotYetParsed,
            manufacturer: FitFieldBasicValue::new_single("".to_string()),
            serial_number: FitFieldBasicValue::new_single("".to_string()),
            product_subfield_bytes: vec![],
            product: FitMessageDeviceInfoSubfieldProduct::NotYetParsed,
            software_version: FitFieldAdjustedValue::new_single("".to_string(), 100.0, 0.0),
            hardware_version: FitFieldBasicValue::new_single("".to_string()),
            cum_operating_time: FitFieldBasicValue::new_single("s".to_string()),
            battery_voltage: FitFieldAdjustedValue::new_single("V".to_string(), 256.0, 0.0),
            battery_status: FitFieldBasicValue::new_single("".to_string()),
            sensor_position: FitFieldBasicValue::new_single("".to_string()),
            descriptor: FitFieldBasicValue::new_single("".to_string()),
            ant_transmission_type: FitFieldBasicValue::new_single("".to_string()),
            ant_device_number: FitFieldBasicValue::new_single("".to_string()),
            ant_network: FitFieldBasicValue::new_single("".to_string()),
            source_type: FitFieldBasicValue::new_single("".to_string()),
            product_name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDeviceInfo),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // device_index
                self.device_index.parse(parse_input, parse_config)?
            }
            1 => {
                // device_type
                self.device_type_subfield_bytes = parse_uint8_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            2 => {
                // manufacturer
                self.manufacturer.parse(parse_input, parse_config)?
            }
            3 => {
                // serial_number
                self.serial_number.parse(parse_input, parse_config)?
            }
            4 => {
                // product
                self.product_subfield_bytes = parse_uint16_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            5 => {
                // software_version
                self.software_version.parse(parse_input, parse_config)?
            }
            6 => {
                // hardware_version
                self.hardware_version.parse(parse_input, parse_config)?
            }
            7 => {
                // cum_operating_time
                self.cum_operating_time.parse(parse_input, parse_config)?
            }
            10 => {
                // battery_voltage
                self.battery_voltage.parse(parse_input, parse_config)?
            }
            11 => {
                // battery_status
                self.battery_status.parse(parse_input, parse_config)?
            }
            18 => {
                // sensor_position
                self.sensor_position.parse(parse_input, parse_config)?
            }
            19 => {
                // descriptor
                self.descriptor.parse(parse_input, parse_config)?
            }
            20 => {
                // ant_transmission_type
                self.ant_transmission_type
                    .parse(parse_input, parse_config)?
            }
            21 => {
                // ant_device_number
                self.ant_device_number.parse(parse_input, parse_config)?
            }
            22 => {
                // ant_network
                self.ant_network.parse(parse_input, parse_config)?
            }
            25 => {
                // source_type
                self.source_type.parse(parse_input, parse_config)?
            }
            27 => {
                // product_name
                self.product_name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            1 => {
                let (val, new_actions) = FitMessageDeviceInfoSubfieldDeviceType::parse(
                    &self,
                    &self.device_type_subfield_bytes,
                    &parse_config,
                )?;
                self.device_type = val;
                new_actions
            }

            4 => {
                let (val, new_actions) = FitMessageDeviceInfoSubfieldProduct::parse(
                    &self,
                    &self.product_subfield_bytes,
                    &parse_config,
                )?;
                self.product = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDeviceInfo {
    fn message_name(&self) -> &'static str {
        return "FitMessageDeviceInfo";
    }
}

#[derive(Debug)]
pub struct FitMessageDeviceSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub active_time_zone: FitFieldBasicValue<FitUint8>, // Index into time zone arrays.
    pub utc_offset: FitFieldBasicValue<FitUint32>, // Offset from system time. Required to convert timestamp from system time to UTC.
    pub time_offset: FitFieldBasicValue<FitUint32>, // Offset from system time.
    pub time_mode: FitFieldBasicValue<FitFieldTimeMode>, // Display mode for the time
    pub time_zone_offset: FitFieldAdjustedValue<FitSint8>, // timezone offset in 1/4 hour increments
    pub backlight_mode: FitFieldBasicValue<FitFieldBacklightMode>, // Mode for backlight
    pub activity_tracker_enabled: FitFieldBasicValue<FitBool>, // Enabled state of the activity tracker functionality
    pub clock_time: FitFieldBasicValue<FitFieldDateTime>, // UTC timestamp used to set the devices clock and date
    pub pages_enabled: FitFieldBasicValue<FitUint16>, // Bitfield  to configure enabled screens for each supported loop
    pub move_alert_enabled: FitFieldBasicValue<FitBool>, // Enabled state of the move alert
    pub date_mode: FitFieldBasicValue<FitFieldDateMode>, // Display mode for the date
    pub display_orientation: FitFieldBasicValue<FitFieldDisplayOrientation>,
    pub mounting_side: FitFieldBasicValue<FitFieldSide>,
    pub default_page: FitFieldBasicValue<FitUint16>, // Bitfield to indicate one page as default for each supported loop
    pub autosync_min_steps: FitFieldBasicValue<FitUint16>, // Minimum steps before an autosync can occur
    pub autosync_min_time: FitFieldBasicValue<FitUint16>, // Minimum minutes before an autosync can occur
    pub lactate_threshold_autodetect_enabled: FitFieldBasicValue<FitBool>, // Enable auto-detect setting for the lactate threshold feature.
    pub ble_auto_upload_enabled: FitFieldBasicValue<FitBool>, // Automatically upload using BLE
    pub auto_sync_frequency: FitFieldBasicValue<FitFieldAutoSyncFrequency>, // Helps to conserve battery by changing modes
    pub auto_activity_detect: FitFieldBasicValue<FitFieldAutoActivityDetect>, // Allows setting specific activities auto-activity detect enabled/disabled settings
    pub number_of_screens: FitFieldBasicValue<FitUint8>, // Number of screens configured to display
    pub smart_notification_display_orientation: FitFieldBasicValue<FitFieldDisplayOrientation>, // Smart Notification display orientation
    pub tap_interface: FitFieldBasicValue<FitFieldSwitch>,
}

impl fmt::Display for FitMessageDeviceSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDeviceSettings")?;
        fmt_message_field!(self.active_time_zone, "active_time_zone", false, f)?;
        fmt_message_field!(self.utc_offset, "utc_offset", false, f)?;
        fmt_message_field!(self.time_offset, "time_offset", false, f)?;
        fmt_message_field!(self.time_mode, "time_mode", false, f)?;
        fmt_message_field!(self.time_zone_offset, "time_zone_offset", true, f)?;
        fmt_message_field!(self.backlight_mode, "backlight_mode", false, f)?;
        fmt_message_field!(
            self.activity_tracker_enabled,
            "activity_tracker_enabled",
            false,
            f
        )?;
        fmt_message_field!(self.clock_time, "clock_time", false, f)?;
        fmt_message_field!(self.pages_enabled, "pages_enabled", false, f)?;
        fmt_message_field!(self.move_alert_enabled, "move_alert_enabled", false, f)?;
        fmt_message_field!(self.date_mode, "date_mode", false, f)?;
        fmt_message_field!(self.display_orientation, "display_orientation", false, f)?;
        fmt_message_field!(self.mounting_side, "mounting_side", false, f)?;
        fmt_message_field!(self.default_page, "default_page", false, f)?;
        fmt_message_field!(self.autosync_min_steps, "autosync_min_steps", false, f)?;
        fmt_message_field!(self.autosync_min_time, "autosync_min_time", false, f)?;
        fmt_message_field!(
            self.lactate_threshold_autodetect_enabled,
            "lactate_threshold_autodetect_enabled",
            false,
            f
        )?;
        fmt_message_field!(
            self.ble_auto_upload_enabled,
            "ble_auto_upload_enabled",
            false,
            f
        )?;
        fmt_message_field!(self.auto_sync_frequency, "auto_sync_frequency", false, f)?;
        fmt_message_field!(self.auto_activity_detect, "auto_activity_detect", false, f)?;
        fmt_message_field!(self.number_of_screens, "number_of_screens", false, f)?;
        fmt_message_field!(
            self.smart_notification_display_orientation,
            "smart_notification_display_orientation",
            false,
            f
        )?;
        fmt_message_field!(self.tap_interface, "tap_interface", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDeviceSettings {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "active_time_zone",
            1 => "utc_offset",
            2 => "time_offset",
            4 => "time_mode",
            5 => "time_zone_offset",
            12 => "backlight_mode",
            36 => "activity_tracker_enabled",
            39 => "clock_time",
            40 => "pages_enabled",
            46 => "move_alert_enabled",
            47 => "date_mode",
            55 => "display_orientation",
            56 => "mounting_side",
            57 => "default_page",
            58 => "autosync_min_steps",
            59 => "autosync_min_time",
            80 => "lactate_threshold_autodetect_enabled",
            86 => "ble_auto_upload_enabled",
            89 => "auto_sync_frequency",
            90 => "auto_activity_detect",
            94 => "number_of_screens",
            95 => "smart_notification_display_orientation",
            134 => "tap_interface",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDeviceSettings> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDeviceSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageDeviceSettings",
            active_time_zone: FitFieldBasicValue::new_single("".to_string()),
            utc_offset: FitFieldBasicValue::new_single("".to_string()),
            time_offset: FitFieldBasicValue::new_vec("s".to_string()),
            time_mode: FitFieldBasicValue::new_vec("".to_string()),
            time_zone_offset: FitFieldAdjustedValue::new_vec("hr".to_string(), 4.0, 0.0),
            backlight_mode: FitFieldBasicValue::new_single("".to_string()),
            activity_tracker_enabled: FitFieldBasicValue::new_single("".to_string()),
            clock_time: FitFieldBasicValue::new_single("".to_string()),
            pages_enabled: FitFieldBasicValue::new_vec("".to_string()),
            move_alert_enabled: FitFieldBasicValue::new_single("".to_string()),
            date_mode: FitFieldBasicValue::new_single("".to_string()),
            display_orientation: FitFieldBasicValue::new_single("".to_string()),
            mounting_side: FitFieldBasicValue::new_single("".to_string()),
            default_page: FitFieldBasicValue::new_vec("".to_string()),
            autosync_min_steps: FitFieldBasicValue::new_single("steps".to_string()),
            autosync_min_time: FitFieldBasicValue::new_single("minutes".to_string()),
            lactate_threshold_autodetect_enabled: FitFieldBasicValue::new_single("".to_string()),
            ble_auto_upload_enabled: FitFieldBasicValue::new_single("".to_string()),
            auto_sync_frequency: FitFieldBasicValue::new_single("".to_string()),
            auto_activity_detect: FitFieldBasicValue::new_single("".to_string()),
            number_of_screens: FitFieldBasicValue::new_single("".to_string()),
            smart_notification_display_orientation: FitFieldBasicValue::new_single("".to_string()),
            tap_interface: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDeviceSettings),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // active_time_zone
                self.active_time_zone.parse(parse_input, parse_config)?
            }
            1 => {
                // utc_offset
                self.utc_offset.parse(parse_input, parse_config)?
            }
            2 => {
                // time_offset
                self.time_offset.parse(parse_input, parse_config)?
            }
            4 => {
                // time_mode
                self.time_mode.parse(parse_input, parse_config)?
            }
            5 => {
                // time_zone_offset
                self.time_zone_offset.parse(parse_input, parse_config)?
            }
            12 => {
                // backlight_mode
                self.backlight_mode.parse(parse_input, parse_config)?
            }
            36 => {
                // activity_tracker_enabled
                self.activity_tracker_enabled
                    .parse(parse_input, parse_config)?
            }
            39 => {
                // clock_time
                self.clock_time.parse(parse_input, parse_config)?
            }
            40 => {
                // pages_enabled
                self.pages_enabled.parse(parse_input, parse_config)?
            }
            46 => {
                // move_alert_enabled
                self.move_alert_enabled.parse(parse_input, parse_config)?
            }
            47 => {
                // date_mode
                self.date_mode.parse(parse_input, parse_config)?
            }
            55 => {
                // display_orientation
                self.display_orientation.parse(parse_input, parse_config)?
            }
            56 => {
                // mounting_side
                self.mounting_side.parse(parse_input, parse_config)?
            }
            57 => {
                // default_page
                self.default_page.parse(parse_input, parse_config)?
            }
            58 => {
                // autosync_min_steps
                self.autosync_min_steps.parse(parse_input, parse_config)?
            }
            59 => {
                // autosync_min_time
                self.autosync_min_time.parse(parse_input, parse_config)?
            }
            80 => {
                // lactate_threshold_autodetect_enabled
                self.lactate_threshold_autodetect_enabled
                    .parse(parse_input, parse_config)?
            }
            86 => {
                // ble_auto_upload_enabled
                self.ble_auto_upload_enabled
                    .parse(parse_input, parse_config)?
            }
            89 => {
                // auto_sync_frequency
                self.auto_sync_frequency.parse(parse_input, parse_config)?
            }
            90 => {
                // auto_activity_detect
                self.auto_activity_detect.parse(parse_input, parse_config)?
            }
            94 => {
                // number_of_screens
                self.number_of_screens.parse(parse_input, parse_config)?
            }
            95 => {
                // smart_notification_display_orientation
                self.smart_notification_display_orientation
                    .parse(parse_input, parse_config)?
            }
            134 => {
                // tap_interface
                self.tap_interface.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDeviceSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageDeviceSettings";
    }
}

#[derive(Debug)]
pub struct FitMessageDiveAlarm {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>, // Index of the alarm
    pub depth: FitFieldAdjustedValue<FitUint32>,
    pub time: FitFieldAdjustedValue<FitSint32>,
    pub enabled: FitFieldBasicValue<FitBool>,
    pub alarm_type: FitFieldBasicValue<FitFieldDiveAlarmType>,
    pub sound: FitFieldBasicValue<FitFieldTone>,
    pub dive_types: FitFieldBasicValue<FitFieldSubSport>,
}

impl fmt::Display for FitMessageDiveAlarm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveAlarm")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.depth, "depth", true, f)?;
        fmt_message_field!(self.time, "time", true, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(self.alarm_type, "alarm_type", false, f)?;
        fmt_message_field!(self.sound, "sound", false, f)?;
        fmt_message_field!(self.dive_types, "dive_types", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveAlarm {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "depth",
            1 => "time",
            2 => "enabled",
            3 => "alarm_type",
            4 => "sound",
            5 => "dive_types",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDiveAlarm> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDiveAlarm {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageDiveAlarm",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            depth: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            time: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            alarm_type: FitFieldBasicValue::new_single("".to_string()),
            sound: FitFieldBasicValue::new_single("".to_string()),
            dive_types: FitFieldBasicValue::new_vec("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDiveAlarm),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // depth
                self.depth.parse(parse_input, parse_config)?
            }
            1 => {
                // time
                self.time.parse(parse_input, parse_config)?
            }
            2 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            3 => {
                // alarm_type
                self.alarm_type.parse(parse_input, parse_config)?
            }
            4 => {
                // sound
                self.sound.parse(parse_input, parse_config)?
            }
            5 => {
                // dive_types
                self.dive_types.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveAlarm {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveAlarm";
    }
}

#[derive(Debug)]
pub struct FitMessageDiveGas {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub helium_content: FitFieldBasicValue<FitUint8>,
    pub oxygen_content: FitFieldBasicValue<FitUint8>,
    pub status: FitFieldBasicValue<FitFieldDiveGasStatus>,
}

impl fmt::Display for FitMessageDiveGas {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveGas")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.helium_content, "helium_content", false, f)?;
        fmt_message_field!(self.oxygen_content, "oxygen_content", false, f)?;
        fmt_message_field!(self.status, "status", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveGas {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "helium_content",
            1 => "oxygen_content",
            2 => "status",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDiveGas> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDiveGas {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageDiveGas",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            helium_content: FitFieldBasicValue::new_single("percent".to_string()),
            oxygen_content: FitFieldBasicValue::new_single("percent".to_string()),
            status: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDiveGas),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // helium_content
                self.helium_content.parse(parse_input, parse_config)?
            }
            1 => {
                // oxygen_content
                self.oxygen_content.parse(parse_input, parse_config)?
            }
            2 => {
                // status
                self.status.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveGas {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveGas";
    }
}

#[derive(Debug)]
pub enum FitMessageDiveSettingsSubfieldHeartRateSource {
    NotYetParsed,
    Default(FitUint8),
    HeartRateLocalDeviceType(FitFieldLocalDeviceType),
    HeartRateAntplusDeviceType(FitFieldAntplusDeviceType),
}

impl FitMessageDiveSettingsSubfieldHeartRateSource {
    fn parse<'a>(
        message: &FitMessageDiveSettings,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageDiveSettingsSubfieldHeartRateSource,
        Vec<FitParseConfig>,
    )> {
        match message.heart_rate_source_type.get_single()? {
            FitFieldSourceType::Antplus => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldAntplusDeviceType>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDiveSettingsSubfieldHeartRateSource::HeartRateAntplusDeviceType(val),
                    new_actions,
                ));
            }

            FitFieldSourceType::Local => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldLocalDeviceType>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageDiveSettingsSubfieldHeartRateSource::HeartRateLocalDeviceType(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageDiveSettingsSubfieldHeartRateSource::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageDiveSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub name: FitFieldBasicValue<FitString>,
    pub model: FitFieldBasicValue<FitFieldTissueModelType>,
    pub gf_low: FitFieldBasicValue<FitUint8>,
    pub gf_high: FitFieldBasicValue<FitUint8>,
    pub water_type: FitFieldBasicValue<FitFieldWaterType>,
    pub water_density: FitFieldBasicValue<FitFloat32>, // Fresh water is usually 1000; salt water is usually 1025
    pub po2_warn: FitFieldAdjustedValue<FitUint8>,     // Typically 1.40
    pub po2_critical: FitFieldAdjustedValue<FitUint8>, // Typically 1.60
    pub po2_deco: FitFieldAdjustedValue<FitUint8>,
    pub safety_stop_enabled: FitFieldBasicValue<FitBool>,
    pub bottom_depth: FitFieldBasicValue<FitFloat32>,
    pub bottom_time: FitFieldBasicValue<FitUint32>,
    pub apnea_countdown_enabled: FitFieldBasicValue<FitBool>,
    pub apnea_countdown_time: FitFieldBasicValue<FitUint32>,
    pub backlight_mode: FitFieldBasicValue<FitFieldDiveBacklightMode>,
    pub backlight_brightness: FitFieldBasicValue<FitUint8>,
    pub backlight_timeout: FitFieldBasicValue<FitFieldBacklightTimeout>,
    pub repeat_dive_interval: FitFieldAdjustedValue<FitUint16>, // Time between surfacing and ending the activity
    pub safety_stop_time: FitFieldAdjustedValue<FitUint16>,     // Time at safety stop (if enabled)
    pub heart_rate_source_type: FitFieldBasicValue<FitFieldSourceType>,
    pub heart_rate_source_subfield_bytes: Vec<u8>,
    pub heart_rate_source: FitMessageDiveSettingsSubfieldHeartRateSource,
}

impl fmt::Display for FitMessageDiveSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveSettings")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.model, "model", false, f)?;
        fmt_message_field!(self.gf_low, "gf_low", false, f)?;
        fmt_message_field!(self.gf_high, "gf_high", false, f)?;
        fmt_message_field!(self.water_type, "water_type", false, f)?;
        fmt_message_field!(self.water_density, "water_density", false, f)?;
        fmt_message_field!(self.po2_warn, "po2_warn", true, f)?;
        fmt_message_field!(self.po2_critical, "po2_critical", true, f)?;
        fmt_message_field!(self.po2_deco, "po2_deco", true, f)?;
        fmt_message_field!(self.safety_stop_enabled, "safety_stop_enabled", false, f)?;
        fmt_message_field!(self.bottom_depth, "bottom_depth", false, f)?;
        fmt_message_field!(self.bottom_time, "bottom_time", false, f)?;
        fmt_message_field!(
            self.apnea_countdown_enabled,
            "apnea_countdown_enabled",
            false,
            f
        )?;
        fmt_message_field!(self.apnea_countdown_time, "apnea_countdown_time", false, f)?;
        fmt_message_field!(self.backlight_mode, "backlight_mode", false, f)?;
        fmt_message_field!(self.backlight_brightness, "backlight_brightness", false, f)?;
        fmt_message_field!(self.backlight_timeout, "backlight_timeout", false, f)?;
        fmt_message_field!(self.repeat_dive_interval, "repeat_dive_interval", true, f)?;
        fmt_message_field!(self.safety_stop_time, "safety_stop_time", true, f)?;
        fmt_message_field!(
            self.heart_rate_source_type,
            "heart_rate_source_type",
            false,
            f
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "heart_rate_source_subfield_bytes", self.heart_rate_source_subfield_bytes
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "heart_rate_source", self.heart_rate_source
        )?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveSettings {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "name",
            1 => "model",
            2 => "gf_low",
            3 => "gf_high",
            4 => "water_type",
            5 => "water_density",
            6 => "po2_warn",
            7 => "po2_critical",
            8 => "po2_deco",
            9 => "safety_stop_enabled",
            10 => "bottom_depth",
            11 => "bottom_time",
            12 => "apnea_countdown_enabled",
            13 => "apnea_countdown_time",
            14 => "backlight_mode",
            15 => "backlight_brightness",
            16 => "backlight_timeout",
            17 => "repeat_dive_interval",
            18 => "safety_stop_time",
            19 => "heart_rate_source_type",
            20 => "heart_rate_source",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDiveSettings> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDiveSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![20],
            message_name: "FitMessageDiveSettings",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
            model: FitFieldBasicValue::new_single("".to_string()),
            gf_low: FitFieldBasicValue::new_single("percent".to_string()),
            gf_high: FitFieldBasicValue::new_single("percent".to_string()),
            water_type: FitFieldBasicValue::new_single("".to_string()),
            water_density: FitFieldBasicValue::new_single("kg/m^3".to_string()),
            po2_warn: FitFieldAdjustedValue::new_single("percent".to_string(), 100.0, 0.0),
            po2_critical: FitFieldAdjustedValue::new_single("percent".to_string(), 100.0, 0.0),
            po2_deco: FitFieldAdjustedValue::new_single("percent".to_string(), 100.0, 0.0),
            safety_stop_enabled: FitFieldBasicValue::new_single("".to_string()),
            bottom_depth: FitFieldBasicValue::new_single("".to_string()),
            bottom_time: FitFieldBasicValue::new_single("".to_string()),
            apnea_countdown_enabled: FitFieldBasicValue::new_single("".to_string()),
            apnea_countdown_time: FitFieldBasicValue::new_single("".to_string()),
            backlight_mode: FitFieldBasicValue::new_single("".to_string()),
            backlight_brightness: FitFieldBasicValue::new_single("".to_string()),
            backlight_timeout: FitFieldBasicValue::new_single("".to_string()),
            repeat_dive_interval: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            safety_stop_time: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            heart_rate_source_type: FitFieldBasicValue::new_single("".to_string()),
            heart_rate_source_subfield_bytes: vec![],
            heart_rate_source: FitMessageDiveSettingsSubfieldHeartRateSource::NotYetParsed,
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDiveSettings),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            1 => {
                // model
                self.model.parse(parse_input, parse_config)?
            }
            2 => {
                // gf_low
                self.gf_low.parse(parse_input, parse_config)?
            }
            3 => {
                // gf_high
                self.gf_high.parse(parse_input, parse_config)?
            }
            4 => {
                // water_type
                self.water_type.parse(parse_input, parse_config)?
            }
            5 => {
                // water_density
                self.water_density.parse(parse_input, parse_config)?
            }
            6 => {
                // po2_warn
                self.po2_warn.parse(parse_input, parse_config)?
            }
            7 => {
                // po2_critical
                self.po2_critical.parse(parse_input, parse_config)?
            }
            8 => {
                // po2_deco
                self.po2_deco.parse(parse_input, parse_config)?
            }
            9 => {
                // safety_stop_enabled
                self.safety_stop_enabled.parse(parse_input, parse_config)?
            }
            10 => {
                // bottom_depth
                self.bottom_depth.parse(parse_input, parse_config)?
            }
            11 => {
                // bottom_time
                self.bottom_time.parse(parse_input, parse_config)?
            }
            12 => {
                // apnea_countdown_enabled
                self.apnea_countdown_enabled
                    .parse(parse_input, parse_config)?
            }
            13 => {
                // apnea_countdown_time
                self.apnea_countdown_time.parse(parse_input, parse_config)?
            }
            14 => {
                // backlight_mode
                self.backlight_mode.parse(parse_input, parse_config)?
            }
            15 => {
                // backlight_brightness
                self.backlight_brightness.parse(parse_input, parse_config)?
            }
            16 => {
                // backlight_timeout
                self.backlight_timeout.parse(parse_input, parse_config)?
            }
            17 => {
                // repeat_dive_interval
                self.repeat_dive_interval.parse(parse_input, parse_config)?
            }
            18 => {
                // safety_stop_time
                self.safety_stop_time.parse(parse_input, parse_config)?
            }
            19 => {
                // heart_rate_source_type
                self.heart_rate_source_type
                    .parse(parse_input, parse_config)?
            }
            20 => {
                // heart_rate_source
                self.heart_rate_source_subfield_bytes =
                    parse_uint8_as_bytes(parse_input, parse_config)?;
                vec![]
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            20 => {
                let (val, new_actions) = FitMessageDiveSettingsSubfieldHeartRateSource::parse(
                    &self,
                    &self.heart_rate_source_subfield_bytes,
                    &parse_config,
                )?;
                self.heart_rate_source = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveSettings";
    }
}

#[derive(Debug)]
pub struct FitMessageDiveSummary {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub reference_mesg: FitFieldBasicValue<FitFieldMesgNum>,
    pub reference_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub avg_depth: FitFieldAdjustedValue<FitUint32>, // 0 if above water
    pub max_depth: FitFieldAdjustedValue<FitUint32>, // 0 if above water
    pub surface_interval: FitFieldAdjustedValue<FitUint32>, // Time since end of last dive
    pub start_cns: FitFieldAdjustedValue<FitUint8>,
    pub end_cns: FitFieldAdjustedValue<FitUint8>,
    pub start_n2: FitFieldAdjustedValue<FitUint16>,
    pub end_n2: FitFieldAdjustedValue<FitUint16>,
    pub o2_toxicity: FitFieldBasicValue<FitUint16>,
    pub dive_number: FitFieldBasicValue<FitUint32>,
    pub bottom_time: FitFieldAdjustedValue<FitUint32>,
}

impl fmt::Display for FitMessageDiveSummary {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveSummary")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.reference_mesg, "reference_mesg", false, f)?;
        fmt_message_field!(self.reference_index, "reference_index", false, f)?;
        fmt_message_field!(self.avg_depth, "avg_depth", true, f)?;
        fmt_message_field!(self.max_depth, "max_depth", true, f)?;
        fmt_message_field!(self.surface_interval, "surface_interval", true, f)?;
        fmt_message_field!(self.start_cns, "start_cns", true, f)?;
        fmt_message_field!(self.end_cns, "end_cns", true, f)?;
        fmt_message_field!(self.start_n2, "start_n2", true, f)?;
        fmt_message_field!(self.end_n2, "end_n2", true, f)?;
        fmt_message_field!(self.o2_toxicity, "o2_toxicity", false, f)?;
        fmt_message_field!(self.dive_number, "dive_number", false, f)?;
        fmt_message_field!(self.bottom_time, "bottom_time", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveSummary {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "reference_mesg",
            1 => "reference_index",
            2 => "avg_depth",
            3 => "max_depth",
            4 => "surface_interval",
            5 => "start_cns",
            6 => "end_cns",
            7 => "start_n2",
            8 => "end_n2",
            9 => "o2_toxicity",
            10 => "dive_number",
            11 => "bottom_time",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageDiveSummary> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageDiveSummary {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageDiveSummary",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            reference_mesg: FitFieldBasicValue::new_single("".to_string()),
            reference_index: FitFieldBasicValue::new_single("".to_string()),
            avg_depth: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            max_depth: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            surface_interval: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            start_cns: FitFieldAdjustedValue::new_single("percent".to_string(), 1.0, 0.0),
            end_cns: FitFieldAdjustedValue::new_single("percent".to_string(), 1.0, 0.0),
            start_n2: FitFieldAdjustedValue::new_single("percent".to_string(), 1.0, 0.0),
            end_n2: FitFieldAdjustedValue::new_single("percent".to_string(), 1.0, 0.0),
            o2_toxicity: FitFieldBasicValue::new_single("OTUs".to_string()),
            dive_number: FitFieldBasicValue::new_single("".to_string()),
            bottom_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageDiveSummary),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // reference_mesg
                self.reference_mesg.parse(parse_input, parse_config)?
            }
            1 => {
                // reference_index
                self.reference_index.parse(parse_input, parse_config)?
            }
            2 => {
                // avg_depth
                self.avg_depth.parse(parse_input, parse_config)?
            }
            3 => {
                // max_depth
                self.max_depth.parse(parse_input, parse_config)?
            }
            4 => {
                // surface_interval
                self.surface_interval.parse(parse_input, parse_config)?
            }
            5 => {
                // start_cns
                self.start_cns.parse(parse_input, parse_config)?
            }
            6 => {
                // end_cns
                self.end_cns.parse(parse_input, parse_config)?
            }
            7 => {
                // start_n2
                self.start_n2.parse(parse_input, parse_config)?
            }
            8 => {
                // end_n2
                self.end_n2.parse(parse_input, parse_config)?
            }
            9 => {
                // o2_toxicity
                self.o2_toxicity.parse(parse_input, parse_config)?
            }
            10 => {
                // dive_number
                self.dive_number.parse(parse_input, parse_config)?
            }
            11 => {
                // bottom_time
                self.bottom_time.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveSummary {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveSummary";
    }
}

#[derive(Debug)]
pub enum FitMessageEventSubfieldData {
    NotYetParsed,
    Default(FitUint32),
    SpeedHighAlert(FitFloat64),
    SportPoint(FitUint32),
    HrLowAlert(FitUint8),
    GearChangeData(FitUint32),
    HrHighAlert(FitUint8),
    TimeDurationAlert(FitFloat64),
    CadLowAlert(FitUint16),
    PowerLowAlert(FitUint16),
    FitnessEquipmentState(FitFieldFitnessEquipmentState),
    CoursePointIndex(FitFieldMessageIndex),
    VirtualPartnerSpeed(FitFloat64),
    CommTimeout(FitFieldCommTimeoutType),
    TimerTrigger(FitFieldTimerTrigger),
    CalorieDurationAlert(FitUint32),
    RiderPosition(FitFieldRiderPositionType),
    CadHighAlert(FitUint16),
    DistanceDurationAlert(FitFloat64),
    BatteryLevel(FitFloat64),
    PowerHighAlert(FitUint16),
    SpeedLowAlert(FitFloat64),
}

impl FitMessageEventSubfieldData {
    fn parse<'a>(
        message: &FitMessageEvent,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageEventSubfieldData, Vec<FitParseConfig>)> {
        let endianness = parse_config.endianness();

        match message.event.get_single()? {
            FitFieldEvent::Timer => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldTimerTrigger>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::TimerTrigger(val), new_actions));
            }

            FitFieldEvent::CoursePoint => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldMessageIndex>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::CoursePointIndex(val),
                    new_actions,
                ));
            }

            FitFieldEvent::Battery => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint16>::new_single("V".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::BatteryLevel(val), new_actions));
            }

            FitFieldEvent::VirtualPartnerPace => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint16>::new_single("m/s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::VirtualPartnerSpeed(val),
                    new_actions,
                ));
            }

            FitFieldEvent::HrHighAlert => {
                let mut parser = FitFieldBasicValue::<FitUint8>::new_single("bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::HrHighAlert(val), new_actions));
            }

            FitFieldEvent::HrLowAlert => {
                let mut parser = FitFieldBasicValue::<FitUint8>::new_single("bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::HrLowAlert(val), new_actions));
            }

            FitFieldEvent::SpeedHighAlert => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m/s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::SpeedHighAlert(val),
                    new_actions,
                ));
            }

            FitFieldEvent::SpeedLowAlert => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m/s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::SpeedLowAlert(val), new_actions));
            }

            FitFieldEvent::CadHighAlert => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("rpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::CadHighAlert(val), new_actions));
            }

            FitFieldEvent::CadLowAlert => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("rpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::CadLowAlert(val), new_actions));
            }

            FitFieldEvent::PowerHighAlert => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("watts".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::PowerHighAlert(val),
                    new_actions,
                ));
            }

            FitFieldEvent::PowerLowAlert => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("watts".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::PowerLowAlert(val), new_actions));
            }

            FitFieldEvent::TimeDurationAlert => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::TimeDurationAlert(val),
                    new_actions,
                ));
            }

            FitFieldEvent::DistanceDurationAlert => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m".to_string(), 100.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::DistanceDurationAlert(val),
                    new_actions,
                ));
            }

            FitFieldEvent::CalorieDurationAlert => {
                let mut parser =
                    FitFieldBasicValue::<FitUint32>::new_single("calories".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::CalorieDurationAlert(val),
                    new_actions,
                ));
            }

            FitFieldEvent::FitnessEquipment => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldFitnessEquipmentState>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageEventSubfieldData::FitnessEquipmentState(val),
                    new_actions,
                ));
            }

            FitFieldEvent::SportPoint => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![
                    FitParseConfig::new_from_component(
                        7,
                        2,
                        132,
                        endianness,
                        0,
                        16,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        8,
                        2,
                        132,
                        endianness,
                        16,
                        16,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                ]
                .iter()
                .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                .collect();

                return Ok((FitMessageEventSubfieldData::SportPoint(val), new_actions));
            }

            FitFieldEvent::FrontGearChange => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![
                    FitParseConfig::new_from_component(
                        11,
                        1,
                        10,
                        endianness,
                        0,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        12,
                        1,
                        10,
                        endianness,
                        8,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        1,
                        10,
                        endianness,
                        16,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        10,
                        1,
                        10,
                        endianness,
                        24,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                ]
                .iter()
                .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                .collect();

                return Ok((
                    FitMessageEventSubfieldData::GearChangeData(val),
                    new_actions,
                ));
            }

            FitFieldEvent::RearGearChange => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![
                    FitParseConfig::new_from_component(
                        11,
                        1,
                        10,
                        endianness,
                        0,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        12,
                        1,
                        10,
                        endianness,
                        8,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        1,
                        10,
                        endianness,
                        16,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        10,
                        1,
                        10,
                        endianness,
                        24,
                        8,
                        Some((1.0, 0.0)),
                        Some("".to_string()),
                    ),
                ]
                .iter()
                .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                .collect();

                return Ok((
                    FitMessageEventSubfieldData::GearChangeData(val),
                    new_actions,
                ));
            }

            FitFieldEvent::RiderPositionChange => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldRiderPositionType>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::RiderPosition(val), new_actions));
            }

            FitFieldEvent::CommTimeout => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldCommTimeoutType>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageEventSubfieldData::CommTimeout(val), new_actions));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageEventSubfieldData::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageEvent {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub event: FitFieldBasicValue<FitFieldEvent>,
    pub event_type: FitFieldBasicValue<FitFieldEventType>,
    pub data16: FitFieldBasicValue<FitUint16>,
    pub data_subfield_bytes: Vec<u8>,
    pub data: FitMessageEventSubfieldData,
    pub event_group: FitFieldBasicValue<FitUint8>,
    pub score: FitFieldBasicValue<FitUint16>, // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
    pub opponent_score: FitFieldBasicValue<FitUint16>, // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
    pub front_gear_num: FitFieldBasicValue<FitUint8z>, // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Front gear number. 1 is innermost.
    pub front_gear: FitFieldBasicValue<FitUint8z>, // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of front teeth.
    pub rear_gear_num: FitFieldBasicValue<FitUint8z>, // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Rear gear number. 1 is innermost.
    pub rear_gear: FitFieldBasicValue<FitUint8z>, // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of rear teeth.
    pub device_index: FitFieldBasicValue<FitFieldDeviceIndex>,
}

impl fmt::Display for FitMessageEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageEvent")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.event, "event", false, f)?;
        fmt_message_field!(self.event_type, "event_type", false, f)?;
        fmt_message_field!(self.data16, "data16", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "data_subfield_bytes", self.data_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "data", self.data)?;
        fmt_message_field!(self.event_group, "event_group", false, f)?;
        fmt_message_field!(self.score, "score", false, f)?;
        fmt_message_field!(self.opponent_score, "opponent_score", false, f)?;
        fmt_message_field!(self.front_gear_num, "front_gear_num", false, f)?;
        fmt_message_field!(self.front_gear, "front_gear", false, f)?;
        fmt_message_field!(self.rear_gear_num, "rear_gear_num", false, f)?;
        fmt_message_field!(self.rear_gear, "rear_gear", false, f)?;
        fmt_message_field!(self.device_index, "device_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageEvent {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "event",
            1 => "event_type",
            2 => "data16",
            3 => "data",
            4 => "event_group",
            7 => "score",
            8 => "opponent_score",
            9 => "front_gear_num",
            10 => "front_gear",
            11 => "rear_gear_num",
            12 => "rear_gear",
            13 => "device_index",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageEvent> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageEvent {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![3],
            message_name: "FitMessageEvent",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            event: FitFieldBasicValue::new_single("".to_string()),
            event_type: FitFieldBasicValue::new_single("".to_string()),
            data16: FitFieldBasicValue::new_single("".to_string()).add_components(vec![
                FitParseConfig::new_from_component(
                    3,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    None,
                    Some("".to_string()),
                ),
            ]),
            data_subfield_bytes: vec![],
            data: FitMessageEventSubfieldData::NotYetParsed,
            event_group: FitFieldBasicValue::new_single("".to_string()),
            score: FitFieldBasicValue::new_single("".to_string()),
            opponent_score: FitFieldBasicValue::new_single("".to_string()),
            front_gear_num: FitFieldBasicValue::new_single("".to_string()),
            front_gear: FitFieldBasicValue::new_single("".to_string()),
            rear_gear_num: FitFieldBasicValue::new_single("".to_string()),
            rear_gear: FitFieldBasicValue::new_single("".to_string()),
            device_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageEvent), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // event
                self.event.parse(parse_input, parse_config)?
            }
            1 => {
                // event_type
                self.event_type.parse(parse_input, parse_config)?
            }
            2 => {
                // data16
                self.data16.parse(parse_input, parse_config)?
            }
            3 => {
                // data
                self.data_subfield_bytes = parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            4 => {
                // event_group
                self.event_group.parse(parse_input, parse_config)?
            }
            7 => {
                // score
                self.score.parse(parse_input, parse_config)?
            }
            8 => {
                // opponent_score
                self.opponent_score.parse(parse_input, parse_config)?
            }
            9 => {
                // front_gear_num
                self.front_gear_num.parse(parse_input, parse_config)?
            }
            10 => {
                // front_gear
                self.front_gear.parse(parse_input, parse_config)?
            }
            11 => {
                // rear_gear_num
                self.rear_gear_num.parse(parse_input, parse_config)?
            }
            12 => {
                // rear_gear
                self.rear_gear.parse(parse_input, parse_config)?
            }
            13 => {
                // device_index
                self.device_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            3 => {
                let (val, new_actions) = FitMessageEventSubfieldData::parse(
                    &self,
                    &self.data_subfield_bytes,
                    &parse_config,
                )?;
                self.data = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageEvent {
    fn message_name(&self) -> &'static str {
        return "FitMessageEvent";
    }
}

#[derive(Debug)]
pub struct FitMessageExdDataConceptConfiguration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub screen_index: FitFieldBasicValue<FitUint8>,
    pub concept_field: FitFieldBasicValue<FitByte>,
    pub field_id: FitFieldBasicValue<FitUint8>,
    pub concept_index: FitFieldBasicValue<FitUint8>,
    pub data_page: FitFieldBasicValue<FitUint8>,
    pub concept_key: FitFieldBasicValue<FitUint8>,
    pub scaling: FitFieldBasicValue<FitUint8>,
    pub data_units: FitFieldBasicValue<FitFieldExdDataUnits>,
    pub qualifier: FitFieldBasicValue<FitFieldExdQualifiers>,
    pub descriptor: FitFieldBasicValue<FitFieldExdDescriptors>,
    pub is_signed: FitFieldBasicValue<FitBool>,
}

impl fmt::Display for FitMessageExdDataConceptConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExdDataConceptConfiguration")?;
        fmt_message_field!(self.screen_index, "screen_index", false, f)?;
        fmt_message_field!(self.concept_field, "concept_field", false, f)?;
        fmt_message_field!(self.field_id, "field_id", false, f)?;
        fmt_message_field!(self.concept_index, "concept_index", false, f)?;
        fmt_message_field!(self.data_page, "data_page", false, f)?;
        fmt_message_field!(self.concept_key, "concept_key", false, f)?;
        fmt_message_field!(self.scaling, "scaling", false, f)?;
        fmt_message_field!(self.data_units, "data_units", false, f)?;
        fmt_message_field!(self.qualifier, "qualifier", false, f)?;
        fmt_message_field!(self.descriptor, "descriptor", false, f)?;
        fmt_message_field!(self.is_signed, "is_signed", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExdDataConceptConfiguration {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "screen_index",
            1 => "concept_field",
            2 => "field_id",
            3 => "concept_index",
            4 => "data_page",
            5 => "concept_key",
            6 => "scaling",
            8 => "data_units",
            9 => "qualifier",
            10 => "descriptor",
            11 => "is_signed",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageExdDataConceptConfiguration> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageExdDataConceptConfiguration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageExdDataConceptConfiguration",
            screen_index: FitFieldBasicValue::new_single("".to_string()),
            concept_field: FitFieldBasicValue::new_single("".to_string()).add_components(vec![
                FitParseConfig::new_from_component(
                    2,
                    1,
                    2,
                    endianness,
                    0,
                    4,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    3,
                    1,
                    2,
                    endianness,
                    4,
                    4,
                    None,
                    Some("".to_string()),
                ),
            ]),
            field_id: FitFieldBasicValue::new_single("".to_string()),
            concept_index: FitFieldBasicValue::new_single("".to_string()),
            data_page: FitFieldBasicValue::new_single("".to_string()),
            concept_key: FitFieldBasicValue::new_single("".to_string()),
            scaling: FitFieldBasicValue::new_single("".to_string()),
            data_units: FitFieldBasicValue::new_single("".to_string()),
            qualifier: FitFieldBasicValue::new_single("".to_string()),
            descriptor: FitFieldBasicValue::new_single("".to_string()),
            is_signed: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageExdDataConceptConfiguration),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // screen_index
                self.screen_index.parse(parse_input, parse_config)?
            }
            1 => {
                // concept_field
                self.concept_field.parse(parse_input, parse_config)?
            }
            2 => {
                // field_id
                self.field_id.parse(parse_input, parse_config)?
            }
            3 => {
                // concept_index
                self.concept_index.parse(parse_input, parse_config)?
            }
            4 => {
                // data_page
                self.data_page.parse(parse_input, parse_config)?
            }
            5 => {
                // concept_key
                self.concept_key.parse(parse_input, parse_config)?
            }
            6 => {
                // scaling
                self.scaling.parse(parse_input, parse_config)?
            }
            8 => {
                // data_units
                self.data_units.parse(parse_input, parse_config)?
            }
            9 => {
                // qualifier
                self.qualifier.parse(parse_input, parse_config)?
            }
            10 => {
                // descriptor
                self.descriptor.parse(parse_input, parse_config)?
            }
            11 => {
                // is_signed
                self.is_signed.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageExdDataConceptConfiguration {
    fn message_name(&self) -> &'static str {
        return "FitMessageExdDataConceptConfiguration";
    }
}

#[derive(Debug)]
pub struct FitMessageExdDataFieldConfiguration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub screen_index: FitFieldBasicValue<FitUint8>,
    pub concept_field: FitFieldBasicValue<FitByte>,
    pub field_id: FitFieldBasicValue<FitUint8>,
    pub concept_count: FitFieldBasicValue<FitUint8>,
    pub display_type: FitFieldBasicValue<FitFieldExdDisplayType>,
    pub title: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageExdDataFieldConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExdDataFieldConfiguration")?;
        fmt_message_field!(self.screen_index, "screen_index", false, f)?;
        fmt_message_field!(self.concept_field, "concept_field", false, f)?;
        fmt_message_field!(self.field_id, "field_id", false, f)?;
        fmt_message_field!(self.concept_count, "concept_count", false, f)?;
        fmt_message_field!(self.display_type, "display_type", false, f)?;
        fmt_message_field!(self.title, "title", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExdDataFieldConfiguration {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "screen_index",
            1 => "concept_field",
            2 => "field_id",
            3 => "concept_count",
            4 => "display_type",
            5 => "title",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageExdDataFieldConfiguration> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageExdDataFieldConfiguration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageExdDataFieldConfiguration",
            screen_index: FitFieldBasicValue::new_single("".to_string()),
            concept_field: FitFieldBasicValue::new_single("".to_string()).add_components(vec![
                FitParseConfig::new_from_component(
                    2,
                    1,
                    2,
                    endianness,
                    0,
                    4,
                    None,
                    Some("".to_string()),
                ),
                FitParseConfig::new_from_component(
                    3,
                    1,
                    2,
                    endianness,
                    4,
                    4,
                    None,
                    Some("".to_string()),
                ),
            ]),
            field_id: FitFieldBasicValue::new_single("".to_string()),
            concept_count: FitFieldBasicValue::new_single("".to_string()),
            display_type: FitFieldBasicValue::new_single("".to_string()),
            title: FitFieldBasicValue::new_vec("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageExdDataFieldConfiguration),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // screen_index
                self.screen_index.parse(parse_input, parse_config)?
            }
            1 => {
                // concept_field
                self.concept_field.parse(parse_input, parse_config)?
            }
            2 => {
                // field_id
                self.field_id.parse(parse_input, parse_config)?
            }
            3 => {
                // concept_count
                self.concept_count.parse(parse_input, parse_config)?
            }
            4 => {
                // display_type
                self.display_type.parse(parse_input, parse_config)?
            }
            5 => {
                // title
                self.title.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageExdDataFieldConfiguration {
    fn message_name(&self) -> &'static str {
        return "FitMessageExdDataFieldConfiguration";
    }
}

#[derive(Debug)]
pub struct FitMessageExdScreenConfiguration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub screen_index: FitFieldBasicValue<FitUint8>,
    pub field_count: FitFieldBasicValue<FitUint8>, // number of fields in screen
    pub layout: FitFieldBasicValue<FitFieldExdLayout>,
    pub screen_enabled: FitFieldBasicValue<FitBool>,
}

impl fmt::Display for FitMessageExdScreenConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExdScreenConfiguration")?;
        fmt_message_field!(self.screen_index, "screen_index", false, f)?;
        fmt_message_field!(self.field_count, "field_count", false, f)?;
        fmt_message_field!(self.layout, "layout", false, f)?;
        fmt_message_field!(self.screen_enabled, "screen_enabled", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExdScreenConfiguration {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "screen_index",
            1 => "field_count",
            2 => "layout",
            3 => "screen_enabled",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageExdScreenConfiguration> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageExdScreenConfiguration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageExdScreenConfiguration",
            screen_index: FitFieldBasicValue::new_single("".to_string()),
            field_count: FitFieldBasicValue::new_single("".to_string()),
            layout: FitFieldBasicValue::new_single("".to_string()),
            screen_enabled: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageExdScreenConfiguration),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // screen_index
                self.screen_index.parse(parse_input, parse_config)?
            }
            1 => {
                // field_count
                self.field_count.parse(parse_input, parse_config)?
            }
            2 => {
                // layout
                self.layout.parse(parse_input, parse_config)?
            }
            3 => {
                // screen_enabled
                self.screen_enabled.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageExdScreenConfiguration {
    fn message_name(&self) -> &'static str {
        return "FitMessageExdScreenConfiguration";
    }
}

#[derive(Debug)]
pub struct FitMessageExerciseTitle {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub exercise_category: FitFieldBasicValue<FitFieldExerciseCategory>,
    pub exercise_name: FitFieldBasicValue<FitUint16>,
    pub wkt_step_name: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageExerciseTitle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExerciseTitle")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.exercise_category, "exercise_category", false, f)?;
        fmt_message_field!(self.exercise_name, "exercise_name", false, f)?;
        fmt_message_field!(self.wkt_step_name, "wkt_step_name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExerciseTitle {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "exercise_category",
            1 => "exercise_name",
            2 => "wkt_step_name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageExerciseTitle> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageExerciseTitle {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageExerciseTitle",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            exercise_category: FitFieldBasicValue::new_single("".to_string()),
            exercise_name: FitFieldBasicValue::new_single("".to_string()),
            wkt_step_name: FitFieldBasicValue::new_vec("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageExerciseTitle),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // exercise_category
                self.exercise_category.parse(parse_input, parse_config)?
            }
            1 => {
                // exercise_name
                self.exercise_name.parse(parse_input, parse_config)?
            }
            2 => {
                // wkt_step_name
                self.wkt_step_name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageExerciseTitle {
    fn message_name(&self) -> &'static str {
        return "FitMessageExerciseTitle";
    }
}

#[derive(Debug)]
pub struct FitMessageFieldCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub file: FitFieldBasicValue<FitFieldFile>,
    pub mesg_num: FitFieldBasicValue<FitFieldMesgNum>,
    pub field_num: FitFieldBasicValue<FitUint8>,
    pub count: FitFieldBasicValue<FitUint16>,
}

impl fmt::Display for FitMessageFieldCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFieldCapabilities")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.file, "file", false, f)?;
        fmt_message_field!(self.mesg_num, "mesg_num", false, f)?;
        fmt_message_field!(self.field_num, "field_num", false, f)?;
        fmt_message_field!(self.count, "count", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFieldCapabilities {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "file",
            1 => "mesg_num",
            2 => "field_num",
            3 => "count",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageFieldCapabilities> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageFieldCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageFieldCapabilities",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            file: FitFieldBasicValue::new_single("".to_string()),
            mesg_num: FitFieldBasicValue::new_single("".to_string()),
            field_num: FitFieldBasicValue::new_single("".to_string()),
            count: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageFieldCapabilities),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // file
                self.file.parse(parse_input, parse_config)?
            }
            1 => {
                // mesg_num
                self.mesg_num.parse(parse_input, parse_config)?
            }
            2 => {
                // field_num
                self.field_num.parse(parse_input, parse_config)?
            }
            3 => {
                // count
                self.count.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageFieldCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageFieldCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageFieldDescription {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub developer_data_index: FitFieldBasicValue<FitUint8>,
    pub field_definition_number: FitFieldBasicValue<FitUint8>,
    pub fit_base_type_id: FitFieldBasicValue<FitFieldFitBaseType>,
    pub field_name: FitFieldBasicValue<FitString>,
    pub array: FitFieldBasicValue<FitUint8>,
    pub components: FitFieldBasicValue<FitString>,
    pub scale: FitFieldBasicValue<FitUint8>,
    pub offset: FitFieldBasicValue<FitSint8>,
    pub units: FitFieldBasicValue<FitString>,
    pub bits: FitFieldBasicValue<FitString>,
    pub accumulate: FitFieldBasicValue<FitString>,
    pub fit_base_unit_id: FitFieldBasicValue<FitFieldFitBaseUnit>,
    pub native_mesg_num: FitFieldBasicValue<FitFieldMesgNum>,
    pub native_field_num: FitFieldBasicValue<FitUint8>,
}

impl fmt::Display for FitMessageFieldDescription {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFieldDescription")?;
        fmt_message_field!(self.developer_data_index, "developer_data_index", false, f)?;
        fmt_message_field!(
            self.field_definition_number,
            "field_definition_number",
            false,
            f
        )?;
        fmt_message_field!(self.fit_base_type_id, "fit_base_type_id", false, f)?;
        fmt_message_field!(self.field_name, "field_name", false, f)?;
        fmt_message_field!(self.array, "array", false, f)?;
        fmt_message_field!(self.components, "components", false, f)?;
        fmt_message_field!(self.scale, "scale", false, f)?;
        fmt_message_field!(self.offset, "offset", false, f)?;
        fmt_message_field!(self.units, "units", false, f)?;
        fmt_message_field!(self.bits, "bits", false, f)?;
        fmt_message_field!(self.accumulate, "accumulate", false, f)?;
        fmt_message_field!(self.fit_base_unit_id, "fit_base_unit_id", false, f)?;
        fmt_message_field!(self.native_mesg_num, "native_mesg_num", false, f)?;
        fmt_message_field!(self.native_field_num, "native_field_num", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFieldDescription {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "developer_data_index",
            1 => "field_definition_number",
            2 => "fit_base_type_id",
            3 => "field_name",
            4 => "array",
            5 => "components",
            6 => "scale",
            7 => "offset",
            8 => "units",
            9 => "bits",
            10 => "accumulate",
            13 => "fit_base_unit_id",
            14 => "native_mesg_num",
            15 => "native_field_num",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageFieldDescription> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageFieldDescription {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageFieldDescription",
            developer_data_index: FitFieldBasicValue::new_single("".to_string()),
            field_definition_number: FitFieldBasicValue::new_single("".to_string()),
            fit_base_type_id: FitFieldBasicValue::new_single("".to_string()),
            field_name: FitFieldBasicValue::new_vec("".to_string()),
            array: FitFieldBasicValue::new_single("".to_string()),
            components: FitFieldBasicValue::new_single("".to_string()),
            scale: FitFieldBasicValue::new_single("".to_string()),
            offset: FitFieldBasicValue::new_single("".to_string()),
            units: FitFieldBasicValue::new_vec("".to_string()),
            bits: FitFieldBasicValue::new_single("".to_string()),
            accumulate: FitFieldBasicValue::new_single("".to_string()),
            fit_base_unit_id: FitFieldBasicValue::new_single("".to_string()),
            native_mesg_num: FitFieldBasicValue::new_single("".to_string()),
            native_field_num: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageFieldDescription),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // developer_data_index
                self.developer_data_index.parse(parse_input, parse_config)?
            }
            1 => {
                // field_definition_number
                self.field_definition_number
                    .parse(parse_input, parse_config)?
            }
            2 => {
                // fit_base_type_id
                self.fit_base_type_id.parse(parse_input, parse_config)?
            }
            3 => {
                // field_name
                self.field_name.parse(parse_input, parse_config)?
            }
            4 => {
                // array
                self.array.parse(parse_input, parse_config)?
            }
            5 => {
                // components
                self.components.parse(parse_input, parse_config)?
            }
            6 => {
                // scale
                self.scale.parse(parse_input, parse_config)?
            }
            7 => {
                // offset
                self.offset.parse(parse_input, parse_config)?
            }
            8 => {
                // units
                self.units.parse(parse_input, parse_config)?
            }
            9 => {
                // bits
                self.bits.parse(parse_input, parse_config)?
            }
            10 => {
                // accumulate
                self.accumulate.parse(parse_input, parse_config)?
            }
            13 => {
                // fit_base_unit_id
                self.fit_base_unit_id.parse(parse_input, parse_config)?
            }
            14 => {
                // native_mesg_num
                self.native_mesg_num.parse(parse_input, parse_config)?
            }
            15 => {
                // native_field_num
                self.native_field_num.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageFieldDescription {
    fn message_name(&self) -> &'static str {
        return "FitMessageFieldDescription";
    }
}

#[derive(Debug)]
pub struct FitMessageFileCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub ftype: FitFieldBasicValue<FitFieldFile>,
    pub flags: FitFieldBasicValue<FitFieldFileFlags>,
    pub directory: FitFieldBasicValue<FitString>,
    pub max_count: FitFieldBasicValue<FitUint16>,
    pub max_size: FitFieldBasicValue<FitUint32>,
}

impl fmt::Display for FitMessageFileCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFileCapabilities")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.flags, "flags", false, f)?;
        fmt_message_field!(self.directory, "directory", false, f)?;
        fmt_message_field!(self.max_count, "max_count", false, f)?;
        fmt_message_field!(self.max_size, "max_size", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFileCapabilities {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "ftype",
            1 => "flags",
            2 => "directory",
            3 => "max_count",
            4 => "max_size",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageFileCapabilities> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageFileCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageFileCapabilities",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            flags: FitFieldBasicValue::new_single("".to_string()),
            directory: FitFieldBasicValue::new_single("".to_string()),
            max_count: FitFieldBasicValue::new_single("".to_string()),
            max_size: FitFieldBasicValue::new_single("bytes".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageFileCapabilities),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            1 => {
                // flags
                self.flags.parse(parse_input, parse_config)?
            }
            2 => {
                // directory
                self.directory.parse(parse_input, parse_config)?
            }
            3 => {
                // max_count
                self.max_count.parse(parse_input, parse_config)?
            }
            4 => {
                // max_size
                self.max_size.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageFileCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageFileCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageFileCreator {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub software_version: FitFieldBasicValue<FitUint16>,
    pub hardware_version: FitFieldBasicValue<FitUint8>,
}

impl fmt::Display for FitMessageFileCreator {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFileCreator")?;
        fmt_message_field!(self.software_version, "software_version", false, f)?;
        fmt_message_field!(self.hardware_version, "hardware_version", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFileCreator {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "software_version",
            1 => "hardware_version",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageFileCreator> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageFileCreator {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageFileCreator",
            software_version: FitFieldBasicValue::new_single("".to_string()),
            hardware_version: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageFileCreator),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // software_version
                self.software_version.parse(parse_input, parse_config)?
            }
            1 => {
                // hardware_version
                self.hardware_version.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageFileCreator {
    fn message_name(&self) -> &'static str {
        return "FitMessageFileCreator";
    }
}

#[derive(Debug)]
pub enum FitMessageFileIdSubfieldProduct {
    NotYetParsed,
    Default(FitUint16),
    GarminProduct(FitFieldGarminProduct),
    FaveroProduct(FitFieldFaveroProduct),
}

impl FitMessageFileIdSubfieldProduct {
    fn parse<'a>(
        message: &FitMessageFileId,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageFileIdSubfieldProduct, Vec<FitParseConfig>)> {
        match message.manufacturer.get_single()? {
            FitFieldManufacturer::FaveroElectronics => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldFaveroProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageFileIdSubfieldProduct::FaveroProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Garmin => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageFileIdSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Dynastream => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageFileIdSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::DynastreamOem => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageFileIdSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageFileIdSubfieldProduct::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageFileId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub ftype: FitFieldBasicValue<FitFieldFile>,
    pub manufacturer: FitFieldBasicValue<FitFieldManufacturer>,
    pub product_subfield_bytes: Vec<u8>,
    pub product: FitMessageFileIdSubfieldProduct,
    pub serial_number: FitFieldBasicValue<FitUint32z>,
    pub time_created: FitFieldBasicValue<FitFieldDateTime>, // Only set for files that are can be created/erased.
    pub number: FitFieldBasicValue<FitUint16>, // Only set for files that are not created/erased.
    pub product_name: FitFieldBasicValue<FitString>, // Optional free form string to indicate the devices name or model
}

impl fmt::Display for FitMessageFileId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFileId")?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.manufacturer, "manufacturer", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "product_subfield_bytes", self.product_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "product", self.product)?;
        fmt_message_field!(self.serial_number, "serial_number", false, f)?;
        fmt_message_field!(self.time_created, "time_created", false, f)?;
        fmt_message_field!(self.number, "number", false, f)?;
        fmt_message_field!(self.product_name, "product_name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFileId {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "ftype",
            1 => "manufacturer",
            2 => "product",
            3 => "serial_number",
            4 => "time_created",
            5 => "number",
            8 => "product_name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageFileId> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageFileId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![2],
            message_name: "FitMessageFileId",
            ftype: FitFieldBasicValue::new_single("".to_string()),
            manufacturer: FitFieldBasicValue::new_single("".to_string()),
            product_subfield_bytes: vec![],
            product: FitMessageFileIdSubfieldProduct::NotYetParsed,
            serial_number: FitFieldBasicValue::new_single("".to_string()),
            time_created: FitFieldBasicValue::new_single("".to_string()),
            number: FitFieldBasicValue::new_single("".to_string()),
            product_name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageFileId), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            1 => {
                // manufacturer
                self.manufacturer.parse(parse_input, parse_config)?
            }
            2 => {
                // product
                self.product_subfield_bytes = parse_uint16_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            3 => {
                // serial_number
                self.serial_number.parse(parse_input, parse_config)?
            }
            4 => {
                // time_created
                self.time_created.parse(parse_input, parse_config)?
            }
            5 => {
                // number
                self.number.parse(parse_input, parse_config)?
            }
            8 => {
                // product_name
                self.product_name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            2 => {
                let (val, new_actions) = FitMessageFileIdSubfieldProduct::parse(
                    &self,
                    &self.product_subfield_bytes,
                    &parse_config,
                )?;
                self.product = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageFileId {
    fn message_name(&self) -> &'static str {
        return "FitMessageFileId";
    }
}

#[derive(Debug)]
pub struct FitMessageGoal {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub start_date: FitFieldBasicValue<FitFieldDateTime>,
    pub end_date: FitFieldBasicValue<FitFieldDateTime>,
    pub ftype: FitFieldBasicValue<FitFieldGoal>,
    pub value: FitFieldBasicValue<FitUint32>,
    pub repeat: FitFieldBasicValue<FitBool>,
    pub target_value: FitFieldBasicValue<FitUint32>,
    pub recurrence: FitFieldBasicValue<FitFieldGoalRecurrence>,
    pub recurrence_value: FitFieldBasicValue<FitUint16>,
    pub enabled: FitFieldBasicValue<FitBool>,
    pub source: FitFieldBasicValue<FitFieldGoalSource>,
}

impl fmt::Display for FitMessageGoal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageGoal")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.start_date, "start_date", false, f)?;
        fmt_message_field!(self.end_date, "end_date", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.value, "value", false, f)?;
        fmt_message_field!(self.repeat, "repeat", false, f)?;
        fmt_message_field!(self.target_value, "target_value", false, f)?;
        fmt_message_field!(self.recurrence, "recurrence", false, f)?;
        fmt_message_field!(self.recurrence_value, "recurrence_value", false, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(self.source, "source", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageGoal {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "sport",
            1 => "sub_sport",
            2 => "start_date",
            3 => "end_date",
            4 => "ftype",
            5 => "value",
            6 => "repeat",
            7 => "target_value",
            8 => "recurrence",
            9 => "recurrence_value",
            10 => "enabled",
            11 => "source",
            _ => "unknown",
        }
    }

    pub fn new(header: FitRecordHeader, parsing_state: &FitParsingState) -> Result<FitMessageGoal> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageGoal {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageGoal",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            start_date: FitFieldBasicValue::new_single("".to_string()),
            end_date: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            value: FitFieldBasicValue::new_single("".to_string()),
            repeat: FitFieldBasicValue::new_single("".to_string()),
            target_value: FitFieldBasicValue::new_single("".to_string()),
            recurrence: FitFieldBasicValue::new_single("".to_string()),
            recurrence_value: FitFieldBasicValue::new_single("".to_string()),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            source: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageGoal), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            1 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            2 => {
                // start_date
                self.start_date.parse(parse_input, parse_config)?
            }
            3 => {
                // end_date
                self.end_date.parse(parse_input, parse_config)?
            }
            4 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            5 => {
                // value
                self.value.parse(parse_input, parse_config)?
            }
            6 => {
                // repeat
                self.repeat.parse(parse_input, parse_config)?
            }
            7 => {
                // target_value
                self.target_value.parse(parse_input, parse_config)?
            }
            8 => {
                // recurrence
                self.recurrence.parse(parse_input, parse_config)?
            }
            9 => {
                // recurrence_value
                self.recurrence_value.parse(parse_input, parse_config)?
            }
            10 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            11 => {
                // source
                self.source.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageGoal {
    fn message_name(&self) -> &'static str {
        return "FitMessageGoal";
    }
}

#[derive(Debug)]
pub struct FitMessageGpsMetadata {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp.
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub position_lat: FitFieldAdjustedValue<FitSint32>,
    pub position_long: FitFieldAdjustedValue<FitSint32>,
    pub enhanced_altitude: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_speed: FitFieldAdjustedValue<FitUint32>,
    pub heading: FitFieldAdjustedValue<FitUint16>,
    pub utc_timestamp: FitFieldBasicValue<FitFieldDateTime>, // Used to correlate UTC to system time if the timestamp of the message is in system time.  This UTC time is derived from the GPS data.
    pub velocity: FitFieldAdjustedValue<FitSint16>, // velocity[0] is lon velocity.  Velocity[1] is lat velocity.  Velocity[2] is altitude velocity.
}

impl fmt::Display for FitMessageGpsMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageGpsMetadata")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.position_lat, "position_lat", true, f)?;
        fmt_message_field!(self.position_long, "position_long", true, f)?;
        fmt_message_field!(self.enhanced_altitude, "enhanced_altitude", true, f)?;
        fmt_message_field!(self.enhanced_speed, "enhanced_speed", true, f)?;
        fmt_message_field!(self.heading, "heading", true, f)?;
        fmt_message_field!(self.utc_timestamp, "utc_timestamp", false, f)?;
        fmt_message_field!(self.velocity, "velocity", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageGpsMetadata {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "position_lat",
            2 => "position_long",
            3 => "enhanced_altitude",
            4 => "enhanced_speed",
            5 => "heading",
            6 => "utc_timestamp",
            7 => "velocity",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageGpsMetadata> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageGpsMetadata {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageGpsMetadata",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            enhanced_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            enhanced_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            heading: FitFieldAdjustedValue::new_single("degrees".to_string(), 100.0, 0.0),
            utc_timestamp: FitFieldBasicValue::new_single("".to_string()),
            velocity: FitFieldAdjustedValue::new_vec("m/s".to_string(), 100.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageGpsMetadata),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // position_lat
                self.position_lat.parse(parse_input, parse_config)?
            }
            2 => {
                // position_long
                self.position_long.parse(parse_input, parse_config)?
            }
            3 => {
                // enhanced_altitude
                self.enhanced_altitude.parse(parse_input, parse_config)?
            }
            4 => {
                // enhanced_speed
                self.enhanced_speed.parse(parse_input, parse_config)?
            }
            5 => {
                // heading
                self.heading.parse(parse_input, parse_config)?
            }
            6 => {
                // utc_timestamp
                self.utc_timestamp.parse(parse_input, parse_config)?
            }
            7 => {
                // velocity
                self.velocity.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageGpsMetadata {
    fn message_name(&self) -> &'static str {
        return "FitMessageGpsMetadata";
    }
}

#[derive(Debug)]
pub struct FitMessageGyroscopeData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub sample_time_offset: FitFieldBasicValue<FitUint16>, // Each time in the array describes the time at which the gyro sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in gyro_x and gyro_y and gyro_z
    pub gyro_x: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub gyro_y: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub gyro_z: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub calibrated_gyro_x: FitFieldBasicValue<FitFloat32>, // Calibrated gyro reading
    pub calibrated_gyro_y: FitFieldBasicValue<FitFloat32>, // Calibrated gyro reading
    pub calibrated_gyro_z: FitFieldBasicValue<FitFloat32>, // Calibrated gyro reading
}

impl fmt::Display for FitMessageGyroscopeData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageGyroscopeData")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.sample_time_offset, "sample_time_offset", false, f)?;
        fmt_message_field!(self.gyro_x, "gyro_x", false, f)?;
        fmt_message_field!(self.gyro_y, "gyro_y", false, f)?;
        fmt_message_field!(self.gyro_z, "gyro_z", false, f)?;
        fmt_message_field!(self.calibrated_gyro_x, "calibrated_gyro_x", false, f)?;
        fmt_message_field!(self.calibrated_gyro_y, "calibrated_gyro_y", false, f)?;
        fmt_message_field!(self.calibrated_gyro_z, "calibrated_gyro_z", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageGyroscopeData {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "sample_time_offset",
            2 => "gyro_x",
            3 => "gyro_y",
            4 => "gyro_z",
            5 => "calibrated_gyro_x",
            6 => "calibrated_gyro_y",
            7 => "calibrated_gyro_z",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageGyroscopeData> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageGyroscopeData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageGyroscopeData",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            sample_time_offset: FitFieldBasicValue::new_vec("ms".to_string()),
            gyro_x: FitFieldBasicValue::new_vec("counts".to_string()),
            gyro_y: FitFieldBasicValue::new_vec("counts".to_string()),
            gyro_z: FitFieldBasicValue::new_vec("counts".to_string()),
            calibrated_gyro_x: FitFieldBasicValue::new_vec("deg/s".to_string()),
            calibrated_gyro_y: FitFieldBasicValue::new_vec("deg/s".to_string()),
            calibrated_gyro_z: FitFieldBasicValue::new_vec("deg/s".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageGyroscopeData),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // sample_time_offset
                self.sample_time_offset.parse(parse_input, parse_config)?
            }
            2 => {
                // gyro_x
                self.gyro_x.parse(parse_input, parse_config)?
            }
            3 => {
                // gyro_y
                self.gyro_y.parse(parse_input, parse_config)?
            }
            4 => {
                // gyro_z
                self.gyro_z.parse(parse_input, parse_config)?
            }
            5 => {
                // calibrated_gyro_x
                self.calibrated_gyro_x.parse(parse_input, parse_config)?
            }
            6 => {
                // calibrated_gyro_y
                self.calibrated_gyro_y.parse(parse_input, parse_config)?
            }
            7 => {
                // calibrated_gyro_z
                self.calibrated_gyro_z.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageGyroscopeData {
    fn message_name(&self) -> &'static str {
        return "FitMessageGyroscopeData";
    }
}

#[derive(Debug)]
pub struct FitMessageHr {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub fractional_timestamp: FitFieldAdjustedValue<FitUint16>,
    pub time256: FitFieldAdjustedValue<FitUint8>,
    pub filtered_bpm: FitFieldBasicValue<FitUint8>,
    pub event_timestamp: FitFieldAdjustedValue<FitUint32>,
    pub event_timestamp_12: FitFieldBasicValue<FitByte>,
}

impl fmt::Display for FitMessageHr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHr")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.fractional_timestamp, "fractional_timestamp", true, f)?;
        fmt_message_field!(self.time256, "time256", true, f)?;
        fmt_message_field!(self.filtered_bpm, "filtered_bpm", false, f)?;
        fmt_message_field!(self.event_timestamp, "event_timestamp", true, f)?;
        fmt_message_field!(self.event_timestamp_12, "event_timestamp_12", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHr {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "fractional_timestamp",
            1 => "time256",
            6 => "filtered_bpm",
            9 => "event_timestamp",
            10 => "event_timestamp_12",
            _ => "unknown",
        }
    }

    pub fn new(header: FitRecordHeader, parsing_state: &FitParsingState) -> Result<FitMessageHr> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageHr {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageHr",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            fractional_timestamp: FitFieldAdjustedValue::new_single("s".to_string(), 32768.0, 0.0),
            time256: FitFieldAdjustedValue::new_single("s".to_string(), 256.0, 0.0).add_components(
                vec![FitParseConfig::new_from_component(
                    0,
                    2,
                    132,
                    endianness,
                    0,
                    8,
                    Some((256.0, 0.0)),
                    Some("s".to_string()),
                )],
            ),
            filtered_bpm: FitFieldBasicValue::new_vec("bpm".to_string()),
            event_timestamp: FitFieldAdjustedValue::new_vec("s".to_string(), 1024.0, 0.0),
            event_timestamp_12: FitFieldBasicValue::new_single("".to_string()).add_components(
                vec![
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        0,
                        12,
                        Some((1024.0, 0.0)),
                        Some("s".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        12,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        24,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        36,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        48,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        60,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        72,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        84,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        96,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        9,
                        4,
                        134,
                        endianness,
                        108,
                        12,
                        Some((1024.0, 0.0)),
                        Some("".to_string()),
                    ),
                ],
            ),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageHr), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // fractional_timestamp
                self.fractional_timestamp.parse(parse_input, parse_config)?
            }
            1 => {
                // time256
                self.time256.parse(parse_input, parse_config)?
            }
            6 => {
                // filtered_bpm
                self.filtered_bpm.parse(parse_input, parse_config)?
            }
            9 => {
                // event_timestamp
                self.event_timestamp.parse(parse_input, parse_config)?
            }
            10 => {
                // event_timestamp_12
                self.event_timestamp_12.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageHr {
    fn message_name(&self) -> &'static str {
        return "FitMessageHr";
    }
}

#[derive(Debug)]
pub struct FitMessageHrZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub high_bpm: FitFieldBasicValue<FitUint8>,
    pub name: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageHrZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHrZone")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.high_bpm, "high_bpm", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHrZone {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            1 => "high_bpm",
            2 => "name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageHrZone> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageHrZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageHrZone",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            high_bpm: FitFieldBasicValue::new_single("bpm".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageHrZone), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            1 => {
                // high_bpm
                self.high_bpm.parse(parse_input, parse_config)?
            }
            2 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageHrZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageHrZone";
    }
}

#[derive(Debug)]
pub struct FitMessageHrmProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub enabled: FitFieldBasicValue<FitBool>,
    pub hrm_ant_id: FitFieldBasicValue<FitUint16z>,
    pub log_hrv: FitFieldBasicValue<FitBool>,
    pub hrm_ant_id_trans_type: FitFieldBasicValue<FitUint8z>,
}

impl fmt::Display for FitMessageHrmProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHrmProfile")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(self.hrm_ant_id, "hrm_ant_id", false, f)?;
        fmt_message_field!(self.log_hrv, "log_hrv", false, f)?;
        fmt_message_field!(
            self.hrm_ant_id_trans_type,
            "hrm_ant_id_trans_type",
            false,
            f
        )?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHrmProfile {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "enabled",
            1 => "hrm_ant_id",
            2 => "log_hrv",
            3 => "hrm_ant_id_trans_type",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageHrmProfile> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageHrmProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageHrmProfile",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            hrm_ant_id: FitFieldBasicValue::new_single("".to_string()),
            log_hrv: FitFieldBasicValue::new_single("".to_string()),
            hrm_ant_id_trans_type: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageHrmProfile),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            1 => {
                // hrm_ant_id
                self.hrm_ant_id.parse(parse_input, parse_config)?
            }
            2 => {
                // log_hrv
                self.log_hrv.parse(parse_input, parse_config)?
            }
            3 => {
                // hrm_ant_id_trans_type
                self.hrm_ant_id_trans_type
                    .parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageHrmProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageHrmProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageHrv {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub time: FitFieldAdjustedValue<FitUint16>, // Time between beats
}

impl fmt::Display for FitMessageHrv {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHrv")?;
        fmt_message_field!(self.time, "time", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHrv {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "time",
            _ => "unknown",
        }
    }

    pub fn new(header: FitRecordHeader, parsing_state: &FitParsingState) -> Result<FitMessageHrv> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageHrv {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageHrv",
            time: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageHrv), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // time
                self.time.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageHrv {
    fn message_name(&self) -> &'static str {
        return "FitMessageHrv";
    }
}

#[derive(Debug)]
pub enum FitMessageLapSubfieldTotalCycles {
    NotYetParsed,
    Default(FitUint32),
    TotalStrides(FitUint32),
}

impl FitMessageLapSubfieldTotalCycles {
    fn parse<'a>(
        message: &FitMessageLap,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageLapSubfieldTotalCycles, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Running => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("strides".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageLapSubfieldTotalCycles::TotalStrides(val),
                    new_actions,
                ));
            }

            FitFieldSport::Walking => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("strides".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageLapSubfieldTotalCycles::TotalStrides(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageLapSubfieldTotalCycles::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub enum FitMessageLapSubfieldAvgCadence {
    NotYetParsed,
    Default(FitUint8),
    AvgRunningCadence(FitUint8),
}

impl FitMessageLapSubfieldAvgCadence {
    fn parse<'a>(
        message: &FitMessageLap,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageLapSubfieldAvgCadence, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Running => {
                let mut parser =
                    FitFieldBasicValue::<FitUint8>::new_single("strides/min".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageLapSubfieldAvgCadence::AvgRunningCadence(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageLapSubfieldAvgCadence::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub enum FitMessageLapSubfieldMaxCadence {
    NotYetParsed,
    Default(FitUint8),
    MaxRunningCadence(FitUint8),
}

impl FitMessageLapSubfieldMaxCadence {
    fn parse<'a>(
        message: &FitMessageLap,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageLapSubfieldMaxCadence, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Running => {
                let mut parser =
                    FitFieldBasicValue::<FitUint8>::new_single("strides/min".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageLapSubfieldMaxCadence::MaxRunningCadence(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageLapSubfieldMaxCadence::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageLap {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Lap end time.
    pub event: FitFieldBasicValue<FitFieldEvent>,
    pub event_type: FitFieldBasicValue<FitFieldEventType>,
    pub start_time: FitFieldBasicValue<FitFieldDateTime>,
    pub start_position_lat: FitFieldAdjustedValue<FitSint32>,
    pub start_position_long: FitFieldAdjustedValue<FitSint32>,
    pub end_position_lat: FitFieldAdjustedValue<FitSint32>,
    pub end_position_long: FitFieldAdjustedValue<FitSint32>,
    pub total_elapsed_time: FitFieldAdjustedValue<FitUint32>, // Time (includes pauses)
    pub total_timer_time: FitFieldAdjustedValue<FitUint32>,   // Timer Time (excludes pauses)
    pub total_distance: FitFieldAdjustedValue<FitUint32>,
    pub total_cycles_subfield_bytes: Vec<u8>,
    pub total_cycles: FitMessageLapSubfieldTotalCycles,
    pub total_calories: FitFieldBasicValue<FitUint16>,
    pub total_fat_calories: FitFieldBasicValue<FitUint16>, // If New Leaf
    pub avg_speed: FitFieldAdjustedValue<FitUint16>,
    pub max_speed: FitFieldAdjustedValue<FitUint16>,
    pub avg_heart_rate: FitFieldBasicValue<FitUint8>,
    pub max_heart_rate: FitFieldBasicValue<FitUint8>,
    pub avg_cadence_subfield_bytes: Vec<u8>,
    pub avg_cadence: FitMessageLapSubfieldAvgCadence, // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
    pub max_cadence_subfield_bytes: Vec<u8>,
    pub max_cadence: FitMessageLapSubfieldMaxCadence,
    pub avg_power: FitFieldBasicValue<FitUint16>, // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
    pub max_power: FitFieldBasicValue<FitUint16>,
    pub total_ascent: FitFieldBasicValue<FitUint16>,
    pub total_descent: FitFieldBasicValue<FitUint16>,
    pub intensity: FitFieldBasicValue<FitFieldIntensity>,
    pub lap_trigger: FitFieldBasicValue<FitFieldLapTrigger>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub event_group: FitFieldBasicValue<FitUint8>,
    pub num_lengths: FitFieldBasicValue<FitUint16>, // # of lengths of swim pool
    pub normalized_power: FitFieldBasicValue<FitUint16>,
    pub left_right_balance: FitFieldBasicValue<FitFieldLeftRightBalance100>,
    pub first_length_index: FitFieldBasicValue<FitUint16>,
    pub avg_stroke_distance: FitFieldAdjustedValue<FitUint16>,
    pub swim_stroke: FitFieldBasicValue<FitFieldSwimStroke>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub num_active_lengths: FitFieldBasicValue<FitUint16>, // # of active lengths of swim pool
    pub total_work: FitFieldBasicValue<FitUint32>,
    pub avg_altitude: FitFieldAdjustedValue<FitUint16>,
    pub max_altitude: FitFieldAdjustedValue<FitUint16>,
    pub gps_accuracy: FitFieldBasicValue<FitUint8>,
    pub avg_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_pos_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_neg_grade: FitFieldAdjustedValue<FitSint16>,
    pub max_pos_grade: FitFieldAdjustedValue<FitSint16>,
    pub max_neg_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_temperature: FitFieldBasicValue<FitSint8>,
    pub max_temperature: FitFieldBasicValue<FitSint8>,
    pub total_moving_time: FitFieldAdjustedValue<FitUint32>,
    pub avg_pos_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub avg_neg_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub max_pos_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub max_neg_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub time_in_hr_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_speed_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_cadence_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_power_zone: FitFieldAdjustedValue<FitUint32>,
    pub repetition_num: FitFieldBasicValue<FitUint16>,
    pub min_altitude: FitFieldAdjustedValue<FitUint16>,
    pub min_heart_rate: FitFieldBasicValue<FitUint8>,
    pub wkt_step_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub opponent_score: FitFieldBasicValue<FitUint16>,
    pub stroke_count: FitFieldBasicValue<FitUint16>, // stroke_type enum used as the index
    pub zone_count: FitFieldBasicValue<FitUint16>,   // zone number used as the index
    pub avg_vertical_oscillation: FitFieldAdjustedValue<FitUint16>,
    pub avg_stance_time_percent: FitFieldAdjustedValue<FitUint16>,
    pub avg_stance_time: FitFieldAdjustedValue<FitUint16>,
    pub avg_fractional_cadence: FitFieldAdjustedValue<FitUint8>, // fractional part of the avg_cadence
    pub max_fractional_cadence: FitFieldAdjustedValue<FitUint8>, // fractional part of the max_cadence
    pub total_fractional_cycles: FitFieldAdjustedValue<FitUint8>, // fractional part of the total_cycles
    pub player_score: FitFieldBasicValue<FitUint16>,
    pub avg_total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Avg saturated and unsaturated hemoglobin
    pub min_total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Min saturated and unsaturated hemoglobin
    pub max_total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Max saturated and unsaturated hemoglobin
    pub avg_saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Avg percentage of hemoglobin saturated with oxygen
    pub min_saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Min percentage of hemoglobin saturated with oxygen
    pub max_saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Max percentage of hemoglobin saturated with oxygen
    pub avg_left_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub avg_right_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub avg_left_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub avg_right_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub avg_combined_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub time_standing: FitFieldAdjustedValue<FitUint32>, // Total time spent in the standing position
    pub stand_count: FitFieldBasicValue<FitUint16>, // Number of transitions to the standing state
    pub avg_left_pco: FitFieldBasicValue<FitSint8>, // Average left platform center offset
    pub avg_right_pco: FitFieldBasicValue<FitSint8>, // Average right platform center offset
    pub avg_left_power_phase: FitFieldAdjustedValue<FitUint8>, // Average left power phase angles. Data value indexes defined by power_phase_type.
    pub avg_left_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Average left power phase peak angles. Data value indexes  defined by power_phase_type.
    pub avg_right_power_phase: FitFieldAdjustedValue<FitUint8>, // Average right power phase angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Average right power phase peak angles. Data value indexes  defined by power_phase_type.
    pub avg_power_position: FitFieldBasicValue<FitUint16>, // Average power by position. Data value indexes defined by rider_position_type.
    pub max_power_position: FitFieldBasicValue<FitUint16>, // Maximum power by position. Data value indexes defined by rider_position_type.
    pub avg_cadence_position: FitFieldBasicValue<FitUint8>, // Average cadence by position. Data value indexes defined by rider_position_type.
    pub max_cadence_position: FitFieldBasicValue<FitUint8>, // Maximum cadence by position. Data value indexes defined by rider_position_type.
    pub enhanced_avg_speed: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_max_speed: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_avg_altitude: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_min_altitude: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_max_altitude: FitFieldAdjustedValue<FitUint32>,
    pub avg_lev_motor_power: FitFieldBasicValue<FitUint16>, // lev average motor power during lap
    pub max_lev_motor_power: FitFieldBasicValue<FitUint16>, // lev maximum motor power during lap
    pub lev_battery_consumption: FitFieldAdjustedValue<FitUint8>, // lev battery consumption during lap
    pub avg_vertical_ratio: FitFieldAdjustedValue<FitUint16>,
    pub avg_stance_time_balance: FitFieldAdjustedValue<FitUint16>,
    pub avg_step_length: FitFieldAdjustedValue<FitUint16>,
    pub avg_vam: FitFieldAdjustedValue<FitUint16>,
}

impl fmt::Display for FitMessageLap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageLap")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.event, "event", false, f)?;
        fmt_message_field!(self.event_type, "event_type", false, f)?;
        fmt_message_field!(self.start_time, "start_time", false, f)?;
        fmt_message_field!(self.start_position_lat, "start_position_lat", true, f)?;
        fmt_message_field!(self.start_position_long, "start_position_long", true, f)?;
        fmt_message_field!(self.end_position_lat, "end_position_lat", true, f)?;
        fmt_message_field!(self.end_position_long, "end_position_long", true, f)?;
        fmt_message_field!(self.total_elapsed_time, "total_elapsed_time", true, f)?;
        fmt_message_field!(self.total_timer_time, "total_timer_time", true, f)?;
        fmt_message_field!(self.total_distance, "total_distance", true, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "total_cycles_subfield_bytes", self.total_cycles_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "total_cycles", self.total_cycles)?;
        fmt_message_field!(self.total_calories, "total_calories", false, f)?;
        fmt_message_field!(self.total_fat_calories, "total_fat_calories", false, f)?;
        fmt_message_field!(self.avg_speed, "avg_speed", true, f)?;
        fmt_message_field!(self.max_speed, "max_speed", true, f)?;
        fmt_message_field!(self.avg_heart_rate, "avg_heart_rate", false, f)?;
        fmt_message_field!(self.max_heart_rate, "max_heart_rate", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "avg_cadence_subfield_bytes", self.avg_cadence_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "avg_cadence", self.avg_cadence)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "max_cadence_subfield_bytes", self.max_cadence_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "max_cadence", self.max_cadence)?;
        fmt_message_field!(self.avg_power, "avg_power", false, f)?;
        fmt_message_field!(self.max_power, "max_power", false, f)?;
        fmt_message_field!(self.total_ascent, "total_ascent", false, f)?;
        fmt_message_field!(self.total_descent, "total_descent", false, f)?;
        fmt_message_field!(self.intensity, "intensity", false, f)?;
        fmt_message_field!(self.lap_trigger, "lap_trigger", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.event_group, "event_group", false, f)?;
        fmt_message_field!(self.num_lengths, "num_lengths", false, f)?;
        fmt_message_field!(self.normalized_power, "normalized_power", false, f)?;
        fmt_message_field!(self.left_right_balance, "left_right_balance", false, f)?;
        fmt_message_field!(self.first_length_index, "first_length_index", false, f)?;
        fmt_message_field!(self.avg_stroke_distance, "avg_stroke_distance", true, f)?;
        fmt_message_field!(self.swim_stroke, "swim_stroke", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.num_active_lengths, "num_active_lengths", false, f)?;
        fmt_message_field!(self.total_work, "total_work", false, f)?;
        fmt_message_field!(self.avg_altitude, "avg_altitude", true, f)?;
        fmt_message_field!(self.max_altitude, "max_altitude", true, f)?;
        fmt_message_field!(self.gps_accuracy, "gps_accuracy", false, f)?;
        fmt_message_field!(self.avg_grade, "avg_grade", true, f)?;
        fmt_message_field!(self.avg_pos_grade, "avg_pos_grade", true, f)?;
        fmt_message_field!(self.avg_neg_grade, "avg_neg_grade", true, f)?;
        fmt_message_field!(self.max_pos_grade, "max_pos_grade", true, f)?;
        fmt_message_field!(self.max_neg_grade, "max_neg_grade", true, f)?;
        fmt_message_field!(self.avg_temperature, "avg_temperature", false, f)?;
        fmt_message_field!(self.max_temperature, "max_temperature", false, f)?;
        fmt_message_field!(self.total_moving_time, "total_moving_time", true, f)?;
        fmt_message_field!(
            self.avg_pos_vertical_speed,
            "avg_pos_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_neg_vertical_speed,
            "avg_neg_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_pos_vertical_speed,
            "max_pos_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_neg_vertical_speed,
            "max_neg_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(self.time_in_hr_zone, "time_in_hr_zone", true, f)?;
        fmt_message_field!(self.time_in_speed_zone, "time_in_speed_zone", true, f)?;
        fmt_message_field!(self.time_in_cadence_zone, "time_in_cadence_zone", true, f)?;
        fmt_message_field!(self.time_in_power_zone, "time_in_power_zone", true, f)?;
        fmt_message_field!(self.repetition_num, "repetition_num", false, f)?;
        fmt_message_field!(self.min_altitude, "min_altitude", true, f)?;
        fmt_message_field!(self.min_heart_rate, "min_heart_rate", false, f)?;
        fmt_message_field!(self.wkt_step_index, "wkt_step_index", false, f)?;
        fmt_message_field!(self.opponent_score, "opponent_score", false, f)?;
        fmt_message_field!(self.stroke_count, "stroke_count", false, f)?;
        fmt_message_field!(self.zone_count, "zone_count", false, f)?;
        fmt_message_field!(
            self.avg_vertical_oscillation,
            "avg_vertical_oscillation",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_stance_time_percent,
            "avg_stance_time_percent",
            true,
            f
        )?;
        fmt_message_field!(self.avg_stance_time, "avg_stance_time", true, f)?;
        fmt_message_field!(
            self.avg_fractional_cadence,
            "avg_fractional_cadence",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_fractional_cadence,
            "max_fractional_cadence",
            true,
            f
        )?;
        fmt_message_field!(
            self.total_fractional_cycles,
            "total_fractional_cycles",
            true,
            f
        )?;
        fmt_message_field!(self.player_score, "player_score", false, f)?;
        fmt_message_field!(
            self.avg_total_hemoglobin_conc,
            "avg_total_hemoglobin_conc",
            true,
            f
        )?;
        fmt_message_field!(
            self.min_total_hemoglobin_conc,
            "min_total_hemoglobin_conc",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_total_hemoglobin_conc,
            "max_total_hemoglobin_conc",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_saturated_hemoglobin_percent,
            "avg_saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.min_saturated_hemoglobin_percent,
            "min_saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_saturated_hemoglobin_percent,
            "max_saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_left_torque_effectiveness,
            "avg_left_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_right_torque_effectiveness,
            "avg_right_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_left_pedal_smoothness,
            "avg_left_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_right_pedal_smoothness,
            "avg_right_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_combined_pedal_smoothness,
            "avg_combined_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(self.time_standing, "time_standing", true, f)?;
        fmt_message_field!(self.stand_count, "stand_count", false, f)?;
        fmt_message_field!(self.avg_left_pco, "avg_left_pco", false, f)?;
        fmt_message_field!(self.avg_right_pco, "avg_right_pco", false, f)?;
        fmt_message_field!(self.avg_left_power_phase, "avg_left_power_phase", true, f)?;
        fmt_message_field!(
            self.avg_left_power_phase_peak,
            "avg_left_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.avg_right_power_phase, "avg_right_power_phase", true, f)?;
        fmt_message_field!(
            self.avg_right_power_phase_peak,
            "avg_right_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.avg_power_position, "avg_power_position", false, f)?;
        fmt_message_field!(self.max_power_position, "max_power_position", false, f)?;
        fmt_message_field!(self.avg_cadence_position, "avg_cadence_position", false, f)?;
        fmt_message_field!(self.max_cadence_position, "max_cadence_position", false, f)?;
        fmt_message_field!(self.enhanced_avg_speed, "enhanced_avg_speed", true, f)?;
        fmt_message_field!(self.enhanced_max_speed, "enhanced_max_speed", true, f)?;
        fmt_message_field!(self.enhanced_avg_altitude, "enhanced_avg_altitude", true, f)?;
        fmt_message_field!(self.enhanced_min_altitude, "enhanced_min_altitude", true, f)?;
        fmt_message_field!(self.enhanced_max_altitude, "enhanced_max_altitude", true, f)?;
        fmt_message_field!(self.avg_lev_motor_power, "avg_lev_motor_power", false, f)?;
        fmt_message_field!(self.max_lev_motor_power, "max_lev_motor_power", false, f)?;
        fmt_message_field!(
            self.lev_battery_consumption,
            "lev_battery_consumption",
            true,
            f
        )?;
        fmt_message_field!(self.avg_vertical_ratio, "avg_vertical_ratio", true, f)?;
        fmt_message_field!(
            self.avg_stance_time_balance,
            "avg_stance_time_balance",
            true,
            f
        )?;
        fmt_message_field!(self.avg_step_length, "avg_step_length", true, f)?;
        fmt_message_field!(self.avg_vam, "avg_vam", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageLap {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            253 => "timestamp",
            0 => "event",
            1 => "event_type",
            2 => "start_time",
            3 => "start_position_lat",
            4 => "start_position_long",
            5 => "end_position_lat",
            6 => "end_position_long",
            7 => "total_elapsed_time",
            8 => "total_timer_time",
            9 => "total_distance",
            10 => "total_cycles",
            11 => "total_calories",
            12 => "total_fat_calories",
            13 => "avg_speed",
            14 => "max_speed",
            15 => "avg_heart_rate",
            16 => "max_heart_rate",
            17 => "avg_cadence",
            18 => "max_cadence",
            19 => "avg_power",
            20 => "max_power",
            21 => "total_ascent",
            22 => "total_descent",
            23 => "intensity",
            24 => "lap_trigger",
            25 => "sport",
            26 => "event_group",
            32 => "num_lengths",
            33 => "normalized_power",
            34 => "left_right_balance",
            35 => "first_length_index",
            37 => "avg_stroke_distance",
            38 => "swim_stroke",
            39 => "sub_sport",
            40 => "num_active_lengths",
            41 => "total_work",
            42 => "avg_altitude",
            43 => "max_altitude",
            44 => "gps_accuracy",
            45 => "avg_grade",
            46 => "avg_pos_grade",
            47 => "avg_neg_grade",
            48 => "max_pos_grade",
            49 => "max_neg_grade",
            50 => "avg_temperature",
            51 => "max_temperature",
            52 => "total_moving_time",
            53 => "avg_pos_vertical_speed",
            54 => "avg_neg_vertical_speed",
            55 => "max_pos_vertical_speed",
            56 => "max_neg_vertical_speed",
            57 => "time_in_hr_zone",
            58 => "time_in_speed_zone",
            59 => "time_in_cadence_zone",
            60 => "time_in_power_zone",
            61 => "repetition_num",
            62 => "min_altitude",
            63 => "min_heart_rate",
            71 => "wkt_step_index",
            74 => "opponent_score",
            75 => "stroke_count",
            76 => "zone_count",
            77 => "avg_vertical_oscillation",
            78 => "avg_stance_time_percent",
            79 => "avg_stance_time",
            80 => "avg_fractional_cadence",
            81 => "max_fractional_cadence",
            82 => "total_fractional_cycles",
            83 => "player_score",
            84 => "avg_total_hemoglobin_conc",
            85 => "min_total_hemoglobin_conc",
            86 => "max_total_hemoglobin_conc",
            87 => "avg_saturated_hemoglobin_percent",
            88 => "min_saturated_hemoglobin_percent",
            89 => "max_saturated_hemoglobin_percent",
            91 => "avg_left_torque_effectiveness",
            92 => "avg_right_torque_effectiveness",
            93 => "avg_left_pedal_smoothness",
            94 => "avg_right_pedal_smoothness",
            95 => "avg_combined_pedal_smoothness",
            98 => "time_standing",
            99 => "stand_count",
            100 => "avg_left_pco",
            101 => "avg_right_pco",
            102 => "avg_left_power_phase",
            103 => "avg_left_power_phase_peak",
            104 => "avg_right_power_phase",
            105 => "avg_right_power_phase_peak",
            106 => "avg_power_position",
            107 => "max_power_position",
            108 => "avg_cadence_position",
            109 => "max_cadence_position",
            110 => "enhanced_avg_speed",
            111 => "enhanced_max_speed",
            112 => "enhanced_avg_altitude",
            113 => "enhanced_min_altitude",
            114 => "enhanced_max_altitude",
            115 => "avg_lev_motor_power",
            116 => "max_lev_motor_power",
            117 => "lev_battery_consumption",
            118 => "avg_vertical_ratio",
            119 => "avg_stance_time_balance",
            120 => "avg_step_length",
            121 => "avg_vam",
            _ => "unknown",
        }
    }

    pub fn new(header: FitRecordHeader, parsing_state: &FitParsingState) -> Result<FitMessageLap> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageLap {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![10, 17, 18],
            message_name: "FitMessageLap",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            event: FitFieldBasicValue::new_single("".to_string()),
            event_type: FitFieldBasicValue::new_single("".to_string()),
            start_time: FitFieldBasicValue::new_single("".to_string()),
            start_position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            start_position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            end_position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            end_position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            total_elapsed_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_timer_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            total_cycles_subfield_bytes: vec![],
            total_cycles: FitMessageLapSubfieldTotalCycles::NotYetParsed,
            total_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            total_fat_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            avg_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    110,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((1000.0, 0.0)),
                    Some("m/s".to_string()),
                )]),
            max_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    111,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((1000.0, 0.0)),
                    Some("m/s".to_string()),
                )]),
            avg_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            max_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            avg_cadence_subfield_bytes: vec![],
            avg_cadence: FitMessageLapSubfieldAvgCadence::NotYetParsed,
            max_cadence_subfield_bytes: vec![],
            max_cadence: FitMessageLapSubfieldMaxCadence::NotYetParsed,
            avg_power: FitFieldBasicValue::new_single("watts".to_string()),
            max_power: FitFieldBasicValue::new_single("watts".to_string()),
            total_ascent: FitFieldBasicValue::new_single("m".to_string()),
            total_descent: FitFieldBasicValue::new_single("m".to_string()),
            intensity: FitFieldBasicValue::new_single("".to_string()),
            lap_trigger: FitFieldBasicValue::new_single("".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            event_group: FitFieldBasicValue::new_single("".to_string()),
            num_lengths: FitFieldBasicValue::new_single("lengths".to_string()),
            normalized_power: FitFieldBasicValue::new_single("watts".to_string()),
            left_right_balance: FitFieldBasicValue::new_single("".to_string()),
            first_length_index: FitFieldBasicValue::new_single("".to_string()),
            avg_stroke_distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            swim_stroke: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            num_active_lengths: FitFieldBasicValue::new_single("lengths".to_string()),
            total_work: FitFieldBasicValue::new_single("J".to_string()),
            avg_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    112,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            max_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    114,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            gps_accuracy: FitFieldBasicValue::new_single("m".to_string()),
            avg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_pos_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_neg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            max_pos_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            max_neg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_temperature: FitFieldBasicValue::new_single("C".to_string()),
            max_temperature: FitFieldBasicValue::new_single("C".to_string()),
            total_moving_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            avg_pos_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            avg_neg_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            max_pos_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            max_neg_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            time_in_hr_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_speed_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_cadence_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_power_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            repetition_num: FitFieldBasicValue::new_single("".to_string()),
            min_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    113,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            min_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            wkt_step_index: FitFieldBasicValue::new_single("".to_string()),
            opponent_score: FitFieldBasicValue::new_single("".to_string()),
            stroke_count: FitFieldBasicValue::new_vec("counts".to_string()),
            zone_count: FitFieldBasicValue::new_vec("counts".to_string()),
            avg_vertical_oscillation: FitFieldAdjustedValue::new_single(
                "mm".to_string(),
                10.0,
                0.0,
            ),
            avg_stance_time_percent: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            avg_stance_time: FitFieldAdjustedValue::new_single("ms".to_string(), 10.0, 0.0),
            avg_fractional_cadence: FitFieldAdjustedValue::new_single(
                "rpm".to_string(),
                128.0,
                0.0,
            ),
            max_fractional_cadence: FitFieldAdjustedValue::new_single(
                "rpm".to_string(),
                128.0,
                0.0,
            ),
            total_fractional_cycles: FitFieldAdjustedValue::new_single(
                "cycles".to_string(),
                128.0,
                0.0,
            ),
            player_score: FitFieldBasicValue::new_single("".to_string()),
            avg_total_hemoglobin_conc: FitFieldAdjustedValue::new_vec(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            min_total_hemoglobin_conc: FitFieldAdjustedValue::new_vec(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            max_total_hemoglobin_conc: FitFieldAdjustedValue::new_vec(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            avg_saturated_hemoglobin_percent: FitFieldAdjustedValue::new_vec(
                "%".to_string(),
                10.0,
                0.0,
            ),
            min_saturated_hemoglobin_percent: FitFieldAdjustedValue::new_vec(
                "%".to_string(),
                10.0,
                0.0,
            ),
            max_saturated_hemoglobin_percent: FitFieldAdjustedValue::new_vec(
                "%".to_string(),
                10.0,
                0.0,
            ),
            avg_left_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_right_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_left_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_right_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_combined_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            time_standing: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            stand_count: FitFieldBasicValue::new_single("".to_string()),
            avg_left_pco: FitFieldBasicValue::new_single("mm".to_string()),
            avg_right_pco: FitFieldBasicValue::new_single("mm".to_string()),
            avg_left_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_left_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_right_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_right_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_power_position: FitFieldBasicValue::new_vec("watts".to_string()),
            max_power_position: FitFieldBasicValue::new_vec("watts".to_string()),
            avg_cadence_position: FitFieldBasicValue::new_vec("rpm".to_string()),
            max_cadence_position: FitFieldBasicValue::new_vec("rpm".to_string()),
            enhanced_avg_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            enhanced_max_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            enhanced_avg_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            enhanced_min_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            enhanced_max_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            avg_lev_motor_power: FitFieldBasicValue::new_single("watts".to_string()),
            max_lev_motor_power: FitFieldBasicValue::new_single("watts".to_string()),
            lev_battery_consumption: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_vertical_ratio: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            avg_stance_time_balance: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            avg_step_length: FitFieldAdjustedValue::new_single("mm".to_string(), 10.0, 0.0),
            avg_vam: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageLap), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // event
                self.event.parse(parse_input, parse_config)?
            }
            1 => {
                // event_type
                self.event_type.parse(parse_input, parse_config)?
            }
            2 => {
                // start_time
                self.start_time.parse(parse_input, parse_config)?
            }
            3 => {
                // start_position_lat
                self.start_position_lat.parse(parse_input, parse_config)?
            }
            4 => {
                // start_position_long
                self.start_position_long.parse(parse_input, parse_config)?
            }
            5 => {
                // end_position_lat
                self.end_position_lat.parse(parse_input, parse_config)?
            }
            6 => {
                // end_position_long
                self.end_position_long.parse(parse_input, parse_config)?
            }
            7 => {
                // total_elapsed_time
                self.total_elapsed_time.parse(parse_input, parse_config)?
            }
            8 => {
                // total_timer_time
                self.total_timer_time.parse(parse_input, parse_config)?
            }
            9 => {
                // total_distance
                self.total_distance.parse(parse_input, parse_config)?
            }
            10 => {
                // total_cycles
                self.total_cycles_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            11 => {
                // total_calories
                self.total_calories.parse(parse_input, parse_config)?
            }
            12 => {
                // total_fat_calories
                self.total_fat_calories.parse(parse_input, parse_config)?
            }
            13 => {
                // avg_speed
                self.avg_speed.parse(parse_input, parse_config)?
            }
            14 => {
                // max_speed
                self.max_speed.parse(parse_input, parse_config)?
            }
            15 => {
                // avg_heart_rate
                self.avg_heart_rate.parse(parse_input, parse_config)?
            }
            16 => {
                // max_heart_rate
                self.max_heart_rate.parse(parse_input, parse_config)?
            }
            17 => {
                // avg_cadence
                self.avg_cadence_subfield_bytes = parse_uint8_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            18 => {
                // max_cadence
                self.max_cadence_subfield_bytes = parse_uint8_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            19 => {
                // avg_power
                self.avg_power.parse(parse_input, parse_config)?
            }
            20 => {
                // max_power
                self.max_power.parse(parse_input, parse_config)?
            }
            21 => {
                // total_ascent
                self.total_ascent.parse(parse_input, parse_config)?
            }
            22 => {
                // total_descent
                self.total_descent.parse(parse_input, parse_config)?
            }
            23 => {
                // intensity
                self.intensity.parse(parse_input, parse_config)?
            }
            24 => {
                // lap_trigger
                self.lap_trigger.parse(parse_input, parse_config)?
            }
            25 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            26 => {
                // event_group
                self.event_group.parse(parse_input, parse_config)?
            }
            32 => {
                // num_lengths
                self.num_lengths.parse(parse_input, parse_config)?
            }
            33 => {
                // normalized_power
                self.normalized_power.parse(parse_input, parse_config)?
            }
            34 => {
                // left_right_balance
                self.left_right_balance.parse(parse_input, parse_config)?
            }
            35 => {
                // first_length_index
                self.first_length_index.parse(parse_input, parse_config)?
            }
            37 => {
                // avg_stroke_distance
                self.avg_stroke_distance.parse(parse_input, parse_config)?
            }
            38 => {
                // swim_stroke
                self.swim_stroke.parse(parse_input, parse_config)?
            }
            39 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            40 => {
                // num_active_lengths
                self.num_active_lengths.parse(parse_input, parse_config)?
            }
            41 => {
                // total_work
                self.total_work.parse(parse_input, parse_config)?
            }
            42 => {
                // avg_altitude
                self.avg_altitude.parse(parse_input, parse_config)?
            }
            43 => {
                // max_altitude
                self.max_altitude.parse(parse_input, parse_config)?
            }
            44 => {
                // gps_accuracy
                self.gps_accuracy.parse(parse_input, parse_config)?
            }
            45 => {
                // avg_grade
                self.avg_grade.parse(parse_input, parse_config)?
            }
            46 => {
                // avg_pos_grade
                self.avg_pos_grade.parse(parse_input, parse_config)?
            }
            47 => {
                // avg_neg_grade
                self.avg_neg_grade.parse(parse_input, parse_config)?
            }
            48 => {
                // max_pos_grade
                self.max_pos_grade.parse(parse_input, parse_config)?
            }
            49 => {
                // max_neg_grade
                self.max_neg_grade.parse(parse_input, parse_config)?
            }
            50 => {
                // avg_temperature
                self.avg_temperature.parse(parse_input, parse_config)?
            }
            51 => {
                // max_temperature
                self.max_temperature.parse(parse_input, parse_config)?
            }
            52 => {
                // total_moving_time
                self.total_moving_time.parse(parse_input, parse_config)?
            }
            53 => {
                // avg_pos_vertical_speed
                self.avg_pos_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            54 => {
                // avg_neg_vertical_speed
                self.avg_neg_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            55 => {
                // max_pos_vertical_speed
                self.max_pos_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            56 => {
                // max_neg_vertical_speed
                self.max_neg_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            57 => {
                // time_in_hr_zone
                self.time_in_hr_zone.parse(parse_input, parse_config)?
            }
            58 => {
                // time_in_speed_zone
                self.time_in_speed_zone.parse(parse_input, parse_config)?
            }
            59 => {
                // time_in_cadence_zone
                self.time_in_cadence_zone.parse(parse_input, parse_config)?
            }
            60 => {
                // time_in_power_zone
                self.time_in_power_zone.parse(parse_input, parse_config)?
            }
            61 => {
                // repetition_num
                self.repetition_num.parse(parse_input, parse_config)?
            }
            62 => {
                // min_altitude
                self.min_altitude.parse(parse_input, parse_config)?
            }
            63 => {
                // min_heart_rate
                self.min_heart_rate.parse(parse_input, parse_config)?
            }
            71 => {
                // wkt_step_index
                self.wkt_step_index.parse(parse_input, parse_config)?
            }
            74 => {
                // opponent_score
                self.opponent_score.parse(parse_input, parse_config)?
            }
            75 => {
                // stroke_count
                self.stroke_count.parse(parse_input, parse_config)?
            }
            76 => {
                // zone_count
                self.zone_count.parse(parse_input, parse_config)?
            }
            77 => {
                // avg_vertical_oscillation
                self.avg_vertical_oscillation
                    .parse(parse_input, parse_config)?
            }
            78 => {
                // avg_stance_time_percent
                self.avg_stance_time_percent
                    .parse(parse_input, parse_config)?
            }
            79 => {
                // avg_stance_time
                self.avg_stance_time.parse(parse_input, parse_config)?
            }
            80 => {
                // avg_fractional_cadence
                self.avg_fractional_cadence
                    .parse(parse_input, parse_config)?
            }
            81 => {
                // max_fractional_cadence
                self.max_fractional_cadence
                    .parse(parse_input, parse_config)?
            }
            82 => {
                // total_fractional_cycles
                self.total_fractional_cycles
                    .parse(parse_input, parse_config)?
            }
            83 => {
                // player_score
                self.player_score.parse(parse_input, parse_config)?
            }
            84 => {
                // avg_total_hemoglobin_conc
                self.avg_total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            85 => {
                // min_total_hemoglobin_conc
                self.min_total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            86 => {
                // max_total_hemoglobin_conc
                self.max_total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            87 => {
                // avg_saturated_hemoglobin_percent
                self.avg_saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            88 => {
                // min_saturated_hemoglobin_percent
                self.min_saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            89 => {
                // max_saturated_hemoglobin_percent
                self.max_saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            91 => {
                // avg_left_torque_effectiveness
                self.avg_left_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            92 => {
                // avg_right_torque_effectiveness
                self.avg_right_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            93 => {
                // avg_left_pedal_smoothness
                self.avg_left_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            94 => {
                // avg_right_pedal_smoothness
                self.avg_right_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            95 => {
                // avg_combined_pedal_smoothness
                self.avg_combined_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            98 => {
                // time_standing
                self.time_standing.parse(parse_input, parse_config)?
            }
            99 => {
                // stand_count
                self.stand_count.parse(parse_input, parse_config)?
            }
            100 => {
                // avg_left_pco
                self.avg_left_pco.parse(parse_input, parse_config)?
            }
            101 => {
                // avg_right_pco
                self.avg_right_pco.parse(parse_input, parse_config)?
            }
            102 => {
                // avg_left_power_phase
                self.avg_left_power_phase.parse(parse_input, parse_config)?
            }
            103 => {
                // avg_left_power_phase_peak
                self.avg_left_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            104 => {
                // avg_right_power_phase
                self.avg_right_power_phase
                    .parse(parse_input, parse_config)?
            }
            105 => {
                // avg_right_power_phase_peak
                self.avg_right_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            106 => {
                // avg_power_position
                self.avg_power_position.parse(parse_input, parse_config)?
            }
            107 => {
                // max_power_position
                self.max_power_position.parse(parse_input, parse_config)?
            }
            108 => {
                // avg_cadence_position
                self.avg_cadence_position.parse(parse_input, parse_config)?
            }
            109 => {
                // max_cadence_position
                self.max_cadence_position.parse(parse_input, parse_config)?
            }
            110 => {
                // enhanced_avg_speed
                self.enhanced_avg_speed.parse(parse_input, parse_config)?
            }
            111 => {
                // enhanced_max_speed
                self.enhanced_max_speed.parse(parse_input, parse_config)?
            }
            112 => {
                // enhanced_avg_altitude
                self.enhanced_avg_altitude
                    .parse(parse_input, parse_config)?
            }
            113 => {
                // enhanced_min_altitude
                self.enhanced_min_altitude
                    .parse(parse_input, parse_config)?
            }
            114 => {
                // enhanced_max_altitude
                self.enhanced_max_altitude
                    .parse(parse_input, parse_config)?
            }
            115 => {
                // avg_lev_motor_power
                self.avg_lev_motor_power.parse(parse_input, parse_config)?
            }
            116 => {
                // max_lev_motor_power
                self.max_lev_motor_power.parse(parse_input, parse_config)?
            }
            117 => {
                // lev_battery_consumption
                self.lev_battery_consumption
                    .parse(parse_input, parse_config)?
            }
            118 => {
                // avg_vertical_ratio
                self.avg_vertical_ratio.parse(parse_input, parse_config)?
            }
            119 => {
                // avg_stance_time_balance
                self.avg_stance_time_balance
                    .parse(parse_input, parse_config)?
            }
            120 => {
                // avg_step_length
                self.avg_step_length.parse(parse_input, parse_config)?
            }
            121 => {
                // avg_vam
                self.avg_vam.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            10 => {
                let (val, new_actions) = FitMessageLapSubfieldTotalCycles::parse(
                    &self,
                    &self.total_cycles_subfield_bytes,
                    &parse_config,
                )?;
                self.total_cycles = val;
                new_actions
            }

            17 => {
                let (val, new_actions) = FitMessageLapSubfieldAvgCadence::parse(
                    &self,
                    &self.avg_cadence_subfield_bytes,
                    &parse_config,
                )?;
                self.avg_cadence = val;
                new_actions
            }

            18 => {
                let (val, new_actions) = FitMessageLapSubfieldMaxCadence::parse(
                    &self,
                    &self.max_cadence_subfield_bytes,
                    &parse_config,
                )?;
                self.max_cadence = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageLap {
    fn message_name(&self) -> &'static str {
        return "FitMessageLap";
    }
}

#[derive(Debug)]
pub struct FitMessageLength {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub event: FitFieldBasicValue<FitFieldEvent>,
    pub event_type: FitFieldBasicValue<FitFieldEventType>,
    pub start_time: FitFieldBasicValue<FitFieldDateTime>,
    pub total_elapsed_time: FitFieldAdjustedValue<FitUint32>,
    pub total_timer_time: FitFieldAdjustedValue<FitUint32>,
    pub total_strokes: FitFieldBasicValue<FitUint16>,
    pub avg_speed: FitFieldAdjustedValue<FitUint16>,
    pub swim_stroke: FitFieldBasicValue<FitFieldSwimStroke>,
    pub avg_swimming_cadence: FitFieldBasicValue<FitUint8>,
    pub event_group: FitFieldBasicValue<FitUint8>,
    pub total_calories: FitFieldBasicValue<FitUint16>,
    pub length_type: FitFieldBasicValue<FitFieldLengthType>,
    pub player_score: FitFieldBasicValue<FitUint16>,
    pub opponent_score: FitFieldBasicValue<FitUint16>,
    pub stroke_count: FitFieldBasicValue<FitUint16>, // stroke_type enum used as the index
    pub zone_count: FitFieldBasicValue<FitUint16>,   // zone number used as the index
}

impl fmt::Display for FitMessageLength {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageLength")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.event, "event", false, f)?;
        fmt_message_field!(self.event_type, "event_type", false, f)?;
        fmt_message_field!(self.start_time, "start_time", false, f)?;
        fmt_message_field!(self.total_elapsed_time, "total_elapsed_time", true, f)?;
        fmt_message_field!(self.total_timer_time, "total_timer_time", true, f)?;
        fmt_message_field!(self.total_strokes, "total_strokes", false, f)?;
        fmt_message_field!(self.avg_speed, "avg_speed", true, f)?;
        fmt_message_field!(self.swim_stroke, "swim_stroke", false, f)?;
        fmt_message_field!(self.avg_swimming_cadence, "avg_swimming_cadence", false, f)?;
        fmt_message_field!(self.event_group, "event_group", false, f)?;
        fmt_message_field!(self.total_calories, "total_calories", false, f)?;
        fmt_message_field!(self.length_type, "length_type", false, f)?;
        fmt_message_field!(self.player_score, "player_score", false, f)?;
        fmt_message_field!(self.opponent_score, "opponent_score", false, f)?;
        fmt_message_field!(self.stroke_count, "stroke_count", false, f)?;
        fmt_message_field!(self.zone_count, "zone_count", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageLength {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            253 => "timestamp",
            0 => "event",
            1 => "event_type",
            2 => "start_time",
            3 => "total_elapsed_time",
            4 => "total_timer_time",
            5 => "total_strokes",
            6 => "avg_speed",
            7 => "swim_stroke",
            9 => "avg_swimming_cadence",
            10 => "event_group",
            11 => "total_calories",
            12 => "length_type",
            18 => "player_score",
            19 => "opponent_score",
            20 => "stroke_count",
            21 => "zone_count",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageLength> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageLength {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageLength",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            event: FitFieldBasicValue::new_single("".to_string()),
            event_type: FitFieldBasicValue::new_single("".to_string()),
            start_time: FitFieldBasicValue::new_single("".to_string()),
            total_elapsed_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_timer_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_strokes: FitFieldBasicValue::new_single("strokes".to_string()),
            avg_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            swim_stroke: FitFieldBasicValue::new_single("".to_string()),
            avg_swimming_cadence: FitFieldBasicValue::new_single("strokes/min".to_string()),
            event_group: FitFieldBasicValue::new_single("".to_string()),
            total_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            length_type: FitFieldBasicValue::new_single("".to_string()),
            player_score: FitFieldBasicValue::new_single("".to_string()),
            opponent_score: FitFieldBasicValue::new_single("".to_string()),
            stroke_count: FitFieldBasicValue::new_vec("counts".to_string()),
            zone_count: FitFieldBasicValue::new_vec("counts".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageLength), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // event
                self.event.parse(parse_input, parse_config)?
            }
            1 => {
                // event_type
                self.event_type.parse(parse_input, parse_config)?
            }
            2 => {
                // start_time
                self.start_time.parse(parse_input, parse_config)?
            }
            3 => {
                // total_elapsed_time
                self.total_elapsed_time.parse(parse_input, parse_config)?
            }
            4 => {
                // total_timer_time
                self.total_timer_time.parse(parse_input, parse_config)?
            }
            5 => {
                // total_strokes
                self.total_strokes.parse(parse_input, parse_config)?
            }
            6 => {
                // avg_speed
                self.avg_speed.parse(parse_input, parse_config)?
            }
            7 => {
                // swim_stroke
                self.swim_stroke.parse(parse_input, parse_config)?
            }
            9 => {
                // avg_swimming_cadence
                self.avg_swimming_cadence.parse(parse_input, parse_config)?
            }
            10 => {
                // event_group
                self.event_group.parse(parse_input, parse_config)?
            }
            11 => {
                // total_calories
                self.total_calories.parse(parse_input, parse_config)?
            }
            12 => {
                // length_type
                self.length_type.parse(parse_input, parse_config)?
            }
            18 => {
                // player_score
                self.player_score.parse(parse_input, parse_config)?
            }
            19 => {
                // opponent_score
                self.opponent_score.parse(parse_input, parse_config)?
            }
            20 => {
                // stroke_count
                self.stroke_count.parse(parse_input, parse_config)?
            }
            21 => {
                // zone_count
                self.zone_count.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageLength {
    fn message_name(&self) -> &'static str {
        return "FitMessageLength";
    }
}

#[derive(Debug)]
pub struct FitMessageMagnetometerData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub sample_time_offset: FitFieldBasicValue<FitUint16>, // Each time in the array describes the time at which the compass sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in cmps_x and cmps_y and cmps_z
    pub mag_x: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub mag_y: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub mag_z: FitFieldBasicValue<FitUint16>, // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub calibrated_mag_x: FitFieldBasicValue<FitFloat32>, // Calibrated Magnetometer reading
    pub calibrated_mag_y: FitFieldBasicValue<FitFloat32>, // Calibrated Magnetometer reading
    pub calibrated_mag_z: FitFieldBasicValue<FitFloat32>, // Calibrated Magnetometer reading
}

impl fmt::Display for FitMessageMagnetometerData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMagnetometerData")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.sample_time_offset, "sample_time_offset", false, f)?;
        fmt_message_field!(self.mag_x, "mag_x", false, f)?;
        fmt_message_field!(self.mag_y, "mag_y", false, f)?;
        fmt_message_field!(self.mag_z, "mag_z", false, f)?;
        fmt_message_field!(self.calibrated_mag_x, "calibrated_mag_x", false, f)?;
        fmt_message_field!(self.calibrated_mag_y, "calibrated_mag_y", false, f)?;
        fmt_message_field!(self.calibrated_mag_z, "calibrated_mag_z", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMagnetometerData {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "sample_time_offset",
            2 => "mag_x",
            3 => "mag_y",
            4 => "mag_z",
            5 => "calibrated_mag_x",
            6 => "calibrated_mag_y",
            7 => "calibrated_mag_z",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageMagnetometerData> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageMagnetometerData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageMagnetometerData",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            sample_time_offset: FitFieldBasicValue::new_vec("ms".to_string()),
            mag_x: FitFieldBasicValue::new_vec("counts".to_string()),
            mag_y: FitFieldBasicValue::new_vec("counts".to_string()),
            mag_z: FitFieldBasicValue::new_vec("counts".to_string()),
            calibrated_mag_x: FitFieldBasicValue::new_vec("G".to_string()),
            calibrated_mag_y: FitFieldBasicValue::new_vec("G".to_string()),
            calibrated_mag_z: FitFieldBasicValue::new_vec("G".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageMagnetometerData),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // sample_time_offset
                self.sample_time_offset.parse(parse_input, parse_config)?
            }
            2 => {
                // mag_x
                self.mag_x.parse(parse_input, parse_config)?
            }
            3 => {
                // mag_y
                self.mag_y.parse(parse_input, parse_config)?
            }
            4 => {
                // mag_z
                self.mag_z.parse(parse_input, parse_config)?
            }
            5 => {
                // calibrated_mag_x
                self.calibrated_mag_x.parse(parse_input, parse_config)?
            }
            6 => {
                // calibrated_mag_y
                self.calibrated_mag_y.parse(parse_input, parse_config)?
            }
            7 => {
                // calibrated_mag_z
                self.calibrated_mag_z.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageMagnetometerData {
    fn message_name(&self) -> &'static str {
        return "FitMessageMagnetometerData";
    }
}

#[derive(Debug)]
pub struct FitMessageMemoGlob {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub part_index: FitFieldBasicValue<FitUint32>, // Sequence number of memo blocks
    pub memo: FitFieldBasicValue<FitByte>,         // Block of utf8 bytes
    pub message_number: FitFieldBasicValue<FitUint16>, // Allows relating glob to another mesg  If used only required for first part of each memo_glob
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>, // Index of external mesg
}

impl fmt::Display for FitMessageMemoGlob {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMemoGlob")?;
        fmt_message_field!(self.part_index, "part_index", false, f)?;
        fmt_message_field!(self.memo, "memo", false, f)?;
        fmt_message_field!(self.message_number, "message_number", false, f)?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMemoGlob {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            250 => "part_index",
            0 => "memo",
            1 => "message_number",
            2 => "message_index",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageMemoGlob> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageMemoGlob {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageMemoGlob",
            part_index: FitFieldBasicValue::new_single("".to_string()),
            memo: FitFieldBasicValue::new_single("".to_string()),
            message_number: FitFieldBasicValue::new_single("".to_string()),
            message_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageMemoGlob),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            250 => {
                // part_index
                self.part_index.parse(parse_input, parse_config)?
            }
            0 => {
                // memo
                self.memo.parse(parse_input, parse_config)?
            }
            1 => {
                // message_number
                self.message_number.parse(parse_input, parse_config)?
            }
            2 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageMemoGlob {
    fn message_name(&self) -> &'static str {
        return "FitMessageMemoGlob";
    }
}

#[derive(Debug)]
pub enum FitMessageMesgCapabilitiesSubfieldCount {
    NotYetParsed,
    Default(FitUint16),
    NumPerFile(FitUint16),
    MaxPerFileType(FitUint16),
    MaxPerFile(FitUint16),
}

impl FitMessageMesgCapabilitiesSubfieldCount {
    fn parse<'a>(
        message: &FitMessageMesgCapabilities,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageMesgCapabilitiesSubfieldCount, Vec<FitParseConfig>)> {
        match message.count_type.get_single()? {
            FitFieldMesgCount::NumPerFile => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageMesgCapabilitiesSubfieldCount::NumPerFile(val),
                    new_actions,
                ));
            }

            FitFieldMesgCount::MaxPerFile => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageMesgCapabilitiesSubfieldCount::MaxPerFile(val),
                    new_actions,
                ));
            }

            FitFieldMesgCount::MaxPerFileType => {
                let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageMesgCapabilitiesSubfieldCount::MaxPerFileType(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageMesgCapabilitiesSubfieldCount::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageMesgCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub file: FitFieldBasicValue<FitFieldFile>,
    pub mesg_num: FitFieldBasicValue<FitFieldMesgNum>,
    pub count_type: FitFieldBasicValue<FitFieldMesgCount>,
    pub count_subfield_bytes: Vec<u8>,
    pub count: FitMessageMesgCapabilitiesSubfieldCount,
}

impl fmt::Display for FitMessageMesgCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMesgCapabilities")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.file, "file", false, f)?;
        fmt_message_field!(self.mesg_num, "mesg_num", false, f)?;
        fmt_message_field!(self.count_type, "count_type", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "count_subfield_bytes", self.count_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "count", self.count)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMesgCapabilities {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "file",
            1 => "mesg_num",
            2 => "count_type",
            3 => "count",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageMesgCapabilities> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageMesgCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![3],
            message_name: "FitMessageMesgCapabilities",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            file: FitFieldBasicValue::new_single("".to_string()),
            mesg_num: FitFieldBasicValue::new_single("".to_string()),
            count_type: FitFieldBasicValue::new_single("".to_string()),
            count_subfield_bytes: vec![],
            count: FitMessageMesgCapabilitiesSubfieldCount::NotYetParsed,
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageMesgCapabilities),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // file
                self.file.parse(parse_input, parse_config)?
            }
            1 => {
                // mesg_num
                self.mesg_num.parse(parse_input, parse_config)?
            }
            2 => {
                // count_type
                self.count_type.parse(parse_input, parse_config)?
            }
            3 => {
                // count
                self.count_subfield_bytes = parse_uint16_as_bytes(parse_input, parse_config)?;
                vec![]
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            3 => {
                let (val, new_actions) = FitMessageMesgCapabilitiesSubfieldCount::parse(
                    &self,
                    &self.count_subfield_bytes,
                    &parse_config,
                )?;
                self.count = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageMesgCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageMesgCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageMetZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub high_bpm: FitFieldBasicValue<FitUint8>,
    pub calories: FitFieldAdjustedValue<FitUint16>,
    pub fat_calories: FitFieldAdjustedValue<FitUint8>,
}

impl fmt::Display for FitMessageMetZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMetZone")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.high_bpm, "high_bpm", false, f)?;
        fmt_message_field!(self.calories, "calories", true, f)?;
        fmt_message_field!(self.fat_calories, "fat_calories", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMetZone {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            1 => "high_bpm",
            2 => "calories",
            3 => "fat_calories",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageMetZone> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageMetZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageMetZone",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            high_bpm: FitFieldBasicValue::new_single("".to_string()),
            calories: FitFieldAdjustedValue::new_single("kcal / min".to_string(), 10.0, 0.0),
            fat_calories: FitFieldAdjustedValue::new_single("kcal / min".to_string(), 10.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageMetZone),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            1 => {
                // high_bpm
                self.high_bpm.parse(parse_input, parse_config)?
            }
            2 => {
                // calories
                self.calories.parse(parse_input, parse_config)?
            }
            3 => {
                // fat_calories
                self.fat_calories.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageMetZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageMetZone";
    }
}

#[derive(Debug)]
pub enum FitMessageMonitoringSubfieldCycles {
    NotYetParsed,
    Default(FitFloat64),
    Strokes(FitFloat64),
    Steps(FitFloat64),
}

impl FitMessageMonitoringSubfieldCycles {
    fn parse<'a>(
        message: &FitMessageMonitoring,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageMonitoringSubfieldCycles, Vec<FitParseConfig>)> {
        match message.activity_type.get_single()? {
            FitFieldActivityType::Walking => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("steps".to_string(), 1.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageMonitoringSubfieldCycles::Steps(val), new_actions));
            }

            FitFieldActivityType::Running => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("steps".to_string(), 1.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((FitMessageMonitoringSubfieldCycles::Steps(val), new_actions));
            }

            FitFieldActivityType::Cycling => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("strokes".to_string(), 2.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageMonitoringSubfieldCycles::Strokes(val),
                    new_actions,
                ));
            }

            FitFieldActivityType::Swimming => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("strokes".to_string(), 2.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageMonitoringSubfieldCycles::Strokes(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldAdjustedValue::<FitFloat64>::new_single("".to_string(), 2.0, 0.0);
        parser.parse(inp, parse_config)?;

        let val = <FitFloat64>::from(parser.get_single()?);

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageMonitoringSubfieldCycles::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageMonitoring {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Must align to logging interval, for example, time must be 00:00:00 for daily log.
    pub device_index: FitFieldBasicValue<FitFieldDeviceIndex>, // Associates this data to device_info message.  Not required for file with single device (sensor).
    pub calories: FitFieldBasicValue<FitUint16>, // Accumulated total calories.  Maintained by MonitoringReader for each activity_type.  See SDK documentation
    pub distance: FitFieldAdjustedValue<FitUint32>, // Accumulated distance.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
    pub cycles_subfield_bytes: Vec<u8>,
    pub cycles: FitMessageMonitoringSubfieldCycles, // Accumulated cycles.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
    pub active_time: FitFieldAdjustedValue<FitUint32>,
    pub activity_type: FitFieldBasicValue<FitFieldActivityType>,
    pub activity_subtype: FitFieldBasicValue<FitFieldActivitySubtype>,
    pub activity_level: FitFieldBasicValue<FitFieldActivityLevel>,
    pub distance_16: FitFieldBasicValue<FitUint16>,
    pub cycles_16: FitFieldBasicValue<FitUint16>,
    pub active_time_16: FitFieldBasicValue<FitUint16>,
    pub local_timestamp: FitFieldBasicValue<FitFieldLocalDateTime>, // Must align to logging interval, for example, time must be 00:00:00 for daily log.
    pub temperature: FitFieldAdjustedValue<FitSint16>, // Avg temperature during the logging interval ended at timestamp
    pub temperature_min: FitFieldAdjustedValue<FitSint16>, // Min temperature during the logging interval ended at timestamp
    pub temperature_max: FitFieldAdjustedValue<FitSint16>, // Max temperature during the logging interval ended at timestamp
    pub activity_time: FitFieldBasicValue<FitUint16>, // Indexed using minute_activity_level enum
    pub active_calories: FitFieldBasicValue<FitUint16>,
    pub current_activity_type_intensity: FitFieldBasicValue<FitByte>, // Indicates single type / intensity for duration since last monitoring message.
    pub timestamp_min_8: FitFieldBasicValue<FitUint8>,
    pub timestamp_16: FitFieldBasicValue<FitUint16>,
    pub heart_rate: FitFieldBasicValue<FitUint8>,
    pub intensity: FitFieldAdjustedValue<FitUint8>,
    pub duration_min: FitFieldBasicValue<FitUint16>,
    pub duration: FitFieldBasicValue<FitUint32>,
    pub ascent: FitFieldAdjustedValue<FitUint32>,
    pub descent: FitFieldAdjustedValue<FitUint32>,
    pub moderate_activity_minutes: FitFieldBasicValue<FitUint16>,
    pub vigorous_activity_minutes: FitFieldBasicValue<FitUint16>,
}

impl fmt::Display for FitMessageMonitoring {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMonitoring")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.device_index, "device_index", false, f)?;
        fmt_message_field!(self.calories, "calories", false, f)?;
        fmt_message_field!(self.distance, "distance", true, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "cycles_subfield_bytes", self.cycles_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "cycles", self.cycles)?;
        fmt_message_field!(self.active_time, "active_time", true, f)?;
        fmt_message_field!(self.activity_type, "activity_type", false, f)?;
        fmt_message_field!(self.activity_subtype, "activity_subtype", false, f)?;
        fmt_message_field!(self.activity_level, "activity_level", false, f)?;
        fmt_message_field!(self.distance_16, "distance_16", false, f)?;
        fmt_message_field!(self.cycles_16, "cycles_16", false, f)?;
        fmt_message_field!(self.active_time_16, "active_time_16", false, f)?;
        fmt_message_field!(self.local_timestamp, "local_timestamp", false, f)?;
        fmt_message_field!(self.temperature, "temperature", true, f)?;
        fmt_message_field!(self.temperature_min, "temperature_min", true, f)?;
        fmt_message_field!(self.temperature_max, "temperature_max", true, f)?;
        fmt_message_field!(self.activity_time, "activity_time", false, f)?;
        fmt_message_field!(self.active_calories, "active_calories", false, f)?;
        fmt_message_field!(
            self.current_activity_type_intensity,
            "current_activity_type_intensity",
            false,
            f
        )?;
        fmt_message_field!(self.timestamp_min_8, "timestamp_min_8", false, f)?;
        fmt_message_field!(self.timestamp_16, "timestamp_16", false, f)?;
        fmt_message_field!(self.heart_rate, "heart_rate", false, f)?;
        fmt_message_field!(self.intensity, "intensity", true, f)?;
        fmt_message_field!(self.duration_min, "duration_min", false, f)?;
        fmt_message_field!(self.duration, "duration", false, f)?;
        fmt_message_field!(self.ascent, "ascent", true, f)?;
        fmt_message_field!(self.descent, "descent", true, f)?;
        fmt_message_field!(
            self.moderate_activity_minutes,
            "moderate_activity_minutes",
            false,
            f
        )?;
        fmt_message_field!(
            self.vigorous_activity_minutes,
            "vigorous_activity_minutes",
            false,
            f
        )?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMonitoring {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "device_index",
            1 => "calories",
            2 => "distance",
            3 => "cycles",
            4 => "active_time",
            5 => "activity_type",
            6 => "activity_subtype",
            7 => "activity_level",
            8 => "distance_16",
            9 => "cycles_16",
            10 => "active_time_16",
            11 => "local_timestamp",
            12 => "temperature",
            14 => "temperature_min",
            15 => "temperature_max",
            16 => "activity_time",
            19 => "active_calories",
            24 => "current_activity_type_intensity",
            25 => "timestamp_min_8",
            26 => "timestamp_16",
            27 => "heart_rate",
            28 => "intensity",
            29 => "duration_min",
            30 => "duration",
            31 => "ascent",
            32 => "descent",
            33 => "moderate_activity_minutes",
            34 => "vigorous_activity_minutes",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageMonitoring> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageMonitoring {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![3],
            message_name: "FitMessageMonitoring",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            device_index: FitFieldBasicValue::new_single("".to_string()),
            calories: FitFieldBasicValue::new_single("kcal".to_string()),
            distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            cycles_subfield_bytes: vec![],
            cycles: FitMessageMonitoringSubfieldCycles::NotYetParsed,
            active_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            activity_type: FitFieldBasicValue::new_single("".to_string()),
            activity_subtype: FitFieldBasicValue::new_single("".to_string()),
            activity_level: FitFieldBasicValue::new_single("".to_string()),
            distance_16: FitFieldBasicValue::new_single("100 * m".to_string()),
            cycles_16: FitFieldBasicValue::new_single("2 * cycles (steps)".to_string()),
            active_time_16: FitFieldBasicValue::new_single("s".to_string()),
            local_timestamp: FitFieldBasicValue::new_single("".to_string()),
            temperature: FitFieldAdjustedValue::new_single("C".to_string(), 100.0, 0.0),
            temperature_min: FitFieldAdjustedValue::new_single("C".to_string(), 100.0, 0.0),
            temperature_max: FitFieldAdjustedValue::new_single("C".to_string(), 100.0, 0.0),
            activity_time: FitFieldBasicValue::new_vec("minutes".to_string()),
            active_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            current_activity_type_intensity: FitFieldBasicValue::new_single("".to_string())
                .add_components(vec![
                    FitParseConfig::new_from_component(
                        5,
                        1,
                        0,
                        endianness,
                        0,
                        5,
                        None,
                        Some("".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        28,
                        1,
                        2,
                        endianness,
                        5,
                        3,
                        None,
                        Some("".to_string()),
                    ),
                ]),
            timestamp_min_8: FitFieldBasicValue::new_single("min".to_string()),
            timestamp_16: FitFieldBasicValue::new_single("s".to_string()),
            heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            intensity: FitFieldAdjustedValue::new_single("".to_string(), 10.0, 0.0),
            duration_min: FitFieldBasicValue::new_single("min".to_string()),
            duration: FitFieldBasicValue::new_single("s".to_string()),
            ascent: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            descent: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            moderate_activity_minutes: FitFieldBasicValue::new_single("minutes".to_string()),
            vigorous_activity_minutes: FitFieldBasicValue::new_single("minutes".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageMonitoring),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // device_index
                self.device_index.parse(parse_input, parse_config)?
            }
            1 => {
                // calories
                self.calories.parse(parse_input, parse_config)?
            }
            2 => {
                // distance
                self.distance.parse(parse_input, parse_config)?
            }
            3 => {
                // cycles
                self.cycles_subfield_bytes = parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            4 => {
                // active_time
                self.active_time.parse(parse_input, parse_config)?
            }
            5 => {
                // activity_type
                self.activity_type.parse(parse_input, parse_config)?
            }
            6 => {
                // activity_subtype
                self.activity_subtype.parse(parse_input, parse_config)?
            }
            7 => {
                // activity_level
                self.activity_level.parse(parse_input, parse_config)?
            }
            8 => {
                // distance_16
                self.distance_16.parse(parse_input, parse_config)?
            }
            9 => {
                // cycles_16
                self.cycles_16.parse(parse_input, parse_config)?
            }
            10 => {
                // active_time_16
                self.active_time_16.parse(parse_input, parse_config)?
            }
            11 => {
                // local_timestamp
                self.local_timestamp.parse(parse_input, parse_config)?
            }
            12 => {
                // temperature
                self.temperature.parse(parse_input, parse_config)?
            }
            14 => {
                // temperature_min
                self.temperature_min.parse(parse_input, parse_config)?
            }
            15 => {
                // temperature_max
                self.temperature_max.parse(parse_input, parse_config)?
            }
            16 => {
                // activity_time
                self.activity_time.parse(parse_input, parse_config)?
            }
            19 => {
                // active_calories
                self.active_calories.parse(parse_input, parse_config)?
            }
            24 => {
                // current_activity_type_intensity
                self.current_activity_type_intensity
                    .parse(parse_input, parse_config)?
            }
            25 => {
                // timestamp_min_8
                self.timestamp_min_8.parse(parse_input, parse_config)?
            }
            26 => {
                // timestamp_16
                self.timestamp_16.parse(parse_input, parse_config)?
            }
            27 => {
                // heart_rate
                self.heart_rate.parse(parse_input, parse_config)?
            }
            28 => {
                // intensity
                self.intensity.parse(parse_input, parse_config)?
            }
            29 => {
                // duration_min
                self.duration_min.parse(parse_input, parse_config)?
            }
            30 => {
                // duration
                self.duration.parse(parse_input, parse_config)?
            }
            31 => {
                // ascent
                self.ascent.parse(parse_input, parse_config)?
            }
            32 => {
                // descent
                self.descent.parse(parse_input, parse_config)?
            }
            33 => {
                // moderate_activity_minutes
                self.moderate_activity_minutes
                    .parse(parse_input, parse_config)?
            }
            34 => {
                // vigorous_activity_minutes
                self.vigorous_activity_minutes
                    .parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            3 => {
                let (val, new_actions) = FitMessageMonitoringSubfieldCycles::parse(
                    &self,
                    &self.cycles_subfield_bytes,
                    &parse_config,
                )?;
                self.cycles = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageMonitoring {
    fn message_name(&self) -> &'static str {
        return "FitMessageMonitoring";
    }
}

#[derive(Debug)]
pub struct FitMessageMonitoringInfo {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub local_timestamp: FitFieldBasicValue<FitFieldLocalDateTime>, // Use to convert activity timestamps to local time if device does not support time zone and daylight savings time correction.
    pub activity_type: FitFieldBasicValue<FitFieldActivityType>,
    pub cycles_to_distance: FitFieldAdjustedValue<FitUint16>, // Indexed by activity_type
    pub cycles_to_calories: FitFieldAdjustedValue<FitUint16>, // Indexed by activity_type
    pub resting_metabolic_rate: FitFieldBasicValue<FitUint16>,
}

impl fmt::Display for FitMessageMonitoringInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMonitoringInfo")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.local_timestamp, "local_timestamp", false, f)?;
        fmt_message_field!(self.activity_type, "activity_type", false, f)?;
        fmt_message_field!(self.cycles_to_distance, "cycles_to_distance", true, f)?;
        fmt_message_field!(self.cycles_to_calories, "cycles_to_calories", true, f)?;
        fmt_message_field!(
            self.resting_metabolic_rate,
            "resting_metabolic_rate",
            false,
            f
        )?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMonitoringInfo {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "local_timestamp",
            1 => "activity_type",
            3 => "cycles_to_distance",
            4 => "cycles_to_calories",
            5 => "resting_metabolic_rate",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageMonitoringInfo> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageMonitoringInfo {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageMonitoringInfo",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            local_timestamp: FitFieldBasicValue::new_single("".to_string()),
            activity_type: FitFieldBasicValue::new_vec("".to_string()),
            cycles_to_distance: FitFieldAdjustedValue::new_vec("m/cycle".to_string(), 5000.0, 0.0),
            cycles_to_calories: FitFieldAdjustedValue::new_vec(
                "kcal/cycle".to_string(),
                5000.0,
                0.0,
            ),
            resting_metabolic_rate: FitFieldBasicValue::new_single("kcal / day".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageMonitoringInfo),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // local_timestamp
                self.local_timestamp.parse(parse_input, parse_config)?
            }
            1 => {
                // activity_type
                self.activity_type.parse(parse_input, parse_config)?
            }
            3 => {
                // cycles_to_distance
                self.cycles_to_distance.parse(parse_input, parse_config)?
            }
            4 => {
                // cycles_to_calories
                self.cycles_to_calories.parse(parse_input, parse_config)?
            }
            5 => {
                // resting_metabolic_rate
                self.resting_metabolic_rate
                    .parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageMonitoringInfo {
    fn message_name(&self) -> &'static str {
        return "FitMessageMonitoringInfo";
    }
}

#[derive(Debug)]
pub struct FitMessageNmeaSentence {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Timestamp message was output
    pub timestamp_ms: FitFieldBasicValue<FitUint16>, // Fractional part of timestamp, added to timestamp
    pub sentence: FitFieldBasicValue<FitString>,     // NMEA sentence
}

impl fmt::Display for FitMessageNmeaSentence {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageNmeaSentence")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.sentence, "sentence", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageNmeaSentence {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "sentence",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageNmeaSentence> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageNmeaSentence {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageNmeaSentence",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            sentence: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageNmeaSentence),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // sentence
                self.sentence.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageNmeaSentence {
    fn message_name(&self) -> &'static str {
        return "FitMessageNmeaSentence";
    }
}

#[derive(Debug)]
pub struct FitMessageObdiiData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Timestamp message was output
    pub timestamp_ms: FitFieldBasicValue<FitUint16>, // Fractional part of timestamp, added to timestamp
    pub time_offset: FitFieldBasicValue<FitUint16>, // Offset of PID reading [i] from start_timestamp+start_timestamp_ms. Readings may span accross seconds.
    pub pid: FitFieldBasicValue<FitByte>,           // Parameter ID
    pub raw_data: FitFieldBasicValue<FitByte>,      // Raw parameter data
    pub pid_data_size: FitFieldBasicValue<FitUint8>, // Optional, data size of PID[i].  If not specified refer to SAE J1979.
    pub system_time: FitFieldBasicValue<FitUint32>, // System time associated with sample expressed in ms, can be used instead of time_offset.  There will be a system_time value for each raw_data element.  For multibyte pids the system_time is repeated.
    pub start_timestamp: FitFieldBasicValue<FitFieldDateTime>, // Timestamp of first sample recorded in the message.  Used with time_offset to generate time of each sample
    pub start_timestamp_ms: FitFieldBasicValue<FitUint16>,     // Fractional part of start_timestamp
}

impl fmt::Display for FitMessageObdiiData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageObdiiData")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.time_offset, "time_offset", false, f)?;
        fmt_message_field!(self.pid, "pid", false, f)?;
        fmt_message_field!(self.raw_data, "raw_data", false, f)?;
        fmt_message_field!(self.pid_data_size, "pid_data_size", false, f)?;
        fmt_message_field!(self.system_time, "system_time", false, f)?;
        fmt_message_field!(self.start_timestamp, "start_timestamp", false, f)?;
        fmt_message_field!(self.start_timestamp_ms, "start_timestamp_ms", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageObdiiData {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "time_offset",
            2 => "pid",
            3 => "raw_data",
            4 => "pid_data_size",
            5 => "system_time",
            6 => "start_timestamp",
            7 => "start_timestamp_ms",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageObdiiData> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageObdiiData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageObdiiData",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            time_offset: FitFieldBasicValue::new_vec("ms".to_string()),
            pid: FitFieldBasicValue::new_single("".to_string()),
            raw_data: FitFieldBasicValue::new_single("".to_string()),
            pid_data_size: FitFieldBasicValue::new_vec("".to_string()),
            system_time: FitFieldBasicValue::new_vec("".to_string()),
            start_timestamp: FitFieldBasicValue::new_single("".to_string()),
            start_timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageObdiiData),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // time_offset
                self.time_offset.parse(parse_input, parse_config)?
            }
            2 => {
                // pid
                self.pid.parse(parse_input, parse_config)?
            }
            3 => {
                // raw_data
                self.raw_data.parse(parse_input, parse_config)?
            }
            4 => {
                // pid_data_size
                self.pid_data_size.parse(parse_input, parse_config)?
            }
            5 => {
                // system_time
                self.system_time.parse(parse_input, parse_config)?
            }
            6 => {
                // start_timestamp
                self.start_timestamp.parse(parse_input, parse_config)?
            }
            7 => {
                // start_timestamp_ms
                self.start_timestamp_ms.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageObdiiData {
    fn message_name(&self) -> &'static str {
        return "FitMessageObdiiData";
    }
}

#[derive(Debug)]
pub struct FitMessageOhrSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub enabled: FitFieldBasicValue<FitFieldSwitch>,
}

impl fmt::Display for FitMessageOhrSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageOhrSettings")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageOhrSettings {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "enabled",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageOhrSettings> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageOhrSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageOhrSettings",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            enabled: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageOhrSettings),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageOhrSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageOhrSettings";
    }
}

#[derive(Debug)]
pub enum FitMessageOneDSensorCalibrationSubfieldCalibrationFactor {
    NotYetParsed,
    Default(FitUint32),
    BaroCalFactor(FitUint32),
}

impl FitMessageOneDSensorCalibrationSubfieldCalibrationFactor {
    fn parse<'a>(
        message: &FitMessageOneDSensorCalibration,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageOneDSensorCalibrationSubfieldCalibrationFactor,
        Vec<FitParseConfig>,
    )> {
        match message.sensor_type.get_single()? {
            FitFieldSensorType::Barometer => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("Pa".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::BaroCalFactor(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageOneDSensorCalibration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub sensor_type: FitFieldBasicValue<FitFieldSensorType>, // Indicates which sensor the calibration is for
    pub calibration_factor_subfield_bytes: Vec<u8>,
    pub calibration_factor: FitMessageOneDSensorCalibrationSubfieldCalibrationFactor, // Calibration factor used to convert from raw ADC value to degrees, g,  etc.
    pub calibration_divisor: FitFieldBasicValue<FitUint32>, // Calibration factor divisor
    pub level_shift: FitFieldBasicValue<FitUint32>, // Level shift value used to shift the ADC value back into range
    pub offset_cal: FitFieldBasicValue<FitSint32>,  // Internal Calibration factor
}

impl fmt::Display for FitMessageOneDSensorCalibration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageOneDSensorCalibration")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.sensor_type, "sensor_type", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "calibration_factor_subfield_bytes", self.calibration_factor_subfield_bytes
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "calibration_factor", self.calibration_factor
        )?;
        fmt_message_field!(self.calibration_divisor, "calibration_divisor", false, f)?;
        fmt_message_field!(self.level_shift, "level_shift", false, f)?;
        fmt_message_field!(self.offset_cal, "offset_cal", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageOneDSensorCalibration {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "sensor_type",
            1 => "calibration_factor",
            2 => "calibration_divisor",
            3 => "level_shift",
            4 => "offset_cal",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageOneDSensorCalibration> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageOneDSensorCalibration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![1],
            message_name: "FitMessageOneDSensorCalibration",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            sensor_type: FitFieldBasicValue::new_single("".to_string()),
            calibration_factor_subfield_bytes: vec![],
            calibration_factor:
                FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::NotYetParsed,
            calibration_divisor: FitFieldBasicValue::new_single("counts".to_string()),
            level_shift: FitFieldBasicValue::new_single("".to_string()),
            offset_cal: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageOneDSensorCalibration),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // sensor_type
                self.sensor_type.parse(parse_input, parse_config)?
            }
            1 => {
                // calibration_factor
                self.calibration_factor_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            2 => {
                // calibration_divisor
                self.calibration_divisor.parse(parse_input, parse_config)?
            }
            3 => {
                // level_shift
                self.level_shift.parse(parse_input, parse_config)?
            }
            4 => {
                // offset_cal
                self.offset_cal.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            1 => {
                let (val, new_actions) =
                    FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::parse(
                        &self,
                        &self.calibration_factor_subfield_bytes,
                        &parse_config,
                    )?;
                self.calibration_factor = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageOneDSensorCalibration {
    fn message_name(&self) -> &'static str {
        return "FitMessageOneDSensorCalibration";
    }
}

#[derive(Debug)]
pub struct FitMessagePowerZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub high_value: FitFieldBasicValue<FitUint16>,
    pub name: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessagePowerZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessagePowerZone")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.high_value, "high_value", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessagePowerZone {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            1 => "high_value",
            2 => "name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessagePowerZone> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessagePowerZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessagePowerZone",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            high_value: FitFieldBasicValue::new_single("watts".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessagePowerZone),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            1 => {
                // high_value
                self.high_value.parse(parse_input, parse_config)?
            }
            2 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessagePowerZone {
    fn message_name(&self) -> &'static str {
        return "FitMessagePowerZone";
    }
}

#[derive(Debug)]
pub struct FitMessageRecord {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub position_lat: FitFieldAdjustedValue<FitSint32>,
    pub position_long: FitFieldAdjustedValue<FitSint32>,
    pub altitude: FitFieldAdjustedValue<FitUint16>,
    pub heart_rate: FitFieldBasicValue<FitUint8>,
    pub cadence: FitFieldBasicValue<FitUint8>,
    pub distance: FitFieldAdjustedValue<FitUint32>,
    pub speed: FitFieldAdjustedValue<FitUint16>,
    pub power: FitFieldBasicValue<FitUint16>,
    pub compressed_speed_distance: FitFieldBasicValue<FitByte>,
    pub grade: FitFieldAdjustedValue<FitSint16>,
    pub resistance: FitFieldBasicValue<FitUint8>, // Relative. 0 is none  254 is Max.
    pub time_from_course: FitFieldAdjustedValue<FitSint32>,
    pub cycle_length: FitFieldAdjustedValue<FitUint8>,
    pub temperature: FitFieldBasicValue<FitSint8>,
    pub speed_1s: FitFieldAdjustedValue<FitUint8>, // Speed at 1s intervals.  Timestamp field indicates time of last array element.
    pub cycles: FitFieldBasicValue<FitUint8>,
    pub total_cycles: FitFieldBasicValue<FitUint32>,
    pub compressed_accumulated_power: FitFieldBasicValue<FitUint16>,
    pub accumulated_power: FitFieldBasicValue<FitUint32>,
    pub left_right_balance: FitFieldBasicValue<FitFieldLeftRightBalance>,
    pub gps_accuracy: FitFieldBasicValue<FitUint8>,
    pub vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub calories: FitFieldBasicValue<FitUint16>,
    pub vertical_oscillation: FitFieldAdjustedValue<FitUint16>,
    pub stance_time_percent: FitFieldAdjustedValue<FitUint16>,
    pub stance_time: FitFieldAdjustedValue<FitUint16>,
    pub activity_type: FitFieldBasicValue<FitFieldActivityType>,
    pub left_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub right_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub left_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub right_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub combined_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub time128: FitFieldAdjustedValue<FitUint8>,
    pub stroke_type: FitFieldBasicValue<FitFieldStrokeType>,
    pub zone: FitFieldBasicValue<FitUint8>,
    pub ball_speed: FitFieldAdjustedValue<FitUint16>,
    pub cadence256: FitFieldAdjustedValue<FitUint16>, // Log cadence and fractional cadence for backwards compatability
    pub fractional_cadence: FitFieldAdjustedValue<FitUint8>,
    pub total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Total saturated and unsaturated hemoglobin
    pub total_hemoglobin_conc_min: FitFieldAdjustedValue<FitUint16>, // Min saturated and unsaturated hemoglobin
    pub total_hemoglobin_conc_max: FitFieldAdjustedValue<FitUint16>, // Max saturated and unsaturated hemoglobin
    pub saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Percentage of hemoglobin saturated with oxygen
    pub saturated_hemoglobin_percent_min: FitFieldAdjustedValue<FitUint16>, // Min percentage of hemoglobin saturated with oxygen
    pub saturated_hemoglobin_percent_max: FitFieldAdjustedValue<FitUint16>, // Max percentage of hemoglobin saturated with oxygen
    pub device_index: FitFieldBasicValue<FitFieldDeviceIndex>,
    pub left_pco: FitFieldBasicValue<FitSint8>, // Left platform center offset
    pub right_pco: FitFieldBasicValue<FitSint8>, // Right platform center offset
    pub left_power_phase: FitFieldAdjustedValue<FitUint8>, // Left power phase angles. Data value indexes defined by power_phase_type.
    pub left_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Left power phase peak angles. Data value indexes defined by power_phase_type.
    pub right_power_phase: FitFieldAdjustedValue<FitUint8>, // Right power phase angles. Data value indexes defined by power_phase_type.
    pub right_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Right power phase peak angles. Data value indexes defined by power_phase_type.
    pub enhanced_speed: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_altitude: FitFieldAdjustedValue<FitUint32>,
    pub battery_soc: FitFieldAdjustedValue<FitUint8>, // lev battery state of charge
    pub motor_power: FitFieldBasicValue<FitUint16>,   // lev motor power
    pub vertical_ratio: FitFieldAdjustedValue<FitUint16>,
    pub stance_time_balance: FitFieldAdjustedValue<FitUint16>,
    pub step_length: FitFieldAdjustedValue<FitUint16>,
    pub absolute_pressure: FitFieldBasicValue<FitUint32>, // Includes atmospheric pressure
    pub depth: FitFieldAdjustedValue<FitUint32>,          // 0 if above water
    pub next_stop_depth: FitFieldAdjustedValue<FitUint32>, // 0 if above water
    pub next_stop_time: FitFieldAdjustedValue<FitUint32>,
    pub time_to_surface: FitFieldAdjustedValue<FitUint32>,
    pub ndl_time: FitFieldAdjustedValue<FitUint32>,
    pub cns_load: FitFieldBasicValue<FitUint8>,
    pub n2_load: FitFieldAdjustedValue<FitUint16>,
}

impl fmt::Display for FitMessageRecord {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageRecord")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.position_lat, "position_lat", true, f)?;
        fmt_message_field!(self.position_long, "position_long", true, f)?;
        fmt_message_field!(self.altitude, "altitude", true, f)?;
        fmt_message_field!(self.heart_rate, "heart_rate", false, f)?;
        fmt_message_field!(self.cadence, "cadence", false, f)?;
        fmt_message_field!(self.distance, "distance", true, f)?;
        fmt_message_field!(self.speed, "speed", true, f)?;
        fmt_message_field!(self.power, "power", false, f)?;
        fmt_message_field!(
            self.compressed_speed_distance,
            "compressed_speed_distance",
            false,
            f
        )?;
        fmt_message_field!(self.grade, "grade", true, f)?;
        fmt_message_field!(self.resistance, "resistance", false, f)?;
        fmt_message_field!(self.time_from_course, "time_from_course", true, f)?;
        fmt_message_field!(self.cycle_length, "cycle_length", true, f)?;
        fmt_message_field!(self.temperature, "temperature", false, f)?;
        fmt_message_field!(self.speed_1s, "speed_1s", true, f)?;
        fmt_message_field!(self.cycles, "cycles", false, f)?;
        fmt_message_field!(self.total_cycles, "total_cycles", false, f)?;
        fmt_message_field!(
            self.compressed_accumulated_power,
            "compressed_accumulated_power",
            false,
            f
        )?;
        fmt_message_field!(self.accumulated_power, "accumulated_power", false, f)?;
        fmt_message_field!(self.left_right_balance, "left_right_balance", false, f)?;
        fmt_message_field!(self.gps_accuracy, "gps_accuracy", false, f)?;
        fmt_message_field!(self.vertical_speed, "vertical_speed", true, f)?;
        fmt_message_field!(self.calories, "calories", false, f)?;
        fmt_message_field!(self.vertical_oscillation, "vertical_oscillation", true, f)?;
        fmt_message_field!(self.stance_time_percent, "stance_time_percent", true, f)?;
        fmt_message_field!(self.stance_time, "stance_time", true, f)?;
        fmt_message_field!(self.activity_type, "activity_type", false, f)?;
        fmt_message_field!(
            self.left_torque_effectiveness,
            "left_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.right_torque_effectiveness,
            "right_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(self.left_pedal_smoothness, "left_pedal_smoothness", true, f)?;
        fmt_message_field!(
            self.right_pedal_smoothness,
            "right_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.combined_pedal_smoothness,
            "combined_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(self.time128, "time128", true, f)?;
        fmt_message_field!(self.stroke_type, "stroke_type", false, f)?;
        fmt_message_field!(self.zone, "zone", false, f)?;
        fmt_message_field!(self.ball_speed, "ball_speed", true, f)?;
        fmt_message_field!(self.cadence256, "cadence256", true, f)?;
        fmt_message_field!(self.fractional_cadence, "fractional_cadence", true, f)?;
        fmt_message_field!(self.total_hemoglobin_conc, "total_hemoglobin_conc", true, f)?;
        fmt_message_field!(
            self.total_hemoglobin_conc_min,
            "total_hemoglobin_conc_min",
            true,
            f
        )?;
        fmt_message_field!(
            self.total_hemoglobin_conc_max,
            "total_hemoglobin_conc_max",
            true,
            f
        )?;
        fmt_message_field!(
            self.saturated_hemoglobin_percent,
            "saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.saturated_hemoglobin_percent_min,
            "saturated_hemoglobin_percent_min",
            true,
            f
        )?;
        fmt_message_field!(
            self.saturated_hemoglobin_percent_max,
            "saturated_hemoglobin_percent_max",
            true,
            f
        )?;
        fmt_message_field!(self.device_index, "device_index", false, f)?;
        fmt_message_field!(self.left_pco, "left_pco", false, f)?;
        fmt_message_field!(self.right_pco, "right_pco", false, f)?;
        fmt_message_field!(self.left_power_phase, "left_power_phase", true, f)?;
        fmt_message_field!(self.left_power_phase_peak, "left_power_phase_peak", true, f)?;
        fmt_message_field!(self.right_power_phase, "right_power_phase", true, f)?;
        fmt_message_field!(
            self.right_power_phase_peak,
            "right_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.enhanced_speed, "enhanced_speed", true, f)?;
        fmt_message_field!(self.enhanced_altitude, "enhanced_altitude", true, f)?;
        fmt_message_field!(self.battery_soc, "battery_soc", true, f)?;
        fmt_message_field!(self.motor_power, "motor_power", false, f)?;
        fmt_message_field!(self.vertical_ratio, "vertical_ratio", true, f)?;
        fmt_message_field!(self.stance_time_balance, "stance_time_balance", true, f)?;
        fmt_message_field!(self.step_length, "step_length", true, f)?;
        fmt_message_field!(self.absolute_pressure, "absolute_pressure", false, f)?;
        fmt_message_field!(self.depth, "depth", true, f)?;
        fmt_message_field!(self.next_stop_depth, "next_stop_depth", true, f)?;
        fmt_message_field!(self.next_stop_time, "next_stop_time", true, f)?;
        fmt_message_field!(self.time_to_surface, "time_to_surface", true, f)?;
        fmt_message_field!(self.ndl_time, "ndl_time", true, f)?;
        fmt_message_field!(self.cns_load, "cns_load", false, f)?;
        fmt_message_field!(self.n2_load, "n2_load", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageRecord {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "position_lat",
            1 => "position_long",
            2 => "altitude",
            3 => "heart_rate",
            4 => "cadence",
            5 => "distance",
            6 => "speed",
            7 => "power",
            8 => "compressed_speed_distance",
            9 => "grade",
            10 => "resistance",
            11 => "time_from_course",
            12 => "cycle_length",
            13 => "temperature",
            17 => "speed_1s",
            18 => "cycles",
            19 => "total_cycles",
            28 => "compressed_accumulated_power",
            29 => "accumulated_power",
            30 => "left_right_balance",
            31 => "gps_accuracy",
            32 => "vertical_speed",
            33 => "calories",
            39 => "vertical_oscillation",
            40 => "stance_time_percent",
            41 => "stance_time",
            42 => "activity_type",
            43 => "left_torque_effectiveness",
            44 => "right_torque_effectiveness",
            45 => "left_pedal_smoothness",
            46 => "right_pedal_smoothness",
            47 => "combined_pedal_smoothness",
            48 => "time128",
            49 => "stroke_type",
            50 => "zone",
            51 => "ball_speed",
            52 => "cadence256",
            53 => "fractional_cadence",
            54 => "total_hemoglobin_conc",
            55 => "total_hemoglobin_conc_min",
            56 => "total_hemoglobin_conc_max",
            57 => "saturated_hemoglobin_percent",
            58 => "saturated_hemoglobin_percent_min",
            59 => "saturated_hemoglobin_percent_max",
            62 => "device_index",
            67 => "left_pco",
            68 => "right_pco",
            69 => "left_power_phase",
            70 => "left_power_phase_peak",
            71 => "right_power_phase",
            72 => "right_power_phase_peak",
            73 => "enhanced_speed",
            78 => "enhanced_altitude",
            81 => "battery_soc",
            82 => "motor_power",
            83 => "vertical_ratio",
            84 => "stance_time_balance",
            85 => "step_length",
            91 => "absolute_pressure",
            92 => "depth",
            93 => "next_stop_depth",
            94 => "next_stop_time",
            95 => "time_to_surface",
            96 => "ndl_time",
            97 => "cns_load",
            98 => "n2_load",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageRecord> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageRecord {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageRecord",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    78,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            cadence: FitFieldBasicValue::new_single("rpm".to_string()),
            distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    73,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((1000.0, 0.0)),
                    Some("m/s".to_string()),
                )]),
            power: FitFieldBasicValue::new_single("watts".to_string()),
            compressed_speed_distance: FitFieldBasicValue::new_single("".to_string())
                .add_components(vec![
                    FitParseConfig::new_from_component(
                        6,
                        2,
                        132,
                        endianness,
                        0,
                        12,
                        Some((100.0, 0.0)),
                        Some("m/s".to_string()),
                    ),
                    FitParseConfig::new_from_component(
                        5,
                        4,
                        134,
                        endianness,
                        12,
                        12,
                        Some((16.0, 0.0)),
                        Some("m".to_string()),
                    ),
                ]),
            grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            resistance: FitFieldBasicValue::new_single("".to_string()),
            time_from_course: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            cycle_length: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            temperature: FitFieldBasicValue::new_single("C".to_string()),
            speed_1s: FitFieldAdjustedValue::new_vec("m/s".to_string(), 16.0, 0.0),
            cycles: FitFieldBasicValue::new_single("cycles".to_string()).add_components(vec![
                FitParseConfig::new_from_component(
                    19,
                    4,
                    134,
                    endianness,
                    0,
                    8,
                    None,
                    Some("cycles".to_string()),
                ),
            ]),
            total_cycles: FitFieldBasicValue::new_single("cycles".to_string()),
            compressed_accumulated_power: FitFieldBasicValue::new_single("watts".to_string())
                .add_components(vec![FitParseConfig::new_from_component(
                    29,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    None,
                    Some("watts".to_string()),
                )]),
            accumulated_power: FitFieldBasicValue::new_single("watts".to_string()),
            left_right_balance: FitFieldBasicValue::new_single("".to_string()),
            gps_accuracy: FitFieldBasicValue::new_single("m".to_string()),
            vertical_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            calories: FitFieldBasicValue::new_single("kcal".to_string()),
            vertical_oscillation: FitFieldAdjustedValue::new_single("mm".to_string(), 10.0, 0.0),
            stance_time_percent: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            stance_time: FitFieldAdjustedValue::new_single("ms".to_string(), 10.0, 0.0),
            activity_type: FitFieldBasicValue::new_single("".to_string()),
            left_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            right_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            left_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            right_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            combined_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            time128: FitFieldAdjustedValue::new_single("s".to_string(), 128.0, 0.0),
            stroke_type: FitFieldBasicValue::new_single("".to_string()),
            zone: FitFieldBasicValue::new_single("".to_string()),
            ball_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 100.0, 0.0),
            cadence256: FitFieldAdjustedValue::new_single("rpm".to_string(), 256.0, 0.0),
            fractional_cadence: FitFieldAdjustedValue::new_single("rpm".to_string(), 128.0, 0.0),
            total_hemoglobin_conc: FitFieldAdjustedValue::new_single(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            total_hemoglobin_conc_min: FitFieldAdjustedValue::new_single(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            total_hemoglobin_conc_max: FitFieldAdjustedValue::new_single(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            saturated_hemoglobin_percent: FitFieldAdjustedValue::new_single(
                "%".to_string(),
                10.0,
                0.0,
            ),
            saturated_hemoglobin_percent_min: FitFieldAdjustedValue::new_single(
                "%".to_string(),
                10.0,
                0.0,
            ),
            saturated_hemoglobin_percent_max: FitFieldAdjustedValue::new_single(
                "%".to_string(),
                10.0,
                0.0,
            ),
            device_index: FitFieldBasicValue::new_single("".to_string()),
            left_pco: FitFieldBasicValue::new_single("mm".to_string()),
            right_pco: FitFieldBasicValue::new_single("mm".to_string()),
            left_power_phase: FitFieldAdjustedValue::new_vec("degrees".to_string(), 0.7111111, 0.0),
            left_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            right_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            right_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            enhanced_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            enhanced_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            battery_soc: FitFieldAdjustedValue::new_single("percent".to_string(), 2.0, 0.0),
            motor_power: FitFieldBasicValue::new_single("watts".to_string()),
            vertical_ratio: FitFieldAdjustedValue::new_single("percent".to_string(), 100.0, 0.0),
            stance_time_balance: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            step_length: FitFieldAdjustedValue::new_single("mm".to_string(), 10.0, 0.0),
            absolute_pressure: FitFieldBasicValue::new_single("Pa".to_string()),
            depth: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            next_stop_depth: FitFieldAdjustedValue::new_single("m".to_string(), 1000.0, 0.0),
            next_stop_time: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            time_to_surface: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            ndl_time: FitFieldAdjustedValue::new_single("s".to_string(), 1.0, 0.0),
            cns_load: FitFieldBasicValue::new_single("percent".to_string()),
            n2_load: FitFieldAdjustedValue::new_single("percent".to_string(), 1.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageRecord), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // position_lat
                self.position_lat.parse(parse_input, parse_config)?
            }
            1 => {
                // position_long
                self.position_long.parse(parse_input, parse_config)?
            }
            2 => {
                // altitude
                self.altitude.parse(parse_input, parse_config)?
            }
            3 => {
                // heart_rate
                self.heart_rate.parse(parse_input, parse_config)?
            }
            4 => {
                // cadence
                self.cadence.parse(parse_input, parse_config)?
            }
            5 => {
                // distance
                self.distance.parse(parse_input, parse_config)?
            }
            6 => {
                // speed
                self.speed.parse(parse_input, parse_config)?
            }
            7 => {
                // power
                self.power.parse(parse_input, parse_config)?
            }
            8 => {
                // compressed_speed_distance
                self.compressed_speed_distance
                    .parse(parse_input, parse_config)?
            }
            9 => {
                // grade
                self.grade.parse(parse_input, parse_config)?
            }
            10 => {
                // resistance
                self.resistance.parse(parse_input, parse_config)?
            }
            11 => {
                // time_from_course
                self.time_from_course.parse(parse_input, parse_config)?
            }
            12 => {
                // cycle_length
                self.cycle_length.parse(parse_input, parse_config)?
            }
            13 => {
                // temperature
                self.temperature.parse(parse_input, parse_config)?
            }
            17 => {
                // speed_1s
                self.speed_1s.parse(parse_input, parse_config)?
            }
            18 => {
                // cycles
                self.cycles.parse(parse_input, parse_config)?
            }
            19 => {
                // total_cycles
                self.total_cycles.parse(parse_input, parse_config)?
            }
            28 => {
                // compressed_accumulated_power
                self.compressed_accumulated_power
                    .parse(parse_input, parse_config)?
            }
            29 => {
                // accumulated_power
                self.accumulated_power.parse(parse_input, parse_config)?
            }
            30 => {
                // left_right_balance
                self.left_right_balance.parse(parse_input, parse_config)?
            }
            31 => {
                // gps_accuracy
                self.gps_accuracy.parse(parse_input, parse_config)?
            }
            32 => {
                // vertical_speed
                self.vertical_speed.parse(parse_input, parse_config)?
            }
            33 => {
                // calories
                self.calories.parse(parse_input, parse_config)?
            }
            39 => {
                // vertical_oscillation
                self.vertical_oscillation.parse(parse_input, parse_config)?
            }
            40 => {
                // stance_time_percent
                self.stance_time_percent.parse(parse_input, parse_config)?
            }
            41 => {
                // stance_time
                self.stance_time.parse(parse_input, parse_config)?
            }
            42 => {
                // activity_type
                self.activity_type.parse(parse_input, parse_config)?
            }
            43 => {
                // left_torque_effectiveness
                self.left_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            44 => {
                // right_torque_effectiveness
                self.right_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            45 => {
                // left_pedal_smoothness
                self.left_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            46 => {
                // right_pedal_smoothness
                self.right_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            47 => {
                // combined_pedal_smoothness
                self.combined_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            48 => {
                // time128
                self.time128.parse(parse_input, parse_config)?
            }
            49 => {
                // stroke_type
                self.stroke_type.parse(parse_input, parse_config)?
            }
            50 => {
                // zone
                self.zone.parse(parse_input, parse_config)?
            }
            51 => {
                // ball_speed
                self.ball_speed.parse(parse_input, parse_config)?
            }
            52 => {
                // cadence256
                self.cadence256.parse(parse_input, parse_config)?
            }
            53 => {
                // fractional_cadence
                self.fractional_cadence.parse(parse_input, parse_config)?
            }
            54 => {
                // total_hemoglobin_conc
                self.total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            55 => {
                // total_hemoglobin_conc_min
                self.total_hemoglobin_conc_min
                    .parse(parse_input, parse_config)?
            }
            56 => {
                // total_hemoglobin_conc_max
                self.total_hemoglobin_conc_max
                    .parse(parse_input, parse_config)?
            }
            57 => {
                // saturated_hemoglobin_percent
                self.saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            58 => {
                // saturated_hemoglobin_percent_min
                self.saturated_hemoglobin_percent_min
                    .parse(parse_input, parse_config)?
            }
            59 => {
                // saturated_hemoglobin_percent_max
                self.saturated_hemoglobin_percent_max
                    .parse(parse_input, parse_config)?
            }
            62 => {
                // device_index
                self.device_index.parse(parse_input, parse_config)?
            }
            67 => {
                // left_pco
                self.left_pco.parse(parse_input, parse_config)?
            }
            68 => {
                // right_pco
                self.right_pco.parse(parse_input, parse_config)?
            }
            69 => {
                // left_power_phase
                self.left_power_phase.parse(parse_input, parse_config)?
            }
            70 => {
                // left_power_phase_peak
                self.left_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            71 => {
                // right_power_phase
                self.right_power_phase.parse(parse_input, parse_config)?
            }
            72 => {
                // right_power_phase_peak
                self.right_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            73 => {
                // enhanced_speed
                self.enhanced_speed.parse(parse_input, parse_config)?
            }
            78 => {
                // enhanced_altitude
                self.enhanced_altitude.parse(parse_input, parse_config)?
            }
            81 => {
                // battery_soc
                self.battery_soc.parse(parse_input, parse_config)?
            }
            82 => {
                // motor_power
                self.motor_power.parse(parse_input, parse_config)?
            }
            83 => {
                // vertical_ratio
                self.vertical_ratio.parse(parse_input, parse_config)?
            }
            84 => {
                // stance_time_balance
                self.stance_time_balance.parse(parse_input, parse_config)?
            }
            85 => {
                // step_length
                self.step_length.parse(parse_input, parse_config)?
            }
            91 => {
                // absolute_pressure
                self.absolute_pressure.parse(parse_input, parse_config)?
            }
            92 => {
                // depth
                self.depth.parse(parse_input, parse_config)?
            }
            93 => {
                // next_stop_depth
                self.next_stop_depth.parse(parse_input, parse_config)?
            }
            94 => {
                // next_stop_time
                self.next_stop_time.parse(parse_input, parse_config)?
            }
            95 => {
                // time_to_surface
                self.time_to_surface.parse(parse_input, parse_config)?
            }
            96 => {
                // ndl_time
                self.ndl_time.parse(parse_input, parse_config)?
            }
            97 => {
                // cns_load
                self.cns_load.parse(parse_input, parse_config)?
            }
            98 => {
                // n2_load
                self.n2_load.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageRecord {
    fn message_name(&self) -> &'static str {
        return "FitMessageRecord";
    }
}

#[derive(Debug)]
pub enum FitMessageScheduleSubfieldProduct {
    NotYetParsed,
    Default(FitUint16),
    GarminProduct(FitFieldGarminProduct),
    FaveroProduct(FitFieldFaveroProduct),
}

impl FitMessageScheduleSubfieldProduct {
    fn parse<'a>(
        message: &FitMessageSchedule,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageScheduleSubfieldProduct, Vec<FitParseConfig>)> {
        match message.manufacturer.get_single()? {
            FitFieldManufacturer::FaveroElectronics => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldFaveroProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageScheduleSubfieldProduct::FaveroProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Garmin => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageScheduleSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Dynastream => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageScheduleSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::DynastreamOem => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageScheduleSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageScheduleSubfieldProduct::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageSchedule {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub manufacturer: FitFieldBasicValue<FitFieldManufacturer>, // Corresponds to file_id of scheduled workout / course.
    pub product_subfield_bytes: Vec<u8>,
    pub product: FitMessageScheduleSubfieldProduct, // Corresponds to file_id of scheduled workout / course.
    pub serial_number: FitFieldBasicValue<FitUint32z>, // Corresponds to file_id of scheduled workout / course.
    pub time_created: FitFieldBasicValue<FitFieldDateTime>, // Corresponds to file_id of scheduled workout / course.
    pub completed: FitFieldBasicValue<FitBool>, // TRUE if this activity has been started
    pub ftype: FitFieldBasicValue<FitFieldSchedule>,
    pub scheduled_time: FitFieldBasicValue<FitFieldLocalDateTime>,
}

impl fmt::Display for FitMessageSchedule {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSchedule")?;
        fmt_message_field!(self.manufacturer, "manufacturer", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "product_subfield_bytes", self.product_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "product", self.product)?;
        fmt_message_field!(self.serial_number, "serial_number", false, f)?;
        fmt_message_field!(self.time_created, "time_created", false, f)?;
        fmt_message_field!(self.completed, "completed", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.scheduled_time, "scheduled_time", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSchedule {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "manufacturer",
            1 => "product",
            2 => "serial_number",
            3 => "time_created",
            4 => "completed",
            5 => "ftype",
            6 => "scheduled_time",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSchedule> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSchedule {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![1],
            message_name: "FitMessageSchedule",
            manufacturer: FitFieldBasicValue::new_single("".to_string()),
            product_subfield_bytes: vec![],
            product: FitMessageScheduleSubfieldProduct::NotYetParsed,
            serial_number: FitFieldBasicValue::new_single("".to_string()),
            time_created: FitFieldBasicValue::new_single("".to_string()),
            completed: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            scheduled_time: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSchedule),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // manufacturer
                self.manufacturer.parse(parse_input, parse_config)?
            }
            1 => {
                // product
                self.product_subfield_bytes = parse_uint16_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            2 => {
                // serial_number
                self.serial_number.parse(parse_input, parse_config)?
            }
            3 => {
                // time_created
                self.time_created.parse(parse_input, parse_config)?
            }
            4 => {
                // completed
                self.completed.parse(parse_input, parse_config)?
            }
            5 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            6 => {
                // scheduled_time
                self.scheduled_time.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            1 => {
                let (val, new_actions) = FitMessageScheduleSubfieldProduct::parse(
                    &self,
                    &self.product_subfield_bytes,
                    &parse_config,
                )?;
                self.product = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSchedule {
    fn message_name(&self) -> &'static str {
        return "FitMessageSchedule";
    }
}

#[derive(Debug)]
pub struct FitMessageSdmProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub enabled: FitFieldBasicValue<FitBool>,
    pub sdm_ant_id: FitFieldBasicValue<FitUint16z>,
    pub sdm_cal_factor: FitFieldAdjustedValue<FitUint16>,
    pub odometer: FitFieldAdjustedValue<FitUint32>,
    pub speed_source: FitFieldBasicValue<FitBool>, // Use footpod for speed source instead of GPS
    pub sdm_ant_id_trans_type: FitFieldBasicValue<FitUint8z>,
    pub odometer_rollover: FitFieldBasicValue<FitUint8>, // Rollover counter that can be used to extend the odometer
}

impl fmt::Display for FitMessageSdmProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSdmProfile")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(self.sdm_ant_id, "sdm_ant_id", false, f)?;
        fmt_message_field!(self.sdm_cal_factor, "sdm_cal_factor", true, f)?;
        fmt_message_field!(self.odometer, "odometer", true, f)?;
        fmt_message_field!(self.speed_source, "speed_source", false, f)?;
        fmt_message_field!(
            self.sdm_ant_id_trans_type,
            "sdm_ant_id_trans_type",
            false,
            f
        )?;
        fmt_message_field!(self.odometer_rollover, "odometer_rollover", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSdmProfile {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "enabled",
            1 => "sdm_ant_id",
            2 => "sdm_cal_factor",
            3 => "odometer",
            4 => "speed_source",
            5 => "sdm_ant_id_trans_type",
            7 => "odometer_rollover",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSdmProfile> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSdmProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSdmProfile",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            sdm_ant_id: FitFieldBasicValue::new_single("".to_string()),
            sdm_cal_factor: FitFieldAdjustedValue::new_single("%".to_string(), 10.0, 0.0),
            odometer: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            speed_source: FitFieldBasicValue::new_single("".to_string()),
            sdm_ant_id_trans_type: FitFieldBasicValue::new_single("".to_string()),
            odometer_rollover: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSdmProfile),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            1 => {
                // sdm_ant_id
                self.sdm_ant_id.parse(parse_input, parse_config)?
            }
            2 => {
                // sdm_cal_factor
                self.sdm_cal_factor.parse(parse_input, parse_config)?
            }
            3 => {
                // odometer
                self.odometer.parse(parse_input, parse_config)?
            }
            4 => {
                // speed_source
                self.speed_source.parse(parse_input, parse_config)?
            }
            5 => {
                // sdm_ant_id_trans_type
                self.sdm_ant_id_trans_type
                    .parse(parse_input, parse_config)?
            }
            7 => {
                // odometer_rollover
                self.odometer_rollover.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSdmProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageSdmProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentFile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub file_uuid: FitFieldBasicValue<FitString>, // UUID of the segment file
    pub enabled: FitFieldBasicValue<FitBool>,     // Enabled state of the segment file
    pub user_profile_primary_key: FitFieldBasicValue<FitUint32>, // Primary key of the user that created the segment file
    pub leader_type: FitFieldBasicValue<FitFieldSegmentLeaderboardType>, // Leader type of each leader in the segment file
    pub leader_group_primary_key: FitFieldBasicValue<FitUint32>, // Group primary key of each leader in the segment file
    pub leader_activity_id: FitFieldBasicValue<FitUint32>, // Activity ID of each leader in the segment file
    pub leader_activity_id_string: FitFieldBasicValue<FitString>, // String version of the activity ID of each leader in the segment file. 21 characters long for each ID, express in decimal
    pub default_race_leader: FitFieldBasicValue<FitUint8>, // Index for the Leader Board entry selected as the default race participant
}

impl fmt::Display for FitMessageSegmentFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentFile")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.file_uuid, "file_uuid", false, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(
            self.user_profile_primary_key,
            "user_profile_primary_key",
            false,
            f
        )?;
        fmt_message_field!(self.leader_type, "leader_type", false, f)?;
        fmt_message_field!(
            self.leader_group_primary_key,
            "leader_group_primary_key",
            false,
            f
        )?;
        fmt_message_field!(self.leader_activity_id, "leader_activity_id", false, f)?;
        fmt_message_field!(
            self.leader_activity_id_string,
            "leader_activity_id_string",
            false,
            f
        )?;
        fmt_message_field!(self.default_race_leader, "default_race_leader", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentFile {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            1 => "file_uuid",
            3 => "enabled",
            4 => "user_profile_primary_key",
            7 => "leader_type",
            8 => "leader_group_primary_key",
            9 => "leader_activity_id",
            10 => "leader_activity_id_string",
            11 => "default_race_leader",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSegmentFile> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSegmentFile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSegmentFile",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            file_uuid: FitFieldBasicValue::new_single("".to_string()),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            user_profile_primary_key: FitFieldBasicValue::new_single("".to_string()),
            leader_type: FitFieldBasicValue::new_vec("".to_string()),
            leader_group_primary_key: FitFieldBasicValue::new_vec("".to_string()),
            leader_activity_id: FitFieldBasicValue::new_vec("".to_string()),
            leader_activity_id_string: FitFieldBasicValue::new_vec("".to_string()),
            default_race_leader: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSegmentFile),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            1 => {
                // file_uuid
                self.file_uuid.parse(parse_input, parse_config)?
            }
            3 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            4 => {
                // user_profile_primary_key
                self.user_profile_primary_key
                    .parse(parse_input, parse_config)?
            }
            7 => {
                // leader_type
                self.leader_type.parse(parse_input, parse_config)?
            }
            8 => {
                // leader_group_primary_key
                self.leader_group_primary_key
                    .parse(parse_input, parse_config)?
            }
            9 => {
                // leader_activity_id
                self.leader_activity_id.parse(parse_input, parse_config)?
            }
            10 => {
                // leader_activity_id_string
                self.leader_activity_id_string
                    .parse(parse_input, parse_config)?
            }
            11 => {
                // default_race_leader
                self.default_race_leader.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentFile {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentFile";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub name: FitFieldBasicValue<FitString>, // Friendly name assigned to segment
    pub uuid: FitFieldBasicValue<FitString>, // UUID of the segment
    pub sport: FitFieldBasicValue<FitFieldSport>, // Sport associated with the segment
    pub enabled: FitFieldBasicValue<FitBool>, // Segment enabled for evaluation
    pub user_profile_primary_key: FitFieldBasicValue<FitUint32>, // Primary key of the user that created the segment
    pub device_id: FitFieldBasicValue<FitUint32>, // ID of the device that created the segment
    pub default_race_leader: FitFieldBasicValue<FitUint8>, // Index for the Leader Board entry selected as the default race participant
    pub delete_status: FitFieldBasicValue<FitFieldSegmentDeleteStatus>, // Indicates if any segments should be deleted
    pub selection_type: FitFieldBasicValue<FitFieldSegmentSelectionType>, // Indicates how the segment was selected to be sent to the device
}

impl fmt::Display for FitMessageSegmentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentId")?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.uuid, "uuid", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.enabled, "enabled", false, f)?;
        fmt_message_field!(
            self.user_profile_primary_key,
            "user_profile_primary_key",
            false,
            f
        )?;
        fmt_message_field!(self.device_id, "device_id", false, f)?;
        fmt_message_field!(self.default_race_leader, "default_race_leader", false, f)?;
        fmt_message_field!(self.delete_status, "delete_status", false, f)?;
        fmt_message_field!(self.selection_type, "selection_type", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentId {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "name",
            1 => "uuid",
            2 => "sport",
            3 => "enabled",
            4 => "user_profile_primary_key",
            5 => "device_id",
            6 => "default_race_leader",
            7 => "delete_status",
            8 => "selection_type",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSegmentId> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSegmentId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSegmentId",
            name: FitFieldBasicValue::new_single("".to_string()),
            uuid: FitFieldBasicValue::new_single("".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            enabled: FitFieldBasicValue::new_single("".to_string()),
            user_profile_primary_key: FitFieldBasicValue::new_single("".to_string()),
            device_id: FitFieldBasicValue::new_single("".to_string()),
            default_race_leader: FitFieldBasicValue::new_single("".to_string()),
            delete_status: FitFieldBasicValue::new_single("".to_string()),
            selection_type: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSegmentId),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            1 => {
                // uuid
                self.uuid.parse(parse_input, parse_config)?
            }
            2 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            3 => {
                // enabled
                self.enabled.parse(parse_input, parse_config)?
            }
            4 => {
                // user_profile_primary_key
                self.user_profile_primary_key
                    .parse(parse_input, parse_config)?
            }
            5 => {
                // device_id
                self.device_id.parse(parse_input, parse_config)?
            }
            6 => {
                // default_race_leader
                self.default_race_leader.parse(parse_input, parse_config)?
            }
            7 => {
                // delete_status
                self.delete_status.parse(parse_input, parse_config)?
            }
            8 => {
                // selection_type
                self.selection_type.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentId {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentId";
    }
}

#[derive(Debug)]
pub enum FitMessageSegmentLapSubfieldTotalCycles {
    NotYetParsed,
    Default(FitUint32),
    TotalStrokes(FitUint32),
}

impl FitMessageSegmentLapSubfieldTotalCycles {
    fn parse<'a>(
        message: &FitMessageSegmentLap,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageSegmentLapSubfieldTotalCycles, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Cycling => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("strokes".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSegmentLapSubfieldTotalCycles::TotalStrokes(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageSegmentLapSubfieldTotalCycles::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageSegmentLap {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Lap end time.
    pub event: FitFieldBasicValue<FitFieldEvent>,
    pub event_type: FitFieldBasicValue<FitFieldEventType>,
    pub start_time: FitFieldBasicValue<FitFieldDateTime>,
    pub start_position_lat: FitFieldAdjustedValue<FitSint32>,
    pub start_position_long: FitFieldAdjustedValue<FitSint32>,
    pub end_position_lat: FitFieldAdjustedValue<FitSint32>,
    pub end_position_long: FitFieldAdjustedValue<FitSint32>,
    pub total_elapsed_time: FitFieldAdjustedValue<FitUint32>, // Time (includes pauses)
    pub total_timer_time: FitFieldAdjustedValue<FitUint32>,   // Timer Time (excludes pauses)
    pub total_distance: FitFieldAdjustedValue<FitUint32>,
    pub total_cycles_subfield_bytes: Vec<u8>,
    pub total_cycles: FitMessageSegmentLapSubfieldTotalCycles,
    pub total_calories: FitFieldBasicValue<FitUint16>,
    pub total_fat_calories: FitFieldBasicValue<FitUint16>, // If New Leaf
    pub avg_speed: FitFieldAdjustedValue<FitUint16>,
    pub max_speed: FitFieldAdjustedValue<FitUint16>,
    pub avg_heart_rate: FitFieldBasicValue<FitUint8>,
    pub max_heart_rate: FitFieldBasicValue<FitUint8>,
    pub avg_cadence: FitFieldBasicValue<FitUint8>, // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
    pub max_cadence: FitFieldBasicValue<FitUint8>,
    pub avg_power: FitFieldBasicValue<FitUint16>, // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
    pub max_power: FitFieldBasicValue<FitUint16>,
    pub total_ascent: FitFieldBasicValue<FitUint16>,
    pub total_descent: FitFieldBasicValue<FitUint16>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub event_group: FitFieldBasicValue<FitUint8>,
    pub nec_lat: FitFieldAdjustedValue<FitSint32>, // North east corner latitude.
    pub nec_long: FitFieldAdjustedValue<FitSint32>, // North east corner longitude.
    pub swc_lat: FitFieldAdjustedValue<FitSint32>, // South west corner latitude.
    pub swc_long: FitFieldAdjustedValue<FitSint32>, // South west corner latitude.
    pub name: FitFieldBasicValue<FitString>,
    pub normalized_power: FitFieldBasicValue<FitUint16>,
    pub left_right_balance: FitFieldBasicValue<FitFieldLeftRightBalance100>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub total_work: FitFieldBasicValue<FitUint32>,
    pub avg_altitude: FitFieldAdjustedValue<FitUint16>,
    pub max_altitude: FitFieldAdjustedValue<FitUint16>,
    pub gps_accuracy: FitFieldBasicValue<FitUint8>,
    pub avg_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_pos_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_neg_grade: FitFieldAdjustedValue<FitSint16>,
    pub max_pos_grade: FitFieldAdjustedValue<FitSint16>,
    pub max_neg_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_temperature: FitFieldBasicValue<FitSint8>,
    pub max_temperature: FitFieldBasicValue<FitSint8>,
    pub total_moving_time: FitFieldAdjustedValue<FitUint32>,
    pub avg_pos_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub avg_neg_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub max_pos_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub max_neg_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub time_in_hr_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_speed_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_cadence_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_power_zone: FitFieldAdjustedValue<FitUint32>,
    pub repetition_num: FitFieldBasicValue<FitUint16>,
    pub min_altitude: FitFieldAdjustedValue<FitUint16>,
    pub min_heart_rate: FitFieldBasicValue<FitUint8>,
    pub active_time: FitFieldAdjustedValue<FitUint32>,
    pub wkt_step_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub sport_event: FitFieldBasicValue<FitFieldSportEvent>,
    pub avg_left_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub avg_right_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub avg_left_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub avg_right_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub avg_combined_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub status: FitFieldBasicValue<FitFieldSegmentLapStatus>,
    pub uuid: FitFieldBasicValue<FitString>,
    pub avg_fractional_cadence: FitFieldAdjustedValue<FitUint8>, // fractional part of the avg_cadence
    pub max_fractional_cadence: FitFieldAdjustedValue<FitUint8>, // fractional part of the max_cadence
    pub total_fractional_cycles: FitFieldAdjustedValue<FitUint8>, // fractional part of the total_cycles
    pub front_gear_shift_count: FitFieldBasicValue<FitUint16>,
    pub rear_gear_shift_count: FitFieldBasicValue<FitUint16>,
    pub time_standing: FitFieldAdjustedValue<FitUint32>, // Total time spent in the standing position
    pub stand_count: FitFieldBasicValue<FitUint16>, // Number of transitions to the standing state
    pub avg_left_pco: FitFieldBasicValue<FitSint8>, // Average left platform center offset
    pub avg_right_pco: FitFieldBasicValue<FitSint8>, // Average right platform center offset
    pub avg_left_power_phase: FitFieldAdjustedValue<FitUint8>, // Average left power phase angles. Data value indexes defined by power_phase_type.
    pub avg_left_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Average left power phase peak angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase: FitFieldAdjustedValue<FitUint8>, // Average right power phase angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Average right power phase peak angles. Data value indexes defined by power_phase_type.
    pub avg_power_position: FitFieldBasicValue<FitUint16>, // Average power by position. Data value indexes defined by rider_position_type.
    pub max_power_position: FitFieldBasicValue<FitUint16>, // Maximum power by position. Data value indexes defined by rider_position_type.
    pub avg_cadence_position: FitFieldBasicValue<FitUint8>, // Average cadence by position. Data value indexes defined by rider_position_type.
    pub max_cadence_position: FitFieldBasicValue<FitUint8>, // Maximum cadence by position. Data value indexes defined by rider_position_type.
    pub manufacturer: FitFieldBasicValue<FitFieldManufacturer>, // Manufacturer that produced the segment
}

impl fmt::Display for FitMessageSegmentLap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentLap")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.event, "event", false, f)?;
        fmt_message_field!(self.event_type, "event_type", false, f)?;
        fmt_message_field!(self.start_time, "start_time", false, f)?;
        fmt_message_field!(self.start_position_lat, "start_position_lat", true, f)?;
        fmt_message_field!(self.start_position_long, "start_position_long", true, f)?;
        fmt_message_field!(self.end_position_lat, "end_position_lat", true, f)?;
        fmt_message_field!(self.end_position_long, "end_position_long", true, f)?;
        fmt_message_field!(self.total_elapsed_time, "total_elapsed_time", true, f)?;
        fmt_message_field!(self.total_timer_time, "total_timer_time", true, f)?;
        fmt_message_field!(self.total_distance, "total_distance", true, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "total_cycles_subfield_bytes", self.total_cycles_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "total_cycles", self.total_cycles)?;
        fmt_message_field!(self.total_calories, "total_calories", false, f)?;
        fmt_message_field!(self.total_fat_calories, "total_fat_calories", false, f)?;
        fmt_message_field!(self.avg_speed, "avg_speed", true, f)?;
        fmt_message_field!(self.max_speed, "max_speed", true, f)?;
        fmt_message_field!(self.avg_heart_rate, "avg_heart_rate", false, f)?;
        fmt_message_field!(self.max_heart_rate, "max_heart_rate", false, f)?;
        fmt_message_field!(self.avg_cadence, "avg_cadence", false, f)?;
        fmt_message_field!(self.max_cadence, "max_cadence", false, f)?;
        fmt_message_field!(self.avg_power, "avg_power", false, f)?;
        fmt_message_field!(self.max_power, "max_power", false, f)?;
        fmt_message_field!(self.total_ascent, "total_ascent", false, f)?;
        fmt_message_field!(self.total_descent, "total_descent", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.event_group, "event_group", false, f)?;
        fmt_message_field!(self.nec_lat, "nec_lat", true, f)?;
        fmt_message_field!(self.nec_long, "nec_long", true, f)?;
        fmt_message_field!(self.swc_lat, "swc_lat", true, f)?;
        fmt_message_field!(self.swc_long, "swc_long", true, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.normalized_power, "normalized_power", false, f)?;
        fmt_message_field!(self.left_right_balance, "left_right_balance", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.total_work, "total_work", false, f)?;
        fmt_message_field!(self.avg_altitude, "avg_altitude", true, f)?;
        fmt_message_field!(self.max_altitude, "max_altitude", true, f)?;
        fmt_message_field!(self.gps_accuracy, "gps_accuracy", false, f)?;
        fmt_message_field!(self.avg_grade, "avg_grade", true, f)?;
        fmt_message_field!(self.avg_pos_grade, "avg_pos_grade", true, f)?;
        fmt_message_field!(self.avg_neg_grade, "avg_neg_grade", true, f)?;
        fmt_message_field!(self.max_pos_grade, "max_pos_grade", true, f)?;
        fmt_message_field!(self.max_neg_grade, "max_neg_grade", true, f)?;
        fmt_message_field!(self.avg_temperature, "avg_temperature", false, f)?;
        fmt_message_field!(self.max_temperature, "max_temperature", false, f)?;
        fmt_message_field!(self.total_moving_time, "total_moving_time", true, f)?;
        fmt_message_field!(
            self.avg_pos_vertical_speed,
            "avg_pos_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_neg_vertical_speed,
            "avg_neg_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_pos_vertical_speed,
            "max_pos_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_neg_vertical_speed,
            "max_neg_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(self.time_in_hr_zone, "time_in_hr_zone", true, f)?;
        fmt_message_field!(self.time_in_speed_zone, "time_in_speed_zone", true, f)?;
        fmt_message_field!(self.time_in_cadence_zone, "time_in_cadence_zone", true, f)?;
        fmt_message_field!(self.time_in_power_zone, "time_in_power_zone", true, f)?;
        fmt_message_field!(self.repetition_num, "repetition_num", false, f)?;
        fmt_message_field!(self.min_altitude, "min_altitude", true, f)?;
        fmt_message_field!(self.min_heart_rate, "min_heart_rate", false, f)?;
        fmt_message_field!(self.active_time, "active_time", true, f)?;
        fmt_message_field!(self.wkt_step_index, "wkt_step_index", false, f)?;
        fmt_message_field!(self.sport_event, "sport_event", false, f)?;
        fmt_message_field!(
            self.avg_left_torque_effectiveness,
            "avg_left_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_right_torque_effectiveness,
            "avg_right_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_left_pedal_smoothness,
            "avg_left_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_right_pedal_smoothness,
            "avg_right_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_combined_pedal_smoothness,
            "avg_combined_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(self.status, "status", false, f)?;
        fmt_message_field!(self.uuid, "uuid", false, f)?;
        fmt_message_field!(
            self.avg_fractional_cadence,
            "avg_fractional_cadence",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_fractional_cadence,
            "max_fractional_cadence",
            true,
            f
        )?;
        fmt_message_field!(
            self.total_fractional_cycles,
            "total_fractional_cycles",
            true,
            f
        )?;
        fmt_message_field!(
            self.front_gear_shift_count,
            "front_gear_shift_count",
            false,
            f
        )?;
        fmt_message_field!(
            self.rear_gear_shift_count,
            "rear_gear_shift_count",
            false,
            f
        )?;
        fmt_message_field!(self.time_standing, "time_standing", true, f)?;
        fmt_message_field!(self.stand_count, "stand_count", false, f)?;
        fmt_message_field!(self.avg_left_pco, "avg_left_pco", false, f)?;
        fmt_message_field!(self.avg_right_pco, "avg_right_pco", false, f)?;
        fmt_message_field!(self.avg_left_power_phase, "avg_left_power_phase", true, f)?;
        fmt_message_field!(
            self.avg_left_power_phase_peak,
            "avg_left_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.avg_right_power_phase, "avg_right_power_phase", true, f)?;
        fmt_message_field!(
            self.avg_right_power_phase_peak,
            "avg_right_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.avg_power_position, "avg_power_position", false, f)?;
        fmt_message_field!(self.max_power_position, "max_power_position", false, f)?;
        fmt_message_field!(self.avg_cadence_position, "avg_cadence_position", false, f)?;
        fmt_message_field!(self.max_cadence_position, "max_cadence_position", false, f)?;
        fmt_message_field!(self.manufacturer, "manufacturer", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentLap {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            253 => "timestamp",
            0 => "event",
            1 => "event_type",
            2 => "start_time",
            3 => "start_position_lat",
            4 => "start_position_long",
            5 => "end_position_lat",
            6 => "end_position_long",
            7 => "total_elapsed_time",
            8 => "total_timer_time",
            9 => "total_distance",
            10 => "total_cycles",
            11 => "total_calories",
            12 => "total_fat_calories",
            13 => "avg_speed",
            14 => "max_speed",
            15 => "avg_heart_rate",
            16 => "max_heart_rate",
            17 => "avg_cadence",
            18 => "max_cadence",
            19 => "avg_power",
            20 => "max_power",
            21 => "total_ascent",
            22 => "total_descent",
            23 => "sport",
            24 => "event_group",
            25 => "nec_lat",
            26 => "nec_long",
            27 => "swc_lat",
            28 => "swc_long",
            29 => "name",
            30 => "normalized_power",
            31 => "left_right_balance",
            32 => "sub_sport",
            33 => "total_work",
            34 => "avg_altitude",
            35 => "max_altitude",
            36 => "gps_accuracy",
            37 => "avg_grade",
            38 => "avg_pos_grade",
            39 => "avg_neg_grade",
            40 => "max_pos_grade",
            41 => "max_neg_grade",
            42 => "avg_temperature",
            43 => "max_temperature",
            44 => "total_moving_time",
            45 => "avg_pos_vertical_speed",
            46 => "avg_neg_vertical_speed",
            47 => "max_pos_vertical_speed",
            48 => "max_neg_vertical_speed",
            49 => "time_in_hr_zone",
            50 => "time_in_speed_zone",
            51 => "time_in_cadence_zone",
            52 => "time_in_power_zone",
            53 => "repetition_num",
            54 => "min_altitude",
            55 => "min_heart_rate",
            56 => "active_time",
            57 => "wkt_step_index",
            58 => "sport_event",
            59 => "avg_left_torque_effectiveness",
            60 => "avg_right_torque_effectiveness",
            61 => "avg_left_pedal_smoothness",
            62 => "avg_right_pedal_smoothness",
            63 => "avg_combined_pedal_smoothness",
            64 => "status",
            65 => "uuid",
            66 => "avg_fractional_cadence",
            67 => "max_fractional_cadence",
            68 => "total_fractional_cycles",
            69 => "front_gear_shift_count",
            70 => "rear_gear_shift_count",
            71 => "time_standing",
            72 => "stand_count",
            73 => "avg_left_pco",
            74 => "avg_right_pco",
            75 => "avg_left_power_phase",
            76 => "avg_left_power_phase_peak",
            77 => "avg_right_power_phase",
            78 => "avg_right_power_phase_peak",
            79 => "avg_power_position",
            80 => "max_power_position",
            81 => "avg_cadence_position",
            82 => "max_cadence_position",
            83 => "manufacturer",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSegmentLap> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSegmentLap {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![10],
            message_name: "FitMessageSegmentLap",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            event: FitFieldBasicValue::new_single("".to_string()),
            event_type: FitFieldBasicValue::new_single("".to_string()),
            start_time: FitFieldBasicValue::new_single("".to_string()),
            start_position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            start_position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            end_position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            end_position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            total_elapsed_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_timer_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            total_cycles_subfield_bytes: vec![],
            total_cycles: FitMessageSegmentLapSubfieldTotalCycles::NotYetParsed,
            total_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            total_fat_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            avg_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            max_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            avg_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            max_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            avg_cadence: FitFieldBasicValue::new_single("rpm".to_string()),
            max_cadence: FitFieldBasicValue::new_single("rpm".to_string()),
            avg_power: FitFieldBasicValue::new_single("watts".to_string()),
            max_power: FitFieldBasicValue::new_single("watts".to_string()),
            total_ascent: FitFieldBasicValue::new_single("m".to_string()),
            total_descent: FitFieldBasicValue::new_single("m".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            event_group: FitFieldBasicValue::new_single("".to_string()),
            nec_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            nec_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            swc_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            swc_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            name: FitFieldBasicValue::new_single("".to_string()),
            normalized_power: FitFieldBasicValue::new_single("watts".to_string()),
            left_right_balance: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            total_work: FitFieldBasicValue::new_single("J".to_string()),
            avg_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            max_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            gps_accuracy: FitFieldBasicValue::new_single("m".to_string()),
            avg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_pos_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_neg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            max_pos_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            max_neg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_temperature: FitFieldBasicValue::new_single("C".to_string()),
            max_temperature: FitFieldBasicValue::new_single("C".to_string()),
            total_moving_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            avg_pos_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            avg_neg_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            max_pos_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            max_neg_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            time_in_hr_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_speed_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_cadence_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_power_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            repetition_num: FitFieldBasicValue::new_single("".to_string()),
            min_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            min_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            active_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            wkt_step_index: FitFieldBasicValue::new_single("".to_string()),
            sport_event: FitFieldBasicValue::new_single("".to_string()),
            avg_left_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_right_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_left_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_right_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_combined_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            status: FitFieldBasicValue::new_single("".to_string()),
            uuid: FitFieldBasicValue::new_single("".to_string()),
            avg_fractional_cadence: FitFieldAdjustedValue::new_single(
                "rpm".to_string(),
                128.0,
                0.0,
            ),
            max_fractional_cadence: FitFieldAdjustedValue::new_single(
                "rpm".to_string(),
                128.0,
                0.0,
            ),
            total_fractional_cycles: FitFieldAdjustedValue::new_single(
                "cycles".to_string(),
                128.0,
                0.0,
            ),
            front_gear_shift_count: FitFieldBasicValue::new_single("".to_string()),
            rear_gear_shift_count: FitFieldBasicValue::new_single("".to_string()),
            time_standing: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            stand_count: FitFieldBasicValue::new_single("".to_string()),
            avg_left_pco: FitFieldBasicValue::new_single("mm".to_string()),
            avg_right_pco: FitFieldBasicValue::new_single("mm".to_string()),
            avg_left_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_left_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_right_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_right_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_power_position: FitFieldBasicValue::new_vec("watts".to_string()),
            max_power_position: FitFieldBasicValue::new_vec("watts".to_string()),
            avg_cadence_position: FitFieldBasicValue::new_vec("rpm".to_string()),
            max_cadence_position: FitFieldBasicValue::new_vec("rpm".to_string()),
            manufacturer: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSegmentLap),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // event
                self.event.parse(parse_input, parse_config)?
            }
            1 => {
                // event_type
                self.event_type.parse(parse_input, parse_config)?
            }
            2 => {
                // start_time
                self.start_time.parse(parse_input, parse_config)?
            }
            3 => {
                // start_position_lat
                self.start_position_lat.parse(parse_input, parse_config)?
            }
            4 => {
                // start_position_long
                self.start_position_long.parse(parse_input, parse_config)?
            }
            5 => {
                // end_position_lat
                self.end_position_lat.parse(parse_input, parse_config)?
            }
            6 => {
                // end_position_long
                self.end_position_long.parse(parse_input, parse_config)?
            }
            7 => {
                // total_elapsed_time
                self.total_elapsed_time.parse(parse_input, parse_config)?
            }
            8 => {
                // total_timer_time
                self.total_timer_time.parse(parse_input, parse_config)?
            }
            9 => {
                // total_distance
                self.total_distance.parse(parse_input, parse_config)?
            }
            10 => {
                // total_cycles
                self.total_cycles_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            11 => {
                // total_calories
                self.total_calories.parse(parse_input, parse_config)?
            }
            12 => {
                // total_fat_calories
                self.total_fat_calories.parse(parse_input, parse_config)?
            }
            13 => {
                // avg_speed
                self.avg_speed.parse(parse_input, parse_config)?
            }
            14 => {
                // max_speed
                self.max_speed.parse(parse_input, parse_config)?
            }
            15 => {
                // avg_heart_rate
                self.avg_heart_rate.parse(parse_input, parse_config)?
            }
            16 => {
                // max_heart_rate
                self.max_heart_rate.parse(parse_input, parse_config)?
            }
            17 => {
                // avg_cadence
                self.avg_cadence.parse(parse_input, parse_config)?
            }
            18 => {
                // max_cadence
                self.max_cadence.parse(parse_input, parse_config)?
            }
            19 => {
                // avg_power
                self.avg_power.parse(parse_input, parse_config)?
            }
            20 => {
                // max_power
                self.max_power.parse(parse_input, parse_config)?
            }
            21 => {
                // total_ascent
                self.total_ascent.parse(parse_input, parse_config)?
            }
            22 => {
                // total_descent
                self.total_descent.parse(parse_input, parse_config)?
            }
            23 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            24 => {
                // event_group
                self.event_group.parse(parse_input, parse_config)?
            }
            25 => {
                // nec_lat
                self.nec_lat.parse(parse_input, parse_config)?
            }
            26 => {
                // nec_long
                self.nec_long.parse(parse_input, parse_config)?
            }
            27 => {
                // swc_lat
                self.swc_lat.parse(parse_input, parse_config)?
            }
            28 => {
                // swc_long
                self.swc_long.parse(parse_input, parse_config)?
            }
            29 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            30 => {
                // normalized_power
                self.normalized_power.parse(parse_input, parse_config)?
            }
            31 => {
                // left_right_balance
                self.left_right_balance.parse(parse_input, parse_config)?
            }
            32 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            33 => {
                // total_work
                self.total_work.parse(parse_input, parse_config)?
            }
            34 => {
                // avg_altitude
                self.avg_altitude.parse(parse_input, parse_config)?
            }
            35 => {
                // max_altitude
                self.max_altitude.parse(parse_input, parse_config)?
            }
            36 => {
                // gps_accuracy
                self.gps_accuracy.parse(parse_input, parse_config)?
            }
            37 => {
                // avg_grade
                self.avg_grade.parse(parse_input, parse_config)?
            }
            38 => {
                // avg_pos_grade
                self.avg_pos_grade.parse(parse_input, parse_config)?
            }
            39 => {
                // avg_neg_grade
                self.avg_neg_grade.parse(parse_input, parse_config)?
            }
            40 => {
                // max_pos_grade
                self.max_pos_grade.parse(parse_input, parse_config)?
            }
            41 => {
                // max_neg_grade
                self.max_neg_grade.parse(parse_input, parse_config)?
            }
            42 => {
                // avg_temperature
                self.avg_temperature.parse(parse_input, parse_config)?
            }
            43 => {
                // max_temperature
                self.max_temperature.parse(parse_input, parse_config)?
            }
            44 => {
                // total_moving_time
                self.total_moving_time.parse(parse_input, parse_config)?
            }
            45 => {
                // avg_pos_vertical_speed
                self.avg_pos_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            46 => {
                // avg_neg_vertical_speed
                self.avg_neg_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            47 => {
                // max_pos_vertical_speed
                self.max_pos_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            48 => {
                // max_neg_vertical_speed
                self.max_neg_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            49 => {
                // time_in_hr_zone
                self.time_in_hr_zone.parse(parse_input, parse_config)?
            }
            50 => {
                // time_in_speed_zone
                self.time_in_speed_zone.parse(parse_input, parse_config)?
            }
            51 => {
                // time_in_cadence_zone
                self.time_in_cadence_zone.parse(parse_input, parse_config)?
            }
            52 => {
                // time_in_power_zone
                self.time_in_power_zone.parse(parse_input, parse_config)?
            }
            53 => {
                // repetition_num
                self.repetition_num.parse(parse_input, parse_config)?
            }
            54 => {
                // min_altitude
                self.min_altitude.parse(parse_input, parse_config)?
            }
            55 => {
                // min_heart_rate
                self.min_heart_rate.parse(parse_input, parse_config)?
            }
            56 => {
                // active_time
                self.active_time.parse(parse_input, parse_config)?
            }
            57 => {
                // wkt_step_index
                self.wkt_step_index.parse(parse_input, parse_config)?
            }
            58 => {
                // sport_event
                self.sport_event.parse(parse_input, parse_config)?
            }
            59 => {
                // avg_left_torque_effectiveness
                self.avg_left_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            60 => {
                // avg_right_torque_effectiveness
                self.avg_right_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            61 => {
                // avg_left_pedal_smoothness
                self.avg_left_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            62 => {
                // avg_right_pedal_smoothness
                self.avg_right_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            63 => {
                // avg_combined_pedal_smoothness
                self.avg_combined_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            64 => {
                // status
                self.status.parse(parse_input, parse_config)?
            }
            65 => {
                // uuid
                self.uuid.parse(parse_input, parse_config)?
            }
            66 => {
                // avg_fractional_cadence
                self.avg_fractional_cadence
                    .parse(parse_input, parse_config)?
            }
            67 => {
                // max_fractional_cadence
                self.max_fractional_cadence
                    .parse(parse_input, parse_config)?
            }
            68 => {
                // total_fractional_cycles
                self.total_fractional_cycles
                    .parse(parse_input, parse_config)?
            }
            69 => {
                // front_gear_shift_count
                self.front_gear_shift_count
                    .parse(parse_input, parse_config)?
            }
            70 => {
                // rear_gear_shift_count
                self.rear_gear_shift_count
                    .parse(parse_input, parse_config)?
            }
            71 => {
                // time_standing
                self.time_standing.parse(parse_input, parse_config)?
            }
            72 => {
                // stand_count
                self.stand_count.parse(parse_input, parse_config)?
            }
            73 => {
                // avg_left_pco
                self.avg_left_pco.parse(parse_input, parse_config)?
            }
            74 => {
                // avg_right_pco
                self.avg_right_pco.parse(parse_input, parse_config)?
            }
            75 => {
                // avg_left_power_phase
                self.avg_left_power_phase.parse(parse_input, parse_config)?
            }
            76 => {
                // avg_left_power_phase_peak
                self.avg_left_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            77 => {
                // avg_right_power_phase
                self.avg_right_power_phase
                    .parse(parse_input, parse_config)?
            }
            78 => {
                // avg_right_power_phase_peak
                self.avg_right_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            79 => {
                // avg_power_position
                self.avg_power_position.parse(parse_input, parse_config)?
            }
            80 => {
                // max_power_position
                self.max_power_position.parse(parse_input, parse_config)?
            }
            81 => {
                // avg_cadence_position
                self.avg_cadence_position.parse(parse_input, parse_config)?
            }
            82 => {
                // max_cadence_position
                self.max_cadence_position.parse(parse_input, parse_config)?
            }
            83 => {
                // manufacturer
                self.manufacturer.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            10 => {
                let (val, new_actions) = FitMessageSegmentLapSubfieldTotalCycles::parse(
                    &self,
                    &self.total_cycles_subfield_bytes,
                    &parse_config,
                )?;
                self.total_cycles = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentLap {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentLap";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentLeaderboardEntry {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub name: FitFieldBasicValue<FitString>, // Friendly name assigned to leader
    pub ftype: FitFieldBasicValue<FitFieldSegmentLeaderboardType>, // Leader classification
    pub group_primary_key: FitFieldBasicValue<FitUint32>, // Primary user ID of this leader
    pub activity_id: FitFieldBasicValue<FitUint32>, // ID of the activity associated with this leader time
    pub segment_time: FitFieldAdjustedValue<FitUint32>, // Segment Time (includes pauses)
    pub activity_id_string: FitFieldBasicValue<FitString>, // String version of the activity_id. 21 characters long, express in decimal
}

impl fmt::Display for FitMessageSegmentLeaderboardEntry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentLeaderboardEntry")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.group_primary_key, "group_primary_key", false, f)?;
        fmt_message_field!(self.activity_id, "activity_id", false, f)?;
        fmt_message_field!(self.segment_time, "segment_time", true, f)?;
        fmt_message_field!(self.activity_id_string, "activity_id_string", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentLeaderboardEntry {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "name",
            1 => "ftype",
            2 => "group_primary_key",
            3 => "activity_id",
            4 => "segment_time",
            5 => "activity_id_string",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSegmentLeaderboardEntry> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSegmentLeaderboardEntry {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSegmentLeaderboardEntry",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            group_primary_key: FitFieldBasicValue::new_single("".to_string()),
            activity_id: FitFieldBasicValue::new_single("".to_string()),
            segment_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            activity_id_string: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSegmentLeaderboardEntry),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }
            1 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            2 => {
                // group_primary_key
                self.group_primary_key.parse(parse_input, parse_config)?
            }
            3 => {
                // activity_id
                self.activity_id.parse(parse_input, parse_config)?
            }
            4 => {
                // segment_time
                self.segment_time.parse(parse_input, parse_config)?
            }
            5 => {
                // activity_id_string
                self.activity_id_string.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentLeaderboardEntry {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentLeaderboardEntry";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentPoint {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub position_lat: FitFieldAdjustedValue<FitSint32>,
    pub position_long: FitFieldAdjustedValue<FitSint32>,
    pub distance: FitFieldAdjustedValue<FitUint32>, // Accumulated distance along the segment at the described point
    pub altitude: FitFieldAdjustedValue<FitUint16>, // Accumulated altitude along the segment at the described point
    pub leader_time: FitFieldAdjustedValue<FitUint32>, // Accumualted time each leader board member required to reach the described point. This value is zero for all leader board members at the starting point of the segment.
}

impl fmt::Display for FitMessageSegmentPoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentPoint")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.position_lat, "position_lat", true, f)?;
        fmt_message_field!(self.position_long, "position_long", true, f)?;
        fmt_message_field!(self.distance, "distance", true, f)?;
        fmt_message_field!(self.altitude, "altitude", true, f)?;
        fmt_message_field!(self.leader_time, "leader_time", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentPoint {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            1 => "position_lat",
            2 => "position_long",
            3 => "distance",
            4 => "altitude",
            5 => "leader_time",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSegmentPoint> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSegmentPoint {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSegmentPoint",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            leader_time: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSegmentPoint),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            1 => {
                // position_lat
                self.position_lat.parse(parse_input, parse_config)?
            }
            2 => {
                // position_long
                self.position_long.parse(parse_input, parse_config)?
            }
            3 => {
                // distance
                self.distance.parse(parse_input, parse_config)?
            }
            4 => {
                // altitude
                self.altitude.parse(parse_input, parse_config)?
            }
            5 => {
                // leader_time
                self.leader_time.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentPoint {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentPoint";
    }
}

#[derive(Debug)]
pub enum FitMessageSessionSubfieldTotalCycles {
    NotYetParsed,
    Default(FitUint32),
    TotalStrides(FitUint32),
}

impl FitMessageSessionSubfieldTotalCycles {
    fn parse<'a>(
        message: &FitMessageSession,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageSessionSubfieldTotalCycles, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Running => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("strides".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSessionSubfieldTotalCycles::TotalStrides(val),
                    new_actions,
                ));
            }

            FitFieldSport::Walking => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("strides".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSessionSubfieldTotalCycles::TotalStrides(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageSessionSubfieldTotalCycles::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub enum FitMessageSessionSubfieldAvgCadence {
    NotYetParsed,
    Default(FitUint8),
    AvgRunningCadence(FitUint8),
}

impl FitMessageSessionSubfieldAvgCadence {
    fn parse<'a>(
        message: &FitMessageSession,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageSessionSubfieldAvgCadence, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Running => {
                let mut parser =
                    FitFieldBasicValue::<FitUint8>::new_single("strides/min".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSessionSubfieldAvgCadence::AvgRunningCadence(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageSessionSubfieldAvgCadence::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub enum FitMessageSessionSubfieldMaxCadence {
    NotYetParsed,
    Default(FitUint8),
    MaxRunningCadence(FitUint8),
}

impl FitMessageSessionSubfieldMaxCadence {
    fn parse<'a>(
        message: &FitMessageSession,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageSessionSubfieldMaxCadence, Vec<FitParseConfig>)> {
        match message.sport.get_single()? {
            FitFieldSport::Running => {
                let mut parser =
                    FitFieldBasicValue::<FitUint8>::new_single("strides/min".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSessionSubfieldMaxCadence::MaxRunningCadence(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint8>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageSessionSubfieldMaxCadence::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageSession {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>, // Selected bit is set for the current session.
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,         // Sesson end time.
    pub event: FitFieldBasicValue<FitFieldEvent>,                // session
    pub event_type: FitFieldBasicValue<FitFieldEventType>,       // stop
    pub start_time: FitFieldBasicValue<FitFieldDateTime>,
    pub start_position_lat: FitFieldAdjustedValue<FitSint32>,
    pub start_position_long: FitFieldAdjustedValue<FitSint32>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub total_elapsed_time: FitFieldAdjustedValue<FitUint32>, // Time (includes pauses)
    pub total_timer_time: FitFieldAdjustedValue<FitUint32>,   // Timer Time (excludes pauses)
    pub total_distance: FitFieldAdjustedValue<FitUint32>,
    pub total_cycles_subfield_bytes: Vec<u8>,
    pub total_cycles: FitMessageSessionSubfieldTotalCycles,
    pub total_calories: FitFieldBasicValue<FitUint16>,
    pub total_fat_calories: FitFieldBasicValue<FitUint16>,
    pub avg_speed: FitFieldAdjustedValue<FitUint16>, // total_distance / total_timer_time
    pub max_speed: FitFieldAdjustedValue<FitUint16>,
    pub avg_heart_rate: FitFieldBasicValue<FitUint8>, // average heart rate (excludes pause time)
    pub max_heart_rate: FitFieldBasicValue<FitUint8>,
    pub avg_cadence_subfield_bytes: Vec<u8>,
    pub avg_cadence: FitMessageSessionSubfieldAvgCadence, // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
    pub max_cadence_subfield_bytes: Vec<u8>,
    pub max_cadence: FitMessageSessionSubfieldMaxCadence,
    pub avg_power: FitFieldBasicValue<FitUint16>, // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
    pub max_power: FitFieldBasicValue<FitUint16>,
    pub total_ascent: FitFieldBasicValue<FitUint16>,
    pub total_descent: FitFieldBasicValue<FitUint16>,
    pub total_training_effect: FitFieldAdjustedValue<FitUint8>,
    pub first_lap_index: FitFieldBasicValue<FitUint16>,
    pub num_laps: FitFieldBasicValue<FitUint16>,
    pub event_group: FitFieldBasicValue<FitUint8>,
    pub trigger: FitFieldBasicValue<FitFieldSessionTrigger>,
    pub nec_lat: FitFieldAdjustedValue<FitSint32>,
    pub nec_long: FitFieldAdjustedValue<FitSint32>,
    pub swc_lat: FitFieldAdjustedValue<FitSint32>,
    pub swc_long: FitFieldAdjustedValue<FitSint32>,
    pub normalized_power: FitFieldBasicValue<FitUint16>,
    pub training_stress_score: FitFieldAdjustedValue<FitUint16>,
    pub intensity_factor: FitFieldAdjustedValue<FitUint16>,
    pub left_right_balance: FitFieldBasicValue<FitFieldLeftRightBalance100>,
    pub avg_stroke_count: FitFieldAdjustedValue<FitUint32>,
    pub avg_stroke_distance: FitFieldAdjustedValue<FitUint16>,
    pub swim_stroke: FitFieldBasicValue<FitFieldSwimStroke>,
    pub pool_length: FitFieldAdjustedValue<FitUint16>,
    pub threshold_power: FitFieldBasicValue<FitUint16>,
    pub pool_length_unit: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub num_active_lengths: FitFieldBasicValue<FitUint16>, // # of active lengths of swim pool
    pub total_work: FitFieldBasicValue<FitUint32>,
    pub avg_altitude: FitFieldAdjustedValue<FitUint16>,
    pub max_altitude: FitFieldAdjustedValue<FitUint16>,
    pub gps_accuracy: FitFieldBasicValue<FitUint8>,
    pub avg_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_pos_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_neg_grade: FitFieldAdjustedValue<FitSint16>,
    pub max_pos_grade: FitFieldAdjustedValue<FitSint16>,
    pub max_neg_grade: FitFieldAdjustedValue<FitSint16>,
    pub avg_temperature: FitFieldBasicValue<FitSint8>,
    pub max_temperature: FitFieldBasicValue<FitSint8>,
    pub total_moving_time: FitFieldAdjustedValue<FitUint32>,
    pub avg_pos_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub avg_neg_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub max_pos_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub max_neg_vertical_speed: FitFieldAdjustedValue<FitSint16>,
    pub min_heart_rate: FitFieldBasicValue<FitUint8>,
    pub time_in_hr_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_speed_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_cadence_zone: FitFieldAdjustedValue<FitUint32>,
    pub time_in_power_zone: FitFieldAdjustedValue<FitUint32>,
    pub avg_lap_time: FitFieldAdjustedValue<FitUint32>,
    pub best_lap_index: FitFieldBasicValue<FitUint16>,
    pub min_altitude: FitFieldAdjustedValue<FitUint16>,
    pub player_score: FitFieldBasicValue<FitUint16>,
    pub opponent_score: FitFieldBasicValue<FitUint16>,
    pub opponent_name: FitFieldBasicValue<FitString>,
    pub stroke_count: FitFieldBasicValue<FitUint16>, // stroke_type enum used as the index
    pub zone_count: FitFieldBasicValue<FitUint16>,   // zone number used as the index
    pub max_ball_speed: FitFieldAdjustedValue<FitUint16>,
    pub avg_ball_speed: FitFieldAdjustedValue<FitUint16>,
    pub avg_vertical_oscillation: FitFieldAdjustedValue<FitUint16>,
    pub avg_stance_time_percent: FitFieldAdjustedValue<FitUint16>,
    pub avg_stance_time: FitFieldAdjustedValue<FitUint16>,
    pub avg_fractional_cadence: FitFieldAdjustedValue<FitUint8>, // fractional part of the avg_cadence
    pub max_fractional_cadence: FitFieldAdjustedValue<FitUint8>, // fractional part of the max_cadence
    pub total_fractional_cycles: FitFieldAdjustedValue<FitUint8>, // fractional part of the total_cycles
    pub avg_total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Avg saturated and unsaturated hemoglobin
    pub min_total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Min saturated and unsaturated hemoglobin
    pub max_total_hemoglobin_conc: FitFieldAdjustedValue<FitUint16>, // Max saturated and unsaturated hemoglobin
    pub avg_saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Avg percentage of hemoglobin saturated with oxygen
    pub min_saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Min percentage of hemoglobin saturated with oxygen
    pub max_saturated_hemoglobin_percent: FitFieldAdjustedValue<FitUint16>, // Max percentage of hemoglobin saturated with oxygen
    pub avg_left_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub avg_right_torque_effectiveness: FitFieldAdjustedValue<FitUint8>,
    pub avg_left_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub avg_right_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub avg_combined_pedal_smoothness: FitFieldAdjustedValue<FitUint8>,
    pub sport_index: FitFieldBasicValue<FitUint8>,
    pub time_standing: FitFieldAdjustedValue<FitUint32>, // Total time spend in the standing position
    pub stand_count: FitFieldBasicValue<FitUint16>, // Number of transitions to the standing state
    pub avg_left_pco: FitFieldBasicValue<FitSint8>, // Average platform center offset Left
    pub avg_right_pco: FitFieldBasicValue<FitSint8>, // Average platform center offset Right
    pub avg_left_power_phase: FitFieldAdjustedValue<FitUint8>, // Average left power phase angles. Indexes defined by power_phase_type.
    pub avg_left_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Average left power phase peak angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase: FitFieldAdjustedValue<FitUint8>, // Average right power phase angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase_peak: FitFieldAdjustedValue<FitUint8>, // Average right power phase peak angles data value indexes  defined by power_phase_type.
    pub avg_power_position: FitFieldBasicValue<FitUint16>, // Average power by position. Data value indexes defined by rider_position_type.
    pub max_power_position: FitFieldBasicValue<FitUint16>, // Maximum power by position. Data value indexes defined by rider_position_type.
    pub avg_cadence_position: FitFieldBasicValue<FitUint8>, // Average cadence by position. Data value indexes defined by rider_position_type.
    pub max_cadence_position: FitFieldBasicValue<FitUint8>, // Maximum cadence by position. Data value indexes defined by rider_position_type.
    pub enhanced_avg_speed: FitFieldAdjustedValue<FitUint32>, // total_distance / total_timer_time
    pub enhanced_max_speed: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_avg_altitude: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_min_altitude: FitFieldAdjustedValue<FitUint32>,
    pub enhanced_max_altitude: FitFieldAdjustedValue<FitUint32>,
    pub avg_lev_motor_power: FitFieldBasicValue<FitUint16>, // lev average motor power during session
    pub max_lev_motor_power: FitFieldBasicValue<FitUint16>, // lev maximum motor power during session
    pub lev_battery_consumption: FitFieldAdjustedValue<FitUint8>, // lev battery consumption during session
    pub avg_vertical_ratio: FitFieldAdjustedValue<FitUint16>,
    pub avg_stance_time_balance: FitFieldAdjustedValue<FitUint16>,
    pub avg_step_length: FitFieldAdjustedValue<FitUint16>,
    pub total_anaerobic_training_effect: FitFieldAdjustedValue<FitUint8>,
    pub avg_vam: FitFieldAdjustedValue<FitUint16>,
}

impl fmt::Display for FitMessageSession {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSession")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.event, "event", false, f)?;
        fmt_message_field!(self.event_type, "event_type", false, f)?;
        fmt_message_field!(self.start_time, "start_time", false, f)?;
        fmt_message_field!(self.start_position_lat, "start_position_lat", true, f)?;
        fmt_message_field!(self.start_position_long, "start_position_long", true, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.total_elapsed_time, "total_elapsed_time", true, f)?;
        fmt_message_field!(self.total_timer_time, "total_timer_time", true, f)?;
        fmt_message_field!(self.total_distance, "total_distance", true, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "total_cycles_subfield_bytes", self.total_cycles_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "total_cycles", self.total_cycles)?;
        fmt_message_field!(self.total_calories, "total_calories", false, f)?;
        fmt_message_field!(self.total_fat_calories, "total_fat_calories", false, f)?;
        fmt_message_field!(self.avg_speed, "avg_speed", true, f)?;
        fmt_message_field!(self.max_speed, "max_speed", true, f)?;
        fmt_message_field!(self.avg_heart_rate, "avg_heart_rate", false, f)?;
        fmt_message_field!(self.max_heart_rate, "max_heart_rate", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "avg_cadence_subfield_bytes", self.avg_cadence_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "avg_cadence", self.avg_cadence)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "max_cadence_subfield_bytes", self.max_cadence_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "max_cadence", self.max_cadence)?;
        fmt_message_field!(self.avg_power, "avg_power", false, f)?;
        fmt_message_field!(self.max_power, "max_power", false, f)?;
        fmt_message_field!(self.total_ascent, "total_ascent", false, f)?;
        fmt_message_field!(self.total_descent, "total_descent", false, f)?;
        fmt_message_field!(self.total_training_effect, "total_training_effect", true, f)?;
        fmt_message_field!(self.first_lap_index, "first_lap_index", false, f)?;
        fmt_message_field!(self.num_laps, "num_laps", false, f)?;
        fmt_message_field!(self.event_group, "event_group", false, f)?;
        fmt_message_field!(self.trigger, "trigger", false, f)?;
        fmt_message_field!(self.nec_lat, "nec_lat", true, f)?;
        fmt_message_field!(self.nec_long, "nec_long", true, f)?;
        fmt_message_field!(self.swc_lat, "swc_lat", true, f)?;
        fmt_message_field!(self.swc_long, "swc_long", true, f)?;
        fmt_message_field!(self.normalized_power, "normalized_power", false, f)?;
        fmt_message_field!(self.training_stress_score, "training_stress_score", true, f)?;
        fmt_message_field!(self.intensity_factor, "intensity_factor", true, f)?;
        fmt_message_field!(self.left_right_balance, "left_right_balance", false, f)?;
        fmt_message_field!(self.avg_stroke_count, "avg_stroke_count", true, f)?;
        fmt_message_field!(self.avg_stroke_distance, "avg_stroke_distance", true, f)?;
        fmt_message_field!(self.swim_stroke, "swim_stroke", false, f)?;
        fmt_message_field!(self.pool_length, "pool_length", true, f)?;
        fmt_message_field!(self.threshold_power, "threshold_power", false, f)?;
        fmt_message_field!(self.pool_length_unit, "pool_length_unit", false, f)?;
        fmt_message_field!(self.num_active_lengths, "num_active_lengths", false, f)?;
        fmt_message_field!(self.total_work, "total_work", false, f)?;
        fmt_message_field!(self.avg_altitude, "avg_altitude", true, f)?;
        fmt_message_field!(self.max_altitude, "max_altitude", true, f)?;
        fmt_message_field!(self.gps_accuracy, "gps_accuracy", false, f)?;
        fmt_message_field!(self.avg_grade, "avg_grade", true, f)?;
        fmt_message_field!(self.avg_pos_grade, "avg_pos_grade", true, f)?;
        fmt_message_field!(self.avg_neg_grade, "avg_neg_grade", true, f)?;
        fmt_message_field!(self.max_pos_grade, "max_pos_grade", true, f)?;
        fmt_message_field!(self.max_neg_grade, "max_neg_grade", true, f)?;
        fmt_message_field!(self.avg_temperature, "avg_temperature", false, f)?;
        fmt_message_field!(self.max_temperature, "max_temperature", false, f)?;
        fmt_message_field!(self.total_moving_time, "total_moving_time", true, f)?;
        fmt_message_field!(
            self.avg_pos_vertical_speed,
            "avg_pos_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_neg_vertical_speed,
            "avg_neg_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_pos_vertical_speed,
            "max_pos_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_neg_vertical_speed,
            "max_neg_vertical_speed",
            true,
            f
        )?;
        fmt_message_field!(self.min_heart_rate, "min_heart_rate", false, f)?;
        fmt_message_field!(self.time_in_hr_zone, "time_in_hr_zone", true, f)?;
        fmt_message_field!(self.time_in_speed_zone, "time_in_speed_zone", true, f)?;
        fmt_message_field!(self.time_in_cadence_zone, "time_in_cadence_zone", true, f)?;
        fmt_message_field!(self.time_in_power_zone, "time_in_power_zone", true, f)?;
        fmt_message_field!(self.avg_lap_time, "avg_lap_time", true, f)?;
        fmt_message_field!(self.best_lap_index, "best_lap_index", false, f)?;
        fmt_message_field!(self.min_altitude, "min_altitude", true, f)?;
        fmt_message_field!(self.player_score, "player_score", false, f)?;
        fmt_message_field!(self.opponent_score, "opponent_score", false, f)?;
        fmt_message_field!(self.opponent_name, "opponent_name", false, f)?;
        fmt_message_field!(self.stroke_count, "stroke_count", false, f)?;
        fmt_message_field!(self.zone_count, "zone_count", false, f)?;
        fmt_message_field!(self.max_ball_speed, "max_ball_speed", true, f)?;
        fmt_message_field!(self.avg_ball_speed, "avg_ball_speed", true, f)?;
        fmt_message_field!(
            self.avg_vertical_oscillation,
            "avg_vertical_oscillation",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_stance_time_percent,
            "avg_stance_time_percent",
            true,
            f
        )?;
        fmt_message_field!(self.avg_stance_time, "avg_stance_time", true, f)?;
        fmt_message_field!(
            self.avg_fractional_cadence,
            "avg_fractional_cadence",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_fractional_cadence,
            "max_fractional_cadence",
            true,
            f
        )?;
        fmt_message_field!(
            self.total_fractional_cycles,
            "total_fractional_cycles",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_total_hemoglobin_conc,
            "avg_total_hemoglobin_conc",
            true,
            f
        )?;
        fmt_message_field!(
            self.min_total_hemoglobin_conc,
            "min_total_hemoglobin_conc",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_total_hemoglobin_conc,
            "max_total_hemoglobin_conc",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_saturated_hemoglobin_percent,
            "avg_saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.min_saturated_hemoglobin_percent,
            "min_saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.max_saturated_hemoglobin_percent,
            "max_saturated_hemoglobin_percent",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_left_torque_effectiveness,
            "avg_left_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_right_torque_effectiveness,
            "avg_right_torque_effectiveness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_left_pedal_smoothness,
            "avg_left_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_right_pedal_smoothness,
            "avg_right_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(
            self.avg_combined_pedal_smoothness,
            "avg_combined_pedal_smoothness",
            true,
            f
        )?;
        fmt_message_field!(self.sport_index, "sport_index", false, f)?;
        fmt_message_field!(self.time_standing, "time_standing", true, f)?;
        fmt_message_field!(self.stand_count, "stand_count", false, f)?;
        fmt_message_field!(self.avg_left_pco, "avg_left_pco", false, f)?;
        fmt_message_field!(self.avg_right_pco, "avg_right_pco", false, f)?;
        fmt_message_field!(self.avg_left_power_phase, "avg_left_power_phase", true, f)?;
        fmt_message_field!(
            self.avg_left_power_phase_peak,
            "avg_left_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.avg_right_power_phase, "avg_right_power_phase", true, f)?;
        fmt_message_field!(
            self.avg_right_power_phase_peak,
            "avg_right_power_phase_peak",
            true,
            f
        )?;
        fmt_message_field!(self.avg_power_position, "avg_power_position", false, f)?;
        fmt_message_field!(self.max_power_position, "max_power_position", false, f)?;
        fmt_message_field!(self.avg_cadence_position, "avg_cadence_position", false, f)?;
        fmt_message_field!(self.max_cadence_position, "max_cadence_position", false, f)?;
        fmt_message_field!(self.enhanced_avg_speed, "enhanced_avg_speed", true, f)?;
        fmt_message_field!(self.enhanced_max_speed, "enhanced_max_speed", true, f)?;
        fmt_message_field!(self.enhanced_avg_altitude, "enhanced_avg_altitude", true, f)?;
        fmt_message_field!(self.enhanced_min_altitude, "enhanced_min_altitude", true, f)?;
        fmt_message_field!(self.enhanced_max_altitude, "enhanced_max_altitude", true, f)?;
        fmt_message_field!(self.avg_lev_motor_power, "avg_lev_motor_power", false, f)?;
        fmt_message_field!(self.max_lev_motor_power, "max_lev_motor_power", false, f)?;
        fmt_message_field!(
            self.lev_battery_consumption,
            "lev_battery_consumption",
            true,
            f
        )?;
        fmt_message_field!(self.avg_vertical_ratio, "avg_vertical_ratio", true, f)?;
        fmt_message_field!(
            self.avg_stance_time_balance,
            "avg_stance_time_balance",
            true,
            f
        )?;
        fmt_message_field!(self.avg_step_length, "avg_step_length", true, f)?;
        fmt_message_field!(
            self.total_anaerobic_training_effect,
            "total_anaerobic_training_effect",
            true,
            f
        )?;
        fmt_message_field!(self.avg_vam, "avg_vam", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSession {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            253 => "timestamp",
            0 => "event",
            1 => "event_type",
            2 => "start_time",
            3 => "start_position_lat",
            4 => "start_position_long",
            5 => "sport",
            6 => "sub_sport",
            7 => "total_elapsed_time",
            8 => "total_timer_time",
            9 => "total_distance",
            10 => "total_cycles",
            11 => "total_calories",
            13 => "total_fat_calories",
            14 => "avg_speed",
            15 => "max_speed",
            16 => "avg_heart_rate",
            17 => "max_heart_rate",
            18 => "avg_cadence",
            19 => "max_cadence",
            20 => "avg_power",
            21 => "max_power",
            22 => "total_ascent",
            23 => "total_descent",
            24 => "total_training_effect",
            25 => "first_lap_index",
            26 => "num_laps",
            27 => "event_group",
            28 => "trigger",
            29 => "nec_lat",
            30 => "nec_long",
            31 => "swc_lat",
            32 => "swc_long",
            34 => "normalized_power",
            35 => "training_stress_score",
            36 => "intensity_factor",
            37 => "left_right_balance",
            41 => "avg_stroke_count",
            42 => "avg_stroke_distance",
            43 => "swim_stroke",
            44 => "pool_length",
            45 => "threshold_power",
            46 => "pool_length_unit",
            47 => "num_active_lengths",
            48 => "total_work",
            49 => "avg_altitude",
            50 => "max_altitude",
            51 => "gps_accuracy",
            52 => "avg_grade",
            53 => "avg_pos_grade",
            54 => "avg_neg_grade",
            55 => "max_pos_grade",
            56 => "max_neg_grade",
            57 => "avg_temperature",
            58 => "max_temperature",
            59 => "total_moving_time",
            60 => "avg_pos_vertical_speed",
            61 => "avg_neg_vertical_speed",
            62 => "max_pos_vertical_speed",
            63 => "max_neg_vertical_speed",
            64 => "min_heart_rate",
            65 => "time_in_hr_zone",
            66 => "time_in_speed_zone",
            67 => "time_in_cadence_zone",
            68 => "time_in_power_zone",
            69 => "avg_lap_time",
            70 => "best_lap_index",
            71 => "min_altitude",
            82 => "player_score",
            83 => "opponent_score",
            84 => "opponent_name",
            85 => "stroke_count",
            86 => "zone_count",
            87 => "max_ball_speed",
            88 => "avg_ball_speed",
            89 => "avg_vertical_oscillation",
            90 => "avg_stance_time_percent",
            91 => "avg_stance_time",
            92 => "avg_fractional_cadence",
            93 => "max_fractional_cadence",
            94 => "total_fractional_cycles",
            95 => "avg_total_hemoglobin_conc",
            96 => "min_total_hemoglobin_conc",
            97 => "max_total_hemoglobin_conc",
            98 => "avg_saturated_hemoglobin_percent",
            99 => "min_saturated_hemoglobin_percent",
            100 => "max_saturated_hemoglobin_percent",
            101 => "avg_left_torque_effectiveness",
            102 => "avg_right_torque_effectiveness",
            103 => "avg_left_pedal_smoothness",
            104 => "avg_right_pedal_smoothness",
            105 => "avg_combined_pedal_smoothness",
            111 => "sport_index",
            112 => "time_standing",
            113 => "stand_count",
            114 => "avg_left_pco",
            115 => "avg_right_pco",
            116 => "avg_left_power_phase",
            117 => "avg_left_power_phase_peak",
            118 => "avg_right_power_phase",
            119 => "avg_right_power_phase_peak",
            120 => "avg_power_position",
            121 => "max_power_position",
            122 => "avg_cadence_position",
            123 => "max_cadence_position",
            124 => "enhanced_avg_speed",
            125 => "enhanced_max_speed",
            126 => "enhanced_avg_altitude",
            127 => "enhanced_min_altitude",
            128 => "enhanced_max_altitude",
            129 => "avg_lev_motor_power",
            130 => "max_lev_motor_power",
            131 => "lev_battery_consumption",
            132 => "avg_vertical_ratio",
            133 => "avg_stance_time_balance",
            134 => "avg_step_length",
            137 => "total_anaerobic_training_effect",
            139 => "avg_vam",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSession> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let endianness = definition_message.endianness;
        let message = FitMessageSession {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![10, 18, 19],
            message_name: "FitMessageSession",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            event: FitFieldBasicValue::new_single("".to_string()),
            event_type: FitFieldBasicValue::new_single("".to_string()),
            start_time: FitFieldBasicValue::new_single("".to_string()),
            start_position_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            start_position_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            sport: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            total_elapsed_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_timer_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            total_distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            total_cycles_subfield_bytes: vec![],
            total_cycles: FitMessageSessionSubfieldTotalCycles::NotYetParsed,
            total_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            total_fat_calories: FitFieldBasicValue::new_single("kcal".to_string()),
            avg_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    124,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((1000.0, 0.0)),
                    Some("m/s".to_string()),
                )]),
            max_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    125,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((1000.0, 0.0)),
                    Some("m/s".to_string()),
                )]),
            avg_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            max_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            avg_cadence_subfield_bytes: vec![],
            avg_cadence: FitMessageSessionSubfieldAvgCadence::NotYetParsed,
            max_cadence_subfield_bytes: vec![],
            max_cadence: FitMessageSessionSubfieldMaxCadence::NotYetParsed,
            avg_power: FitFieldBasicValue::new_single("watts".to_string()),
            max_power: FitFieldBasicValue::new_single("watts".to_string()),
            total_ascent: FitFieldBasicValue::new_single("m".to_string()),
            total_descent: FitFieldBasicValue::new_single("m".to_string()),
            total_training_effect: FitFieldAdjustedValue::new_single("".to_string(), 10.0, 0.0),
            first_lap_index: FitFieldBasicValue::new_single("".to_string()),
            num_laps: FitFieldBasicValue::new_single("".to_string()),
            event_group: FitFieldBasicValue::new_single("".to_string()),
            trigger: FitFieldBasicValue::new_single("".to_string()),
            nec_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            nec_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            swc_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            swc_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            normalized_power: FitFieldBasicValue::new_single("watts".to_string()),
            training_stress_score: FitFieldAdjustedValue::new_single("tss".to_string(), 10.0, 0.0),
            intensity_factor: FitFieldAdjustedValue::new_single("if".to_string(), 1000.0, 0.0),
            left_right_balance: FitFieldBasicValue::new_single("".to_string()),
            avg_stroke_count: FitFieldAdjustedValue::new_single(
                "strokes/lap".to_string(),
                10.0,
                0.0,
            ),
            avg_stroke_distance: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            swim_stroke: FitFieldBasicValue::new_single("".to_string()),
            pool_length: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            threshold_power: FitFieldBasicValue::new_single("watts".to_string()),
            pool_length_unit: FitFieldBasicValue::new_single("".to_string()),
            num_active_lengths: FitFieldBasicValue::new_single("lengths".to_string()),
            total_work: FitFieldBasicValue::new_single("J".to_string()),
            avg_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    126,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            max_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    128,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            gps_accuracy: FitFieldBasicValue::new_single("m".to_string()),
            avg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_pos_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_neg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            max_pos_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            max_neg_grade: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            avg_temperature: FitFieldBasicValue::new_single("C".to_string()),
            max_temperature: FitFieldBasicValue::new_single("C".to_string()),
            total_moving_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            avg_pos_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            avg_neg_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            max_pos_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            max_neg_vertical_speed: FitFieldAdjustedValue::new_single(
                "m/s".to_string(),
                1000.0,
                0.0,
            ),
            min_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            time_in_hr_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_speed_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_cadence_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            time_in_power_zone: FitFieldAdjustedValue::new_vec("s".to_string(), 1000.0, 0.0),
            avg_lap_time: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            best_lap_index: FitFieldBasicValue::new_single("".to_string()),
            min_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0)
                .add_components(vec![FitParseConfig::new_from_component(
                    127,
                    4,
                    134,
                    endianness,
                    0,
                    16,
                    Some((5.0, 500.0)),
                    Some("m".to_string()),
                )]),
            player_score: FitFieldBasicValue::new_single("".to_string()),
            opponent_score: FitFieldBasicValue::new_single("".to_string()),
            opponent_name: FitFieldBasicValue::new_single("".to_string()),
            stroke_count: FitFieldBasicValue::new_vec("counts".to_string()),
            zone_count: FitFieldBasicValue::new_vec("counts".to_string()),
            max_ball_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 100.0, 0.0),
            avg_ball_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 100.0, 0.0),
            avg_vertical_oscillation: FitFieldAdjustedValue::new_single(
                "mm".to_string(),
                10.0,
                0.0,
            ),
            avg_stance_time_percent: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            avg_stance_time: FitFieldAdjustedValue::new_single("ms".to_string(), 10.0, 0.0),
            avg_fractional_cadence: FitFieldAdjustedValue::new_single(
                "rpm".to_string(),
                128.0,
                0.0,
            ),
            max_fractional_cadence: FitFieldAdjustedValue::new_single(
                "rpm".to_string(),
                128.0,
                0.0,
            ),
            total_fractional_cycles: FitFieldAdjustedValue::new_single(
                "cycles".to_string(),
                128.0,
                0.0,
            ),
            avg_total_hemoglobin_conc: FitFieldAdjustedValue::new_vec(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            min_total_hemoglobin_conc: FitFieldAdjustedValue::new_vec(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            max_total_hemoglobin_conc: FitFieldAdjustedValue::new_vec(
                "g/dL".to_string(),
                100.0,
                0.0,
            ),
            avg_saturated_hemoglobin_percent: FitFieldAdjustedValue::new_vec(
                "%".to_string(),
                10.0,
                0.0,
            ),
            min_saturated_hemoglobin_percent: FitFieldAdjustedValue::new_vec(
                "%".to_string(),
                10.0,
                0.0,
            ),
            max_saturated_hemoglobin_percent: FitFieldAdjustedValue::new_vec(
                "%".to_string(),
                10.0,
                0.0,
            ),
            avg_left_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_right_torque_effectiveness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_left_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_right_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_combined_pedal_smoothness: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            sport_index: FitFieldBasicValue::new_single("".to_string()),
            time_standing: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            stand_count: FitFieldBasicValue::new_single("".to_string()),
            avg_left_pco: FitFieldBasicValue::new_single("mm".to_string()),
            avg_right_pco: FitFieldBasicValue::new_single("mm".to_string()),
            avg_left_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_left_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_right_power_phase: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_right_power_phase_peak: FitFieldAdjustedValue::new_vec(
                "degrees".to_string(),
                0.7111111,
                0.0,
            ),
            avg_power_position: FitFieldBasicValue::new_vec("watts".to_string()),
            max_power_position: FitFieldBasicValue::new_vec("watts".to_string()),
            avg_cadence_position: FitFieldBasicValue::new_vec("rpm".to_string()),
            max_cadence_position: FitFieldBasicValue::new_vec("rpm".to_string()),
            enhanced_avg_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            enhanced_max_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            enhanced_avg_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            enhanced_min_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            enhanced_max_altitude: FitFieldAdjustedValue::new_single("m".to_string(), 5.0, 500.0),
            avg_lev_motor_power: FitFieldBasicValue::new_single("watts".to_string()),
            max_lev_motor_power: FitFieldBasicValue::new_single("watts".to_string()),
            lev_battery_consumption: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                2.0,
                0.0,
            ),
            avg_vertical_ratio: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            avg_stance_time_balance: FitFieldAdjustedValue::new_single(
                "percent".to_string(),
                100.0,
                0.0,
            ),
            avg_step_length: FitFieldAdjustedValue::new_single("mm".to_string(), 10.0, 0.0),
            total_anaerobic_training_effect: FitFieldAdjustedValue::new_single(
                "".to_string(),
                10.0,
                0.0,
            ),
            avg_vam: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSession),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // event
                self.event.parse(parse_input, parse_config)?
            }
            1 => {
                // event_type
                self.event_type.parse(parse_input, parse_config)?
            }
            2 => {
                // start_time
                self.start_time.parse(parse_input, parse_config)?
            }
            3 => {
                // start_position_lat
                self.start_position_lat.parse(parse_input, parse_config)?
            }
            4 => {
                // start_position_long
                self.start_position_long.parse(parse_input, parse_config)?
            }
            5 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            6 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            7 => {
                // total_elapsed_time
                self.total_elapsed_time.parse(parse_input, parse_config)?
            }
            8 => {
                // total_timer_time
                self.total_timer_time.parse(parse_input, parse_config)?
            }
            9 => {
                // total_distance
                self.total_distance.parse(parse_input, parse_config)?
            }
            10 => {
                // total_cycles
                self.total_cycles_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            11 => {
                // total_calories
                self.total_calories.parse(parse_input, parse_config)?
            }
            13 => {
                // total_fat_calories
                self.total_fat_calories.parse(parse_input, parse_config)?
            }
            14 => {
                // avg_speed
                self.avg_speed.parse(parse_input, parse_config)?
            }
            15 => {
                // max_speed
                self.max_speed.parse(parse_input, parse_config)?
            }
            16 => {
                // avg_heart_rate
                self.avg_heart_rate.parse(parse_input, parse_config)?
            }
            17 => {
                // max_heart_rate
                self.max_heart_rate.parse(parse_input, parse_config)?
            }
            18 => {
                // avg_cadence
                self.avg_cadence_subfield_bytes = parse_uint8_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            19 => {
                // max_cadence
                self.max_cadence_subfield_bytes = parse_uint8_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            20 => {
                // avg_power
                self.avg_power.parse(parse_input, parse_config)?
            }
            21 => {
                // max_power
                self.max_power.parse(parse_input, parse_config)?
            }
            22 => {
                // total_ascent
                self.total_ascent.parse(parse_input, parse_config)?
            }
            23 => {
                // total_descent
                self.total_descent.parse(parse_input, parse_config)?
            }
            24 => {
                // total_training_effect
                self.total_training_effect
                    .parse(parse_input, parse_config)?
            }
            25 => {
                // first_lap_index
                self.first_lap_index.parse(parse_input, parse_config)?
            }
            26 => {
                // num_laps
                self.num_laps.parse(parse_input, parse_config)?
            }
            27 => {
                // event_group
                self.event_group.parse(parse_input, parse_config)?
            }
            28 => {
                // trigger
                self.trigger.parse(parse_input, parse_config)?
            }
            29 => {
                // nec_lat
                self.nec_lat.parse(parse_input, parse_config)?
            }
            30 => {
                // nec_long
                self.nec_long.parse(parse_input, parse_config)?
            }
            31 => {
                // swc_lat
                self.swc_lat.parse(parse_input, parse_config)?
            }
            32 => {
                // swc_long
                self.swc_long.parse(parse_input, parse_config)?
            }
            34 => {
                // normalized_power
                self.normalized_power.parse(parse_input, parse_config)?
            }
            35 => {
                // training_stress_score
                self.training_stress_score
                    .parse(parse_input, parse_config)?
            }
            36 => {
                // intensity_factor
                self.intensity_factor.parse(parse_input, parse_config)?
            }
            37 => {
                // left_right_balance
                self.left_right_balance.parse(parse_input, parse_config)?
            }
            41 => {
                // avg_stroke_count
                self.avg_stroke_count.parse(parse_input, parse_config)?
            }
            42 => {
                // avg_stroke_distance
                self.avg_stroke_distance.parse(parse_input, parse_config)?
            }
            43 => {
                // swim_stroke
                self.swim_stroke.parse(parse_input, parse_config)?
            }
            44 => {
                // pool_length
                self.pool_length.parse(parse_input, parse_config)?
            }
            45 => {
                // threshold_power
                self.threshold_power.parse(parse_input, parse_config)?
            }
            46 => {
                // pool_length_unit
                self.pool_length_unit.parse(parse_input, parse_config)?
            }
            47 => {
                // num_active_lengths
                self.num_active_lengths.parse(parse_input, parse_config)?
            }
            48 => {
                // total_work
                self.total_work.parse(parse_input, parse_config)?
            }
            49 => {
                // avg_altitude
                self.avg_altitude.parse(parse_input, parse_config)?
            }
            50 => {
                // max_altitude
                self.max_altitude.parse(parse_input, parse_config)?
            }
            51 => {
                // gps_accuracy
                self.gps_accuracy.parse(parse_input, parse_config)?
            }
            52 => {
                // avg_grade
                self.avg_grade.parse(parse_input, parse_config)?
            }
            53 => {
                // avg_pos_grade
                self.avg_pos_grade.parse(parse_input, parse_config)?
            }
            54 => {
                // avg_neg_grade
                self.avg_neg_grade.parse(parse_input, parse_config)?
            }
            55 => {
                // max_pos_grade
                self.max_pos_grade.parse(parse_input, parse_config)?
            }
            56 => {
                // max_neg_grade
                self.max_neg_grade.parse(parse_input, parse_config)?
            }
            57 => {
                // avg_temperature
                self.avg_temperature.parse(parse_input, parse_config)?
            }
            58 => {
                // max_temperature
                self.max_temperature.parse(parse_input, parse_config)?
            }
            59 => {
                // total_moving_time
                self.total_moving_time.parse(parse_input, parse_config)?
            }
            60 => {
                // avg_pos_vertical_speed
                self.avg_pos_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            61 => {
                // avg_neg_vertical_speed
                self.avg_neg_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            62 => {
                // max_pos_vertical_speed
                self.max_pos_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            63 => {
                // max_neg_vertical_speed
                self.max_neg_vertical_speed
                    .parse(parse_input, parse_config)?
            }
            64 => {
                // min_heart_rate
                self.min_heart_rate.parse(parse_input, parse_config)?
            }
            65 => {
                // time_in_hr_zone
                self.time_in_hr_zone.parse(parse_input, parse_config)?
            }
            66 => {
                // time_in_speed_zone
                self.time_in_speed_zone.parse(parse_input, parse_config)?
            }
            67 => {
                // time_in_cadence_zone
                self.time_in_cadence_zone.parse(parse_input, parse_config)?
            }
            68 => {
                // time_in_power_zone
                self.time_in_power_zone.parse(parse_input, parse_config)?
            }
            69 => {
                // avg_lap_time
                self.avg_lap_time.parse(parse_input, parse_config)?
            }
            70 => {
                // best_lap_index
                self.best_lap_index.parse(parse_input, parse_config)?
            }
            71 => {
                // min_altitude
                self.min_altitude.parse(parse_input, parse_config)?
            }
            82 => {
                // player_score
                self.player_score.parse(parse_input, parse_config)?
            }
            83 => {
                // opponent_score
                self.opponent_score.parse(parse_input, parse_config)?
            }
            84 => {
                // opponent_name
                self.opponent_name.parse(parse_input, parse_config)?
            }
            85 => {
                // stroke_count
                self.stroke_count.parse(parse_input, parse_config)?
            }
            86 => {
                // zone_count
                self.zone_count.parse(parse_input, parse_config)?
            }
            87 => {
                // max_ball_speed
                self.max_ball_speed.parse(parse_input, parse_config)?
            }
            88 => {
                // avg_ball_speed
                self.avg_ball_speed.parse(parse_input, parse_config)?
            }
            89 => {
                // avg_vertical_oscillation
                self.avg_vertical_oscillation
                    .parse(parse_input, parse_config)?
            }
            90 => {
                // avg_stance_time_percent
                self.avg_stance_time_percent
                    .parse(parse_input, parse_config)?
            }
            91 => {
                // avg_stance_time
                self.avg_stance_time.parse(parse_input, parse_config)?
            }
            92 => {
                // avg_fractional_cadence
                self.avg_fractional_cadence
                    .parse(parse_input, parse_config)?
            }
            93 => {
                // max_fractional_cadence
                self.max_fractional_cadence
                    .parse(parse_input, parse_config)?
            }
            94 => {
                // total_fractional_cycles
                self.total_fractional_cycles
                    .parse(parse_input, parse_config)?
            }
            95 => {
                // avg_total_hemoglobin_conc
                self.avg_total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            96 => {
                // min_total_hemoglobin_conc
                self.min_total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            97 => {
                // max_total_hemoglobin_conc
                self.max_total_hemoglobin_conc
                    .parse(parse_input, parse_config)?
            }
            98 => {
                // avg_saturated_hemoglobin_percent
                self.avg_saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            99 => {
                // min_saturated_hemoglobin_percent
                self.min_saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            100 => {
                // max_saturated_hemoglobin_percent
                self.max_saturated_hemoglobin_percent
                    .parse(parse_input, parse_config)?
            }
            101 => {
                // avg_left_torque_effectiveness
                self.avg_left_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            102 => {
                // avg_right_torque_effectiveness
                self.avg_right_torque_effectiveness
                    .parse(parse_input, parse_config)?
            }
            103 => {
                // avg_left_pedal_smoothness
                self.avg_left_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            104 => {
                // avg_right_pedal_smoothness
                self.avg_right_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            105 => {
                // avg_combined_pedal_smoothness
                self.avg_combined_pedal_smoothness
                    .parse(parse_input, parse_config)?
            }
            111 => {
                // sport_index
                self.sport_index.parse(parse_input, parse_config)?
            }
            112 => {
                // time_standing
                self.time_standing.parse(parse_input, parse_config)?
            }
            113 => {
                // stand_count
                self.stand_count.parse(parse_input, parse_config)?
            }
            114 => {
                // avg_left_pco
                self.avg_left_pco.parse(parse_input, parse_config)?
            }
            115 => {
                // avg_right_pco
                self.avg_right_pco.parse(parse_input, parse_config)?
            }
            116 => {
                // avg_left_power_phase
                self.avg_left_power_phase.parse(parse_input, parse_config)?
            }
            117 => {
                // avg_left_power_phase_peak
                self.avg_left_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            118 => {
                // avg_right_power_phase
                self.avg_right_power_phase
                    .parse(parse_input, parse_config)?
            }
            119 => {
                // avg_right_power_phase_peak
                self.avg_right_power_phase_peak
                    .parse(parse_input, parse_config)?
            }
            120 => {
                // avg_power_position
                self.avg_power_position.parse(parse_input, parse_config)?
            }
            121 => {
                // max_power_position
                self.max_power_position.parse(parse_input, parse_config)?
            }
            122 => {
                // avg_cadence_position
                self.avg_cadence_position.parse(parse_input, parse_config)?
            }
            123 => {
                // max_cadence_position
                self.max_cadence_position.parse(parse_input, parse_config)?
            }
            124 => {
                // enhanced_avg_speed
                self.enhanced_avg_speed.parse(parse_input, parse_config)?
            }
            125 => {
                // enhanced_max_speed
                self.enhanced_max_speed.parse(parse_input, parse_config)?
            }
            126 => {
                // enhanced_avg_altitude
                self.enhanced_avg_altitude
                    .parse(parse_input, parse_config)?
            }
            127 => {
                // enhanced_min_altitude
                self.enhanced_min_altitude
                    .parse(parse_input, parse_config)?
            }
            128 => {
                // enhanced_max_altitude
                self.enhanced_max_altitude
                    .parse(parse_input, parse_config)?
            }
            129 => {
                // avg_lev_motor_power
                self.avg_lev_motor_power.parse(parse_input, parse_config)?
            }
            130 => {
                // max_lev_motor_power
                self.max_lev_motor_power.parse(parse_input, parse_config)?
            }
            131 => {
                // lev_battery_consumption
                self.lev_battery_consumption
                    .parse(parse_input, parse_config)?
            }
            132 => {
                // avg_vertical_ratio
                self.avg_vertical_ratio.parse(parse_input, parse_config)?
            }
            133 => {
                // avg_stance_time_balance
                self.avg_stance_time_balance
                    .parse(parse_input, parse_config)?
            }
            134 => {
                // avg_step_length
                self.avg_step_length.parse(parse_input, parse_config)?
            }
            137 => {
                // total_anaerobic_training_effect
                self.total_anaerobic_training_effect
                    .parse(parse_input, parse_config)?
            }
            139 => {
                // avg_vam
                self.avg_vam.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            10 => {
                let (val, new_actions) = FitMessageSessionSubfieldTotalCycles::parse(
                    &self,
                    &self.total_cycles_subfield_bytes,
                    &parse_config,
                )?;
                self.total_cycles = val;
                new_actions
            }

            18 => {
                let (val, new_actions) = FitMessageSessionSubfieldAvgCadence::parse(
                    &self,
                    &self.avg_cadence_subfield_bytes,
                    &parse_config,
                )?;
                self.avg_cadence = val;
                new_actions
            }

            19 => {
                let (val, new_actions) = FitMessageSessionSubfieldMaxCadence::parse(
                    &self,
                    &self.max_cadence_subfield_bytes,
                    &parse_config,
                )?;
                self.max_cadence = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSession {
    fn message_name(&self) -> &'static str {
        return "FitMessageSession";
    }
}

#[derive(Debug)]
pub struct FitMessageSet {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Timestamp of the set
    pub duration: FitFieldAdjustedValue<FitUint32>,
    pub repetitions: FitFieldBasicValue<FitUint16>, // # of repitions of the movement
    pub weight: FitFieldAdjustedValue<FitUint16>,   // Amount of weight applied for the set
    pub set_type: FitFieldBasicValue<FitFieldSetType>,
    pub start_time: FitFieldBasicValue<FitFieldDateTime>, // Start time of the set
    pub category: FitFieldBasicValue<FitFieldExerciseCategory>,
    pub category_subtype: FitFieldBasicValue<FitUint16>, // Based on the associated category, see [category]_exercise_names
    pub weight_display_unit: FitFieldBasicValue<FitFieldFitBaseUnit>,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub wkt_step_index: FitFieldBasicValue<FitFieldMessageIndex>,
}

impl fmt::Display for FitMessageSet {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSet")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.duration, "duration", true, f)?;
        fmt_message_field!(self.repetitions, "repetitions", false, f)?;
        fmt_message_field!(self.weight, "weight", true, f)?;
        fmt_message_field!(self.set_type, "set_type", false, f)?;
        fmt_message_field!(self.start_time, "start_time", false, f)?;
        fmt_message_field!(self.category, "category", false, f)?;
        fmt_message_field!(self.category_subtype, "category_subtype", false, f)?;
        fmt_message_field!(self.weight_display_unit, "weight_display_unit", false, f)?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.wkt_step_index, "wkt_step_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSet {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "timestamp",
            0 => "duration",
            3 => "repetitions",
            4 => "weight",
            5 => "set_type",
            6 => "start_time",
            7 => "category",
            8 => "category_subtype",
            9 => "weight_display_unit",
            10 => "message_index",
            11 => "wkt_step_index",
            _ => "unknown",
        }
    }

    pub fn new(header: FitRecordHeader, parsing_state: &FitParsingState) -> Result<FitMessageSet> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSet {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSet",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            duration: FitFieldAdjustedValue::new_single("s".to_string(), 1000.0, 0.0),
            repetitions: FitFieldBasicValue::new_single("".to_string()),
            weight: FitFieldAdjustedValue::new_single("kg".to_string(), 16.0, 0.0),
            set_type: FitFieldBasicValue::new_single("".to_string()),
            start_time: FitFieldBasicValue::new_single("".to_string()),
            category: FitFieldBasicValue::new_vec("".to_string()),
            category_subtype: FitFieldBasicValue::new_vec("".to_string()),
            weight_display_unit: FitFieldBasicValue::new_single("".to_string()),
            message_index: FitFieldBasicValue::new_single("".to_string()),
            wkt_step_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageSet), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // duration
                self.duration.parse(parse_input, parse_config)?
            }
            3 => {
                // repetitions
                self.repetitions.parse(parse_input, parse_config)?
            }
            4 => {
                // weight
                self.weight.parse(parse_input, parse_config)?
            }
            5 => {
                // set_type
                self.set_type.parse(parse_input, parse_config)?
            }
            6 => {
                // start_time
                self.start_time.parse(parse_input, parse_config)?
            }
            7 => {
                // category
                self.category.parse(parse_input, parse_config)?
            }
            8 => {
                // category_subtype
                self.category_subtype.parse(parse_input, parse_config)?
            }
            9 => {
                // weight_display_unit
                self.weight_display_unit.parse(parse_input, parse_config)?
            }
            10 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            11 => {
                // wkt_step_index
                self.wkt_step_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSet {
    fn message_name(&self) -> &'static str {
        return "FitMessageSet";
    }
}

#[derive(Debug)]
pub enum FitMessageSlaveDeviceSubfieldProduct {
    NotYetParsed,
    Default(FitUint16),
    GarminProduct(FitFieldGarminProduct),
    FaveroProduct(FitFieldFaveroProduct),
}

impl FitMessageSlaveDeviceSubfieldProduct {
    fn parse<'a>(
        message: &FitMessageSlaveDevice,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageSlaveDeviceSubfieldProduct, Vec<FitParseConfig>)> {
        match message.manufacturer.get_single()? {
            FitFieldManufacturer::FaveroElectronics => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldFaveroProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSlaveDeviceSubfieldProduct::FaveroProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Garmin => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSlaveDeviceSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Dynastream => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSlaveDeviceSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::DynastreamOem => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageSlaveDeviceSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageSlaveDeviceSubfieldProduct::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageSlaveDevice {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub manufacturer: FitFieldBasicValue<FitFieldManufacturer>,
    pub product_subfield_bytes: Vec<u8>,
    pub product: FitMessageSlaveDeviceSubfieldProduct,
}

impl fmt::Display for FitMessageSlaveDevice {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSlaveDevice")?;
        fmt_message_field!(self.manufacturer, "manufacturer", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "product_subfield_bytes", self.product_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "product", self.product)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSlaveDevice {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "manufacturer",
            1 => "product",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSlaveDevice> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSlaveDevice {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![1],
            message_name: "FitMessageSlaveDevice",
            manufacturer: FitFieldBasicValue::new_single("".to_string()),
            product_subfield_bytes: vec![],
            product: FitMessageSlaveDeviceSubfieldProduct::NotYetParsed,
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSlaveDevice),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // manufacturer
                self.manufacturer.parse(parse_input, parse_config)?
            }
            1 => {
                // product
                self.product_subfield_bytes = parse_uint16_as_bytes(parse_input, parse_config)?;
                vec![]
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            1 => {
                let (val, new_actions) = FitMessageSlaveDeviceSubfieldProduct::parse(
                    &self,
                    &self.product_subfield_bytes,
                    &parse_config,
                )?;
                self.product = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSlaveDevice {
    fn message_name(&self) -> &'static str {
        return "FitMessageSlaveDevice";
    }
}

#[derive(Debug)]
pub struct FitMessageSoftware {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub version: FitFieldAdjustedValue<FitUint16>,
    pub part_number: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageSoftware {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSoftware")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.version, "version", true, f)?;
        fmt_message_field!(self.part_number, "part_number", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSoftware {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            3 => "version",
            5 => "part_number",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSoftware> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSoftware {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSoftware",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            version: FitFieldAdjustedValue::new_single("".to_string(), 100.0, 0.0),
            part_number: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSoftware),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            3 => {
                // version
                self.version.parse(parse_input, parse_config)?
            }
            5 => {
                // part_number
                self.part_number.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSoftware {
    fn message_name(&self) -> &'static str {
        return "FitMessageSoftware";
    }
}

#[derive(Debug)]
pub struct FitMessageSpeedZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub high_value: FitFieldAdjustedValue<FitUint16>,
    pub name: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageSpeedZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSpeedZone")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.high_value, "high_value", true, f)?;
        fmt_message_field!(self.name, "name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSpeedZone {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "high_value",
            1 => "name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSpeedZone> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSpeedZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSpeedZone",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            high_value: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageSpeedZone),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // high_value
                self.high_value.parse(parse_input, parse_config)?
            }
            1 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSpeedZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageSpeedZone";
    }
}

#[derive(Debug)]
pub struct FitMessageSport {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub name: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageSport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSport")?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.name, "name", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSport {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "sport",
            1 => "sub_sport",
            3 => "name",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageSport> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageSport {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageSport",
            sport: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            name: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageSport), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            1 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            3 => {
                // name
                self.name.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageSport {
    fn message_name(&self) -> &'static str {
        return "FitMessageSport";
    }
}

#[derive(Debug)]
pub struct FitMessageStressLevel {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub stress_level_value: FitFieldBasicValue<FitSint16>,
    pub stress_level_time: FitFieldBasicValue<FitFieldDateTime>, // Time stress score was calculated
}

impl fmt::Display for FitMessageStressLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageStressLevel")?;
        fmt_message_field!(self.stress_level_value, "stress_level_value", false, f)?;
        fmt_message_field!(self.stress_level_time, "stress_level_time", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageStressLevel {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "stress_level_value",
            1 => "stress_level_time",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageStressLevel> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageStressLevel {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageStressLevel",
            stress_level_value: FitFieldBasicValue::new_single("".to_string()),
            stress_level_time: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageStressLevel),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // stress_level_value
                self.stress_level_value.parse(parse_input, parse_config)?
            }
            1 => {
                // stress_level_time
                self.stress_level_time.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageStressLevel {
    fn message_name(&self) -> &'static str {
        return "FitMessageStressLevel";
    }
}

#[derive(Debug)]
pub enum FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor {
    NotYetParsed,
    Default(FitUint32),
    AccelCalFactor(FitUint32),
    GyroCalFactor(FitUint32),
}

impl FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor {
    fn parse<'a>(
        message: &FitMessageThreeDSensorCalibration,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor,
        Vec<FitParseConfig>,
    )> {
        match message.sensor_type.get_single()? {
            FitFieldSensorType::Accelerometer => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("g".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::AccelCalFactor(val),
                    new_actions,
                ));
            }

            FitFieldSensorType::Gyroscope => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("deg/s".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::GyroCalFactor(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageThreeDSensorCalibration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub sensor_type: FitFieldBasicValue<FitFieldSensorType>, // Indicates which sensor the calibration is for
    pub calibration_factor_subfield_bytes: Vec<u8>,
    pub calibration_factor: FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor, // Calibration factor used to convert from raw ADC value to degrees, g,  etc.
    pub calibration_divisor: FitFieldBasicValue<FitUint32>, // Calibration factor divisor
    pub level_shift: FitFieldBasicValue<FitUint32>, // Level shift value used to shift the ADC value back into range
    pub offset_cal: FitFieldBasicValue<FitSint32>, // Internal calibration factors, one for each: xy, yx, zx
    pub orientation_matrix: FitFieldAdjustedValue<FitSint32>, // 3 x 3 rotation matrix (row major)
}

impl fmt::Display for FitMessageThreeDSensorCalibration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageThreeDSensorCalibration")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.sensor_type, "sensor_type", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "calibration_factor_subfield_bytes", self.calibration_factor_subfield_bytes
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "calibration_factor", self.calibration_factor
        )?;
        fmt_message_field!(self.calibration_divisor, "calibration_divisor", false, f)?;
        fmt_message_field!(self.level_shift, "level_shift", false, f)?;
        fmt_message_field!(self.offset_cal, "offset_cal", false, f)?;
        fmt_message_field!(self.orientation_matrix, "orientation_matrix", true, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageThreeDSensorCalibration {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "sensor_type",
            1 => "calibration_factor",
            2 => "calibration_divisor",
            3 => "level_shift",
            4 => "offset_cal",
            5 => "orientation_matrix",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageThreeDSensorCalibration> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageThreeDSensorCalibration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![1],
            message_name: "FitMessageThreeDSensorCalibration",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            sensor_type: FitFieldBasicValue::new_single("".to_string()),
            calibration_factor_subfield_bytes: vec![],
            calibration_factor:
                FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::NotYetParsed,
            calibration_divisor: FitFieldBasicValue::new_single("counts".to_string()),
            level_shift: FitFieldBasicValue::new_single("".to_string()),
            offset_cal: FitFieldBasicValue::new_vec("".to_string()),
            orientation_matrix: FitFieldAdjustedValue::new_vec("".to_string(), 65535.0, 0.0),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageThreeDSensorCalibration),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // sensor_type
                self.sensor_type.parse(parse_input, parse_config)?
            }
            1 => {
                // calibration_factor
                self.calibration_factor_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            2 => {
                // calibration_divisor
                self.calibration_divisor.parse(parse_input, parse_config)?
            }
            3 => {
                // level_shift
                self.level_shift.parse(parse_input, parse_config)?
            }
            4 => {
                // offset_cal
                self.offset_cal.parse(parse_input, parse_config)?
            }
            5 => {
                // orientation_matrix
                self.orientation_matrix.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            1 => {
                let (val, new_actions) =
                    FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::parse(
                        &self,
                        &self.calibration_factor_subfield_bytes,
                        &parse_config,
                    )?;
                self.calibration_factor = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageThreeDSensorCalibration {
    fn message_name(&self) -> &'static str {
        return "FitMessageThreeDSensorCalibration";
    }
}

#[derive(Debug)]
pub struct FitMessageTimestampCorrelation {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of UTC timestamp at the time the system timestamp was recorded.
    pub fractional_timestamp: FitFieldAdjustedValue<FitUint16>, // Fractional part of the UTC timestamp at the time the system timestamp was recorded.
    pub system_timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the system timestamp
    pub fractional_system_timestamp: FitFieldAdjustedValue<FitUint16>, // Fractional part of the system timestamp
    pub local_timestamp: FitFieldBasicValue<FitFieldLocalDateTime>, // timestamp epoch expressed in local time used to convert timestamps to local time
    pub timestamp_ms: FitFieldBasicValue<FitUint16>, // Millisecond part of the UTC timestamp at the time the system timestamp was recorded.
    pub system_timestamp_ms: FitFieldBasicValue<FitUint16>, // Millisecond part of the system timestamp
}

impl fmt::Display for FitMessageTimestampCorrelation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageTimestampCorrelation")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.fractional_timestamp, "fractional_timestamp", true, f)?;
        fmt_message_field!(self.system_timestamp, "system_timestamp", false, f)?;
        fmt_message_field!(
            self.fractional_system_timestamp,
            "fractional_system_timestamp",
            true,
            f
        )?;
        fmt_message_field!(self.local_timestamp, "local_timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.system_timestamp_ms, "system_timestamp_ms", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageTimestampCorrelation {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "fractional_timestamp",
            1 => "system_timestamp",
            2 => "fractional_system_timestamp",
            3 => "local_timestamp",
            4 => "timestamp_ms",
            5 => "system_timestamp_ms",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageTimestampCorrelation> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageTimestampCorrelation {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageTimestampCorrelation",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            fractional_timestamp: FitFieldAdjustedValue::new_single("s".to_string(), 32768.0, 0.0),
            system_timestamp: FitFieldBasicValue::new_single("".to_string()),
            fractional_system_timestamp: FitFieldAdjustedValue::new_single(
                "s".to_string(),
                32768.0,
                0.0,
            ),
            local_timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            system_timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageTimestampCorrelation),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // fractional_timestamp
                self.fractional_timestamp.parse(parse_input, parse_config)?
            }
            1 => {
                // system_timestamp
                self.system_timestamp.parse(parse_input, parse_config)?
            }
            2 => {
                // fractional_system_timestamp
                self.fractional_system_timestamp
                    .parse(parse_input, parse_config)?
            }
            3 => {
                // local_timestamp
                self.local_timestamp.parse(parse_input, parse_config)?
            }
            4 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            5 => {
                // system_timestamp_ms
                self.system_timestamp_ms.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageTimestampCorrelation {
    fn message_name(&self) -> &'static str {
        return "FitMessageTimestampCorrelation";
    }
}

#[derive(Debug)]
pub struct FitMessageTotals {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub timer_time: FitFieldBasicValue<FitUint32>, // Excludes pauses
    pub distance: FitFieldBasicValue<FitUint32>,
    pub calories: FitFieldBasicValue<FitUint32>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub elapsed_time: FitFieldBasicValue<FitUint32>, // Includes pauses
    pub sessions: FitFieldBasicValue<FitUint16>,
    pub active_time: FitFieldBasicValue<FitUint32>,
    pub sport_index: FitFieldBasicValue<FitUint8>,
}

impl fmt::Display for FitMessageTotals {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageTotals")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timer_time, "timer_time", false, f)?;
        fmt_message_field!(self.distance, "distance", false, f)?;
        fmt_message_field!(self.calories, "calories", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.elapsed_time, "elapsed_time", false, f)?;
        fmt_message_field!(self.sessions, "sessions", false, f)?;
        fmt_message_field!(self.active_time, "active_time", false, f)?;
        fmt_message_field!(self.sport_index, "sport_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageTotals {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            253 => "timestamp",
            0 => "timer_time",
            1 => "distance",
            2 => "calories",
            3 => "sport",
            4 => "elapsed_time",
            5 => "sessions",
            6 => "active_time",
            9 => "sport_index",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageTotals> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageTotals {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageTotals",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timer_time: FitFieldBasicValue::new_single("s".to_string()),
            distance: FitFieldBasicValue::new_single("m".to_string()),
            calories: FitFieldBasicValue::new_single("kcal".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            elapsed_time: FitFieldBasicValue::new_single("s".to_string()),
            sessions: FitFieldBasicValue::new_single("".to_string()),
            active_time: FitFieldBasicValue::new_single("s".to_string()),
            sport_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageTotals), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timer_time
                self.timer_time.parse(parse_input, parse_config)?
            }
            1 => {
                // distance
                self.distance.parse(parse_input, parse_config)?
            }
            2 => {
                // calories
                self.calories.parse(parse_input, parse_config)?
            }
            3 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            4 => {
                // elapsed_time
                self.elapsed_time.parse(parse_input, parse_config)?
            }
            5 => {
                // sessions
                self.sessions.parse(parse_input, parse_config)?
            }
            6 => {
                // active_time
                self.active_time.parse(parse_input, parse_config)?
            }
            9 => {
                // sport_index
                self.sport_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageTotals {
    fn message_name(&self) -> &'static str {
        return "FitMessageTotals";
    }
}

#[derive(Debug)]
pub enum FitMessageTrainingFileSubfieldProduct {
    NotYetParsed,
    Default(FitUint16),
    GarminProduct(FitFieldGarminProduct),
    FaveroProduct(FitFieldFaveroProduct),
}

impl FitMessageTrainingFileSubfieldProduct {
    fn parse<'a>(
        message: &FitMessageTrainingFile,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(FitMessageTrainingFileSubfieldProduct, Vec<FitParseConfig>)> {
        match message.manufacturer.get_single()? {
            FitFieldManufacturer::FaveroElectronics => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldFaveroProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageTrainingFileSubfieldProduct::FaveroProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Garmin => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageTrainingFileSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::Dynastream => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageTrainingFileSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            FitFieldManufacturer::DynastreamOem => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldGarminProduct>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageTrainingFileSubfieldProduct::GarminProduct(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint16>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((FitMessageTrainingFileSubfieldProduct::Default(val), vec![]))
    }
}
#[derive(Debug)]
pub struct FitMessageTrainingFile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub ftype: FitFieldBasicValue<FitFieldFile>,
    pub manufacturer: FitFieldBasicValue<FitFieldManufacturer>,
    pub product_subfield_bytes: Vec<u8>,
    pub product: FitMessageTrainingFileSubfieldProduct,
    pub serial_number: FitFieldBasicValue<FitUint32z>,
    pub time_created: FitFieldBasicValue<FitFieldDateTime>,
}

impl fmt::Display for FitMessageTrainingFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageTrainingFile")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;
        fmt_message_field!(self.manufacturer, "manufacturer", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "product_subfield_bytes", self.product_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "product", self.product)?;
        fmt_message_field!(self.serial_number, "serial_number", false, f)?;
        fmt_message_field!(self.time_created, "time_created", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageTrainingFile {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "ftype",
            1 => "manufacturer",
            2 => "product",
            3 => "serial_number",
            4 => "time_created",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageTrainingFile> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageTrainingFile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![2],
            message_name: "FitMessageTrainingFile",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
            manufacturer: FitFieldBasicValue::new_single("".to_string()),
            product_subfield_bytes: vec![],
            product: FitMessageTrainingFileSubfieldProduct::NotYetParsed,
            serial_number: FitFieldBasicValue::new_single("".to_string()),
            time_created: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageTrainingFile),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }
            1 => {
                // manufacturer
                self.manufacturer.parse(parse_input, parse_config)?
            }
            2 => {
                // product
                self.product_subfield_bytes = parse_uint16_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            3 => {
                // serial_number
                self.serial_number.parse(parse_input, parse_config)?
            }
            4 => {
                // time_created
                self.time_created.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            2 => {
                let (val, new_actions) = FitMessageTrainingFileSubfieldProduct::parse(
                    &self,
                    &self.product_subfield_bytes,
                    &parse_config,
                )?;
                self.product = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageTrainingFile {
    fn message_name(&self) -> &'static str {
        return "FitMessageTrainingFile";
    }
}

#[derive(Debug)]
pub struct FitMessageUserProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub friendly_name: FitFieldBasicValue<FitString>,
    pub gender: FitFieldBasicValue<FitFieldGender>,
    pub age: FitFieldBasicValue<FitUint8>,
    pub height: FitFieldAdjustedValue<FitUint8>,
    pub weight: FitFieldAdjustedValue<FitUint16>,
    pub language: FitFieldBasicValue<FitFieldLanguage>,
    pub elev_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub weight_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub resting_heart_rate: FitFieldBasicValue<FitUint8>,
    pub default_max_running_heart_rate: FitFieldBasicValue<FitUint8>,
    pub default_max_biking_heart_rate: FitFieldBasicValue<FitUint8>,
    pub default_max_heart_rate: FitFieldBasicValue<FitUint8>,
    pub hr_setting: FitFieldBasicValue<FitFieldDisplayHeart>,
    pub speed_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub dist_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub power_setting: FitFieldBasicValue<FitFieldDisplayPower>,
    pub activity_class: FitFieldBasicValue<FitFieldActivityClass>,
    pub position_setting: FitFieldBasicValue<FitFieldDisplayPosition>,
    pub temperature_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub local_id: FitFieldBasicValue<FitFieldUserLocalId>,
    pub global_id: FitFieldBasicValue<FitByte>,
    pub wake_time: FitFieldBasicValue<FitFieldLocaltimeIntoDay>, // Typical wake time
    pub sleep_time: FitFieldBasicValue<FitFieldLocaltimeIntoDay>, // Typical bed time
    pub height_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub user_running_step_length: FitFieldAdjustedValue<FitUint16>, // User defined running step length set to 0 for auto length
    pub user_walking_step_length: FitFieldAdjustedValue<FitUint16>, // User defined walking step length set to 0 for auto length
    pub depth_setting: FitFieldBasicValue<FitFieldDisplayMeasure>,
    pub dive_count: FitFieldBasicValue<FitUint32>,
}

impl fmt::Display for FitMessageUserProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageUserProfile")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.friendly_name, "friendly_name", false, f)?;
        fmt_message_field!(self.gender, "gender", false, f)?;
        fmt_message_field!(self.age, "age", false, f)?;
        fmt_message_field!(self.height, "height", true, f)?;
        fmt_message_field!(self.weight, "weight", true, f)?;
        fmt_message_field!(self.language, "language", false, f)?;
        fmt_message_field!(self.elev_setting, "elev_setting", false, f)?;
        fmt_message_field!(self.weight_setting, "weight_setting", false, f)?;
        fmt_message_field!(self.resting_heart_rate, "resting_heart_rate", false, f)?;
        fmt_message_field!(
            self.default_max_running_heart_rate,
            "default_max_running_heart_rate",
            false,
            f
        )?;
        fmt_message_field!(
            self.default_max_biking_heart_rate,
            "default_max_biking_heart_rate",
            false,
            f
        )?;
        fmt_message_field!(
            self.default_max_heart_rate,
            "default_max_heart_rate",
            false,
            f
        )?;
        fmt_message_field!(self.hr_setting, "hr_setting", false, f)?;
        fmt_message_field!(self.speed_setting, "speed_setting", false, f)?;
        fmt_message_field!(self.dist_setting, "dist_setting", false, f)?;
        fmt_message_field!(self.power_setting, "power_setting", false, f)?;
        fmt_message_field!(self.activity_class, "activity_class", false, f)?;
        fmt_message_field!(self.position_setting, "position_setting", false, f)?;
        fmt_message_field!(self.temperature_setting, "temperature_setting", false, f)?;
        fmt_message_field!(self.local_id, "local_id", false, f)?;
        fmt_message_field!(self.global_id, "global_id", false, f)?;
        fmt_message_field!(self.wake_time, "wake_time", false, f)?;
        fmt_message_field!(self.sleep_time, "sleep_time", false, f)?;
        fmt_message_field!(self.height_setting, "height_setting", false, f)?;
        fmt_message_field!(
            self.user_running_step_length,
            "user_running_step_length",
            true,
            f
        )?;
        fmt_message_field!(
            self.user_walking_step_length,
            "user_walking_step_length",
            true,
            f
        )?;
        fmt_message_field!(self.depth_setting, "depth_setting", false, f)?;
        fmt_message_field!(self.dive_count, "dive_count", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageUserProfile {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "friendly_name",
            1 => "gender",
            2 => "age",
            3 => "height",
            4 => "weight",
            5 => "language",
            6 => "elev_setting",
            7 => "weight_setting",
            8 => "resting_heart_rate",
            9 => "default_max_running_heart_rate",
            10 => "default_max_biking_heart_rate",
            11 => "default_max_heart_rate",
            12 => "hr_setting",
            13 => "speed_setting",
            14 => "dist_setting",
            16 => "power_setting",
            17 => "activity_class",
            18 => "position_setting",
            21 => "temperature_setting",
            22 => "local_id",
            23 => "global_id",
            28 => "wake_time",
            29 => "sleep_time",
            30 => "height_setting",
            31 => "user_running_step_length",
            32 => "user_walking_step_length",
            47 => "depth_setting",
            49 => "dive_count",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageUserProfile> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageUserProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageUserProfile",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            friendly_name: FitFieldBasicValue::new_single("".to_string()),
            gender: FitFieldBasicValue::new_single("".to_string()),
            age: FitFieldBasicValue::new_single("years".to_string()),
            height: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            weight: FitFieldAdjustedValue::new_single("kg".to_string(), 10.0, 0.0),
            language: FitFieldBasicValue::new_single("".to_string()),
            elev_setting: FitFieldBasicValue::new_single("".to_string()),
            weight_setting: FitFieldBasicValue::new_single("".to_string()),
            resting_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            default_max_running_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            default_max_biking_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            default_max_heart_rate: FitFieldBasicValue::new_single("bpm".to_string()),
            hr_setting: FitFieldBasicValue::new_single("".to_string()),
            speed_setting: FitFieldBasicValue::new_single("".to_string()),
            dist_setting: FitFieldBasicValue::new_single("".to_string()),
            power_setting: FitFieldBasicValue::new_single("".to_string()),
            activity_class: FitFieldBasicValue::new_single("".to_string()),
            position_setting: FitFieldBasicValue::new_single("".to_string()),
            temperature_setting: FitFieldBasicValue::new_single("".to_string()),
            local_id: FitFieldBasicValue::new_single("".to_string()),
            global_id: FitFieldBasicValue::new_single("".to_string()),
            wake_time: FitFieldBasicValue::new_single("".to_string()),
            sleep_time: FitFieldBasicValue::new_single("".to_string()),
            height_setting: FitFieldBasicValue::new_single("".to_string()),
            user_running_step_length: FitFieldAdjustedValue::new_single(
                "m".to_string(),
                1000.0,
                0.0,
            ),
            user_walking_step_length: FitFieldAdjustedValue::new_single(
                "m".to_string(),
                1000.0,
                0.0,
            ),
            depth_setting: FitFieldBasicValue::new_single("".to_string()),
            dive_count: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageUserProfile),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // friendly_name
                self.friendly_name.parse(parse_input, parse_config)?
            }
            1 => {
                // gender
                self.gender.parse(parse_input, parse_config)?
            }
            2 => {
                // age
                self.age.parse(parse_input, parse_config)?
            }
            3 => {
                // height
                self.height.parse(parse_input, parse_config)?
            }
            4 => {
                // weight
                self.weight.parse(parse_input, parse_config)?
            }
            5 => {
                // language
                self.language.parse(parse_input, parse_config)?
            }
            6 => {
                // elev_setting
                self.elev_setting.parse(parse_input, parse_config)?
            }
            7 => {
                // weight_setting
                self.weight_setting.parse(parse_input, parse_config)?
            }
            8 => {
                // resting_heart_rate
                self.resting_heart_rate.parse(parse_input, parse_config)?
            }
            9 => {
                // default_max_running_heart_rate
                self.default_max_running_heart_rate
                    .parse(parse_input, parse_config)?
            }
            10 => {
                // default_max_biking_heart_rate
                self.default_max_biking_heart_rate
                    .parse(parse_input, parse_config)?
            }
            11 => {
                // default_max_heart_rate
                self.default_max_heart_rate
                    .parse(parse_input, parse_config)?
            }
            12 => {
                // hr_setting
                self.hr_setting.parse(parse_input, parse_config)?
            }
            13 => {
                // speed_setting
                self.speed_setting.parse(parse_input, parse_config)?
            }
            14 => {
                // dist_setting
                self.dist_setting.parse(parse_input, parse_config)?
            }
            16 => {
                // power_setting
                self.power_setting.parse(parse_input, parse_config)?
            }
            17 => {
                // activity_class
                self.activity_class.parse(parse_input, parse_config)?
            }
            18 => {
                // position_setting
                self.position_setting.parse(parse_input, parse_config)?
            }
            21 => {
                // temperature_setting
                self.temperature_setting.parse(parse_input, parse_config)?
            }
            22 => {
                // local_id
                self.local_id.parse(parse_input, parse_config)?
            }
            23 => {
                // global_id
                self.global_id.parse(parse_input, parse_config)?
            }
            28 => {
                // wake_time
                self.wake_time.parse(parse_input, parse_config)?
            }
            29 => {
                // sleep_time
                self.sleep_time.parse(parse_input, parse_config)?
            }
            30 => {
                // height_setting
                self.height_setting.parse(parse_input, parse_config)?
            }
            31 => {
                // user_running_step_length
                self.user_running_step_length
                    .parse(parse_input, parse_config)?
            }
            32 => {
                // user_walking_step_length
                self.user_walking_step_length
                    .parse(parse_input, parse_config)?
            }
            47 => {
                // depth_setting
                self.depth_setting.parse(parse_input, parse_config)?
            }
            49 => {
                // dive_count
                self.dive_count.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageUserProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageUserProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageVideo {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub url: FitFieldBasicValue<FitString>,
    pub hosting_provider: FitFieldBasicValue<FitString>,
    pub duration: FitFieldBasicValue<FitUint32>, // Playback time of video
}

impl fmt::Display for FitMessageVideo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideo")?;
        fmt_message_field!(self.url, "url", false, f)?;
        fmt_message_field!(self.hosting_provider, "hosting_provider", false, f)?;
        fmt_message_field!(self.duration, "duration", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideo {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "url",
            1 => "hosting_provider",
            2 => "duration",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageVideo> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageVideo {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageVideo",
            url: FitFieldBasicValue::new_single("".to_string()),
            hosting_provider: FitFieldBasicValue::new_single("".to_string()),
            duration: FitFieldBasicValue::new_single("ms".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string =
                    String::from(concat!("Error parsing ", stringify!(FitMessageVideo), ":"));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // url
                self.url.parse(parse_input, parse_config)?
            }
            1 => {
                // hosting_provider
                self.hosting_provider.parse(parse_input, parse_config)?
            }
            2 => {
                // duration
                self.duration.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageVideo {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideo";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoClip {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub clip_number: FitFieldBasicValue<FitUint16>,
    pub start_timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub start_timestamp_ms: FitFieldBasicValue<FitUint16>,
    pub end_timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub end_timestamp_ms: FitFieldBasicValue<FitUint16>,
    pub clip_start: FitFieldBasicValue<FitUint32>, // Start of clip in video time
    pub clip_end: FitFieldBasicValue<FitUint32>,   // End of clip in video time
}

impl fmt::Display for FitMessageVideoClip {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoClip")?;
        fmt_message_field!(self.clip_number, "clip_number", false, f)?;
        fmt_message_field!(self.start_timestamp, "start_timestamp", false, f)?;
        fmt_message_field!(self.start_timestamp_ms, "start_timestamp_ms", false, f)?;
        fmt_message_field!(self.end_timestamp, "end_timestamp", false, f)?;
        fmt_message_field!(self.end_timestamp_ms, "end_timestamp_ms", false, f)?;
        fmt_message_field!(self.clip_start, "clip_start", false, f)?;
        fmt_message_field!(self.clip_end, "clip_end", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoClip {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            0 => "clip_number",
            1 => "start_timestamp",
            2 => "start_timestamp_ms",
            3 => "end_timestamp",
            4 => "end_timestamp_ms",
            6 => "clip_start",
            7 => "clip_end",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageVideoClip> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageVideoClip {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageVideoClip",
            clip_number: FitFieldBasicValue::new_single("".to_string()),
            start_timestamp: FitFieldBasicValue::new_single("".to_string()),
            start_timestamp_ms: FitFieldBasicValue::new_single("".to_string()),
            end_timestamp: FitFieldBasicValue::new_single("".to_string()),
            end_timestamp_ms: FitFieldBasicValue::new_single("".to_string()),
            clip_start: FitFieldBasicValue::new_single("ms".to_string()),
            clip_end: FitFieldBasicValue::new_single("ms".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageVideoClip),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            0 => {
                // clip_number
                self.clip_number.parse(parse_input, parse_config)?
            }
            1 => {
                // start_timestamp
                self.start_timestamp.parse(parse_input, parse_config)?
            }
            2 => {
                // start_timestamp_ms
                self.start_timestamp_ms.parse(parse_input, parse_config)?
            }
            3 => {
                // end_timestamp
                self.end_timestamp.parse(parse_input, parse_config)?
            }
            4 => {
                // end_timestamp_ms
                self.end_timestamp_ms.parse(parse_input, parse_config)?
            }
            6 => {
                // clip_start
                self.clip_start.parse(parse_input, parse_config)?
            }
            7 => {
                // clip_end
                self.clip_end.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoClip {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoClip";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoDescription {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>, // Long descriptions will be split into multiple parts
    pub message_count: FitFieldBasicValue<FitUint16>, // Total number of description parts
    pub text: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageVideoDescription {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoDescription")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.message_count, "message_count", false, f)?;
        fmt_message_field!(self.text, "text", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoDescription {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "message_count",
            1 => "text",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageVideoDescription> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageVideoDescription {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageVideoDescription",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            message_count: FitFieldBasicValue::new_single("".to_string()),
            text: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageVideoDescription),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // message_count
                self.message_count.parse(parse_input, parse_config)?
            }
            1 => {
                // text
                self.text.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoDescription {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoDescription";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoFrame {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // Whole second part of the timestamp
    pub timestamp_ms: FitFieldBasicValue<FitUint16>,     // Millisecond part of the timestamp.
    pub frame_number: FitFieldBasicValue<FitUint32>, // Number of the frame that the timestamp and timestamp_ms correlate to
}

impl fmt::Display for FitMessageVideoFrame {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoFrame")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.timestamp_ms, "timestamp_ms", false, f)?;
        fmt_message_field!(self.frame_number, "frame_number", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoFrame {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "timestamp_ms",
            1 => "frame_number",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageVideoFrame> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageVideoFrame {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageVideoFrame",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            timestamp_ms: FitFieldBasicValue::new_single("ms".to_string()),
            frame_number: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageVideoFrame),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // timestamp_ms
                self.timestamp_ms.parse(parse_input, parse_config)?
            }
            1 => {
                // frame_number
                self.frame_number.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoFrame {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoFrame";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoTitle {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>, // Long titles will be split into multiple parts
    pub message_count: FitFieldBasicValue<FitUint16>,            // Total number of title parts
    pub text: FitFieldBasicValue<FitString>,
}

impl fmt::Display for FitMessageVideoTitle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoTitle")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.message_count, "message_count", false, f)?;
        fmt_message_field!(self.text, "text", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoTitle {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "message_count",
            1 => "text",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageVideoTitle> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageVideoTitle {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageVideoTitle",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            message_count: FitFieldBasicValue::new_single("".to_string()),
            text: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageVideoTitle),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // message_count
                self.message_count.parse(parse_input, parse_config)?
            }
            1 => {
                // text
                self.text.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoTitle {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoTitle";
    }
}

#[derive(Debug)]
pub enum FitMessageWatchfaceSettingsSubfieldLayout {
    NotYetParsed,
    Default(FitByte),
    DigitalLayout(FitFieldDigitalWatchfaceLayout),
    AnalogLayout(FitFieldAnalogWatchfaceLayout),
}

impl FitMessageWatchfaceSettingsSubfieldLayout {
    fn parse<'a>(
        message: &FitMessageWatchfaceSettings,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageWatchfaceSettingsSubfieldLayout,
        Vec<FitParseConfig>,
    )> {
        match message.mode.get_single()? {
            FitFieldWatchfaceMode::Digital => {
                let mut parser = FitFieldBasicValue::<FitFieldDigitalWatchfaceLayout>::new_single(
                    "".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWatchfaceSettingsSubfieldLayout::DigitalLayout(val),
                    new_actions,
                ));
            }

            FitFieldWatchfaceMode::Analog => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldAnalogWatchfaceLayout>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWatchfaceSettingsSubfieldLayout::AnalogLayout(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitByte>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageWatchfaceSettingsSubfieldLayout::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageWatchfaceSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub mode: FitFieldBasicValue<FitFieldWatchfaceMode>,
    pub layout_subfield_bytes: Vec<u8>,
    pub layout: FitMessageWatchfaceSettingsSubfieldLayout,
}

impl fmt::Display for FitMessageWatchfaceSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWatchfaceSettings")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.mode, "mode", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "layout_subfield_bytes", self.layout_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "layout", self.layout)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWatchfaceSettings {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "mode",
            1 => "layout",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWatchfaceSettings> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWatchfaceSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![1],
            message_name: "FitMessageWatchfaceSettings",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            mode: FitFieldBasicValue::new_single("".to_string()),
            layout_subfield_bytes: vec![],
            layout: FitMessageWatchfaceSettingsSubfieldLayout::NotYetParsed,
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWatchfaceSettings),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // mode
                self.mode.parse(parse_input, parse_config)?
            }
            1 => {
                // layout
                self.layout_subfield_bytes = parse_byte_as_bytes(parse_input, parse_config)?;
                vec![]
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            1 => {
                let (val, new_actions) = FitMessageWatchfaceSettingsSubfieldLayout::parse(
                    &self,
                    &self.layout_subfield_bytes,
                    &parse_config,
                )?;
                self.layout = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWatchfaceSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageWatchfaceSettings";
    }
}

#[derive(Debug)]
pub struct FitMessageWeatherAlert {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub report_id: FitFieldBasicValue<FitString>, // Unique identifier from GCS report ID string, length is 12
    pub issue_time: FitFieldBasicValue<FitFieldDateTime>, // Time alert was issued
    pub expire_time: FitFieldBasicValue<FitFieldDateTime>, // Time alert expires
    pub severity: FitFieldBasicValue<FitFieldWeatherSeverity>, // Warning, Watch, Advisory, Statement
    pub ftype: FitFieldBasicValue<FitFieldWeatherSevereType>,  // Tornado, Severe Thunderstorm, etc.
}

impl fmt::Display for FitMessageWeatherAlert {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWeatherAlert")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.report_id, "report_id", false, f)?;
        fmt_message_field!(self.issue_time, "issue_time", false, f)?;
        fmt_message_field!(self.expire_time, "expire_time", false, f)?;
        fmt_message_field!(self.severity, "severity", false, f)?;
        fmt_message_field!(self.ftype, "ftype", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWeatherAlert {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "report_id",
            1 => "issue_time",
            2 => "expire_time",
            3 => "severity",
            4 => "ftype",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWeatherAlert> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWeatherAlert {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageWeatherAlert",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            report_id: FitFieldBasicValue::new_single("".to_string()),
            issue_time: FitFieldBasicValue::new_single("".to_string()),
            expire_time: FitFieldBasicValue::new_single("".to_string()),
            severity: FitFieldBasicValue::new_single("".to_string()),
            ftype: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWeatherAlert),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // report_id
                self.report_id.parse(parse_input, parse_config)?
            }
            1 => {
                // issue_time
                self.issue_time.parse(parse_input, parse_config)?
            }
            2 => {
                // expire_time
                self.expire_time.parse(parse_input, parse_config)?
            }
            3 => {
                // severity
                self.severity.parse(parse_input, parse_config)?
            }
            4 => {
                // ftype
                self.ftype.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWeatherAlert {
    fn message_name(&self) -> &'static str {
        return "FitMessageWeatherAlert";
    }
}

#[derive(Debug)]
pub struct FitMessageWeatherConditions {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>, // time of update for current conditions, else forecast time
    pub weather_report: FitFieldBasicValue<FitFieldWeatherReport>, // Current or forecast
    pub temperature: FitFieldBasicValue<FitSint8>,
    pub condition: FitFieldBasicValue<FitFieldWeatherStatus>, // Corresponds to GSC Response weatherIcon field
    pub wind_direction: FitFieldBasicValue<FitUint16>,
    pub wind_speed: FitFieldAdjustedValue<FitUint16>,
    pub precipitation_probability: FitFieldBasicValue<FitUint8>, // range 0-100
    pub temperature_feels_like: FitFieldBasicValue<FitSint8>, // Heat Index if  GCS heatIdx above or equal to 90F or wind chill if GCS windChill below or equal to 32F
    pub relative_humidity: FitFieldBasicValue<FitUint8>,
    pub location: FitFieldBasicValue<FitString>, // string corresponding to GCS response location string
    pub observed_at_time: FitFieldBasicValue<FitFieldDateTime>,
    pub observed_location_lat: FitFieldAdjustedValue<FitSint32>,
    pub observed_location_long: FitFieldAdjustedValue<FitSint32>,
    pub day_of_week: FitFieldBasicValue<FitFieldDayOfWeek>,
    pub high_temperature: FitFieldBasicValue<FitSint8>,
    pub low_temperature: FitFieldBasicValue<FitSint8>,
}

impl fmt::Display for FitMessageWeatherConditions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWeatherConditions")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.weather_report, "weather_report", false, f)?;
        fmt_message_field!(self.temperature, "temperature", false, f)?;
        fmt_message_field!(self.condition, "condition", false, f)?;
        fmt_message_field!(self.wind_direction, "wind_direction", false, f)?;
        fmt_message_field!(self.wind_speed, "wind_speed", true, f)?;
        fmt_message_field!(
            self.precipitation_probability,
            "precipitation_probability",
            false,
            f
        )?;
        fmt_message_field!(
            self.temperature_feels_like,
            "temperature_feels_like",
            false,
            f
        )?;
        fmt_message_field!(self.relative_humidity, "relative_humidity", false, f)?;
        fmt_message_field!(self.location, "location", false, f)?;
        fmt_message_field!(self.observed_at_time, "observed_at_time", false, f)?;
        fmt_message_field!(self.observed_location_lat, "observed_location_lat", true, f)?;
        fmt_message_field!(
            self.observed_location_long,
            "observed_location_long",
            true,
            f
        )?;
        fmt_message_field!(self.day_of_week, "day_of_week", false, f)?;
        fmt_message_field!(self.high_temperature, "high_temperature", false, f)?;
        fmt_message_field!(self.low_temperature, "low_temperature", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWeatherConditions {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "weather_report",
            1 => "temperature",
            2 => "condition",
            3 => "wind_direction",
            4 => "wind_speed",
            5 => "precipitation_probability",
            6 => "temperature_feels_like",
            7 => "relative_humidity",
            8 => "location",
            9 => "observed_at_time",
            10 => "observed_location_lat",
            11 => "observed_location_long",
            12 => "day_of_week",
            13 => "high_temperature",
            14 => "low_temperature",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWeatherConditions> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWeatherConditions {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageWeatherConditions",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            weather_report: FitFieldBasicValue::new_single("".to_string()),
            temperature: FitFieldBasicValue::new_single("C".to_string()),
            condition: FitFieldBasicValue::new_single("".to_string()),
            wind_direction: FitFieldBasicValue::new_single("degrees".to_string()),
            wind_speed: FitFieldAdjustedValue::new_single("m/s".to_string(), 1000.0, 0.0),
            precipitation_probability: FitFieldBasicValue::new_single("".to_string()),
            temperature_feels_like: FitFieldBasicValue::new_single("C".to_string()),
            relative_humidity: FitFieldBasicValue::new_single("".to_string()),
            location: FitFieldBasicValue::new_single("".to_string()),
            observed_at_time: FitFieldBasicValue::new_single("".to_string()),
            observed_location_lat: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            observed_location_long: FitFieldAdjustedValue::new_single("deg".to_string(), 0.0, 0.0),
            day_of_week: FitFieldBasicValue::new_single("".to_string()),
            high_temperature: FitFieldBasicValue::new_single("C".to_string()),
            low_temperature: FitFieldBasicValue::new_single("C".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWeatherConditions),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // weather_report
                self.weather_report.parse(parse_input, parse_config)?
            }
            1 => {
                // temperature
                self.temperature.parse(parse_input, parse_config)?
            }
            2 => {
                // condition
                self.condition.parse(parse_input, parse_config)?
            }
            3 => {
                // wind_direction
                self.wind_direction.parse(parse_input, parse_config)?
            }
            4 => {
                // wind_speed
                self.wind_speed.parse(parse_input, parse_config)?
            }
            5 => {
                // precipitation_probability
                self.precipitation_probability
                    .parse(parse_input, parse_config)?
            }
            6 => {
                // temperature_feels_like
                self.temperature_feels_like
                    .parse(parse_input, parse_config)?
            }
            7 => {
                // relative_humidity
                self.relative_humidity.parse(parse_input, parse_config)?
            }
            8 => {
                // location
                self.location.parse(parse_input, parse_config)?
            }
            9 => {
                // observed_at_time
                self.observed_at_time.parse(parse_input, parse_config)?
            }
            10 => {
                // observed_location_lat
                self.observed_location_lat
                    .parse(parse_input, parse_config)?
            }
            11 => {
                // observed_location_long
                self.observed_location_long
                    .parse(parse_input, parse_config)?
            }
            12 => {
                // day_of_week
                self.day_of_week.parse(parse_input, parse_config)?
            }
            13 => {
                // high_temperature
                self.high_temperature.parse(parse_input, parse_config)?
            }
            14 => {
                // low_temperature
                self.low_temperature.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWeatherConditions {
    fn message_name(&self) -> &'static str {
        return "FitMessageWeatherConditions";
    }
}

#[derive(Debug)]
pub struct FitMessageWeightScale {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: FitFieldBasicValue<FitFieldDateTime>,
    pub weight: FitFieldBasicValue<FitFieldWeight>,
    pub percent_fat: FitFieldAdjustedValue<FitUint16>,
    pub percent_hydration: FitFieldAdjustedValue<FitUint16>,
    pub visceral_fat_mass: FitFieldAdjustedValue<FitUint16>,
    pub bone_mass: FitFieldAdjustedValue<FitUint16>,
    pub muscle_mass: FitFieldAdjustedValue<FitUint16>,
    pub basal_met: FitFieldAdjustedValue<FitUint16>,
    pub physique_rating: FitFieldBasicValue<FitUint8>,
    pub active_met: FitFieldAdjustedValue<FitUint16>, // ~4kJ per kcal, 0.25 allows max 16384 kcal
    pub metabolic_age: FitFieldBasicValue<FitUint8>,
    pub visceral_fat_rating: FitFieldBasicValue<FitUint8>,
    pub user_profile_index: FitFieldBasicValue<FitFieldMessageIndex>, // Associates this weight scale message to a user.  This corresponds to the index of the user profile message in the weight scale file.
}

impl fmt::Display for FitMessageWeightScale {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWeightScale")?;
        fmt_message_field!(self.timestamp, "timestamp", false, f)?;
        fmt_message_field!(self.weight, "weight", false, f)?;
        fmt_message_field!(self.percent_fat, "percent_fat", true, f)?;
        fmt_message_field!(self.percent_hydration, "percent_hydration", true, f)?;
        fmt_message_field!(self.visceral_fat_mass, "visceral_fat_mass", true, f)?;
        fmt_message_field!(self.bone_mass, "bone_mass", true, f)?;
        fmt_message_field!(self.muscle_mass, "muscle_mass", true, f)?;
        fmt_message_field!(self.basal_met, "basal_met", true, f)?;
        fmt_message_field!(self.physique_rating, "physique_rating", false, f)?;
        fmt_message_field!(self.active_met, "active_met", true, f)?;
        fmt_message_field!(self.metabolic_age, "metabolic_age", false, f)?;
        fmt_message_field!(self.visceral_fat_rating, "visceral_fat_rating", false, f)?;
        fmt_message_field!(self.user_profile_index, "user_profile_index", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWeightScale {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            253 => "timestamp",
            0 => "weight",
            1 => "percent_fat",
            2 => "percent_hydration",
            3 => "visceral_fat_mass",
            4 => "bone_mass",
            5 => "muscle_mass",
            7 => "basal_met",
            8 => "physique_rating",
            9 => "active_met",
            10 => "metabolic_age",
            11 => "visceral_fat_rating",
            12 => "user_profile_index",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWeightScale> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWeightScale {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageWeightScale",
            timestamp: FitFieldBasicValue::new_single("".to_string()),
            weight: FitFieldBasicValue::new_single("".to_string()),
            percent_fat: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            percent_hydration: FitFieldAdjustedValue::new_single("%".to_string(), 100.0, 0.0),
            visceral_fat_mass: FitFieldAdjustedValue::new_single("kg".to_string(), 100.0, 0.0),
            bone_mass: FitFieldAdjustedValue::new_single("kg".to_string(), 100.0, 0.0),
            muscle_mass: FitFieldAdjustedValue::new_single("kg".to_string(), 100.0, 0.0),
            basal_met: FitFieldAdjustedValue::new_single("kcal/day".to_string(), 4.0, 0.0),
            physique_rating: FitFieldBasicValue::new_single("".to_string()),
            active_met: FitFieldAdjustedValue::new_single("kcal/day".to_string(), 4.0, 0.0),
            metabolic_age: FitFieldBasicValue::new_single("years".to_string()),
            visceral_fat_rating: FitFieldBasicValue::new_single("".to_string()),
            user_profile_index: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWeightScale),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        match _timestamp {
            Some(ts) => {
                self.timestamp.value = BasicValue::Single(ts);
            }
            None => {
                if self.timestamp.is_parsed() {
                    let ts = self.timestamp.get_single()?;
                    parsing_state.set_last_timestamp(ts);
                }
            }
        }

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            253 => {
                // timestamp
                self.timestamp.parse(parse_input, parse_config)?
            }
            0 => {
                // weight
                self.weight.parse(parse_input, parse_config)?
            }
            1 => {
                // percent_fat
                self.percent_fat.parse(parse_input, parse_config)?
            }
            2 => {
                // percent_hydration
                self.percent_hydration.parse(parse_input, parse_config)?
            }
            3 => {
                // visceral_fat_mass
                self.visceral_fat_mass.parse(parse_input, parse_config)?
            }
            4 => {
                // bone_mass
                self.bone_mass.parse(parse_input, parse_config)?
            }
            5 => {
                // muscle_mass
                self.muscle_mass.parse(parse_input, parse_config)?
            }
            7 => {
                // basal_met
                self.basal_met.parse(parse_input, parse_config)?
            }
            8 => {
                // physique_rating
                self.physique_rating.parse(parse_input, parse_config)?
            }
            9 => {
                // active_met
                self.active_met.parse(parse_input, parse_config)?
            }
            10 => {
                // metabolic_age
                self.metabolic_age.parse(parse_input, parse_config)?
            }
            11 => {
                // visceral_fat_rating
                self.visceral_fat_rating.parse(parse_input, parse_config)?
            }
            12 => {
                // user_profile_index
                self.user_profile_index.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWeightScale {
    fn message_name(&self) -> &'static str {
        return "FitMessageWeightScale";
    }
}

#[derive(Debug)]
pub struct FitMessageWorkout {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub capabilities: FitFieldBasicValue<FitFieldWorkoutCapabilities>,
    pub num_valid_steps: FitFieldBasicValue<FitUint16>, // number of valid steps
    pub wkt_name: FitFieldBasicValue<FitString>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub pool_length: FitFieldAdjustedValue<FitUint16>,
    pub pool_length_unit: FitFieldBasicValue<FitFieldDisplayMeasure>,
}

impl fmt::Display for FitMessageWorkout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWorkout")?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.capabilities, "capabilities", false, f)?;
        fmt_message_field!(self.num_valid_steps, "num_valid_steps", false, f)?;
        fmt_message_field!(self.wkt_name, "wkt_name", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.pool_length, "pool_length", true, f)?;
        fmt_message_field!(self.pool_length_unit, "pool_length_unit", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWorkout {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            4 => "sport",
            5 => "capabilities",
            6 => "num_valid_steps",
            8 => "wkt_name",
            11 => "sub_sport",
            14 => "pool_length",
            15 => "pool_length_unit",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWorkout> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWorkout {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageWorkout",
            sport: FitFieldBasicValue::new_single("".to_string()),
            capabilities: FitFieldBasicValue::new_single("".to_string()),
            num_valid_steps: FitFieldBasicValue::new_single("".to_string()),
            wkt_name: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            pool_length: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            pool_length_unit: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWorkout),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            4 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            5 => {
                // capabilities
                self.capabilities.parse(parse_input, parse_config)?
            }
            6 => {
                // num_valid_steps
                self.num_valid_steps.parse(parse_input, parse_config)?
            }
            8 => {
                // wkt_name
                self.wkt_name.parse(parse_input, parse_config)?
            }
            11 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            14 => {
                // pool_length
                self.pool_length.parse(parse_input, parse_config)?
            }
            15 => {
                // pool_length_unit
                self.pool_length_unit.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWorkout {
    fn message_name(&self) -> &'static str {
        return "FitMessageWorkout";
    }
}

#[derive(Debug)]
pub struct FitMessageWorkoutSession {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub sport: FitFieldBasicValue<FitFieldSport>,
    pub sub_sport: FitFieldBasicValue<FitFieldSubSport>,
    pub num_valid_steps: FitFieldBasicValue<FitUint16>,
    pub first_step_index: FitFieldBasicValue<FitUint16>,
    pub pool_length: FitFieldAdjustedValue<FitUint16>,
    pub pool_length_unit: FitFieldBasicValue<FitFieldDisplayMeasure>,
}

impl fmt::Display for FitMessageWorkoutSession {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWorkoutSession")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.sport, "sport", false, f)?;
        fmt_message_field!(self.sub_sport, "sub_sport", false, f)?;
        fmt_message_field!(self.num_valid_steps, "num_valid_steps", false, f)?;
        fmt_message_field!(self.first_step_index, "first_step_index", false, f)?;
        fmt_message_field!(self.pool_length, "pool_length", true, f)?;
        fmt_message_field!(self.pool_length_unit, "pool_length_unit", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWorkoutSession {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "sport",
            1 => "sub_sport",
            2 => "num_valid_steps",
            3 => "first_step_index",
            4 => "pool_length",
            5 => "pool_length_unit",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWorkoutSession> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWorkoutSession {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageWorkoutSession",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            sport: FitFieldBasicValue::new_single("".to_string()),
            sub_sport: FitFieldBasicValue::new_single("".to_string()),
            num_valid_steps: FitFieldBasicValue::new_single("".to_string()),
            first_step_index: FitFieldBasicValue::new_single("".to_string()),
            pool_length: FitFieldAdjustedValue::new_single("m".to_string(), 100.0, 0.0),
            pool_length_unit: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWorkoutSession),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // sport
                self.sport.parse(parse_input, parse_config)?
            }
            1 => {
                // sub_sport
                self.sub_sport.parse(parse_input, parse_config)?
            }
            2 => {
                // num_valid_steps
                self.num_valid_steps.parse(parse_input, parse_config)?
            }
            3 => {
                // first_step_index
                self.first_step_index.parse(parse_input, parse_config)?
            }
            4 => {
                // pool_length
                self.pool_length.parse(parse_input, parse_config)?
            }
            5 => {
                // pool_length_unit
                self.pool_length_unit.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWorkoutSession {
    fn message_name(&self) -> &'static str {
        return "FitMessageWorkoutSession";
    }
}

#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldDurationValue {
    NotYetParsed,
    Default(FitUint32),
    DurationPower(FitFieldWorkoutPower),
    DurationHr(FitFieldWorkoutHr),
    DurationDistance(FitFloat64),
    DurationReps(FitUint32),
    DurationCalories(FitUint32),
    DurationStep(FitUint32),
    DurationTime(FitFloat64),
}

impl FitMessageWorkoutStepSubfieldDurationValue {
    fn parse<'a>(
        message: &FitMessageWorkoutStep,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageWorkoutStepSubfieldDurationValue,
        Vec<FitParseConfig>,
    )> {
        match message.duration_type.get_single()? {
            FitFieldWktStepDuration::Time => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationTime(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepetitionTime => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationTime(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::Distance => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m".to_string(), 100.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationDistance(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::HrLessThan => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldWorkoutHr>::new_single("% or bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationHr(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::HrGreaterThan => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldWorkoutHr>::new_single("% or bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationHr(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::Calories => {
                let mut parser =
                    FitFieldBasicValue::<FitUint32>::new_single("calories".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationCalories(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilStepsCmplt => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilTime => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilDistance => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilCalories => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilHrLessThan => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilHrGreaterThan => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilPowerLessThan => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilPowerGreaterThan => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::PowerLessThan => {
                let mut parser = FitFieldBasicValue::<FitFieldWorkoutPower>::new_single(
                    "% or watts".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationPower(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::PowerGreaterThan => {
                let mut parser = FitFieldBasicValue::<FitFieldWorkoutPower>::new_single(
                    "% or watts".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationPower(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::Reps => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldDurationValue::DurationReps(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageWorkoutStepSubfieldDurationValue::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldTargetValue {
    NotYetParsed,
    Default(FitUint32),
    RepeatCalories(FitUint32),
    RepeatTime(FitFloat64),
    TargetPowerZone(FitUint32),
    TargetCadenceZone(FitUint32),
    RepeatPower(FitFieldWorkoutPower),
    TargetHrZone(FitUint32),
    TargetSpeedZone(FitUint32),
    RepeatHr(FitFieldWorkoutHr),
    RepeatDistance(FitFloat64),
    RepeatSteps(FitUint32),
    TargetStrokeType(FitFieldSwimStroke),
}

impl FitMessageWorkoutStepSubfieldTargetValue {
    fn parse<'a>(
        message: &FitMessageWorkoutStep,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageWorkoutStepSubfieldTargetValue,
        Vec<FitParseConfig>,
    )> {
        match message.target_type.get_single()? {
            FitFieldWktStepTarget::Speed => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::TargetSpeedZone(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::HeartRate => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::TargetHrZone(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::Cadence => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::TargetCadenceZone(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::Power => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::TargetPowerZone(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::SwimStroke => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldSwimStroke>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::TargetStrokeType(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        match message.duration_type.get_single()? {
            FitFieldWktStepDuration::RepeatUntilStepsCmplt => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatSteps(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilTime => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatTime(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilDistance => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m".to_string(), 100.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatDistance(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilCalories => {
                let mut parser =
                    FitFieldBasicValue::<FitUint32>::new_single("calories".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatCalories(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilHrLessThan => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldWorkoutHr>::new_single("% or bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatHr(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilHrGreaterThan => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldWorkoutHr>::new_single("% or bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatHr(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilPowerLessThan => {
                let mut parser = FitFieldBasicValue::<FitFieldWorkoutPower>::new_single(
                    "% or watts".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatPower(val),
                    new_actions,
                ));
            }

            FitFieldWktStepDuration::RepeatUntilPowerGreaterThan => {
                let mut parser = FitFieldBasicValue::<FitFieldWorkoutPower>::new_single(
                    "% or watts".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldTargetValue::RepeatPower(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageWorkoutStepSubfieldTargetValue::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldCustomTargetValueLow {
    NotYetParsed,
    Default(FitUint32),
    CustomTargetSpeedLow(FitFloat64),
    CustomTargetCadenceLow(FitUint32),
    CustomTargetHeartRateLow(FitFieldWorkoutHr),
    CustomTargetPowerLow(FitFieldWorkoutPower),
}

impl FitMessageWorkoutStepSubfieldCustomTargetValueLow {
    fn parse<'a>(
        message: &FitMessageWorkoutStep,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageWorkoutStepSubfieldCustomTargetValueLow,
        Vec<FitParseConfig>,
    )> {
        match message.target_type.get_single()? {
            FitFieldWktStepTarget::Speed => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m/s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetSpeedLow(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::HeartRate => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldWorkoutHr>::new_single("% or bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetHeartRateLow(
                        val,
                    ),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::Cadence => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("rpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetCadenceLow(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::Power => {
                let mut parser = FitFieldBasicValue::<FitFieldWorkoutPower>::new_single(
                    "% or watts".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetPowerLow(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageWorkoutStepSubfieldCustomTargetValueLow::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldCustomTargetValueHigh {
    NotYetParsed,
    Default(FitUint32),
    CustomTargetPowerHigh(FitFieldWorkoutPower),
    CustomTargetHeartRateHigh(FitFieldWorkoutHr),
    CustomTargetSpeedHigh(FitFloat64),
    CustomTargetCadenceHigh(FitUint32),
}

impl FitMessageWorkoutStepSubfieldCustomTargetValueHigh {
    fn parse<'a>(
        message: &FitMessageWorkoutStep,
        inp: &'a [u8],
        parse_config: &FitParseConfig,
    ) -> Result<(
        FitMessageWorkoutStepSubfieldCustomTargetValueHigh,
        Vec<FitParseConfig>,
    )> {
        match message.target_type.get_single()? {
            FitFieldWktStepTarget::Speed => {
                let mut parser =
                    FitFieldAdjustedValue::<FitUint32>::new_single("m/s".to_string(), 1000.0, 0.0);
                parser.parse(inp, parse_config)?;

                let val = <FitFloat64>::from(parser.get_single()?);

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetSpeedHigh(val),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::HeartRate => {
                let mut parser =
                    FitFieldBasicValue::<FitFieldWorkoutHr>::new_single("% or bpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetHeartRateHigh(
                        val,
                    ),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::Cadence => {
                let mut parser = FitFieldBasicValue::<FitUint32>::new_single("rpm".to_string());
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetCadenceHigh(
                        val,
                    ),
                    new_actions,
                ));
            }

            FitFieldWktStepTarget::Power => {
                let mut parser = FitFieldBasicValue::<FitFieldWorkoutPower>::new_single(
                    "% or watts".to_string(),
                );
                parser.parse(inp, parse_config)?;

                let val = parser.get_single()?;

                let new_actions: Vec<FitParseConfig> = vec![]
                    .iter()
                    .map(|action: &FitParseConfig| action.add_bytes_to_parse(&inp))
                    .collect();

                return Ok((
                    FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetPowerHigh(val),
                    new_actions,
                ));
            }

            _ => (),
        }

        let mut parser = FitFieldBasicValue::<FitUint32>::new_single("".to_string());
        parser.parse(inp, parse_config)?;

        let val = parser.get_single()?;

        // AFAICT, the top-level subfield can never have components
        Ok((
            FitMessageWorkoutStepSubfieldCustomTargetValueHigh::Default(val),
            vec![],
        ))
    }
}
#[derive(Debug)]
pub struct FitMessageWorkoutStep {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: FitFieldBasicValue<FitFieldMessageIndex>,
    pub wkt_step_name: FitFieldBasicValue<FitString>,
    pub duration_type: FitFieldBasicValue<FitFieldWktStepDuration>,
    pub duration_value_subfield_bytes: Vec<u8>,
    pub duration_value: FitMessageWorkoutStepSubfieldDurationValue,
    pub target_type: FitFieldBasicValue<FitFieldWktStepTarget>,
    pub target_value_subfield_bytes: Vec<u8>,
    pub target_value: FitMessageWorkoutStepSubfieldTargetValue,
    pub custom_target_value_low_subfield_bytes: Vec<u8>,
    pub custom_target_value_low: FitMessageWorkoutStepSubfieldCustomTargetValueLow,
    pub custom_target_value_high_subfield_bytes: Vec<u8>,
    pub custom_target_value_high: FitMessageWorkoutStepSubfieldCustomTargetValueHigh,
    pub intensity: FitFieldBasicValue<FitFieldIntensity>,
    pub notes: FitFieldBasicValue<FitString>,
    pub equipment: FitFieldBasicValue<FitFieldWorkoutEquipment>,
    pub exercise_category: FitFieldBasicValue<FitFieldExerciseCategory>,
    pub exercise_name: FitFieldBasicValue<FitUint16>,
    pub exercise_weight: FitFieldAdjustedValue<FitUint16>,
    pub weight_display_unit: FitFieldBasicValue<FitFieldFitBaseUnit>,
}

impl fmt::Display for FitMessageWorkoutStep {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWorkoutStep")?;
        fmt_message_field!(self.message_index, "message_index", false, f)?;
        fmt_message_field!(self.wkt_step_name, "wkt_step_name", false, f)?;
        fmt_message_field!(self.duration_type, "duration_type", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "duration_value_subfield_bytes", self.duration_value_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "duration_value", self.duration_value)?;
        fmt_message_field!(self.target_type, "target_type", false, f)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "target_value_subfield_bytes", self.target_value_subfield_bytes
        )?;
        writeln!(f, "  {: >28}: {:?}", "target_value", self.target_value)?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "custom_target_value_low_subfield_bytes", self.custom_target_value_low_subfield_bytes
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "custom_target_value_low", self.custom_target_value_low
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "custom_target_value_high_subfield_bytes", self.custom_target_value_high_subfield_bytes
        )?;
        writeln!(
            f,
            "  {: >28}: {:?}",
            "custom_target_value_high", self.custom_target_value_high
        )?;
        fmt_message_field!(self.intensity, "intensity", false, f)?;
        fmt_message_field!(self.notes, "notes", false, f)?;
        fmt_message_field!(self.equipment, "equipment", false, f)?;
        fmt_message_field!(self.exercise_category, "exercise_category", false, f)?;
        fmt_message_field!(self.exercise_name, "exercise_name", false, f)?;
        fmt_message_field!(self.exercise_weight, "exercise_weight", true, f)?;
        fmt_message_field!(self.weight_display_unit, "weight_display_unit", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWorkoutStep {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            254 => "message_index",
            0 => "wkt_step_name",
            1 => "duration_type",
            2 => "duration_value",
            3 => "target_type",
            4 => "target_value",
            5 => "custom_target_value_low",
            6 => "custom_target_value_high",
            7 => "intensity",
            8 => "notes",
            9 => "equipment",
            10 => "exercise_category",
            11 => "exercise_name",
            12 => "exercise_weight",
            13 => "weight_display_unit",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageWorkoutStep> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageWorkoutStep {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![2, 4, 5, 6],
            message_name: "FitMessageWorkoutStep",
            message_index: FitFieldBasicValue::new_single("".to_string()),
            wkt_step_name: FitFieldBasicValue::new_single("".to_string()),
            duration_type: FitFieldBasicValue::new_single("".to_string()),
            duration_value_subfield_bytes: vec![],
            duration_value: FitMessageWorkoutStepSubfieldDurationValue::NotYetParsed,
            target_type: FitFieldBasicValue::new_single("".to_string()),
            target_value_subfield_bytes: vec![],
            target_value: FitMessageWorkoutStepSubfieldTargetValue::NotYetParsed,
            custom_target_value_low_subfield_bytes: vec![],
            custom_target_value_low:
                FitMessageWorkoutStepSubfieldCustomTargetValueLow::NotYetParsed,
            custom_target_value_high_subfield_bytes: vec![],
            custom_target_value_high:
                FitMessageWorkoutStepSubfieldCustomTargetValueHigh::NotYetParsed,
            intensity: FitFieldBasicValue::new_single("".to_string()),
            notes: FitFieldBasicValue::new_single("".to_string()),
            equipment: FitFieldBasicValue::new_single("".to_string()),
            exercise_category: FitFieldBasicValue::new_single("".to_string()),
            exercise_name: FitFieldBasicValue::new_single("".to_string()),
            exercise_weight: FitFieldAdjustedValue::new_single("kg".to_string(), 100.0, 0.0),
            weight_display_unit: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageWorkoutStep),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            254 => {
                // message_index
                self.message_index.parse(parse_input, parse_config)?
            }
            0 => {
                // wkt_step_name
                self.wkt_step_name.parse(parse_input, parse_config)?
            }
            1 => {
                // duration_type
                self.duration_type.parse(parse_input, parse_config)?
            }
            2 => {
                // duration_value
                self.duration_value_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            3 => {
                // target_type
                self.target_type.parse(parse_input, parse_config)?
            }
            4 => {
                // target_value
                self.target_value_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            5 => {
                // custom_target_value_low
                self.custom_target_value_low_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            6 => {
                // custom_target_value_high
                self.custom_target_value_high_subfield_bytes =
                    parse_uint32_as_bytes(parse_input, parse_config)?;
                vec![]
            }
            7 => {
                // intensity
                self.intensity.parse(parse_input, parse_config)?
            }
            8 => {
                // notes
                self.notes.parse(parse_input, parse_config)?
            }
            9 => {
                // equipment
                self.equipment.parse(parse_input, parse_config)?
            }
            10 => {
                // exercise_category
                self.exercise_category.parse(parse_input, parse_config)?
            }
            11 => {
                // exercise_name
                self.exercise_name.parse(parse_input, parse_config)?
            }
            12 => {
                // exercise_weight
                self.exercise_weight.parse(parse_input, parse_config)?
            }
            13 => {
                // weight_display_unit
                self.weight_display_unit.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_one_subfield<'a>(
        &'a mut self,
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let new_actions = match parse_config.field_definition_number() {
            2 => {
                let (val, new_actions) = FitMessageWorkoutStepSubfieldDurationValue::parse(
                    &self,
                    &self.duration_value_subfield_bytes,
                    &parse_config,
                )?;
                self.duration_value = val;
                new_actions
            }

            4 => {
                let (val, new_actions) = FitMessageWorkoutStepSubfieldTargetValue::parse(
                    &self,
                    &self.target_value_subfield_bytes,
                    &parse_config,
                )?;
                self.target_value = val;
                new_actions
            }

            5 => {
                let (val, new_actions) = FitMessageWorkoutStepSubfieldCustomTargetValueLow::parse(
                    &self,
                    &self.custom_target_value_low_subfield_bytes,
                    &parse_config,
                )?;
                self.custom_target_value_low = val;
                new_actions
            }

            6 => {
                let (val, new_actions) = FitMessageWorkoutStepSubfieldCustomTargetValueHigh::parse(
                    &self,
                    &self.custom_target_value_high_subfield_bytes,
                    &parse_config,
                )?;
                self.custom_target_value_high = val;
                new_actions
            }

            bad_number => return Err(Error::bad_subfield_field_number(bad_number)),
        };
        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        let mut subfields: Vec<u8> = actions
            .iter()
            .map(|action| action.field_definition_number())
            .filter(|field_num| self.subfield_field_numbers.contains(field_num))
            .collect();

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                let new_subfields: Vec<u8> = new_actions
                    .iter()
                    .map(|action| action.field_definition_number())
                    .filter(|field_num| self.subfield_field_numbers.contains(field_num))
                    .collect();

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                subfields.extend(new_subfields);

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            while subfields.len() > 0 {
                let this_subfield = subfields.remove(0);
                let fds: Vec<_> = self
                    .definition_message
                    .field_definitions
                    .iter()
                    .filter(|f| f.definition_number == this_subfield)
                    .collect();
                let mut new_actions = vec![];

                // FIXME(should error if this fails)
                if fds.len() == 1 {
                    let parse_config =
                        FitParseConfig::new(*fds[0], self.definition_message.endianness, tz_offset);
                    new_actions.extend(self.parse_one_subfield(&parse_config)?);
                }

                actions.extend(new_actions);
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageWorkoutStep {
    fn message_name(&self) -> &'static str {
        return "FitMessageWorkoutStep";
    }
}

#[derive(Debug)]
pub struct FitMessageZonesTarget {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub subfield_field_numbers: Vec<u8>,
    pub message_name: &'static str,
    pub max_heart_rate: FitFieldBasicValue<FitUint8>,
    pub threshold_heart_rate: FitFieldBasicValue<FitUint8>,
    pub functional_threshold_power: FitFieldBasicValue<FitUint16>,
    pub hr_calc_type: FitFieldBasicValue<FitFieldHrZoneCalc>,
    pub pwr_calc_type: FitFieldBasicValue<FitFieldPwrZoneCalc>,
}

impl fmt::Display for FitMessageZonesTarget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageZonesTarget")?;
        fmt_message_field!(self.max_heart_rate, "max_heart_rate", false, f)?;
        fmt_message_field!(self.threshold_heart_rate, "threshold_heart_rate", false, f)?;
        fmt_message_field!(
            self.functional_threshold_power,
            "functional_threshold_power",
            false,
            f
        )?;
        fmt_message_field!(self.hr_calc_type, "hr_calc_type", false, f)?;
        fmt_message_field!(self.pwr_calc_type, "pwr_calc_type", false, f)?;

        fmt_unknown_fields!(self, f);
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageZonesTarget {
    pub fn field_name(field_number: u8) -> &'static str {
        match field_number {
            1 => "max_heart_rate",
            2 => "threshold_heart_rate",
            3 => "functional_threshold_power",
            5 => "hr_calc_type",
            7 => "pwr_calc_type",
            _ => "unknown",
        }
    }

    pub fn new(
        header: FitRecordHeader,
        parsing_state: &FitParsingState,
    ) -> Result<FitMessageZonesTarget> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;

        let message = FitMessageZonesTarget {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            subfield_field_numbers: vec![],
            message_name: "FitMessageZonesTarget",
            max_heart_rate: FitFieldBasicValue::new_single("".to_string()),
            threshold_heart_rate: FitFieldBasicValue::new_single("".to_string()),
            functional_threshold_power: FitFieldBasicValue::new_single("".to_string()),
            hr_calc_type: FitFieldBasicValue::new_single("".to_string()),
            pwr_calc_type: FitFieldBasicValue::new_single("".to_string()),
        };

        Ok(message)
    }

    fn parse_developer_fields<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &FitParsingState,
    ) -> Result<&'b [u8]> {
        let mut inp = input;

        for dev_field in &self.definition_message.developer_field_definitions {
            let dev_data_definition =
                parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description =
                dev_data_definition.get_field_description(dev_field.definition_number)?;

            let base_type_num: u8 = match field_description.fit_base_type_id.get_single()? {
                FitFieldFitBaseType::Enum => 0,
                FitFieldFitBaseType::Sint8 => 1,
                FitFieldFitBaseType::Uint8 => 2,
                FitFieldFitBaseType::Sint16 => 131,
                FitFieldFitBaseType::Uint16 => 132,
                FitFieldFitBaseType::Sint32 => 133,
                FitFieldFitBaseType::Uint32 => 134,
                FitFieldFitBaseType::String => 7,
                FitFieldFitBaseType::Float32 => 136,
                FitFieldFitBaseType::Float64 => 137,
                FitFieldFitBaseType::Uint8z => 10,
                FitFieldFitBaseType::Uint16z => 139,
                FitFieldFitBaseType::Uint32z => 140,
                FitFieldFitBaseType::Byte => 13,
                FitFieldFitBaseType::Sint64 => 142,
                FitFieldFitBaseType::Uint64 => 143,
                FitFieldFitBaseType::Uint64z => 144,
                _ => return Err(Error::unknown_error()),
            };

            let def_num = <u8>::from(field_description.field_definition_number.get_single()?);

            let parse_config = FitParseConfig::new(
                FitFieldDefinition {
                    definition_number: def_num,
                    field_size: dev_field.field_size,
                    base_type: base_type_num,
                },
                self.definition_message.endianness,
                0.0,
            );

            let dd = FitFieldDeveloperData::parse(inp, field_description.clone(), &parse_config)?;
            self.developer_fields.push(dd);

            // we can run out of input before all fields are consumed. according
            // to the spec, buffering with zero-padded fields is appropriate

            if inp.len() < parse_config.field_size() {
                inp = &inp[inp.len()..];
            } else {
                inp = &inp[parse_config.field_size()..];
            }
        }
        Ok(inp)
    }

    fn parse<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parsing_state: &mut FitParsingState,
        _timestamp: Option<FitFieldDateTime>,
    ) -> Result<&'b [u8]> {
        let to_copy = &input[..self.definition_message.message_size];
        let mut inp = input;

        if parsing_state.retain_bytes == true {
            self.raw_bytes
                .resize(self.definition_message.message_size, 0);
            self.raw_bytes.copy_from_slice(to_copy);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let outp = match self.parse_internal(inp, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from(concat!(
                    "Error parsing ",
                    stringify!(FitMessageZonesTarget),
                    ":"
                ));
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string));
            }
        };
        inp = outp;

        let inp = self.parse_developer_fields(inp, parsing_state)?;
        Ok(inp)
    }

    fn parse_one_field<'a, 'b>(
        &'a mut self,
        input: &'b [u8],
        parse_config: &FitParseConfig,
    ) -> Result<Vec<FitParseConfig>> {
        let alternate_input: Vec<u8>;
        let mut parse_input = input;

        if parse_config.use_stored_input() {
            alternate_input = parse_config.get_stored_input()?;
            parse_input = &alternate_input;
        }

        let new_actions = match parse_config.field_definition_number() {
            1 => {
                // max_heart_rate
                self.max_heart_rate.parse(parse_input, parse_config)?
            }
            2 => {
                // threshold_heart_rate
                self.threshold_heart_rate.parse(parse_input, parse_config)?
            }
            3 => {
                // functional_threshold_power
                self.functional_threshold_power
                    .parse(parse_input, parse_config)?
            }
            5 => {
                // hr_calc_type
                self.hr_calc_type.parse(parse_input, parse_config)?
            }
            7 => {
                // pwr_calc_type
                self.pwr_calc_type.parse(parse_input, parse_config)?
            }

            unknown_field_num => {
                let val = FitBaseValue::parse(parse_input, parse_config)?;
                self.unknown_fields.insert(unknown_field_num, val);
                vec![]
            }
        };

        Ok(new_actions)
    }

    fn parse_internal<'a, 'b>(&'a mut self, input: &'b [u8], tz_offset: f64) -> Result<&'b [u8]> {
        let mut inp = input;

        // first parse things according to the definitions, don't deep-parse the subfields
        let mut actions = vec![];
        for field in &self.definition_message.field_definitions {
            actions.push(FitParseConfig::new(
                *field,
                self.definition_message.endianness,
                tz_offset,
            ));
        }

        loop {
            while actions.len() > 0 {
                let this_action = actions.remove(0);
                let mut new_actions = self.parse_one_field(inp, &this_action)?;

                // new actions here go to the front of the list
                new_actions.reverse();
                while new_actions.len() > 0 {
                    actions.insert(0, new_actions.remove(0))
                }

                if this_action.use_stored_input() == false {
                    inp = &inp[this_action.field_size()..];
                }
            }

            if actions.len() == 0 {
                break;
            }
        }

        Ok(inp)
    }
}

impl FitRecord for FitMessageZonesTarget {
    fn message_name(&self) -> &'static str {
        return "FitMessageZonesTarget";
    }
}

#[derive(Debug)]
pub enum FitDataMessage {
    AccelerometerData(Rc<FitMessageAccelerometerData>),
    Activity(Rc<FitMessageActivity>),
    AntChannelId(Rc<FitMessageAntChannelId>),
    AntRx(Rc<FitMessageAntRx>),
    AntTx(Rc<FitMessageAntTx>),
    AviationAttitude(Rc<FitMessageAviationAttitude>),
    BarometerData(Rc<FitMessageBarometerData>),
    BikeProfile(Rc<FitMessageBikeProfile>),
    BloodPressure(Rc<FitMessageBloodPressure>),
    CadenceZone(Rc<FitMessageCadenceZone>),
    CameraEvent(Rc<FitMessageCameraEvent>),
    Capabilities(Rc<FitMessageCapabilities>),
    Connectivity(Rc<FitMessageConnectivity>),
    Course(Rc<FitMessageCourse>),
    CoursePoint(Rc<FitMessageCoursePoint>),
    DeveloperDataId(Rc<FitMessageDeveloperDataId>),
    DeviceInfo(Rc<FitMessageDeviceInfo>),
    DeviceSettings(Rc<FitMessageDeviceSettings>),
    DiveAlarm(Rc<FitMessageDiveAlarm>),
    DiveGas(Rc<FitMessageDiveGas>),
    DiveSettings(Rc<FitMessageDiveSettings>),
    DiveSummary(Rc<FitMessageDiveSummary>),
    Event(Rc<FitMessageEvent>),
    ExdDataConceptConfiguration(Rc<FitMessageExdDataConceptConfiguration>),
    ExdDataFieldConfiguration(Rc<FitMessageExdDataFieldConfiguration>),
    ExdScreenConfiguration(Rc<FitMessageExdScreenConfiguration>),
    ExerciseTitle(Rc<FitMessageExerciseTitle>),
    FieldCapabilities(Rc<FitMessageFieldCapabilities>),
    FieldDescription(Rc<FitMessageFieldDescription>),
    FileCapabilities(Rc<FitMessageFileCapabilities>),
    FileCreator(Rc<FitMessageFileCreator>),
    FileId(Rc<FitMessageFileId>),
    Goal(Rc<FitMessageGoal>),
    GpsMetadata(Rc<FitMessageGpsMetadata>),
    GyroscopeData(Rc<FitMessageGyroscopeData>),
    Hr(Rc<FitMessageHr>),
    HrZone(Rc<FitMessageHrZone>),
    HrmProfile(Rc<FitMessageHrmProfile>),
    Hrv(Rc<FitMessageHrv>),
    Lap(Rc<FitMessageLap>),
    Length(Rc<FitMessageLength>),
    MagnetometerData(Rc<FitMessageMagnetometerData>),
    MemoGlob(Rc<FitMessageMemoGlob>),
    MesgCapabilities(Rc<FitMessageMesgCapabilities>),
    MetZone(Rc<FitMessageMetZone>),
    Monitoring(Rc<FitMessageMonitoring>),
    MonitoringInfo(Rc<FitMessageMonitoringInfo>),
    NmeaSentence(Rc<FitMessageNmeaSentence>),
    ObdiiData(Rc<FitMessageObdiiData>),
    OhrSettings(Rc<FitMessageOhrSettings>),
    OneDSensorCalibration(Rc<FitMessageOneDSensorCalibration>),
    PowerZone(Rc<FitMessagePowerZone>),
    Record(Rc<FitMessageRecord>),
    Schedule(Rc<FitMessageSchedule>),
    SdmProfile(Rc<FitMessageSdmProfile>),
    SegmentFile(Rc<FitMessageSegmentFile>),
    SegmentId(Rc<FitMessageSegmentId>),
    SegmentLap(Rc<FitMessageSegmentLap>),
    SegmentLeaderboardEntry(Rc<FitMessageSegmentLeaderboardEntry>),
    SegmentPoint(Rc<FitMessageSegmentPoint>),
    Session(Rc<FitMessageSession>),
    Set(Rc<FitMessageSet>),
    SlaveDevice(Rc<FitMessageSlaveDevice>),
    Software(Rc<FitMessageSoftware>),
    SpeedZone(Rc<FitMessageSpeedZone>),
    Sport(Rc<FitMessageSport>),
    StressLevel(Rc<FitMessageStressLevel>),
    ThreeDSensorCalibration(Rc<FitMessageThreeDSensorCalibration>),
    TimestampCorrelation(Rc<FitMessageTimestampCorrelation>),
    Totals(Rc<FitMessageTotals>),
    TrainingFile(Rc<FitMessageTrainingFile>),
    UserProfile(Rc<FitMessageUserProfile>),
    Video(Rc<FitMessageVideo>),
    VideoClip(Rc<FitMessageVideoClip>),
    VideoDescription(Rc<FitMessageVideoDescription>),
    VideoFrame(Rc<FitMessageVideoFrame>),
    VideoTitle(Rc<FitMessageVideoTitle>),
    WatchfaceSettings(Rc<FitMessageWatchfaceSettings>),
    WeatherAlert(Rc<FitMessageWeatherAlert>),
    WeatherConditions(Rc<FitMessageWeatherConditions>),
    WeightScale(Rc<FitMessageWeightScale>),
    Workout(Rc<FitMessageWorkout>),
    WorkoutSession(Rc<FitMessageWorkoutSession>),
    WorkoutStep(Rc<FitMessageWorkoutStep>),
    ZonesTarget(Rc<FitMessageZonesTarget>),
    UnknownToSdk(Rc<FitMessageUnknownToSdk>),
}

impl fmt::Display for FitDataMessage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitDataMessage::AccelerometerData(m) => write!(f, "{}", m),
            FitDataMessage::Activity(m) => write!(f, "{}", m),
            FitDataMessage::AntChannelId(m) => write!(f, "{}", m),
            FitDataMessage::AntRx(m) => write!(f, "{}", m),
            FitDataMessage::AntTx(m) => write!(f, "{}", m),
            FitDataMessage::AviationAttitude(m) => write!(f, "{}", m),
            FitDataMessage::BarometerData(m) => write!(f, "{}", m),
            FitDataMessage::BikeProfile(m) => write!(f, "{}", m),
            FitDataMessage::BloodPressure(m) => write!(f, "{}", m),
            FitDataMessage::CadenceZone(m) => write!(f, "{}", m),
            FitDataMessage::CameraEvent(m) => write!(f, "{}", m),
            FitDataMessage::Capabilities(m) => write!(f, "{}", m),
            FitDataMessage::Connectivity(m) => write!(f, "{}", m),
            FitDataMessage::Course(m) => write!(f, "{}", m),
            FitDataMessage::CoursePoint(m) => write!(f, "{}", m),
            FitDataMessage::DeveloperDataId(m) => write!(f, "{}", m),
            FitDataMessage::DeviceInfo(m) => write!(f, "{}", m),
            FitDataMessage::DeviceSettings(m) => write!(f, "{}", m),
            FitDataMessage::DiveAlarm(m) => write!(f, "{}", m),
            FitDataMessage::DiveGas(m) => write!(f, "{}", m),
            FitDataMessage::DiveSettings(m) => write!(f, "{}", m),
            FitDataMessage::DiveSummary(m) => write!(f, "{}", m),
            FitDataMessage::Event(m) => write!(f, "{}", m),
            FitDataMessage::ExdDataConceptConfiguration(m) => write!(f, "{}", m),
            FitDataMessage::ExdDataFieldConfiguration(m) => write!(f, "{}", m),
            FitDataMessage::ExdScreenConfiguration(m) => write!(f, "{}", m),
            FitDataMessage::ExerciseTitle(m) => write!(f, "{}", m),
            FitDataMessage::FieldCapabilities(m) => write!(f, "{}", m),
            FitDataMessage::FieldDescription(m) => write!(f, "{}", m),
            FitDataMessage::FileCapabilities(m) => write!(f, "{}", m),
            FitDataMessage::FileCreator(m) => write!(f, "{}", m),
            FitDataMessage::FileId(m) => write!(f, "{}", m),
            FitDataMessage::Goal(m) => write!(f, "{}", m),
            FitDataMessage::GpsMetadata(m) => write!(f, "{}", m),
            FitDataMessage::GyroscopeData(m) => write!(f, "{}", m),
            FitDataMessage::Hr(m) => write!(f, "{}", m),
            FitDataMessage::HrZone(m) => write!(f, "{}", m),
            FitDataMessage::HrmProfile(m) => write!(f, "{}", m),
            FitDataMessage::Hrv(m) => write!(f, "{}", m),
            FitDataMessage::Lap(m) => write!(f, "{}", m),
            FitDataMessage::Length(m) => write!(f, "{}", m),
            FitDataMessage::MagnetometerData(m) => write!(f, "{}", m),
            FitDataMessage::MemoGlob(m) => write!(f, "{}", m),
            FitDataMessage::MesgCapabilities(m) => write!(f, "{}", m),
            FitDataMessage::MetZone(m) => write!(f, "{}", m),
            FitDataMessage::Monitoring(m) => write!(f, "{}", m),
            FitDataMessage::MonitoringInfo(m) => write!(f, "{}", m),
            FitDataMessage::NmeaSentence(m) => write!(f, "{}", m),
            FitDataMessage::ObdiiData(m) => write!(f, "{}", m),
            FitDataMessage::OhrSettings(m) => write!(f, "{}", m),
            FitDataMessage::OneDSensorCalibration(m) => write!(f, "{}", m),
            FitDataMessage::PowerZone(m) => write!(f, "{}", m),
            FitDataMessage::Record(m) => write!(f, "{}", m),
            FitDataMessage::Schedule(m) => write!(f, "{}", m),
            FitDataMessage::SdmProfile(m) => write!(f, "{}", m),
            FitDataMessage::SegmentFile(m) => write!(f, "{}", m),
            FitDataMessage::SegmentId(m) => write!(f, "{}", m),
            FitDataMessage::SegmentLap(m) => write!(f, "{}", m),
            FitDataMessage::SegmentLeaderboardEntry(m) => write!(f, "{}", m),
            FitDataMessage::SegmentPoint(m) => write!(f, "{}", m),
            FitDataMessage::Session(m) => write!(f, "{}", m),
            FitDataMessage::Set(m) => write!(f, "{}", m),
            FitDataMessage::SlaveDevice(m) => write!(f, "{}", m),
            FitDataMessage::Software(m) => write!(f, "{}", m),
            FitDataMessage::SpeedZone(m) => write!(f, "{}", m),
            FitDataMessage::Sport(m) => write!(f, "{}", m),
            FitDataMessage::StressLevel(m) => write!(f, "{}", m),
            FitDataMessage::ThreeDSensorCalibration(m) => write!(f, "{}", m),
            FitDataMessage::TimestampCorrelation(m) => write!(f, "{}", m),
            FitDataMessage::Totals(m) => write!(f, "{}", m),
            FitDataMessage::TrainingFile(m) => write!(f, "{}", m),
            FitDataMessage::UserProfile(m) => write!(f, "{}", m),
            FitDataMessage::Video(m) => write!(f, "{}", m),
            FitDataMessage::VideoClip(m) => write!(f, "{}", m),
            FitDataMessage::VideoDescription(m) => write!(f, "{}", m),
            FitDataMessage::VideoFrame(m) => write!(f, "{}", m),
            FitDataMessage::VideoTitle(m) => write!(f, "{}", m),
            FitDataMessage::WatchfaceSettings(m) => write!(f, "{}", m),
            FitDataMessage::WeatherAlert(m) => write!(f, "{}", m),
            FitDataMessage::WeatherConditions(m) => write!(f, "{}", m),
            FitDataMessage::WeightScale(m) => write!(f, "{}", m),
            FitDataMessage::Workout(m) => write!(f, "{}", m),
            FitDataMessage::WorkoutSession(m) => write!(f, "{}", m),
            FitDataMessage::WorkoutStep(m) => write!(f, "{}", m),
            FitDataMessage::ZonesTarget(m) => write!(f, "{}", m),
            FitDataMessage::UnknownToSdk(m) => write!(f, "{}", m),
        }
    }
}

impl FitDataMessage {
    pub fn field_name(global_mesg_num: &FitGlobalMesgNum, field_number: u8) -> &'static str {
        match *global_mesg_num {
            FitGlobalMesgNum::Known(FitFieldMesgNum::AccelerometerData) => {
                FitMessageAccelerometerData::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Activity) => {
                FitMessageActivity::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AntChannelId) => {
                FitMessageAntChannelId::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AntRx) => {
                FitMessageAntRx::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AntTx) => {
                FitMessageAntTx::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AviationAttitude) => {
                FitMessageAviationAttitude::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::BarometerData) => {
                FitMessageBarometerData::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::BikeProfile) => {
                FitMessageBikeProfile::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::BloodPressure) => {
                FitMessageBloodPressure::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::CadenceZone) => {
                FitMessageCadenceZone::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::CameraEvent) => {
                FitMessageCameraEvent::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Capabilities) => {
                FitMessageCapabilities::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Connectivity) => {
                FitMessageConnectivity::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Course) => {
                FitMessageCourse::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::CoursePoint) => {
                FitMessageCoursePoint::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DeveloperDataId) => {
                FitMessageDeveloperDataId::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DeviceInfo) => {
                FitMessageDeviceInfo::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DeviceSettings) => {
                FitMessageDeviceSettings::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveAlarm) => {
                FitMessageDiveAlarm::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveGas) => {
                FitMessageDiveGas::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveSettings) => {
                FitMessageDiveSettings::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveSummary) => {
                FitMessageDiveSummary::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Event) => {
                FitMessageEvent::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdDataConceptConfiguration) => {
                FitMessageExdDataConceptConfiguration::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdDataFieldConfiguration) => {
                FitMessageExdDataFieldConfiguration::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdScreenConfiguration) => {
                FitMessageExdScreenConfiguration::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExerciseTitle) => {
                FitMessageExerciseTitle::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FieldCapabilities) => {
                FitMessageFieldCapabilities::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FieldDescription) => {
                FitMessageFieldDescription::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FileCapabilities) => {
                FitMessageFileCapabilities::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FileCreator) => {
                FitMessageFileCreator::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FileId) => {
                FitMessageFileId::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Goal) => {
                FitMessageGoal::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::GpsMetadata) => {
                FitMessageGpsMetadata::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::GyroscopeData) => {
                FitMessageGyroscopeData::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Hr) => FitMessageHr::field_name(field_number),

            FitGlobalMesgNum::Known(FitFieldMesgNum::HrZone) => {
                FitMessageHrZone::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::HrmProfile) => {
                FitMessageHrmProfile::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Hrv) => {
                FitMessageHrv::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Lap) => {
                FitMessageLap::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Length) => {
                FitMessageLength::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MagnetometerData) => {
                FitMessageMagnetometerData::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MemoGlob) => {
                FitMessageMemoGlob::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MesgCapabilities) => {
                FitMessageMesgCapabilities::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MetZone) => {
                FitMessageMetZone::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Monitoring) => {
                FitMessageMonitoring::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MonitoringInfo) => {
                FitMessageMonitoringInfo::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::NmeaSentence) => {
                FitMessageNmeaSentence::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ObdiiData) => {
                FitMessageObdiiData::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::OhrSettings) => {
                FitMessageOhrSettings::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::OneDSensorCalibration) => {
                FitMessageOneDSensorCalibration::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::PowerZone) => {
                FitMessagePowerZone::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Record) => {
                FitMessageRecord::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Schedule) => {
                FitMessageSchedule::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SdmProfile) => {
                FitMessageSdmProfile::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentFile) => {
                FitMessageSegmentFile::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentId) => {
                FitMessageSegmentId::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentLap) => {
                FitMessageSegmentLap::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentLeaderboardEntry) => {
                FitMessageSegmentLeaderboardEntry::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentPoint) => {
                FitMessageSegmentPoint::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Session) => {
                FitMessageSession::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Set) => {
                FitMessageSet::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SlaveDevice) => {
                FitMessageSlaveDevice::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Software) => {
                FitMessageSoftware::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SpeedZone) => {
                FitMessageSpeedZone::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Sport) => {
                FitMessageSport::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::StressLevel) => {
                FitMessageStressLevel::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ThreeDSensorCalibration) => {
                FitMessageThreeDSensorCalibration::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::TimestampCorrelation) => {
                FitMessageTimestampCorrelation::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Totals) => {
                FitMessageTotals::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::TrainingFile) => {
                FitMessageTrainingFile::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::UserProfile) => {
                FitMessageUserProfile::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Video) => {
                FitMessageVideo::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoClip) => {
                FitMessageVideoClip::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoDescription) => {
                FitMessageVideoDescription::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoFrame) => {
                FitMessageVideoFrame::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoTitle) => {
                FitMessageVideoTitle::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WatchfaceSettings) => {
                FitMessageWatchfaceSettings::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WeatherAlert) => {
                FitMessageWeatherAlert::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WeatherConditions) => {
                FitMessageWeatherConditions::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WeightScale) => {
                FitMessageWeightScale::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Workout) => {
                FitMessageWorkout::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WorkoutSession) => {
                FitMessageWorkoutSession::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WorkoutStep) => {
                FitMessageWorkoutStep::field_name(field_number)
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ZonesTarget) => {
                FitMessageZonesTarget::field_name(field_number)
            }

            FitGlobalMesgNum::Unknown(_) => "unknown",
            _ => "unexpected",
        }
    }

    pub fn parse<'a>(
        input: &'a [u8],
        header: FitRecordHeader,
        parsing_state: &mut FitParsingState,
        timestamp: Option<FitFieldDateTime>,
    ) -> Result<(FitDataMessage, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        match definition_message.global_mesg_num {
            FitGlobalMesgNum::Known(FitFieldMesgNum::AccelerometerData) => {
                let mut m = FitMessageAccelerometerData::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::AccelerometerData(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Activity) => {
                let mut m = FitMessageActivity::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Activity(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AntChannelId) => {
                let mut m = FitMessageAntChannelId::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::AntChannelId(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AntRx) => {
                let mut m = FitMessageAntRx::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::AntRx(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AntTx) => {
                let mut m = FitMessageAntTx::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::AntTx(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::AviationAttitude) => {
                let mut m = FitMessageAviationAttitude::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::AviationAttitude(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::BarometerData) => {
                let mut m = FitMessageBarometerData::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::BarometerData(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::BikeProfile) => {
                let mut m = FitMessageBikeProfile::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::BikeProfile(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::BloodPressure) => {
                let mut m = FitMessageBloodPressure::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::BloodPressure(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::CadenceZone) => {
                let mut m = FitMessageCadenceZone::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::CadenceZone(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::CameraEvent) => {
                let mut m = FitMessageCameraEvent::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::CameraEvent(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Capabilities) => {
                let mut m = FitMessageCapabilities::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Capabilities(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Connectivity) => {
                let mut m = FitMessageConnectivity::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Connectivity(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Course) => {
                let mut m = FitMessageCourse::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Course(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::CoursePoint) => {
                let mut m = FitMessageCoursePoint::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::CoursePoint(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DeveloperDataId) => {
                let mut m = FitMessageDeveloperDataId::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DeveloperDataId(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DeviceInfo) => {
                let mut m = FitMessageDeviceInfo::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DeviceInfo(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DeviceSettings) => {
                let mut m = FitMessageDeviceSettings::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DeviceSettings(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveAlarm) => {
                let mut m = FitMessageDiveAlarm::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DiveAlarm(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveGas) => {
                let mut m = FitMessageDiveGas::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DiveGas(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveSettings) => {
                let mut m = FitMessageDiveSettings::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DiveSettings(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveSummary) => {
                let mut m = FitMessageDiveSummary::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::DiveSummary(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Event) => {
                let mut m = FitMessageEvent::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Event(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdDataConceptConfiguration) => {
                let mut m = FitMessageExdDataConceptConfiguration::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ExdDataConceptConfiguration(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdDataFieldConfiguration) => {
                let mut m = FitMessageExdDataFieldConfiguration::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ExdDataFieldConfiguration(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdScreenConfiguration) => {
                let mut m = FitMessageExdScreenConfiguration::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ExdScreenConfiguration(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ExerciseTitle) => {
                let mut m = FitMessageExerciseTitle::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ExerciseTitle(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FieldCapabilities) => {
                let mut m = FitMessageFieldCapabilities::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::FieldCapabilities(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FieldDescription) => {
                let mut m = FitMessageFieldDescription::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::FieldDescription(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FileCapabilities) => {
                let mut m = FitMessageFileCapabilities::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::FileCapabilities(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FileCreator) => {
                let mut m = FitMessageFileCreator::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::FileCreator(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::FileId) => {
                let mut m = FitMessageFileId::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::FileId(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Goal) => {
                let mut m = FitMessageGoal::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Goal(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::GpsMetadata) => {
                let mut m = FitMessageGpsMetadata::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::GpsMetadata(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::GyroscopeData) => {
                let mut m = FitMessageGyroscopeData::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::GyroscopeData(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Hr) => {
                let mut m = FitMessageHr::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Hr(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::HrZone) => {
                let mut m = FitMessageHrZone::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::HrZone(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::HrmProfile) => {
                let mut m = FitMessageHrmProfile::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::HrmProfile(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Hrv) => {
                let mut m = FitMessageHrv::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Hrv(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Lap) => {
                let mut m = FitMessageLap::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Lap(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Length) => {
                let mut m = FitMessageLength::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Length(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MagnetometerData) => {
                let mut m = FitMessageMagnetometerData::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::MagnetometerData(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MemoGlob) => {
                let mut m = FitMessageMemoGlob::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::MemoGlob(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MesgCapabilities) => {
                let mut m = FitMessageMesgCapabilities::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::MesgCapabilities(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MetZone) => {
                let mut m = FitMessageMetZone::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::MetZone(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Monitoring) => {
                let mut m = FitMessageMonitoring::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Monitoring(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MonitoringInfo) => {
                let mut m = FitMessageMonitoringInfo::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::MonitoringInfo(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::NmeaSentence) => {
                let mut m = FitMessageNmeaSentence::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::NmeaSentence(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ObdiiData) => {
                let mut m = FitMessageObdiiData::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ObdiiData(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::OhrSettings) => {
                let mut m = FitMessageOhrSettings::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::OhrSettings(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::OneDSensorCalibration) => {
                let mut m = FitMessageOneDSensorCalibration::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::OneDSensorCalibration(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::PowerZone) => {
                let mut m = FitMessagePowerZone::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::PowerZone(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Record) => {
                let mut m = FitMessageRecord::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Record(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Schedule) => {
                let mut m = FitMessageSchedule::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Schedule(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SdmProfile) => {
                let mut m = FitMessageSdmProfile::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SdmProfile(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentFile) => {
                let mut m = FitMessageSegmentFile::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SegmentFile(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentId) => {
                let mut m = FitMessageSegmentId::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SegmentId(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentLap) => {
                let mut m = FitMessageSegmentLap::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SegmentLap(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentLeaderboardEntry) => {
                let mut m = FitMessageSegmentLeaderboardEntry::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SegmentLeaderboardEntry(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentPoint) => {
                let mut m = FitMessageSegmentPoint::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SegmentPoint(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Session) => {
                let mut m = FitMessageSession::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Session(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Set) => {
                let mut m = FitMessageSet::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Set(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SlaveDevice) => {
                let mut m = FitMessageSlaveDevice::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SlaveDevice(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Software) => {
                let mut m = FitMessageSoftware::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Software(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::SpeedZone) => {
                let mut m = FitMessageSpeedZone::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::SpeedZone(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Sport) => {
                let mut m = FitMessageSport::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Sport(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::StressLevel) => {
                let mut m = FitMessageStressLevel::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::StressLevel(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ThreeDSensorCalibration) => {
                let mut m = FitMessageThreeDSensorCalibration::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ThreeDSensorCalibration(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::TimestampCorrelation) => {
                let mut m = FitMessageTimestampCorrelation::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::TimestampCorrelation(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Totals) => {
                let mut m = FitMessageTotals::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Totals(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::TrainingFile) => {
                let mut m = FitMessageTrainingFile::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::TrainingFile(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::UserProfile) => {
                let mut m = FitMessageUserProfile::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::UserProfile(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Video) => {
                let mut m = FitMessageVideo::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Video(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoClip) => {
                let mut m = FitMessageVideoClip::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::VideoClip(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoDescription) => {
                let mut m = FitMessageVideoDescription::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::VideoDescription(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoFrame) => {
                let mut m = FitMessageVideoFrame::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::VideoFrame(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoTitle) => {
                let mut m = FitMessageVideoTitle::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::VideoTitle(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WatchfaceSettings) => {
                let mut m = FitMessageWatchfaceSettings::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::WatchfaceSettings(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WeatherAlert) => {
                let mut m = FitMessageWeatherAlert::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::WeatherAlert(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WeatherConditions) => {
                let mut m = FitMessageWeatherConditions::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::WeatherConditions(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WeightScale) => {
                let mut m = FitMessageWeightScale::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::WeightScale(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::Workout) => {
                let mut m = FitMessageWorkout::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::Workout(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WorkoutSession) => {
                let mut m = FitMessageWorkoutSession::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::WorkoutSession(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::WorkoutStep) => {
                let mut m = FitMessageWorkoutStep::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::WorkoutStep(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::ZonesTarget) => {
                let mut m = FitMessageZonesTarget::new(header, parsing_state)?;
                let o = m.parse(input, parsing_state, timestamp)?;
                Ok((FitDataMessage::ZonesTarget(Rc::new(m)), o))
            }

            FitGlobalMesgNum::Known(FitFieldMesgNum::MesgNum(number)) => {
                let (val, o) =
                    FitMessageUnknownToSdk::parse(number, input, header, parsing_state, timestamp)?;
                Ok((FitDataMessage::UnknownToSdk(val), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MfgRangeMin) => {
                Err(Error::field_mfg_range_min())
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MfgRangeMax) => {
                Err(Error::field_mfg_range_max())
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::InvalidFieldValue) => {
                Err(Error::field_invalid_value())
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::UnknownToSdk) => {
                Err(Error::field_unknown_to_sdk())
            }
            FitGlobalMesgNum::Unknown(number) => {
                let (val, o) =
                    FitMessageUnknownToSdk::parse(number, input, header, parsing_state, timestamp)?;
                Ok((FitDataMessage::UnknownToSdk(val), o))
            } //_ => Ok((None, &input[definition_message.message_size..])),
        }
    }

    pub fn message_name(&self) -> &'static str {
        match self {
            FitDataMessage::AccelerometerData(_) => "AccelerometerData",
            FitDataMessage::Activity(_) => "Activity",
            FitDataMessage::AntChannelId(_) => "AntChannelId",
            FitDataMessage::AntRx(_) => "AntRx",
            FitDataMessage::AntTx(_) => "AntTx",
            FitDataMessage::AviationAttitude(_) => "AviationAttitude",
            FitDataMessage::BarometerData(_) => "BarometerData",
            FitDataMessage::BikeProfile(_) => "BikeProfile",
            FitDataMessage::BloodPressure(_) => "BloodPressure",
            FitDataMessage::CadenceZone(_) => "CadenceZone",
            FitDataMessage::CameraEvent(_) => "CameraEvent",
            FitDataMessage::Capabilities(_) => "Capabilities",
            FitDataMessage::Connectivity(_) => "Connectivity",
            FitDataMessage::Course(_) => "Course",
            FitDataMessage::CoursePoint(_) => "CoursePoint",
            FitDataMessage::DeveloperDataId(_) => "DeveloperDataId",
            FitDataMessage::DeviceInfo(_) => "DeviceInfo",
            FitDataMessage::DeviceSettings(_) => "DeviceSettings",
            FitDataMessage::DiveAlarm(_) => "DiveAlarm",
            FitDataMessage::DiveGas(_) => "DiveGas",
            FitDataMessage::DiveSettings(_) => "DiveSettings",
            FitDataMessage::DiveSummary(_) => "DiveSummary",
            FitDataMessage::Event(_) => "Event",
            FitDataMessage::ExdDataConceptConfiguration(_) => "ExdDataConceptConfiguration",
            FitDataMessage::ExdDataFieldConfiguration(_) => "ExdDataFieldConfiguration",
            FitDataMessage::ExdScreenConfiguration(_) => "ExdScreenConfiguration",
            FitDataMessage::ExerciseTitle(_) => "ExerciseTitle",
            FitDataMessage::FieldCapabilities(_) => "FieldCapabilities",
            FitDataMessage::FieldDescription(_) => "FieldDescription",
            FitDataMessage::FileCapabilities(_) => "FileCapabilities",
            FitDataMessage::FileCreator(_) => "FileCreator",
            FitDataMessage::FileId(_) => "FileId",
            FitDataMessage::Goal(_) => "Goal",
            FitDataMessage::GpsMetadata(_) => "GpsMetadata",
            FitDataMessage::GyroscopeData(_) => "GyroscopeData",
            FitDataMessage::Hr(_) => "Hr",
            FitDataMessage::HrZone(_) => "HrZone",
            FitDataMessage::HrmProfile(_) => "HrmProfile",
            FitDataMessage::Hrv(_) => "Hrv",
            FitDataMessage::Lap(_) => "Lap",
            FitDataMessage::Length(_) => "Length",
            FitDataMessage::MagnetometerData(_) => "MagnetometerData",
            FitDataMessage::MemoGlob(_) => "MemoGlob",
            FitDataMessage::MesgCapabilities(_) => "MesgCapabilities",
            FitDataMessage::MetZone(_) => "MetZone",
            FitDataMessage::Monitoring(_) => "Monitoring",
            FitDataMessage::MonitoringInfo(_) => "MonitoringInfo",
            FitDataMessage::NmeaSentence(_) => "NmeaSentence",
            FitDataMessage::ObdiiData(_) => "ObdiiData",
            FitDataMessage::OhrSettings(_) => "OhrSettings",
            FitDataMessage::OneDSensorCalibration(_) => "OneDSensorCalibration",
            FitDataMessage::PowerZone(_) => "PowerZone",
            FitDataMessage::Record(_) => "Record",
            FitDataMessage::Schedule(_) => "Schedule",
            FitDataMessage::SdmProfile(_) => "SdmProfile",
            FitDataMessage::SegmentFile(_) => "SegmentFile",
            FitDataMessage::SegmentId(_) => "SegmentId",
            FitDataMessage::SegmentLap(_) => "SegmentLap",
            FitDataMessage::SegmentLeaderboardEntry(_) => "SegmentLeaderboardEntry",
            FitDataMessage::SegmentPoint(_) => "SegmentPoint",
            FitDataMessage::Session(_) => "Session",
            FitDataMessage::Set(_) => "Set",
            FitDataMessage::SlaveDevice(_) => "SlaveDevice",
            FitDataMessage::Software(_) => "Software",
            FitDataMessage::SpeedZone(_) => "SpeedZone",
            FitDataMessage::Sport(_) => "Sport",
            FitDataMessage::StressLevel(_) => "StressLevel",
            FitDataMessage::ThreeDSensorCalibration(_) => "ThreeDSensorCalibration",
            FitDataMessage::TimestampCorrelation(_) => "TimestampCorrelation",
            FitDataMessage::Totals(_) => "Totals",
            FitDataMessage::TrainingFile(_) => "TrainingFile",
            FitDataMessage::UserProfile(_) => "UserProfile",
            FitDataMessage::Video(_) => "Video",
            FitDataMessage::VideoClip(_) => "VideoClip",
            FitDataMessage::VideoDescription(_) => "VideoDescription",
            FitDataMessage::VideoFrame(_) => "VideoFrame",
            FitDataMessage::VideoTitle(_) => "VideoTitle",
            FitDataMessage::WatchfaceSettings(_) => "WatchfaceSettings",
            FitDataMessage::WeatherAlert(_) => "WeatherAlert",
            FitDataMessage::WeatherConditions(_) => "WeatherConditions",
            FitDataMessage::WeightScale(_) => "WeightScale",
            FitDataMessage::Workout(_) => "Workout",
            FitDataMessage::WorkoutSession(_) => "WorkoutSession",
            FitDataMessage::WorkoutStep(_) => "WorkoutStep",
            FitDataMessage::ZonesTarget(_) => "ZonesTarget",
            FitDataMessage::UnknownToSdk(_) => "UnknownToSdk",
        }
    }

    pub fn is_accelerometer_data(&self) -> bool {
        match *self {
            FitDataMessage::AccelerometerData(_) => true,
            _ => false,
        }
    }

    pub fn is_activity(&self) -> bool {
        match *self {
            FitDataMessage::Activity(_) => true,
            _ => false,
        }
    }

    pub fn is_ant_channel_id(&self) -> bool {
        match *self {
            FitDataMessage::AntChannelId(_) => true,
            _ => false,
        }
    }

    pub fn is_ant_rx(&self) -> bool {
        match *self {
            FitDataMessage::AntRx(_) => true,
            _ => false,
        }
    }

    pub fn is_ant_tx(&self) -> bool {
        match *self {
            FitDataMessage::AntTx(_) => true,
            _ => false,
        }
    }

    pub fn is_aviation_attitude(&self) -> bool {
        match *self {
            FitDataMessage::AviationAttitude(_) => true,
            _ => false,
        }
    }

    pub fn is_barometer_data(&self) -> bool {
        match *self {
            FitDataMessage::BarometerData(_) => true,
            _ => false,
        }
    }

    pub fn is_bike_profile(&self) -> bool {
        match *self {
            FitDataMessage::BikeProfile(_) => true,
            _ => false,
        }
    }

    pub fn is_blood_pressure(&self) -> bool {
        match *self {
            FitDataMessage::BloodPressure(_) => true,
            _ => false,
        }
    }

    pub fn is_cadence_zone(&self) -> bool {
        match *self {
            FitDataMessage::CadenceZone(_) => true,
            _ => false,
        }
    }

    pub fn is_camera_event(&self) -> bool {
        match *self {
            FitDataMessage::CameraEvent(_) => true,
            _ => false,
        }
    }

    pub fn is_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::Capabilities(_) => true,
            _ => false,
        }
    }

    pub fn is_connectivity(&self) -> bool {
        match *self {
            FitDataMessage::Connectivity(_) => true,
            _ => false,
        }
    }

    pub fn is_course(&self) -> bool {
        match *self {
            FitDataMessage::Course(_) => true,
            _ => false,
        }
    }

    pub fn is_course_point(&self) -> bool {
        match *self {
            FitDataMessage::CoursePoint(_) => true,
            _ => false,
        }
    }

    pub fn is_developer_data_id(&self) -> bool {
        match *self {
            FitDataMessage::DeveloperDataId(_) => true,
            _ => false,
        }
    }

    pub fn is_device_info(&self) -> bool {
        match *self {
            FitDataMessage::DeviceInfo(_) => true,
            _ => false,
        }
    }

    pub fn is_device_settings(&self) -> bool {
        match *self {
            FitDataMessage::DeviceSettings(_) => true,
            _ => false,
        }
    }

    pub fn is_dive_alarm(&self) -> bool {
        match *self {
            FitDataMessage::DiveAlarm(_) => true,
            _ => false,
        }
    }

    pub fn is_dive_gas(&self) -> bool {
        match *self {
            FitDataMessage::DiveGas(_) => true,
            _ => false,
        }
    }

    pub fn is_dive_settings(&self) -> bool {
        match *self {
            FitDataMessage::DiveSettings(_) => true,
            _ => false,
        }
    }

    pub fn is_dive_summary(&self) -> bool {
        match *self {
            FitDataMessage::DiveSummary(_) => true,
            _ => false,
        }
    }

    pub fn is_event(&self) -> bool {
        match *self {
            FitDataMessage::Event(_) => true,
            _ => false,
        }
    }

    pub fn is_exd_data_concept_configuration(&self) -> bool {
        match *self {
            FitDataMessage::ExdDataConceptConfiguration(_) => true,
            _ => false,
        }
    }

    pub fn is_exd_data_field_configuration(&self) -> bool {
        match *self {
            FitDataMessage::ExdDataFieldConfiguration(_) => true,
            _ => false,
        }
    }

    pub fn is_exd_screen_configuration(&self) -> bool {
        match *self {
            FitDataMessage::ExdScreenConfiguration(_) => true,
            _ => false,
        }
    }

    pub fn is_exercise_title(&self) -> bool {
        match *self {
            FitDataMessage::ExerciseTitle(_) => true,
            _ => false,
        }
    }

    pub fn is_field_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::FieldCapabilities(_) => true,
            _ => false,
        }
    }

    pub fn is_field_description(&self) -> bool {
        match *self {
            FitDataMessage::FieldDescription(_) => true,
            _ => false,
        }
    }

    pub fn is_file_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::FileCapabilities(_) => true,
            _ => false,
        }
    }

    pub fn is_file_creator(&self) -> bool {
        match *self {
            FitDataMessage::FileCreator(_) => true,
            _ => false,
        }
    }

    pub fn is_file_id(&self) -> bool {
        match *self {
            FitDataMessage::FileId(_) => true,
            _ => false,
        }
    }

    pub fn is_goal(&self) -> bool {
        match *self {
            FitDataMessage::Goal(_) => true,
            _ => false,
        }
    }

    pub fn is_gps_metadata(&self) -> bool {
        match *self {
            FitDataMessage::GpsMetadata(_) => true,
            _ => false,
        }
    }

    pub fn is_gyroscope_data(&self) -> bool {
        match *self {
            FitDataMessage::GyroscopeData(_) => true,
            _ => false,
        }
    }

    pub fn is_hr(&self) -> bool {
        match *self {
            FitDataMessage::Hr(_) => true,
            _ => false,
        }
    }

    pub fn is_hr_zone(&self) -> bool {
        match *self {
            FitDataMessage::HrZone(_) => true,
            _ => false,
        }
    }

    pub fn is_hrm_profile(&self) -> bool {
        match *self {
            FitDataMessage::HrmProfile(_) => true,
            _ => false,
        }
    }

    pub fn is_hrv(&self) -> bool {
        match *self {
            FitDataMessage::Hrv(_) => true,
            _ => false,
        }
    }

    pub fn is_lap(&self) -> bool {
        match *self {
            FitDataMessage::Lap(_) => true,
            _ => false,
        }
    }

    pub fn is_length(&self) -> bool {
        match *self {
            FitDataMessage::Length(_) => true,
            _ => false,
        }
    }

    pub fn is_magnetometer_data(&self) -> bool {
        match *self {
            FitDataMessage::MagnetometerData(_) => true,
            _ => false,
        }
    }

    pub fn is_memo_glob(&self) -> bool {
        match *self {
            FitDataMessage::MemoGlob(_) => true,
            _ => false,
        }
    }

    pub fn is_mesg_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::MesgCapabilities(_) => true,
            _ => false,
        }
    }

    pub fn is_met_zone(&self) -> bool {
        match *self {
            FitDataMessage::MetZone(_) => true,
            _ => false,
        }
    }

    pub fn is_monitoring(&self) -> bool {
        match *self {
            FitDataMessage::Monitoring(_) => true,
            _ => false,
        }
    }

    pub fn is_monitoring_info(&self) -> bool {
        match *self {
            FitDataMessage::MonitoringInfo(_) => true,
            _ => false,
        }
    }

    pub fn is_nmea_sentence(&self) -> bool {
        match *self {
            FitDataMessage::NmeaSentence(_) => true,
            _ => false,
        }
    }

    pub fn is_obdii_data(&self) -> bool {
        match *self {
            FitDataMessage::ObdiiData(_) => true,
            _ => false,
        }
    }

    pub fn is_ohr_settings(&self) -> bool {
        match *self {
            FitDataMessage::OhrSettings(_) => true,
            _ => false,
        }
    }

    pub fn is_one_d_sensor_calibration(&self) -> bool {
        match *self {
            FitDataMessage::OneDSensorCalibration(_) => true,
            _ => false,
        }
    }

    pub fn is_power_zone(&self) -> bool {
        match *self {
            FitDataMessage::PowerZone(_) => true,
            _ => false,
        }
    }

    pub fn is_record(&self) -> bool {
        match *self {
            FitDataMessage::Record(_) => true,
            _ => false,
        }
    }

    pub fn is_schedule(&self) -> bool {
        match *self {
            FitDataMessage::Schedule(_) => true,
            _ => false,
        }
    }

    pub fn is_sdm_profile(&self) -> bool {
        match *self {
            FitDataMessage::SdmProfile(_) => true,
            _ => false,
        }
    }

    pub fn is_segment_file(&self) -> bool {
        match *self {
            FitDataMessage::SegmentFile(_) => true,
            _ => false,
        }
    }

    pub fn is_segment_id(&self) -> bool {
        match *self {
            FitDataMessage::SegmentId(_) => true,
            _ => false,
        }
    }

    pub fn is_segment_lap(&self) -> bool {
        match *self {
            FitDataMessage::SegmentLap(_) => true,
            _ => false,
        }
    }

    pub fn is_segment_leaderboard_entry(&self) -> bool {
        match *self {
            FitDataMessage::SegmentLeaderboardEntry(_) => true,
            _ => false,
        }
    }

    pub fn is_segment_point(&self) -> bool {
        match *self {
            FitDataMessage::SegmentPoint(_) => true,
            _ => false,
        }
    }

    pub fn is_session(&self) -> bool {
        match *self {
            FitDataMessage::Session(_) => true,
            _ => false,
        }
    }

    pub fn is_set(&self) -> bool {
        match *self {
            FitDataMessage::Set(_) => true,
            _ => false,
        }
    }

    pub fn is_slave_device(&self) -> bool {
        match *self {
            FitDataMessage::SlaveDevice(_) => true,
            _ => false,
        }
    }

    pub fn is_software(&self) -> bool {
        match *self {
            FitDataMessage::Software(_) => true,
            _ => false,
        }
    }

    pub fn is_speed_zone(&self) -> bool {
        match *self {
            FitDataMessage::SpeedZone(_) => true,
            _ => false,
        }
    }

    pub fn is_sport(&self) -> bool {
        match *self {
            FitDataMessage::Sport(_) => true,
            _ => false,
        }
    }

    pub fn is_stress_level(&self) -> bool {
        match *self {
            FitDataMessage::StressLevel(_) => true,
            _ => false,
        }
    }

    pub fn is_three_d_sensor_calibration(&self) -> bool {
        match *self {
            FitDataMessage::ThreeDSensorCalibration(_) => true,
            _ => false,
        }
    }

    pub fn is_timestamp_correlation(&self) -> bool {
        match *self {
            FitDataMessage::TimestampCorrelation(_) => true,
            _ => false,
        }
    }

    pub fn is_totals(&self) -> bool {
        match *self {
            FitDataMessage::Totals(_) => true,
            _ => false,
        }
    }

    pub fn is_training_file(&self) -> bool {
        match *self {
            FitDataMessage::TrainingFile(_) => true,
            _ => false,
        }
    }

    pub fn is_user_profile(&self) -> bool {
        match *self {
            FitDataMessage::UserProfile(_) => true,
            _ => false,
        }
    }

    pub fn is_video(&self) -> bool {
        match *self {
            FitDataMessage::Video(_) => true,
            _ => false,
        }
    }

    pub fn is_video_clip(&self) -> bool {
        match *self {
            FitDataMessage::VideoClip(_) => true,
            _ => false,
        }
    }

    pub fn is_video_description(&self) -> bool {
        match *self {
            FitDataMessage::VideoDescription(_) => true,
            _ => false,
        }
    }

    pub fn is_video_frame(&self) -> bool {
        match *self {
            FitDataMessage::VideoFrame(_) => true,
            _ => false,
        }
    }

    pub fn is_video_title(&self) -> bool {
        match *self {
            FitDataMessage::VideoTitle(_) => true,
            _ => false,
        }
    }

    pub fn is_watchface_settings(&self) -> bool {
        match *self {
            FitDataMessage::WatchfaceSettings(_) => true,
            _ => false,
        }
    }

    pub fn is_weather_alert(&self) -> bool {
        match *self {
            FitDataMessage::WeatherAlert(_) => true,
            _ => false,
        }
    }

    pub fn is_weather_conditions(&self) -> bool {
        match *self {
            FitDataMessage::WeatherConditions(_) => true,
            _ => false,
        }
    }

    pub fn is_weight_scale(&self) -> bool {
        match *self {
            FitDataMessage::WeightScale(_) => true,
            _ => false,
        }
    }

    pub fn is_workout(&self) -> bool {
        match *self {
            FitDataMessage::Workout(_) => true,
            _ => false,
        }
    }

    pub fn is_workout_session(&self) -> bool {
        match *self {
            FitDataMessage::WorkoutSession(_) => true,
            _ => false,
        }
    }

    pub fn is_workout_step(&self) -> bool {
        match *self {
            FitDataMessage::WorkoutStep(_) => true,
            _ => false,
        }
    }

    pub fn is_zones_target(&self) -> bool {
        match *self {
            FitDataMessage::ZonesTarget(_) => true,
            _ => false,
        }
    }

    pub fn is_unknown(&self) -> bool {
        match *self {
            FitDataMessage::UnknownToSdk(_) => true,
            _ => false,
        }
    }
}

#[cfg(test)]
#[path = "./fittypes_test.rs"]
mod fittypes_test;
