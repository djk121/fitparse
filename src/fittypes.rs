
use std::fmt;
use std::rc::Rc;
use std::mem::transmute;
use std::collections::HashMap;
use std::cmp::Ordering;

use nom::Endianness;

use chrono::{DateTime, UTC, FixedOffset, TimeZone, Duration};

use FitRecord;
use FitRecordHeader;
use FitDefinitionMessage;
use FitFieldDefinition;
use FitFieldDeveloperData;
use FitGlobalMesgNum;
use FitMessageUnknownToSdk;
use FitBaseValue;
use fitparsingstate::FitParsingState;
use fitparsers::{parse_enum, parse_uint8, parse_uint8z, parse_sint8, parse_bool, parse_sint16, parse_uint16, parse_uint16z, parse_uint32, parse_uint32z, parse_sint32, parse_byte, parse_string, parse_float32, parse_date_time};

use subset_with_pad;

use errors::{Error, Result};

macro_rules! fmt_developer_fields {
    ($s:ident, $f:ident) => {
        if $s.developer_fields.len() > 0 {
            for developer_field in &$s.developer_fields {
                if let Some(field_names) = &developer_field.field_description.field_name {
                    if let Some(name) = &field_names[0] { write!($f, "  {: >28}: ", name)?; }
                }
                writeln!($f, "{}", developer_field.value)?;
            }
        }
    };
}

macro_rules! fmt_raw_bytes {
    ($s:ident, $f:ident) => {{
        write!($f, "  {: >28}: [", "raw_bytes")?;
        for i in 0..$s.raw_bytes.len() - 1 {
            write!($f, "{:08b}", $s.raw_bytes[i])?;
            if i < $s.raw_bytes.len() - 1 { write!($f, ",")?; }
        }
        writeln!($f, "]")?;
    }};
}

#[derive(Copy, Clone, Debug)]
pub struct FitFieldDateTime {
    seconds_since_garmin_epoch: u32,
    rust_time: DateTime<UTC>,
}

impl FitFieldDateTime {
    fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldDateTime> {
        let (utc_dt, garmin_epoch_offset) = parse_date_time(input, endianness)?;
        Ok(FitFieldDateTime{
            seconds_since_garmin_epoch: garmin_epoch_offset,
            rust_time: utc_dt
        })
    }

    #[allow(dead_code)]
    pub fn new_from_compressed_timestamp(&self, offset_secs: u8) -> Result<FitFieldDateTime> {
        let last_5_existing = {
            let bytes: [u8; 4] = unsafe { transmute(self.seconds_since_garmin_epoch.to_be()) };
            bytes[3] & 0x0000001F
        };
        let last_5_offset = offset_secs & 0x0000001F;

        let new_epoch_offset = match last_5_existing.cmp(&last_5_offset) {
            Ordering::Equal => {
                self.seconds_since_garmin_epoch
            },
            Ordering::Greater => {
                (self.seconds_since_garmin_epoch & 0b11111111_11111111_11111111_11100000) + last_5_offset as u32 + 0x20
            },
            Ordering::Less => {
                (self.seconds_since_garmin_epoch & 0b11111111_11111111_11111111_11100000) + last_5_offset as u32
            }
        };

        let bytes: [u8; 4] = unsafe { transmute(new_epoch_offset.to_be()) };

        let result = FitFieldDateTime::parse(&bytes, Endianness::Big)?;
        Ok(result)
    }
}

#[derive(Debug)]
pub struct FitFieldLocalDateTime {
    seconds_since_garmin_epoch: u32,
    rust_time: DateTime<FixedOffset>,
}

impl FitFieldLocalDateTime {
    fn parse(input: &[u8], endianness: Endianness, _offset_secs: f64) -> Result<FitFieldLocalDateTime> {
        let garmin_epoch = UTC.ymd(1989, 12, 31).and_hms(0, 0, 0);
        let result = parse_uint32(input, endianness)?;
        let garmin_epoch_offset = match result {
            Some(geo) => geo,
            None => return Err(Error::invalid_fit_base_type_parse())
        };
        let local_dt = FixedOffset::east(_offset_secs as i32).timestamp(
            (garmin_epoch + Duration::seconds(garmin_epoch_offset.into())).timestamp(),
            0 // nanosecs
        );

        Ok(FitFieldLocalDateTime{
            seconds_since_garmin_epoch: garmin_epoch_offset,
            rust_time: local_dt
        })
    }
}








#[derive(Debug, PartialEq)]
pub enum FitFieldPowerPhaseType { // fit base type: enum
    PowerPhaseStartAngle = 0,
    PowerPhaseEndAngle = 1,
    PowerPhaseArcLength = 2,
    PowerPhaseCenter = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldPowerPhaseType {
    pub fn parse(input: &[u8]) -> Result<FitFieldPowerPhaseType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldPowerPhaseType::from(valid_val)),
            None => Ok(FitFieldPowerPhaseType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldPowerPhaseType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldPowerPhaseType::PowerPhaseStartAngle,
            1 => FitFieldPowerPhaseType::PowerPhaseEndAngle,
            2 => FitFieldPowerPhaseType::PowerPhaseArcLength,
            3 => FitFieldPowerPhaseType::PowerPhaseCenter,
            _ => FitFieldPowerPhaseType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLeftRightBalance { // fit base type: uint8
    Mask, // 127  % contribution
    Right, // 128  data corresponds to right if set, otherwise unknown
    LeftRightBalance(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLeftRightBalance {
    pub fn parse(input: &[u8]) -> Result<FitFieldLeftRightBalance> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    127 => Ok(FitFieldLeftRightBalance::from(valid_val)),
                    
                    128 => Ok(FitFieldLeftRightBalance::from(valid_val)),
                    
                    v => Ok(FitFieldLeftRightBalance::LeftRightBalance(v)),
                }
            },
            None => Ok(FitFieldLeftRightBalance::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLeftRightBalance {
    fn from(code: u8) -> Self {
        match code {
            127 => FitFieldLeftRightBalance::Mask,
            128 => FitFieldLeftRightBalance::Right,
            _ => FitFieldLeftRightBalance::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWorkoutCapabilities { // fit base type: uint32z
    Interval, // 1
    Custom, // 2
    FitnessEquipment, // 4
    Firstbeat, // 8
    NewLeaf, // 16
    Tcx, // 32  For backwards compatibility.  Watch should add missing id fields then clear flag.
    Speed, // 128  Speed source required for workout step.
    HeartRate, // 256  Heart rate source required for workout step.
    Distance, // 512  Distance source required for workout step.
    Cadence, // 1024  Cadence source required for workout step.
    Power, // 2048  Power source required for workout step.
    Grade, // 4096  Grade source required for workout step.
    Resistance, // 8192  Resistance source required for workout step.
    Protected, // 16384
    WorkoutCapabilities(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldWorkoutCapabilities {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldWorkoutCapabilities> {
        let val = parse_uint32z(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    2 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    4 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    8 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    16 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    32 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    128 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    256 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    512 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    1024 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    2048 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    4096 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    8192 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    16384 => Ok(FitFieldWorkoutCapabilities::from(valid_val)),
                    
                    v => Ok(FitFieldWorkoutCapabilities::WorkoutCapabilities(v)),
                }
            },
            None => Ok(FitFieldWorkoutCapabilities::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldWorkoutCapabilities {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldWorkoutCapabilities::Interval,
            2 => FitFieldWorkoutCapabilities::Custom,
            4 => FitFieldWorkoutCapabilities::FitnessEquipment,
            8 => FitFieldWorkoutCapabilities::Firstbeat,
            16 => FitFieldWorkoutCapabilities::NewLeaf,
            32 => FitFieldWorkoutCapabilities::Tcx,
            128 => FitFieldWorkoutCapabilities::Speed,
            256 => FitFieldWorkoutCapabilities::HeartRate,
            512 => FitFieldWorkoutCapabilities::Distance,
            1024 => FitFieldWorkoutCapabilities::Cadence,
            2048 => FitFieldWorkoutCapabilities::Power,
            4096 => FitFieldWorkoutCapabilities::Grade,
            8192 => FitFieldWorkoutCapabilities::Resistance,
            16384 => FitFieldWorkoutCapabilities::Protected,
            _ => FitFieldWorkoutCapabilities::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldShoulderPressExerciseName { // fit base type: uint16
    AlternatingDumbbellShoulderPress, // 0
    ArnoldPress, // 1
    BarbellFrontSquatToPushPress, // 2
    BarbellPushPress, // 3
    BarbellShoulderPress, // 4
    DeadCurlPress, // 5
    DumbbellAlternatingShoulderPressAndTwist, // 6
    DumbbellHammerCurlToLungeToPress, // 7
    DumbbellPushPress, // 8
    FloorInvertedShoulderPress, // 9
    WeightedFloorInvertedShoulderPress, // 10
    InvertedShoulderPress, // 11
    WeightedInvertedShoulderPress, // 12
    OneArmPushPress, // 13
    OverheadBarbellPress, // 14
    OverheadDumbbellPress, // 15
    SeatedBarbellShoulderPress, // 16
    SeatedDumbbellShoulderPress, // 17
    SingleArmDumbbellShoulderPress, // 18
    SingleArmStepUpAndPress, // 19
    SmithMachineOverheadPress, // 20
    SplitStanceHammerCurlToPress, // 21
    SwissBallDumbbellShoulderPress, // 22
    WeightPlateFrontRaise, // 23
    ShoulderPressExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldShoulderPressExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldShoulderPressExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldShoulderPressExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldShoulderPressExerciseName::ShoulderPressExerciseName(v)),
                }
            },
            None => Ok(FitFieldShoulderPressExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldShoulderPressExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldShoulderPressExerciseName::AlternatingDumbbellShoulderPress,
            1 => FitFieldShoulderPressExerciseName::ArnoldPress,
            2 => FitFieldShoulderPressExerciseName::BarbellFrontSquatToPushPress,
            3 => FitFieldShoulderPressExerciseName::BarbellPushPress,
            4 => FitFieldShoulderPressExerciseName::BarbellShoulderPress,
            5 => FitFieldShoulderPressExerciseName::DeadCurlPress,
            6 => FitFieldShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist,
            7 => FitFieldShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress,
            8 => FitFieldShoulderPressExerciseName::DumbbellPushPress,
            9 => FitFieldShoulderPressExerciseName::FloorInvertedShoulderPress,
            10 => FitFieldShoulderPressExerciseName::WeightedFloorInvertedShoulderPress,
            11 => FitFieldShoulderPressExerciseName::InvertedShoulderPress,
            12 => FitFieldShoulderPressExerciseName::WeightedInvertedShoulderPress,
            13 => FitFieldShoulderPressExerciseName::OneArmPushPress,
            14 => FitFieldShoulderPressExerciseName::OverheadBarbellPress,
            15 => FitFieldShoulderPressExerciseName::OverheadDumbbellPress,
            16 => FitFieldShoulderPressExerciseName::SeatedBarbellShoulderPress,
            17 => FitFieldShoulderPressExerciseName::SeatedDumbbellShoulderPress,
            18 => FitFieldShoulderPressExerciseName::SingleArmDumbbellShoulderPress,
            19 => FitFieldShoulderPressExerciseName::SingleArmStepUpAndPress,
            20 => FitFieldShoulderPressExerciseName::SmithMachineOverheadPress,
            21 => FitFieldShoulderPressExerciseName::SplitStanceHammerCurlToPress,
            22 => FitFieldShoulderPressExerciseName::SwissBallDumbbellShoulderPress,
            23 => FitFieldShoulderPressExerciseName::WeightPlateFrontRaise,
            _ => FitFieldShoulderPressExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSensorType { // fit base type: enum
    Accelerometer = 0,
    Gyroscope = 1,
    Compass = 2,  // Magnetometer
    Barometer = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSensorType {
    pub fn parse(input: &[u8]) -> Result<FitFieldSensorType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSensorType::from(valid_val)),
            None => Ok(FitFieldSensorType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSensorType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSensorType::Accelerometer,
            1 => FitFieldSensorType::Gyroscope,
            2 => FitFieldSensorType::Compass,
            3 => FitFieldSensorType::Barometer,
            _ => FitFieldSensorType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldGender { // fit base type: enum
    Female = 0,
    Male = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldGender {
    pub fn parse(input: &[u8]) -> Result<FitFieldGender> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldGender::from(valid_val)),
            None => Ok(FitFieldGender::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldGender {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGender::Female,
            1 => FitFieldGender::Male,
            _ => FitFieldGender::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSessionTrigger { // fit base type: enum
    ActivityEnd = 0,
    Manual = 1,  // User changed sport.
    AutoMultiSport = 2,  // Auto multi-sport feature is enabled and user pressed lap button to advance session.
    FitnessEquipment = 3,  // Auto sport change caused by user linking to fitness equipment.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSessionTrigger {
    pub fn parse(input: &[u8]) -> Result<FitFieldSessionTrigger> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSessionTrigger::from(valid_val)),
            None => Ok(FitFieldSessionTrigger::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSessionTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSessionTrigger::ActivityEnd,
            1 => FitFieldSessionTrigger::Manual,
            2 => FitFieldSessionTrigger::AutoMultiSport,
            3 => FitFieldSessionTrigger::FitnessEquipment,
            _ => FitFieldSessionTrigger::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFileFlags { // fit base type: uint8z
    Read, // 2
    Write, // 4
    Erase, // 8
    FileFlags(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldFileFlags {
    pub fn parse(input: &[u8]) -> Result<FitFieldFileFlags> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    2 => Ok(FitFieldFileFlags::from(valid_val)),
                    
                    4 => Ok(FitFieldFileFlags::from(valid_val)),
                    
                    8 => Ok(FitFieldFileFlags::from(valid_val)),
                    
                    v => Ok(FitFieldFileFlags::FileFlags(v)),
                }
            },
            None => Ok(FitFieldFileFlags::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldFileFlags {
    fn from(code: u8) -> Self {
        match code {
            2 => FitFieldFileFlags::Read,
            4 => FitFieldFileFlags::Write,
            8 => FitFieldFileFlags::Erase,
            _ => FitFieldFileFlags::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBacklightTimeout { // fit base type: uint8
    Infinite, // 0  Backlight stays on forever.
    BacklightTimeout(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldBacklightTimeout {
    pub fn parse(input: &[u8]) -> Result<FitFieldBacklightTimeout> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldBacklightTimeout::from(valid_val)),
                    
                    v => Ok(FitFieldBacklightTimeout::BacklightTimeout(v)),
                }
            },
            None => Ok(FitFieldBacklightTimeout::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldBacklightTimeout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBacklightTimeout::Infinite,
            _ => FitFieldBacklightTimeout::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCardioExerciseName { // fit base type: uint16
    BobAndWeaveCircle, // 0
    WeightedBobAndWeaveCircle, // 1
    CardioCoreCrawl, // 2
    WeightedCardioCoreCrawl, // 3
    DoubleUnder, // 4
    WeightedDoubleUnder, // 5
    JumpRope, // 6
    WeightedJumpRope, // 7
    JumpRopeCrossover, // 8
    WeightedJumpRopeCrossover, // 9
    JumpRopeJog, // 10
    WeightedJumpRopeJog, // 11
    JumpingJacks, // 12
    WeightedJumpingJacks, // 13
    SkiMoguls, // 14
    WeightedSkiMoguls, // 15
    SplitJacks, // 16
    WeightedSplitJacks, // 17
    SquatJacks, // 18
    WeightedSquatJacks, // 19
    TripleUnder, // 20
    WeightedTripleUnder, // 21
    CardioExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCardioExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCardioExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldCardioExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldCardioExerciseName::CardioExerciseName(v)),
                }
            },
            None => Ok(FitFieldCardioExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCardioExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCardioExerciseName::BobAndWeaveCircle,
            1 => FitFieldCardioExerciseName::WeightedBobAndWeaveCircle,
            2 => FitFieldCardioExerciseName::CardioCoreCrawl,
            3 => FitFieldCardioExerciseName::WeightedCardioCoreCrawl,
            4 => FitFieldCardioExerciseName::DoubleUnder,
            5 => FitFieldCardioExerciseName::WeightedDoubleUnder,
            6 => FitFieldCardioExerciseName::JumpRope,
            7 => FitFieldCardioExerciseName::WeightedJumpRope,
            8 => FitFieldCardioExerciseName::JumpRopeCrossover,
            9 => FitFieldCardioExerciseName::WeightedJumpRopeCrossover,
            10 => FitFieldCardioExerciseName::JumpRopeJog,
            11 => FitFieldCardioExerciseName::WeightedJumpRopeJog,
            12 => FitFieldCardioExerciseName::JumpingJacks,
            13 => FitFieldCardioExerciseName::WeightedJumpingJacks,
            14 => FitFieldCardioExerciseName::SkiMoguls,
            15 => FitFieldCardioExerciseName::WeightedSkiMoguls,
            16 => FitFieldCardioExerciseName::SplitJacks,
            17 => FitFieldCardioExerciseName::WeightedSplitJacks,
            18 => FitFieldCardioExerciseName::SquatJacks,
            19 => FitFieldCardioExerciseName::WeightedSquatJacks,
            20 => FitFieldCardioExerciseName::TripleUnder,
            21 => FitFieldCardioExerciseName::WeightedTripleUnder,
            _ => FitFieldCardioExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldMesgCount { // fit base type: enum
    NumPerFile = 0,
    MaxPerFile = 1,
    MaxPerFileType = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldMesgCount {
    pub fn parse(input: &[u8]) -> Result<FitFieldMesgCount> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldMesgCount::from(valid_val)),
            None => Ok(FitFieldMesgCount::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldMesgCount {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldMesgCount::NumPerFile,
            1 => FitFieldMesgCount::MaxPerFile,
            2 => FitFieldMesgCount::MaxPerFileType,
            _ => FitFieldMesgCount::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFitBaseType { // fit base type: uint8
    Enum, // 0
    Sint8, // 1
    Uint8, // 2
    Sint16, // 131
    Uint16, // 132
    Sint32, // 133
    Uint32, // 134
    String, // 7
    Float32, // 136
    Float64, // 137
    Uint8z, // 10
    Uint16z, // 139
    Uint32z, // 140
    Byte, // 13
    Sint64, // 142
    Uint64, // 143
    Uint64z, // 144
    FitBaseType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldFitBaseType {
    pub fn parse(input: &[u8]) -> Result<FitFieldFitBaseType> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    1 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    2 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    131 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    132 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    133 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    134 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    7 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    136 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    137 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    10 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    139 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    140 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    13 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    142 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    143 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    144 => Ok(FitFieldFitBaseType::from(valid_val)),
                    
                    v => Ok(FitFieldFitBaseType::FitBaseType(v)),
                }
            },
            None => Ok(FitFieldFitBaseType::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldFitBaseType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldFitBaseType::Enum,
            1 => FitFieldFitBaseType::Sint8,
            2 => FitFieldFitBaseType::Uint8,
            131 => FitFieldFitBaseType::Sint16,
            132 => FitFieldFitBaseType::Uint16,
            133 => FitFieldFitBaseType::Sint32,
            134 => FitFieldFitBaseType::Uint32,
            7 => FitFieldFitBaseType::String,
            136 => FitFieldFitBaseType::Float32,
            137 => FitFieldFitBaseType::Float64,
            10 => FitFieldFitBaseType::Uint8z,
            139 => FitFieldFitBaseType::Uint16z,
            140 => FitFieldFitBaseType::Uint32z,
            13 => FitFieldFitBaseType::Byte,
            142 => FitFieldFitBaseType::Sint64,
            143 => FitFieldFitBaseType::Uint64,
            144 => FitFieldFitBaseType::Uint64z,
            _ => FitFieldFitBaseType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTotalBodyExerciseName { // fit base type: uint16
    Burpee, // 0
    WeightedBurpee, // 1
    BurpeeBoxJump, // 2
    WeightedBurpeeBoxJump, // 3
    HighPullBurpee, // 4
    ManMakers, // 5
    OneArmBurpee, // 6
    SquatThrusts, // 7
    WeightedSquatThrusts, // 8
    SquatPlankPushUp, // 9
    WeightedSquatPlankPushUp, // 10
    StandingTRotationBalance, // 11
    WeightedStandingTRotationBalance, // 12
    TotalBodyExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldTotalBodyExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldTotalBodyExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldTotalBodyExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldTotalBodyExerciseName::TotalBodyExerciseName(v)),
                }
            },
            None => Ok(FitFieldTotalBodyExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldTotalBodyExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldTotalBodyExerciseName::Burpee,
            1 => FitFieldTotalBodyExerciseName::WeightedBurpee,
            2 => FitFieldTotalBodyExerciseName::BurpeeBoxJump,
            3 => FitFieldTotalBodyExerciseName::WeightedBurpeeBoxJump,
            4 => FitFieldTotalBodyExerciseName::HighPullBurpee,
            5 => FitFieldTotalBodyExerciseName::ManMakers,
            6 => FitFieldTotalBodyExerciseName::OneArmBurpee,
            7 => FitFieldTotalBodyExerciseName::SquatThrusts,
            8 => FitFieldTotalBodyExerciseName::WeightedSquatThrusts,
            9 => FitFieldTotalBodyExerciseName::SquatPlankPushUp,
            10 => FitFieldTotalBodyExerciseName::WeightedSquatPlankPushUp,
            11 => FitFieldTotalBodyExerciseName::StandingTRotationBalance,
            12 => FitFieldTotalBodyExerciseName::WeightedStandingTRotationBalance,
            _ => FitFieldTotalBodyExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCurlExerciseName { // fit base type: uint16
    AlternatingDumbbellBicepsCurl, // 0
    AlternatingDumbbellBicepsCurlOnSwissBall, // 1
    AlternatingInclineDumbbellBicepsCurl, // 2
    BarbellBicepsCurl, // 3
    BarbellReverseWristCurl, // 4
    BarbellWristCurl, // 5
    BehindTheBackBarbellReverseWristCurl, // 6
    BehindTheBackOneArmCableCurl, // 7
    CableBicepsCurl, // 8
    CableHammerCurl, // 9
    CheatingBarbellBicepsCurl, // 10
    CloseGripEzBarBicepsCurl, // 11
    CrossBodyDumbbellHammerCurl, // 12
    DeadHangBicepsCurl, // 13
    DeclineHammerCurl, // 14
    DumbbellBicepsCurlWithStaticHold, // 15
    DumbbellHammerCurl, // 16
    DumbbellReverseWristCurl, // 17
    DumbbellWristCurl, // 18
    EzBarPreacherCurl, // 19
    ForwardBendBicepsCurl, // 20
    HammerCurlToPress, // 21
    InclineDumbbellBicepsCurl, // 22
    InclineOffsetThumbDumbbellCurl, // 23
    KettlebellBicepsCurl, // 24
    LyingConcentrationCableCurl, // 25
    OneArmPreacherCurl, // 26
    PlatePinchCurl, // 27
    PreacherCurlWithCable, // 28
    ReverseEzBarCurl, // 29
    ReverseGripWristCurl, // 30
    ReverseGripBarbellBicepsCurl, // 31
    SeatedAlternatingDumbbellBicepsCurl, // 32
    SeatedDumbbellBicepsCurl, // 33
    SeatedReverseDumbbellCurl, // 34
    SplitStanceOffsetPinkyDumbbellCurl, // 35
    StandingAlternatingDumbbellCurls, // 36
    StandingDumbbellBicepsCurl, // 37
    StandingEzBarBicepsCurl, // 38
    StaticCurl, // 39
    SwissBallDumbbellOverheadTricepsExtension, // 40
    SwissBallEzBarPreacherCurl, // 41
    TwistingStandingDumbbellBicepsCurl, // 42
    WideGripEzBarBicepsCurl, // 43
    CurlExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCurlExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCurlExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldCurlExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldCurlExerciseName::CurlExerciseName(v)),
                }
            },
            None => Ok(FitFieldCurlExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCurlExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCurlExerciseName::AlternatingDumbbellBicepsCurl,
            1 => FitFieldCurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall,
            2 => FitFieldCurlExerciseName::AlternatingInclineDumbbellBicepsCurl,
            3 => FitFieldCurlExerciseName::BarbellBicepsCurl,
            4 => FitFieldCurlExerciseName::BarbellReverseWristCurl,
            5 => FitFieldCurlExerciseName::BarbellWristCurl,
            6 => FitFieldCurlExerciseName::BehindTheBackBarbellReverseWristCurl,
            7 => FitFieldCurlExerciseName::BehindTheBackOneArmCableCurl,
            8 => FitFieldCurlExerciseName::CableBicepsCurl,
            9 => FitFieldCurlExerciseName::CableHammerCurl,
            10 => FitFieldCurlExerciseName::CheatingBarbellBicepsCurl,
            11 => FitFieldCurlExerciseName::CloseGripEzBarBicepsCurl,
            12 => FitFieldCurlExerciseName::CrossBodyDumbbellHammerCurl,
            13 => FitFieldCurlExerciseName::DeadHangBicepsCurl,
            14 => FitFieldCurlExerciseName::DeclineHammerCurl,
            15 => FitFieldCurlExerciseName::DumbbellBicepsCurlWithStaticHold,
            16 => FitFieldCurlExerciseName::DumbbellHammerCurl,
            17 => FitFieldCurlExerciseName::DumbbellReverseWristCurl,
            18 => FitFieldCurlExerciseName::DumbbellWristCurl,
            19 => FitFieldCurlExerciseName::EzBarPreacherCurl,
            20 => FitFieldCurlExerciseName::ForwardBendBicepsCurl,
            21 => FitFieldCurlExerciseName::HammerCurlToPress,
            22 => FitFieldCurlExerciseName::InclineDumbbellBicepsCurl,
            23 => FitFieldCurlExerciseName::InclineOffsetThumbDumbbellCurl,
            24 => FitFieldCurlExerciseName::KettlebellBicepsCurl,
            25 => FitFieldCurlExerciseName::LyingConcentrationCableCurl,
            26 => FitFieldCurlExerciseName::OneArmPreacherCurl,
            27 => FitFieldCurlExerciseName::PlatePinchCurl,
            28 => FitFieldCurlExerciseName::PreacherCurlWithCable,
            29 => FitFieldCurlExerciseName::ReverseEzBarCurl,
            30 => FitFieldCurlExerciseName::ReverseGripWristCurl,
            31 => FitFieldCurlExerciseName::ReverseGripBarbellBicepsCurl,
            32 => FitFieldCurlExerciseName::SeatedAlternatingDumbbellBicepsCurl,
            33 => FitFieldCurlExerciseName::SeatedDumbbellBicepsCurl,
            34 => FitFieldCurlExerciseName::SeatedReverseDumbbellCurl,
            35 => FitFieldCurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl,
            36 => FitFieldCurlExerciseName::StandingAlternatingDumbbellCurls,
            37 => FitFieldCurlExerciseName::StandingDumbbellBicepsCurl,
            38 => FitFieldCurlExerciseName::StandingEzBarBicepsCurl,
            39 => FitFieldCurlExerciseName::StaticCurl,
            40 => FitFieldCurlExerciseName::SwissBallDumbbellOverheadTricepsExtension,
            41 => FitFieldCurlExerciseName::SwissBallEzBarPreacherCurl,
            42 => FitFieldCurlExerciseName::TwistingStandingDumbbellBicepsCurl,
            43 => FitFieldCurlExerciseName::WideGripEzBarBicepsCurl,
            _ => FitFieldCurlExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTimerTrigger { // fit base type: enum
    Manual = 0,
    Auto = 1,
    FitnessEquipment = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldTimerTrigger {
    pub fn parse(input: &[u8]) -> Result<FitFieldTimerTrigger> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldTimerTrigger::from(valid_val)),
            None => Ok(FitFieldTimerTrigger::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldTimerTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTimerTrigger::Manual,
            1 => FitFieldTimerTrigger::Auto,
            2 => FitFieldTimerTrigger::FitnessEquipment,
            _ => FitFieldTimerTrigger::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportEvent { // fit base type: enum
    Uncategorized = 0,
    Geocaching = 1,
    Fitness = 2,
    Recreation = 3,
    Race = 4,
    SpecialEvent = 5,
    Training = 6,
    Transportation = 7,
    Touring = 8,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSportEvent {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportEvent> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSportEvent::from(valid_val)),
            None => Ok(FitFieldSportEvent::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSportEvent {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSportEvent::Uncategorized,
            1 => FitFieldSportEvent::Geocaching,
            2 => FitFieldSportEvent::Fitness,
            3 => FitFieldSportEvent::Recreation,
            4 => FitFieldSportEvent::Race,
            5 => FitFieldSportEvent::SpecialEvent,
            6 => FitFieldSportEvent::Training,
            7 => FitFieldSportEvent::Transportation,
            8 => FitFieldSportEvent::Touring,
            _ => FitFieldSportEvent::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAutoscroll { // fit base type: enum
    None = 0,
    Slow = 1,
    Medium = 2,
    Fast = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldAutoscroll {
    pub fn parse(input: &[u8]) -> Result<FitFieldAutoscroll> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldAutoscroll::from(valid_val)),
            None => Ok(FitFieldAutoscroll::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldAutoscroll {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAutoscroll::None,
            1 => FitFieldAutoscroll::Slow,
            2 => FitFieldAutoscroll::Medium,
            3 => FitFieldAutoscroll::Fast,
            _ => FitFieldAutoscroll::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldStrokeType { // fit base type: enum
    NoEvent = 0,
    Other = 1,  // stroke was detected but cannot be identified
    Serve = 2,
    Forehand = 3,
    Backhand = 4,
    Smash = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldStrokeType {
    pub fn parse(input: &[u8]) -> Result<FitFieldStrokeType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldStrokeType::from(valid_val)),
            None => Ok(FitFieldStrokeType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldStrokeType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldStrokeType::NoEvent,
            1 => FitFieldStrokeType::Other,
            2 => FitFieldStrokeType::Serve,
            3 => FitFieldStrokeType::Forehand,
            4 => FitFieldStrokeType::Backhand,
            5 => FitFieldStrokeType::Smash,
            _ => FitFieldStrokeType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTissueModelType { // fit base type: enum
    Zhl16c = 0,  // Buhlmann's decompression algorithm, version C
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldTissueModelType {
    pub fn parse(input: &[u8]) -> Result<FitFieldTissueModelType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldTissueModelType::from(valid_val)),
            None => Ok(FitFieldTissueModelType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldTissueModelType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTissueModelType::Zhl16c,
            _ => FitFieldTissueModelType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWeatherSevereType { // fit base type: enum
    Unspecified = 0,
    Tornado = 1,
    Tsunami = 2,
    Hurricane = 3,
    ExtremeWind = 4,
    Typhoon = 5,
    InlandHurricane = 6,
    HurricaneForceWind = 7,
    Waterspout = 8,
    SevereThunderstorm = 9,
    WreckhouseWinds = 10,
    LesSuetesWind = 11,
    Avalanche = 12,
    FlashFlood = 13,
    TropicalStorm = 14,
    InlandTropicalStorm = 15,
    Blizzard = 16,
    IceStorm = 17,
    FreezingRain = 18,
    DebrisFlow = 19,
    FlashFreeze = 20,
    DustStorm = 21,
    HighWind = 22,
    WinterStorm = 23,
    HeavyFreezingSpray = 24,
    ExtremeCold = 25,
    WindChill = 26,
    ColdWave = 27,
    HeavySnowAlert = 28,
    LakeEffectBlowingSnow = 29,
    SnowSquall = 30,
    LakeEffectSnow = 31,
    WinterWeather = 32,
    Sleet = 33,
    Snowfall = 34,
    SnowAndBlowingSnow = 35,
    BlowingSnow = 36,
    SnowAlert = 37,
    ArcticOutflow = 38,
    FreezingDrizzle = 39,
    Storm = 40,
    StormSurge = 41,
    Rainfall = 42,
    ArealFlood = 43,
    CoastalFlood = 44,
    LakeshoreFlood = 45,
    ExcessiveHeat = 46,
    Heat = 47,
    Weather = 48,
    HighHeatAndHumidity = 49,
    HumidexAndHealth = 50,
    Humidex = 51,
    Gale = 52,
    FreezingSpray = 53,
    SpecialMarine = 54,
    Squall = 55,
    StrongWind = 56,
    LakeWind = 57,
    MarineWeather = 58,
    Wind = 59,
    SmallCraftHazardousSeas = 60,
    HazardousSeas = 61,
    SmallCraft = 62,
    SmallCraftWinds = 63,
    SmallCraftRoughBar = 64,
    HighWaterLevel = 65,
    Ashfall = 66,
    FreezingFog = 67,
    DenseFog = 68,
    DenseSmoke = 69,
    BlowingDust = 70,
    HardFreeze = 71,
    Freeze = 72,
    Frost = 73,
    FireWeather = 74,
    Flood = 75,
    RipTide = 76,
    HighSurf = 77,
    Smog = 78,
    AirQuality = 79,
    BriskWind = 80,
    AirStagnation = 81,
    LowWater = 82,
    Hydrological = 83,
    SpecialWeather = 84,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWeatherSevereType {
    pub fn parse(input: &[u8]) -> Result<FitFieldWeatherSevereType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWeatherSevereType::from(valid_val)),
            None => Ok(FitFieldWeatherSevereType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWeatherSevereType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherSevereType::Unspecified,
            1 => FitFieldWeatherSevereType::Tornado,
            2 => FitFieldWeatherSevereType::Tsunami,
            3 => FitFieldWeatherSevereType::Hurricane,
            4 => FitFieldWeatherSevereType::ExtremeWind,
            5 => FitFieldWeatherSevereType::Typhoon,
            6 => FitFieldWeatherSevereType::InlandHurricane,
            7 => FitFieldWeatherSevereType::HurricaneForceWind,
            8 => FitFieldWeatherSevereType::Waterspout,
            9 => FitFieldWeatherSevereType::SevereThunderstorm,
            10 => FitFieldWeatherSevereType::WreckhouseWinds,
            11 => FitFieldWeatherSevereType::LesSuetesWind,
            12 => FitFieldWeatherSevereType::Avalanche,
            13 => FitFieldWeatherSevereType::FlashFlood,
            14 => FitFieldWeatherSevereType::TropicalStorm,
            15 => FitFieldWeatherSevereType::InlandTropicalStorm,
            16 => FitFieldWeatherSevereType::Blizzard,
            17 => FitFieldWeatherSevereType::IceStorm,
            18 => FitFieldWeatherSevereType::FreezingRain,
            19 => FitFieldWeatherSevereType::DebrisFlow,
            20 => FitFieldWeatherSevereType::FlashFreeze,
            21 => FitFieldWeatherSevereType::DustStorm,
            22 => FitFieldWeatherSevereType::HighWind,
            23 => FitFieldWeatherSevereType::WinterStorm,
            24 => FitFieldWeatherSevereType::HeavyFreezingSpray,
            25 => FitFieldWeatherSevereType::ExtremeCold,
            26 => FitFieldWeatherSevereType::WindChill,
            27 => FitFieldWeatherSevereType::ColdWave,
            28 => FitFieldWeatherSevereType::HeavySnowAlert,
            29 => FitFieldWeatherSevereType::LakeEffectBlowingSnow,
            30 => FitFieldWeatherSevereType::SnowSquall,
            31 => FitFieldWeatherSevereType::LakeEffectSnow,
            32 => FitFieldWeatherSevereType::WinterWeather,
            33 => FitFieldWeatherSevereType::Sleet,
            34 => FitFieldWeatherSevereType::Snowfall,
            35 => FitFieldWeatherSevereType::SnowAndBlowingSnow,
            36 => FitFieldWeatherSevereType::BlowingSnow,
            37 => FitFieldWeatherSevereType::SnowAlert,
            38 => FitFieldWeatherSevereType::ArcticOutflow,
            39 => FitFieldWeatherSevereType::FreezingDrizzle,
            40 => FitFieldWeatherSevereType::Storm,
            41 => FitFieldWeatherSevereType::StormSurge,
            42 => FitFieldWeatherSevereType::Rainfall,
            43 => FitFieldWeatherSevereType::ArealFlood,
            44 => FitFieldWeatherSevereType::CoastalFlood,
            45 => FitFieldWeatherSevereType::LakeshoreFlood,
            46 => FitFieldWeatherSevereType::ExcessiveHeat,
            47 => FitFieldWeatherSevereType::Heat,
            48 => FitFieldWeatherSevereType::Weather,
            49 => FitFieldWeatherSevereType::HighHeatAndHumidity,
            50 => FitFieldWeatherSevereType::HumidexAndHealth,
            51 => FitFieldWeatherSevereType::Humidex,
            52 => FitFieldWeatherSevereType::Gale,
            53 => FitFieldWeatherSevereType::FreezingSpray,
            54 => FitFieldWeatherSevereType::SpecialMarine,
            55 => FitFieldWeatherSevereType::Squall,
            56 => FitFieldWeatherSevereType::StrongWind,
            57 => FitFieldWeatherSevereType::LakeWind,
            58 => FitFieldWeatherSevereType::MarineWeather,
            59 => FitFieldWeatherSevereType::Wind,
            60 => FitFieldWeatherSevereType::SmallCraftHazardousSeas,
            61 => FitFieldWeatherSevereType::HazardousSeas,
            62 => FitFieldWeatherSevereType::SmallCraft,
            63 => FitFieldWeatherSevereType::SmallCraftWinds,
            64 => FitFieldWeatherSevereType::SmallCraftRoughBar,
            65 => FitFieldWeatherSevereType::HighWaterLevel,
            66 => FitFieldWeatherSevereType::Ashfall,
            67 => FitFieldWeatherSevereType::FreezingFog,
            68 => FitFieldWeatherSevereType::DenseFog,
            69 => FitFieldWeatherSevereType::DenseSmoke,
            70 => FitFieldWeatherSevereType::BlowingDust,
            71 => FitFieldWeatherSevereType::HardFreeze,
            72 => FitFieldWeatherSevereType::Freeze,
            73 => FitFieldWeatherSevereType::Frost,
            74 => FitFieldWeatherSevereType::FireWeather,
            75 => FitFieldWeatherSevereType::Flood,
            76 => FitFieldWeatherSevereType::RipTide,
            77 => FitFieldWeatherSevereType::HighSurf,
            78 => FitFieldWeatherSevereType::Smog,
            79 => FitFieldWeatherSevereType::AirQuality,
            80 => FitFieldWeatherSevereType::BriskWind,
            81 => FitFieldWeatherSevereType::AirStagnation,
            82 => FitFieldWeatherSevereType::LowWater,
            83 => FitFieldWeatherSevereType::Hydrological,
            84 => FitFieldWeatherSevereType::SpecialWeather,
            _ => FitFieldWeatherSevereType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldHrZoneCalc { // fit base type: enum
    Custom = 0,
    PercentMaxHr = 1,
    PercentHrr = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldHrZoneCalc {
    pub fn parse(input: &[u8]) -> Result<FitFieldHrZoneCalc> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldHrZoneCalc::from(valid_val)),
            None => Ok(FitFieldHrZoneCalc::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldHrZoneCalc {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldHrZoneCalc::Custom,
            1 => FitFieldHrZoneCalc::PercentMaxHr,
            2 => FitFieldHrZoneCalc::PercentHrr,
            _ => FitFieldHrZoneCalc::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldHrType { // fit base type: enum
    Normal = 0,
    Irregular = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldHrType {
    pub fn parse(input: &[u8]) -> Result<FitFieldHrType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldHrType::from(valid_val)),
            None => Ok(FitFieldHrType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldHrType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldHrType::Normal,
            1 => FitFieldHrType::Irregular,
            _ => FitFieldHrType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSegmentLeaderboardType { // fit base type: enum
    Overall = 0,
    PersonalBest = 1,
    Connections = 2,
    Group = 3,
    Challenger = 4,
    Kom = 5,
    Qom = 6,
    Pr = 7,
    Goal = 8,
    Rival = 9,
    ClubLeader = 10,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSegmentLeaderboardType {
    pub fn parse(input: &[u8]) -> Result<FitFieldSegmentLeaderboardType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSegmentLeaderboardType::from(valid_val)),
            None => Ok(FitFieldSegmentLeaderboardType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSegmentLeaderboardType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentLeaderboardType::Overall,
            1 => FitFieldSegmentLeaderboardType::PersonalBest,
            2 => FitFieldSegmentLeaderboardType::Connections,
            3 => FitFieldSegmentLeaderboardType::Group,
            4 => FitFieldSegmentLeaderboardType::Challenger,
            5 => FitFieldSegmentLeaderboardType::Kom,
            6 => FitFieldSegmentLeaderboardType::Qom,
            7 => FitFieldSegmentLeaderboardType::Pr,
            8 => FitFieldSegmentLeaderboardType::Goal,
            9 => FitFieldSegmentLeaderboardType::Rival,
            10 => FitFieldSegmentLeaderboardType::ClubLeader,
            _ => FitFieldSegmentLeaderboardType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAttitudeStage { // fit base type: enum
    Failed = 0,
    Aligning = 1,
    Degraded = 2,
    Valid = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldAttitudeStage {
    pub fn parse(input: &[u8]) -> Result<FitFieldAttitudeStage> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldAttitudeStage::from(valid_val)),
            None => Ok(FitFieldAttitudeStage::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldAttitudeStage {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAttitudeStage::Failed,
            1 => FitFieldAttitudeStage::Aligning,
            2 => FitFieldAttitudeStage::Degraded,
            3 => FitFieldAttitudeStage::Valid,
            _ => FitFieldAttitudeStage::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLocalDeviceType { // fit base type: uint8
    LocalDeviceType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLocalDeviceType {
    pub fn parse(input: &[u8]) -> Result<FitFieldLocalDeviceType> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    v => Ok(FitFieldLocalDeviceType::LocalDeviceType(v)),
                }
            },
            None => Ok(FitFieldLocalDeviceType::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLocalDeviceType {
    fn from(code: u8) -> Self {
        match code {
            _ => FitFieldLocalDeviceType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDigitalWatchfaceLayout { // fit base type: enum
    Traditional = 0,
    Modern = 1,
    Bold = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDigitalWatchfaceLayout {
    pub fn parse(input: &[u8]) -> Result<FitFieldDigitalWatchfaceLayout> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDigitalWatchfaceLayout::from(valid_val)),
            None => Ok(FitFieldDigitalWatchfaceLayout::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDigitalWatchfaceLayout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDigitalWatchfaceLayout::Traditional,
            1 => FitFieldDigitalWatchfaceLayout::Modern,
            2 => FitFieldDigitalWatchfaceLayout::Bold,
            _ => FitFieldDigitalWatchfaceLayout::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldPwrZoneCalc { // fit base type: enum
    Custom = 0,
    PercentFtp = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldPwrZoneCalc {
    pub fn parse(input: &[u8]) -> Result<FitFieldPwrZoneCalc> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldPwrZoneCalc::from(valid_val)),
            None => Ok(FitFieldPwrZoneCalc::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldPwrZoneCalc {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldPwrZoneCalc::Custom,
            1 => FitFieldPwrZoneCalc::PercentFtp,
            _ => FitFieldPwrZoneCalc::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldOlympicLiftExerciseName { // fit base type: uint16
    BarbellHangPowerClean, // 0
    BarbellHangSquatClean, // 1
    BarbellPowerClean, // 2
    BarbellPowerSnatch, // 3
    BarbellSquatClean, // 4
    CleanAndJerk, // 5
    BarbellHangPowerSnatch, // 6
    BarbellHangPull, // 7
    BarbellHighPull, // 8
    BarbellSnatch, // 9
    BarbellSplitJerk, // 10
    Clean, // 11
    DumbbellClean, // 12
    DumbbellHangPull, // 13
    OneHandDumbbellSplitSnatch, // 14
    PushJerk, // 15
    SingleArmDumbbellSnatch, // 16
    SingleArmHangSnatch, // 17
    SingleArmKettlebellSnatch, // 18
    SplitJerk, // 19
    SquatCleanAndJerk, // 20
    OlympicLiftExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldOlympicLiftExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldOlympicLiftExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldOlympicLiftExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldOlympicLiftExerciseName::OlympicLiftExerciseName(v)),
                }
            },
            None => Ok(FitFieldOlympicLiftExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldOlympicLiftExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldOlympicLiftExerciseName::BarbellHangPowerClean,
            1 => FitFieldOlympicLiftExerciseName::BarbellHangSquatClean,
            2 => FitFieldOlympicLiftExerciseName::BarbellPowerClean,
            3 => FitFieldOlympicLiftExerciseName::BarbellPowerSnatch,
            4 => FitFieldOlympicLiftExerciseName::BarbellSquatClean,
            5 => FitFieldOlympicLiftExerciseName::CleanAndJerk,
            6 => FitFieldOlympicLiftExerciseName::BarbellHangPowerSnatch,
            7 => FitFieldOlympicLiftExerciseName::BarbellHangPull,
            8 => FitFieldOlympicLiftExerciseName::BarbellHighPull,
            9 => FitFieldOlympicLiftExerciseName::BarbellSnatch,
            10 => FitFieldOlympicLiftExerciseName::BarbellSplitJerk,
            11 => FitFieldOlympicLiftExerciseName::Clean,
            12 => FitFieldOlympicLiftExerciseName::DumbbellClean,
            13 => FitFieldOlympicLiftExerciseName::DumbbellHangPull,
            14 => FitFieldOlympicLiftExerciseName::OneHandDumbbellSplitSnatch,
            15 => FitFieldOlympicLiftExerciseName::PushJerk,
            16 => FitFieldOlympicLiftExerciseName::SingleArmDumbbellSnatch,
            17 => FitFieldOlympicLiftExerciseName::SingleArmHangSnatch,
            18 => FitFieldOlympicLiftExerciseName::SingleArmKettlebellSnatch,
            19 => FitFieldOlympicLiftExerciseName::SplitJerk,
            20 => FitFieldOlympicLiftExerciseName::SquatCleanAndJerk,
            _ => FitFieldOlympicLiftExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWktStepTarget { // fit base type: enum
    Speed = 0,
    HeartRate = 1,
    Open = 2,
    Cadence = 3,
    Power = 4,
    Grade = 5,
    Resistance = 6,
    Power3s = 7,
    Power10s = 8,
    Power30s = 9,
    PowerLap = 10,
    SwimStroke = 11,
    SpeedLap = 12,
    HeartRateLap = 13,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWktStepTarget {
    pub fn parse(input: &[u8]) -> Result<FitFieldWktStepTarget> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWktStepTarget::from(valid_val)),
            None => Ok(FitFieldWktStepTarget::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWktStepTarget {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWktStepTarget::Speed,
            1 => FitFieldWktStepTarget::HeartRate,
            2 => FitFieldWktStepTarget::Open,
            3 => FitFieldWktStepTarget::Cadence,
            4 => FitFieldWktStepTarget::Power,
            5 => FitFieldWktStepTarget::Grade,
            6 => FitFieldWktStepTarget::Resistance,
            7 => FitFieldWktStepTarget::Power3s,
            8 => FitFieldWktStepTarget::Power10s,
            9 => FitFieldWktStepTarget::Power30s,
            10 => FitFieldWktStepTarget::PowerLap,
            11 => FitFieldWktStepTarget::SwimStroke,
            12 => FitFieldWktStepTarget::SpeedLap,
            13 => FitFieldWktStepTarget::HeartRateLap,
            _ => FitFieldWktStepTarget::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFlyeExerciseName { // fit base type: uint16
    CableCrossover, // 0
    DeclineDumbbellFlye, // 1
    DumbbellFlye, // 2
    InclineDumbbellFlye, // 3
    KettlebellFlye, // 4
    KneelingRearFlye, // 5
    SingleArmStandingCableReverseFlye, // 6
    SwissBallDumbbellFlye, // 7
    ArmRotations, // 8
    HugATree, // 9
    FlyeExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldFlyeExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldFlyeExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldFlyeExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldFlyeExerciseName::FlyeExerciseName(v)),
                }
            },
            None => Ok(FitFieldFlyeExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldFlyeExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldFlyeExerciseName::CableCrossover,
            1 => FitFieldFlyeExerciseName::DeclineDumbbellFlye,
            2 => FitFieldFlyeExerciseName::DumbbellFlye,
            3 => FitFieldFlyeExerciseName::InclineDumbbellFlye,
            4 => FitFieldFlyeExerciseName::KettlebellFlye,
            5 => FitFieldFlyeExerciseName::KneelingRearFlye,
            6 => FitFieldFlyeExerciseName::SingleArmStandingCableReverseFlye,
            7 => FitFieldFlyeExerciseName::SwissBallDumbbellFlye,
            8 => FitFieldFlyeExerciseName::ArmRotations,
            9 => FitFieldFlyeExerciseName::HugATree,
            _ => FitFieldFlyeExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldActivity { // fit base type: enum
    Manual = 0,
    AutoMultiSport = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldActivity {
    pub fn parse(input: &[u8]) -> Result<FitFieldActivity> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldActivity::from(valid_val)),
            None => Ok(FitFieldActivity::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldActivity {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivity::Manual,
            1 => FitFieldActivity::AutoMultiSport,
            _ => FitFieldActivity::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWatchfaceMode { // fit base type: enum
    Digital = 0,
    Analog = 1,
    ConnectIq = 2,
    Disabled = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWatchfaceMode {
    pub fn parse(input: &[u8]) -> Result<FitFieldWatchfaceMode> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWatchfaceMode::from(valid_val)),
            None => Ok(FitFieldWatchfaceMode::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWatchfaceMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWatchfaceMode::Digital,
            1 => FitFieldWatchfaceMode::Analog,
            2 => FitFieldWatchfaceMode::ConnectIq,
            3 => FitFieldWatchfaceMode::Disabled,
            _ => FitFieldWatchfaceMode::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCoursePoint { // fit base type: enum
    Generic = 0,
    Summit = 1,
    Valley = 2,
    Water = 3,
    Food = 4,
    Danger = 5,
    Left = 6,
    Right = 7,
    Straight = 8,
    FirstAid = 9,
    FourthCategory = 10,
    ThirdCategory = 11,
    SecondCategory = 12,
    FirstCategory = 13,
    HorsCategory = 14,
    Sprint = 15,
    LeftFork = 16,
    RightFork = 17,
    MiddleFork = 18,
    SlightLeft = 19,
    SharpLeft = 20,
    SlightRight = 21,
    SharpRight = 22,
    UTurn = 23,
    SegmentStart = 24,
    SegmentEnd = 25,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldCoursePoint {
    pub fn parse(input: &[u8]) -> Result<FitFieldCoursePoint> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldCoursePoint::from(valid_val)),
            None => Ok(FitFieldCoursePoint::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldCoursePoint {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldCoursePoint::Generic,
            1 => FitFieldCoursePoint::Summit,
            2 => FitFieldCoursePoint::Valley,
            3 => FitFieldCoursePoint::Water,
            4 => FitFieldCoursePoint::Food,
            5 => FitFieldCoursePoint::Danger,
            6 => FitFieldCoursePoint::Left,
            7 => FitFieldCoursePoint::Right,
            8 => FitFieldCoursePoint::Straight,
            9 => FitFieldCoursePoint::FirstAid,
            10 => FitFieldCoursePoint::FourthCategory,
            11 => FitFieldCoursePoint::ThirdCategory,
            12 => FitFieldCoursePoint::SecondCategory,
            13 => FitFieldCoursePoint::FirstCategory,
            14 => FitFieldCoursePoint::HorsCategory,
            15 => FitFieldCoursePoint::Sprint,
            16 => FitFieldCoursePoint::LeftFork,
            17 => FitFieldCoursePoint::RightFork,
            18 => FitFieldCoursePoint::MiddleFork,
            19 => FitFieldCoursePoint::SlightLeft,
            20 => FitFieldCoursePoint::SharpLeft,
            21 => FitFieldCoursePoint::SlightRight,
            22 => FitFieldCoursePoint::SharpRight,
            23 => FitFieldCoursePoint::UTurn,
            24 => FitFieldCoursePoint::SegmentStart,
            25 => FitFieldCoursePoint::SegmentEnd,
            _ => FitFieldCoursePoint::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSide { // fit base type: enum
    Right = 0,
    Left = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSide {
    pub fn parse(input: &[u8]) -> Result<FitFieldSide> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSide::from(valid_val)),
            None => Ok(FitFieldSide::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSide {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSide::Right,
            1 => FitFieldSide::Left,
            _ => FitFieldSide::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldRowExerciseName { // fit base type: uint16
    BarbellStraightLegDeadliftToRow, // 0
    CableRowStanding, // 1
    DumbbellRow, // 2
    ElevatedFeetInvertedRow, // 3
    WeightedElevatedFeetInvertedRow, // 4
    FacePull, // 5
    FacePullWithExternalRotation, // 6
    InvertedRowWithFeetOnSwissBall, // 7
    WeightedInvertedRowWithFeetOnSwissBall, // 8
    KettlebellRow, // 9
    ModifiedInvertedRow, // 10
    WeightedModifiedInvertedRow, // 11
    NeutralGripAlternatingDumbbellRow, // 12
    OneArmBentOverRow, // 13
    OneLeggedDumbbellRow, // 14
    RenegadeRow, // 15
    ReverseGripBarbellRow, // 16
    RopeHandleCableRow, // 17
    SeatedCableRow, // 18
    SeatedDumbbellRow, // 19
    SingleArmCableRow, // 20
    SingleArmCableRowAndRotation, // 21
    SingleArmInvertedRow, // 22
    WeightedSingleArmInvertedRow, // 23
    SingleArmNeutralGripDumbbellRow, // 24
    SingleArmNeutralGripDumbbellRowAndRotation, // 25
    SuspendedInvertedRow, // 26
    WeightedSuspendedInvertedRow, // 27
    TBarRow, // 28
    TowelGripInvertedRow, // 29
    WeightedTowelGripInvertedRow, // 30
    UnderhandGripCableRow, // 31
    VGripCableRow, // 32
    WideGripSeatedCableRow, // 33
    RowExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldRowExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldRowExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldRowExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldRowExerciseName::RowExerciseName(v)),
                }
            },
            None => Ok(FitFieldRowExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldRowExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldRowExerciseName::BarbellStraightLegDeadliftToRow,
            1 => FitFieldRowExerciseName::CableRowStanding,
            2 => FitFieldRowExerciseName::DumbbellRow,
            3 => FitFieldRowExerciseName::ElevatedFeetInvertedRow,
            4 => FitFieldRowExerciseName::WeightedElevatedFeetInvertedRow,
            5 => FitFieldRowExerciseName::FacePull,
            6 => FitFieldRowExerciseName::FacePullWithExternalRotation,
            7 => FitFieldRowExerciseName::InvertedRowWithFeetOnSwissBall,
            8 => FitFieldRowExerciseName::WeightedInvertedRowWithFeetOnSwissBall,
            9 => FitFieldRowExerciseName::KettlebellRow,
            10 => FitFieldRowExerciseName::ModifiedInvertedRow,
            11 => FitFieldRowExerciseName::WeightedModifiedInvertedRow,
            12 => FitFieldRowExerciseName::NeutralGripAlternatingDumbbellRow,
            13 => FitFieldRowExerciseName::OneArmBentOverRow,
            14 => FitFieldRowExerciseName::OneLeggedDumbbellRow,
            15 => FitFieldRowExerciseName::RenegadeRow,
            16 => FitFieldRowExerciseName::ReverseGripBarbellRow,
            17 => FitFieldRowExerciseName::RopeHandleCableRow,
            18 => FitFieldRowExerciseName::SeatedCableRow,
            19 => FitFieldRowExerciseName::SeatedDumbbellRow,
            20 => FitFieldRowExerciseName::SingleArmCableRow,
            21 => FitFieldRowExerciseName::SingleArmCableRowAndRotation,
            22 => FitFieldRowExerciseName::SingleArmInvertedRow,
            23 => FitFieldRowExerciseName::WeightedSingleArmInvertedRow,
            24 => FitFieldRowExerciseName::SingleArmNeutralGripDumbbellRow,
            25 => FitFieldRowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation,
            26 => FitFieldRowExerciseName::SuspendedInvertedRow,
            27 => FitFieldRowExerciseName::WeightedSuspendedInvertedRow,
            28 => FitFieldRowExerciseName::TBarRow,
            29 => FitFieldRowExerciseName::TowelGripInvertedRow,
            30 => FitFieldRowExerciseName::WeightedTowelGripInvertedRow,
            31 => FitFieldRowExerciseName::UnderhandGripCableRow,
            32 => FitFieldRowExerciseName::VGripCableRow,
            33 => FitFieldRowExerciseName::WideGripSeatedCableRow,
            _ => FitFieldRowExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAnalogWatchfaceLayout { // fit base type: enum
    Minimal = 0,
    Traditional = 1,
    Modern = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldAnalogWatchfaceLayout {
    pub fn parse(input: &[u8]) -> Result<FitFieldAnalogWatchfaceLayout> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldAnalogWatchfaceLayout::from(valid_val)),
            None => Ok(FitFieldAnalogWatchfaceLayout::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldAnalogWatchfaceLayout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAnalogWatchfaceLayout::Minimal,
            1 => FitFieldAnalogWatchfaceLayout::Traditional,
            2 => FitFieldAnalogWatchfaceLayout::Modern,
            _ => FitFieldAnalogWatchfaceLayout::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWeight { // fit base type: uint16
    Calculating, // 65534
    Weight(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldWeight {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldWeight> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    65534 => Ok(FitFieldWeight::from(valid_val)),
                    
                    v => Ok(FitFieldWeight::Weight(v)),
                }
            },
            None => Ok(FitFieldWeight::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldWeight {
    fn from(code: u16) -> Self {
        match code {
            65534 => FitFieldWeight::Calculating,
            _ => FitFieldWeight::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDiveGasStatus { // fit base type: enum
    Disabled = 0,
    Enabled = 1,
    BackupOnly = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDiveGasStatus {
    pub fn parse(input: &[u8]) -> Result<FitFieldDiveGasStatus> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDiveGasStatus::from(valid_val)),
            None => Ok(FitFieldDiveGasStatus::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDiveGasStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDiveGasStatus::Disabled,
            1 => FitFieldDiveGasStatus::Enabled,
            2 => FitFieldDiveGasStatus::BackupOnly,
            _ => FitFieldDiveGasStatus::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldIntensity { // fit base type: enum
    Active = 0,
    Rest = 1,
    Warmup = 2,
    Cooldown = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldIntensity {
    pub fn parse(input: &[u8]) -> Result<FitFieldIntensity> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldIntensity::from(valid_val)),
            None => Ok(FitFieldIntensity::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldIntensity {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldIntensity::Active,
            1 => FitFieldIntensity::Rest,
            2 => FitFieldIntensity::Warmup,
            3 => FitFieldIntensity::Cooldown,
            _ => FitFieldIntensity::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldConnectivityCapabilities { // fit base type: uint32z
    Bluetooth, // 1
    BluetoothLe, // 2
    Ant, // 4
    ActivityUpload, // 8
    CourseDownload, // 16
    WorkoutDownload, // 32
    LiveTrack, // 64
    WeatherConditions, // 128
    WeatherAlerts, // 256
    GpsEphemerisDownload, // 512
    ExplicitArchive, // 1024
    SetupIncomplete, // 2048
    ContinueSyncAfterSoftwareUpdate, // 4096
    ConnectIqAppDownload, // 8192
    GolfCourseDownload, // 16384
    DeviceInitiatesSync, // 32768  Indicates device is in control of initiating all syncs
    ConnectIqWatchAppDownload, // 65536
    ConnectIqWidgetDownload, // 131072
    ConnectIqWatchFaceDownload, // 262144
    ConnectIqDataFieldDownload, // 524288
    ConnectIqAppManagment, // 1048576  Device supports delete and reorder of apps via GCM
    SwingSensor, // 2097152
    SwingSensorRemote, // 4194304
    IncidentDetection, // 8388608  Device supports incident detection
    AudioPrompts, // 16777216
    WifiVerification, // 33554432  Device supports reporting wifi verification via GCM
    TrueUp, // 67108864  Device supports True Up
    FindMyWatch, // 134217728  Device supports Find My Watch
    RemoteManualSync, // 268435456
    LiveTrackAutoStart, // 536870912  Device supports LiveTrack auto start
    LiveTrackMessaging, // 1073741824  Device supports LiveTrack Messaging
    InstantInput, // 2147483648  Device supports instant input feature
    ConnectivityCapabilities(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldConnectivityCapabilities {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldConnectivityCapabilities> {
        let val = parse_uint32z(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    2 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    4 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    8 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    16 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    32 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    64 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    128 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    256 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    512 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    1024 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    2048 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    4096 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    8192 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    16384 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    32768 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    65536 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    131072 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    262144 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    524288 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    1048576 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    2097152 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    4194304 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    8388608 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    16777216 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    33554432 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    67108864 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    134217728 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    268435456 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    536870912 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    1073741824 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    2147483648 => Ok(FitFieldConnectivityCapabilities::from(valid_val)),
                    
                    v => Ok(FitFieldConnectivityCapabilities::ConnectivityCapabilities(v)),
                }
            },
            None => Ok(FitFieldConnectivityCapabilities::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldConnectivityCapabilities {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldConnectivityCapabilities::Bluetooth,
            2 => FitFieldConnectivityCapabilities::BluetoothLe,
            4 => FitFieldConnectivityCapabilities::Ant,
            8 => FitFieldConnectivityCapabilities::ActivityUpload,
            16 => FitFieldConnectivityCapabilities::CourseDownload,
            32 => FitFieldConnectivityCapabilities::WorkoutDownload,
            64 => FitFieldConnectivityCapabilities::LiveTrack,
            128 => FitFieldConnectivityCapabilities::WeatherConditions,
            256 => FitFieldConnectivityCapabilities::WeatherAlerts,
            512 => FitFieldConnectivityCapabilities::GpsEphemerisDownload,
            1024 => FitFieldConnectivityCapabilities::ExplicitArchive,
            2048 => FitFieldConnectivityCapabilities::SetupIncomplete,
            4096 => FitFieldConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate,
            8192 => FitFieldConnectivityCapabilities::ConnectIqAppDownload,
            16384 => FitFieldConnectivityCapabilities::GolfCourseDownload,
            32768 => FitFieldConnectivityCapabilities::DeviceInitiatesSync,
            65536 => FitFieldConnectivityCapabilities::ConnectIqWatchAppDownload,
            131072 => FitFieldConnectivityCapabilities::ConnectIqWidgetDownload,
            262144 => FitFieldConnectivityCapabilities::ConnectIqWatchFaceDownload,
            524288 => FitFieldConnectivityCapabilities::ConnectIqDataFieldDownload,
            1048576 => FitFieldConnectivityCapabilities::ConnectIqAppManagment,
            2097152 => FitFieldConnectivityCapabilities::SwingSensor,
            4194304 => FitFieldConnectivityCapabilities::SwingSensorRemote,
            8388608 => FitFieldConnectivityCapabilities::IncidentDetection,
            16777216 => FitFieldConnectivityCapabilities::AudioPrompts,
            33554432 => FitFieldConnectivityCapabilities::WifiVerification,
            67108864 => FitFieldConnectivityCapabilities::TrueUp,
            134217728 => FitFieldConnectivityCapabilities::FindMyWatch,
            268435456 => FitFieldConnectivityCapabilities::RemoteManualSync,
            536870912 => FitFieldConnectivityCapabilities::LiveTrackAutoStart,
            1073741824 => FitFieldConnectivityCapabilities::LiveTrackMessaging,
            2147483648 => FitFieldConnectivityCapabilities::InstantInput,
            _ => FitFieldConnectivityCapabilities::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSquatExerciseName { // fit base type: uint16
    LegPress, // 0
    BackSquatWithBodyBar, // 1
    BackSquats, // 2
    WeightedBackSquats, // 3
    BalancingSquat, // 4
    WeightedBalancingSquat, // 5
    BarbellBackSquat, // 6
    BarbellBoxSquat, // 7
    BarbellFrontSquat, // 8
    BarbellHackSquat, // 9
    BarbellHangSquatSnatch, // 10
    BarbellLateralStepUp, // 11
    BarbellQuarterSquat, // 12
    BarbellSiffSquat, // 13
    BarbellSquatSnatch, // 14
    BarbellSquatWithHeelsRaised, // 15
    BarbellStepover, // 16
    BarbellStepUp, // 17
    BenchSquatWithRotationalChop, // 18
    WeightedBenchSquatWithRotationalChop, // 19
    BodyWeightWallSquat, // 20
    WeightedWallSquat, // 21
    BoxStepSquat, // 22
    WeightedBoxStepSquat, // 23
    BracedSquat, // 24
    CrossedArmBarbellFrontSquat, // 25
    CrossoverDumbbellStepUp, // 26
    DumbbellFrontSquat, // 27
    DumbbellSplitSquat, // 28
    DumbbellSquat, // 29
    DumbbellSquatClean, // 30
    DumbbellStepover, // 31
    DumbbellStepUp, // 32
    ElevatedSingleLegSquat, // 33
    WeightedElevatedSingleLegSquat, // 34
    FigureFourSquats, // 35
    WeightedFigureFourSquats, // 36
    GobletSquat, // 37
    KettlebellSquat, // 38
    KettlebellSwingOverhead, // 39
    KettlebellSwingWithFlipToSquat, // 40
    LateralDumbbellStepUp, // 41
    OneLeggedSquat, // 42
    OverheadDumbbellSquat, // 43
    OverheadSquat, // 44
    PartialSingleLegSquat, // 45
    WeightedPartialSingleLegSquat, // 46
    PistolSquat, // 47
    WeightedPistolSquat, // 48
    PlieSlides, // 49
    WeightedPlieSlides, // 50
    PlieSquat, // 51
    WeightedPlieSquat, // 52
    PrisonerSquat, // 53
    WeightedPrisonerSquat, // 54
    SingleLegBenchGetUp, // 55
    WeightedSingleLegBenchGetUp, // 56
    SingleLegBenchSquat, // 57
    WeightedSingleLegBenchSquat, // 58
    SingleLegSquatOnSwissBall, // 59
    WeightedSingleLegSquatOnSwissBall, // 60
    Squat, // 61
    WeightedSquat, // 62
    SquatsWithBand, // 63
    StaggeredSquat, // 64
    WeightedStaggeredSquat, // 65
    StepUp, // 66
    WeightedStepUp, // 67
    SuitcaseSquats, // 68
    SumoSquat, // 69
    SumoSquatSlideIn, // 70
    WeightedSumoSquatSlideIn, // 71
    SumoSquatToHighPull, // 72
    SumoSquatToStand, // 73
    WeightedSumoSquatToStand, // 74
    SumoSquatWithRotation, // 75
    WeightedSumoSquatWithRotation, // 76
    SwissBallBodyWeightWallSquat, // 77
    WeightedSwissBallWallSquat, // 78
    Thrusters, // 79
    UnevenSquat, // 80
    WeightedUnevenSquat, // 81
    WaistSlimmingSquat, // 82
    WallBall, // 83
    WideStanceBarbellSquat, // 84
    WideStanceGobletSquat, // 85
    ZercherSquat, // 86
    KbsOverhead, // 87
    SquatAndSideKick, // 88
    SquatJumpsInNOut, // 89
    PilatesPlieSquatsParallelTurnedOutFlatAndHeels, // 90
    ReleveStraightLegAndKneeBentWithOneLegVariation, // 91
    SquatExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSquatExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldSquatExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    50 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    51 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    52 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    53 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    54 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    55 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    56 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    57 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    58 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    59 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    60 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    61 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    62 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    63 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    64 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    65 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    66 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    67 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    68 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    69 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    70 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    71 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    72 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    73 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    74 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    75 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    76 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    77 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    78 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    79 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    80 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    81 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    82 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    83 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    84 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    85 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    86 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    87 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    88 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    89 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    90 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    91 => Ok(FitFieldSquatExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldSquatExerciseName::SquatExerciseName(v)),
                }
            },
            None => Ok(FitFieldSquatExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldSquatExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldSquatExerciseName::LegPress,
            1 => FitFieldSquatExerciseName::BackSquatWithBodyBar,
            2 => FitFieldSquatExerciseName::BackSquats,
            3 => FitFieldSquatExerciseName::WeightedBackSquats,
            4 => FitFieldSquatExerciseName::BalancingSquat,
            5 => FitFieldSquatExerciseName::WeightedBalancingSquat,
            6 => FitFieldSquatExerciseName::BarbellBackSquat,
            7 => FitFieldSquatExerciseName::BarbellBoxSquat,
            8 => FitFieldSquatExerciseName::BarbellFrontSquat,
            9 => FitFieldSquatExerciseName::BarbellHackSquat,
            10 => FitFieldSquatExerciseName::BarbellHangSquatSnatch,
            11 => FitFieldSquatExerciseName::BarbellLateralStepUp,
            12 => FitFieldSquatExerciseName::BarbellQuarterSquat,
            13 => FitFieldSquatExerciseName::BarbellSiffSquat,
            14 => FitFieldSquatExerciseName::BarbellSquatSnatch,
            15 => FitFieldSquatExerciseName::BarbellSquatWithHeelsRaised,
            16 => FitFieldSquatExerciseName::BarbellStepover,
            17 => FitFieldSquatExerciseName::BarbellStepUp,
            18 => FitFieldSquatExerciseName::BenchSquatWithRotationalChop,
            19 => FitFieldSquatExerciseName::WeightedBenchSquatWithRotationalChop,
            20 => FitFieldSquatExerciseName::BodyWeightWallSquat,
            21 => FitFieldSquatExerciseName::WeightedWallSquat,
            22 => FitFieldSquatExerciseName::BoxStepSquat,
            23 => FitFieldSquatExerciseName::WeightedBoxStepSquat,
            24 => FitFieldSquatExerciseName::BracedSquat,
            25 => FitFieldSquatExerciseName::CrossedArmBarbellFrontSquat,
            26 => FitFieldSquatExerciseName::CrossoverDumbbellStepUp,
            27 => FitFieldSquatExerciseName::DumbbellFrontSquat,
            28 => FitFieldSquatExerciseName::DumbbellSplitSquat,
            29 => FitFieldSquatExerciseName::DumbbellSquat,
            30 => FitFieldSquatExerciseName::DumbbellSquatClean,
            31 => FitFieldSquatExerciseName::DumbbellStepover,
            32 => FitFieldSquatExerciseName::DumbbellStepUp,
            33 => FitFieldSquatExerciseName::ElevatedSingleLegSquat,
            34 => FitFieldSquatExerciseName::WeightedElevatedSingleLegSquat,
            35 => FitFieldSquatExerciseName::FigureFourSquats,
            36 => FitFieldSquatExerciseName::WeightedFigureFourSquats,
            37 => FitFieldSquatExerciseName::GobletSquat,
            38 => FitFieldSquatExerciseName::KettlebellSquat,
            39 => FitFieldSquatExerciseName::KettlebellSwingOverhead,
            40 => FitFieldSquatExerciseName::KettlebellSwingWithFlipToSquat,
            41 => FitFieldSquatExerciseName::LateralDumbbellStepUp,
            42 => FitFieldSquatExerciseName::OneLeggedSquat,
            43 => FitFieldSquatExerciseName::OverheadDumbbellSquat,
            44 => FitFieldSquatExerciseName::OverheadSquat,
            45 => FitFieldSquatExerciseName::PartialSingleLegSquat,
            46 => FitFieldSquatExerciseName::WeightedPartialSingleLegSquat,
            47 => FitFieldSquatExerciseName::PistolSquat,
            48 => FitFieldSquatExerciseName::WeightedPistolSquat,
            49 => FitFieldSquatExerciseName::PlieSlides,
            50 => FitFieldSquatExerciseName::WeightedPlieSlides,
            51 => FitFieldSquatExerciseName::PlieSquat,
            52 => FitFieldSquatExerciseName::WeightedPlieSquat,
            53 => FitFieldSquatExerciseName::PrisonerSquat,
            54 => FitFieldSquatExerciseName::WeightedPrisonerSquat,
            55 => FitFieldSquatExerciseName::SingleLegBenchGetUp,
            56 => FitFieldSquatExerciseName::WeightedSingleLegBenchGetUp,
            57 => FitFieldSquatExerciseName::SingleLegBenchSquat,
            58 => FitFieldSquatExerciseName::WeightedSingleLegBenchSquat,
            59 => FitFieldSquatExerciseName::SingleLegSquatOnSwissBall,
            60 => FitFieldSquatExerciseName::WeightedSingleLegSquatOnSwissBall,
            61 => FitFieldSquatExerciseName::Squat,
            62 => FitFieldSquatExerciseName::WeightedSquat,
            63 => FitFieldSquatExerciseName::SquatsWithBand,
            64 => FitFieldSquatExerciseName::StaggeredSquat,
            65 => FitFieldSquatExerciseName::WeightedStaggeredSquat,
            66 => FitFieldSquatExerciseName::StepUp,
            67 => FitFieldSquatExerciseName::WeightedStepUp,
            68 => FitFieldSquatExerciseName::SuitcaseSquats,
            69 => FitFieldSquatExerciseName::SumoSquat,
            70 => FitFieldSquatExerciseName::SumoSquatSlideIn,
            71 => FitFieldSquatExerciseName::WeightedSumoSquatSlideIn,
            72 => FitFieldSquatExerciseName::SumoSquatToHighPull,
            73 => FitFieldSquatExerciseName::SumoSquatToStand,
            74 => FitFieldSquatExerciseName::WeightedSumoSquatToStand,
            75 => FitFieldSquatExerciseName::SumoSquatWithRotation,
            76 => FitFieldSquatExerciseName::WeightedSumoSquatWithRotation,
            77 => FitFieldSquatExerciseName::SwissBallBodyWeightWallSquat,
            78 => FitFieldSquatExerciseName::WeightedSwissBallWallSquat,
            79 => FitFieldSquatExerciseName::Thrusters,
            80 => FitFieldSquatExerciseName::UnevenSquat,
            81 => FitFieldSquatExerciseName::WeightedUnevenSquat,
            82 => FitFieldSquatExerciseName::WaistSlimmingSquat,
            83 => FitFieldSquatExerciseName::WallBall,
            84 => FitFieldSquatExerciseName::WideStanceBarbellSquat,
            85 => FitFieldSquatExerciseName::WideStanceGobletSquat,
            86 => FitFieldSquatExerciseName::ZercherSquat,
            87 => FitFieldSquatExerciseName::KbsOverhead,
            88 => FitFieldSquatExerciseName::SquatAndSideKick,
            89 => FitFieldSquatExerciseName::SquatJumpsInNOut,
            90 => FitFieldSquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels,
            91 => FitFieldSquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation,
            _ => FitFieldSquatExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSport { // fit base type: enum
    Generic = 0,
    Running = 1,
    Cycling = 2,
    Transition = 3,  // Mulitsport transition
    FitnessEquipment = 4,
    Swimming = 5,
    Basketball = 6,
    Soccer = 7,
    Tennis = 8,
    AmericanFootball = 9,
    Training = 10,
    Walking = 11,
    CrossCountrySkiing = 12,
    AlpineSkiing = 13,
    Snowboarding = 14,
    Rowing = 15,
    Mountaineering = 16,
    Hiking = 17,
    Multisport = 18,
    Paddling = 19,
    Flying = 20,
    EBiking = 21,
    Motorcycling = 22,
    Boating = 23,
    Driving = 24,
    Golf = 25,
    HangGliding = 26,
    HorsebackRiding = 27,
    Hunting = 28,
    Fishing = 29,
    InlineSkating = 30,
    RockClimbing = 31,
    Sailing = 32,
    IceSkating = 33,
    SkyDiving = 34,
    Snowshoeing = 35,
    Snowmobiling = 36,
    StandUpPaddleboarding = 37,
    Surfing = 38,
    Wakeboarding = 39,
    WaterSkiing = 40,
    Kayaking = 41,
    Rafting = 42,
    Windsurfing = 43,
    Kitesurfing = 44,
    Tactical = 45,
    Jumpmaster = 46,
    Boxing = 47,
    FloorClimbing = 48,
    All = 254,  // All is for goals only to include all sports.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSport {
    pub fn parse(input: &[u8]) -> Result<FitFieldSport> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSport::from(valid_val)),
            None => Ok(FitFieldSport::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSport {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSport::Generic,
            1 => FitFieldSport::Running,
            2 => FitFieldSport::Cycling,
            3 => FitFieldSport::Transition,
            4 => FitFieldSport::FitnessEquipment,
            5 => FitFieldSport::Swimming,
            6 => FitFieldSport::Basketball,
            7 => FitFieldSport::Soccer,
            8 => FitFieldSport::Tennis,
            9 => FitFieldSport::AmericanFootball,
            10 => FitFieldSport::Training,
            11 => FitFieldSport::Walking,
            12 => FitFieldSport::CrossCountrySkiing,
            13 => FitFieldSport::AlpineSkiing,
            14 => FitFieldSport::Snowboarding,
            15 => FitFieldSport::Rowing,
            16 => FitFieldSport::Mountaineering,
            17 => FitFieldSport::Hiking,
            18 => FitFieldSport::Multisport,
            19 => FitFieldSport::Paddling,
            20 => FitFieldSport::Flying,
            21 => FitFieldSport::EBiking,
            22 => FitFieldSport::Motorcycling,
            23 => FitFieldSport::Boating,
            24 => FitFieldSport::Driving,
            25 => FitFieldSport::Golf,
            26 => FitFieldSport::HangGliding,
            27 => FitFieldSport::HorsebackRiding,
            28 => FitFieldSport::Hunting,
            29 => FitFieldSport::Fishing,
            30 => FitFieldSport::InlineSkating,
            31 => FitFieldSport::RockClimbing,
            32 => FitFieldSport::Sailing,
            33 => FitFieldSport::IceSkating,
            34 => FitFieldSport::SkyDiving,
            35 => FitFieldSport::Snowshoeing,
            36 => FitFieldSport::Snowmobiling,
            37 => FitFieldSport::StandUpPaddleboarding,
            38 => FitFieldSport::Surfing,
            39 => FitFieldSport::Wakeboarding,
            40 => FitFieldSport::WaterSkiing,
            41 => FitFieldSport::Kayaking,
            42 => FitFieldSport::Rafting,
            43 => FitFieldSport::Windsurfing,
            44 => FitFieldSport::Kitesurfing,
            45 => FitFieldSport::Tactical,
            46 => FitFieldSport::Jumpmaster,
            47 => FitFieldSport::Boxing,
            48 => FitFieldSport::FloorClimbing,
            254 => FitFieldSport::All,
            _ => FitFieldSport::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldEvent { // fit base type: enum
    Timer = 0,  // Group 0.  Start / stop_all
    Workout = 3,  // start / stop
    WorkoutStep = 4,  // Start at beginning of workout.  Stop at end of each step.
    PowerDown = 5,  // stop_all group 0
    PowerUp = 6,  // stop_all group 0
    OffCourse = 7,  // start / stop group 0
    Session = 8,  // Stop at end of each session.
    Lap = 9,  // Stop at end of each lap.
    CoursePoint = 10,  // marker
    Battery = 11,  // marker
    VirtualPartnerPace = 12,  // Group 1. Start at beginning of activity if VP enabled, when VP pace is changed during activity or VP enabled mid activity.  stop_disable when VP disabled.
    HrHighAlert = 13,  // Group 0.  Start / stop when in alert condition.
    HrLowAlert = 14,  // Group 0.  Start / stop when in alert condition.
    SpeedHighAlert = 15,  // Group 0.  Start / stop when in alert condition.
    SpeedLowAlert = 16,  // Group 0.  Start / stop when in alert condition.
    CadHighAlert = 17,  // Group 0.  Start / stop when in alert condition.
    CadLowAlert = 18,  // Group 0.  Start / stop when in alert condition.
    PowerHighAlert = 19,  // Group 0.  Start / stop when in alert condition.
    PowerLowAlert = 20,  // Group 0.  Start / stop when in alert condition.
    RecoveryHr = 21,  // marker
    BatteryLow = 22,  // marker
    TimeDurationAlert = 23,  // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
    DistanceDurationAlert = 24,  // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
    CalorieDurationAlert = 25,  // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
    Activity = 26,  // Group 1..  Stop at end of activity.
    FitnessEquipment = 27,  // marker
    Length = 28,  // Stop at end of each length.
    UserMarker = 32,  // marker
    SportPoint = 33,  // marker
    Calibration = 36,  // start/stop/marker
    FrontGearChange = 42,  // marker
    RearGearChange = 43,  // marker
    RiderPositionChange = 44,  // marker
    ElevHighAlert = 45,  // Group 0.  Start / stop when in alert condition.
    ElevLowAlert = 46,  // Group 0.  Start / stop when in alert condition.
    CommTimeout = 47,  // marker
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldEvent {
    pub fn parse(input: &[u8]) -> Result<FitFieldEvent> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldEvent::from(valid_val)),
            None => Ok(FitFieldEvent::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldEvent {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldEvent::Timer,
            3 => FitFieldEvent::Workout,
            4 => FitFieldEvent::WorkoutStep,
            5 => FitFieldEvent::PowerDown,
            6 => FitFieldEvent::PowerUp,
            7 => FitFieldEvent::OffCourse,
            8 => FitFieldEvent::Session,
            9 => FitFieldEvent::Lap,
            10 => FitFieldEvent::CoursePoint,
            11 => FitFieldEvent::Battery,
            12 => FitFieldEvent::VirtualPartnerPace,
            13 => FitFieldEvent::HrHighAlert,
            14 => FitFieldEvent::HrLowAlert,
            15 => FitFieldEvent::SpeedHighAlert,
            16 => FitFieldEvent::SpeedLowAlert,
            17 => FitFieldEvent::CadHighAlert,
            18 => FitFieldEvent::CadLowAlert,
            19 => FitFieldEvent::PowerHighAlert,
            20 => FitFieldEvent::PowerLowAlert,
            21 => FitFieldEvent::RecoveryHr,
            22 => FitFieldEvent::BatteryLow,
            23 => FitFieldEvent::TimeDurationAlert,
            24 => FitFieldEvent::DistanceDurationAlert,
            25 => FitFieldEvent::CalorieDurationAlert,
            26 => FitFieldEvent::Activity,
            27 => FitFieldEvent::FitnessEquipment,
            28 => FitFieldEvent::Length,
            32 => FitFieldEvent::UserMarker,
            33 => FitFieldEvent::SportPoint,
            36 => FitFieldEvent::Calibration,
            42 => FitFieldEvent::FrontGearChange,
            43 => FitFieldEvent::RearGearChange,
            44 => FitFieldEvent::RiderPositionChange,
            45 => FitFieldEvent::ElevHighAlert,
            46 => FitFieldEvent::ElevLowAlert,
            47 => FitFieldEvent::CommTimeout,
            _ => FitFieldEvent::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDisplayPower { // fit base type: enum
    Watts = 0,
    PercentFtp = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDisplayPower {
    pub fn parse(input: &[u8]) -> Result<FitFieldDisplayPower> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDisplayPower::from(valid_val)),
            None => Ok(FitFieldDisplayPower::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDisplayPower {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayPower::Watts,
            1 => FitFieldDisplayPower::PercentFtp,
            _ => FitFieldDisplayPower::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBikeLightNetworkConfigType { // fit base type: enum
    Auto = 0,
    Individual = 4,
    HighVisibility = 5,
    Trail = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldBikeLightNetworkConfigType {
    pub fn parse(input: &[u8]) -> Result<FitFieldBikeLightNetworkConfigType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldBikeLightNetworkConfigType::from(valid_val)),
            None => Ok(FitFieldBikeLightNetworkConfigType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldBikeLightNetworkConfigType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBikeLightNetworkConfigType::Auto,
            4 => FitFieldBikeLightNetworkConfigType::Individual,
            5 => FitFieldBikeLightNetworkConfigType::HighVisibility,
            6 => FitFieldBikeLightNetworkConfigType::Trail,
            _ => FitFieldBikeLightNetworkConfigType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBpStatus { // fit base type: enum
    NoError = 0,
    ErrorIncompleteData = 1,
    ErrorNoMeasurement = 2,
    ErrorDataOutOfRange = 3,
    ErrorIrregularHeartRate = 4,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldBpStatus {
    pub fn parse(input: &[u8]) -> Result<FitFieldBpStatus> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldBpStatus::from(valid_val)),
            None => Ok(FitFieldBpStatus::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldBpStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBpStatus::NoError,
            1 => FitFieldBpStatus::ErrorIncompleteData,
            2 => FitFieldBpStatus::ErrorNoMeasurement,
            3 => FitFieldBpStatus::ErrorDataOutOfRange,
            4 => FitFieldBpStatus::ErrorIrregularHeartRate,
            _ => FitFieldBpStatus::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldShoulderStabilityExerciseName { // fit base type: uint16
    NinetyDegreeCableExternalRotation, // 0
    BandExternalRotation, // 1
    BandInternalRotation, // 2
    BentArmLateralRaiseAndExternalRotation, // 3
    CableExternalRotation, // 4
    DumbbellFacePullWithExternalRotation, // 5
    FloorIRaise, // 6
    WeightedFloorIRaise, // 7
    FloorTRaise, // 8
    WeightedFloorTRaise, // 9
    FloorYRaise, // 10
    WeightedFloorYRaise, // 11
    InclineIRaise, // 12
    WeightedInclineIRaise, // 13
    InclineLRaise, // 14
    WeightedInclineLRaise, // 15
    InclineTRaise, // 16
    WeightedInclineTRaise, // 17
    InclineWRaise, // 18
    WeightedInclineWRaise, // 19
    InclineYRaise, // 20
    WeightedInclineYRaise, // 21
    LyingExternalRotation, // 22
    SeatedDumbbellExternalRotation, // 23
    StandingLRaise, // 24
    SwissBallIRaise, // 25
    WeightedSwissBallIRaise, // 26
    SwissBallTRaise, // 27
    WeightedSwissBallTRaise, // 28
    SwissBallWRaise, // 29
    WeightedSwissBallWRaise, // 30
    SwissBallYRaise, // 31
    WeightedSwissBallYRaise, // 32
    ShoulderStabilityExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldShoulderStabilityExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldShoulderStabilityExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldShoulderStabilityExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldShoulderStabilityExerciseName::ShoulderStabilityExerciseName(v)),
                }
            },
            None => Ok(FitFieldShoulderStabilityExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldShoulderStabilityExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldShoulderStabilityExerciseName::NinetyDegreeCableExternalRotation,
            1 => FitFieldShoulderStabilityExerciseName::BandExternalRotation,
            2 => FitFieldShoulderStabilityExerciseName::BandInternalRotation,
            3 => FitFieldShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation,
            4 => FitFieldShoulderStabilityExerciseName::CableExternalRotation,
            5 => FitFieldShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation,
            6 => FitFieldShoulderStabilityExerciseName::FloorIRaise,
            7 => FitFieldShoulderStabilityExerciseName::WeightedFloorIRaise,
            8 => FitFieldShoulderStabilityExerciseName::FloorTRaise,
            9 => FitFieldShoulderStabilityExerciseName::WeightedFloorTRaise,
            10 => FitFieldShoulderStabilityExerciseName::FloorYRaise,
            11 => FitFieldShoulderStabilityExerciseName::WeightedFloorYRaise,
            12 => FitFieldShoulderStabilityExerciseName::InclineIRaise,
            13 => FitFieldShoulderStabilityExerciseName::WeightedInclineIRaise,
            14 => FitFieldShoulderStabilityExerciseName::InclineLRaise,
            15 => FitFieldShoulderStabilityExerciseName::WeightedInclineLRaise,
            16 => FitFieldShoulderStabilityExerciseName::InclineTRaise,
            17 => FitFieldShoulderStabilityExerciseName::WeightedInclineTRaise,
            18 => FitFieldShoulderStabilityExerciseName::InclineWRaise,
            19 => FitFieldShoulderStabilityExerciseName::WeightedInclineWRaise,
            20 => FitFieldShoulderStabilityExerciseName::InclineYRaise,
            21 => FitFieldShoulderStabilityExerciseName::WeightedInclineYRaise,
            22 => FitFieldShoulderStabilityExerciseName::LyingExternalRotation,
            23 => FitFieldShoulderStabilityExerciseName::SeatedDumbbellExternalRotation,
            24 => FitFieldShoulderStabilityExerciseName::StandingLRaise,
            25 => FitFieldShoulderStabilityExerciseName::SwissBallIRaise,
            26 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallIRaise,
            27 => FitFieldShoulderStabilityExerciseName::SwissBallTRaise,
            28 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallTRaise,
            29 => FitFieldShoulderStabilityExerciseName::SwissBallWRaise,
            30 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallWRaise,
            31 => FitFieldShoulderStabilityExerciseName::SwissBallYRaise,
            32 => FitFieldShoulderStabilityExerciseName::WeightedSwissBallYRaise,
            _ => FitFieldShoulderStabilityExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDiveBacklightMode { // fit base type: enum
    AtDepth = 0,
    AlwaysOn = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDiveBacklightMode {
    pub fn parse(input: &[u8]) -> Result<FitFieldDiveBacklightMode> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDiveBacklightMode::from(valid_val)),
            None => Ok(FitFieldDiveBacklightMode::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDiveBacklightMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDiveBacklightMode::AtDepth,
            1 => FitFieldDiveBacklightMode::AlwaysOn,
            _ => FitFieldDiveBacklightMode::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBikeLightBeamAngleMode { // fit base type: uint8
    Manual, // 0
    Auto, // 1
    BikeLightBeamAngleMode(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldBikeLightBeamAngleMode {
    pub fn parse(input: &[u8]) -> Result<FitFieldBikeLightBeamAngleMode> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldBikeLightBeamAngleMode::from(valid_val)),
                    
                    1 => Ok(FitFieldBikeLightBeamAngleMode::from(valid_val)),
                    
                    v => Ok(FitFieldBikeLightBeamAngleMode::BikeLightBeamAngleMode(v)),
                }
            },
            None => Ok(FitFieldBikeLightBeamAngleMode::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldBikeLightBeamAngleMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBikeLightBeamAngleMode::Manual,
            1 => FitFieldBikeLightBeamAngleMode::Auto,
            _ => FitFieldBikeLightBeamAngleMode::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLocaltimeIntoDay { // fit base type: uint32
    LocaltimeIntoDay(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLocaltimeIntoDay {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldLocaltimeIntoDay> {
        let val = parse_uint32(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    v => Ok(FitFieldLocaltimeIntoDay::LocaltimeIntoDay(v)),
                }
            },
            None => Ok(FitFieldLocaltimeIntoDay::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldLocaltimeIntoDay {
    fn from(code: u32) -> Self {
        match code {
            _ => FitFieldLocaltimeIntoDay::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLegCurlExerciseName { // fit base type: uint16
    LegCurl, // 0
    WeightedLegCurl, // 1
    GoodMorning, // 2
    SeatedBarbellGoodMorning, // 3
    SingleLegBarbellGoodMorning, // 4
    SingleLegSlidingLegCurl, // 5
    SlidingLegCurl, // 6
    SplitBarbellGoodMorning, // 7
    SplitStanceExtension, // 8
    StaggeredStanceGoodMorning, // 9
    SwissBallHipRaiseAndLegCurl, // 10
    ZercherGoodMorning, // 11
    LegCurlExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLegCurlExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldLegCurlExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldLegCurlExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldLegCurlExerciseName::LegCurlExerciseName(v)),
                }
            },
            None => Ok(FitFieldLegCurlExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldLegCurlExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLegCurlExerciseName::LegCurl,
            1 => FitFieldLegCurlExerciseName::WeightedLegCurl,
            2 => FitFieldLegCurlExerciseName::GoodMorning,
            3 => FitFieldLegCurlExerciseName::SeatedBarbellGoodMorning,
            4 => FitFieldLegCurlExerciseName::SingleLegBarbellGoodMorning,
            5 => FitFieldLegCurlExerciseName::SingleLegSlidingLegCurl,
            6 => FitFieldLegCurlExerciseName::SlidingLegCurl,
            7 => FitFieldLegCurlExerciseName::SplitBarbellGoodMorning,
            8 => FitFieldLegCurlExerciseName::SplitStanceExtension,
            9 => FitFieldLegCurlExerciseName::StaggeredStanceGoodMorning,
            10 => FitFieldLegCurlExerciseName::SwissBallHipRaiseAndLegCurl,
            11 => FitFieldLegCurlExerciseName::ZercherGoodMorning,
            _ => FitFieldLegCurlExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWarmUpExerciseName { // fit base type: uint16
    QuadrupedRocking, // 0
    NeckTilts, // 1
    AnkleCircles, // 2
    AnkleDorsiflexionWithBand, // 3
    AnkleInternalRotation, // 4
    ArmCircles, // 5
    BentOverReachToSky, // 6
    CatCamel, // 7
    ElbowToFootLunge, // 8
    ForwardAndBackwardLegSwings, // 9
    Groiners, // 10
    InvertedHamstringStretch, // 11
    LateralDuckUnder, // 12
    NeckRotations, // 13
    OppositeArmAndLegBalance, // 14
    ReachRollAndLift, // 15
    Scorpion, // 16
    ShoulderCircles, // 17
    SideToSideLegSwings, // 18
    SleeperStretch, // 19
    SlideOut, // 20
    SwissBallHipCrossover, // 21
    SwissBallReachRollAndLift, // 22
    SwissBallWindshieldWipers, // 23
    ThoracicRotation, // 24
    WalkingHighKicks, // 25
    WalkingHighKnees, // 26
    WalkingKneeHugs, // 27
    WalkingLegCradles, // 28
    Walkout, // 29
    WalkoutFromPushUpPosition, // 30
    WarmUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldWarmUpExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldWarmUpExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldWarmUpExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldWarmUpExerciseName::WarmUpExerciseName(v)),
                }
            },
            None => Ok(FitFieldWarmUpExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldWarmUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldWarmUpExerciseName::QuadrupedRocking,
            1 => FitFieldWarmUpExerciseName::NeckTilts,
            2 => FitFieldWarmUpExerciseName::AnkleCircles,
            3 => FitFieldWarmUpExerciseName::AnkleDorsiflexionWithBand,
            4 => FitFieldWarmUpExerciseName::AnkleInternalRotation,
            5 => FitFieldWarmUpExerciseName::ArmCircles,
            6 => FitFieldWarmUpExerciseName::BentOverReachToSky,
            7 => FitFieldWarmUpExerciseName::CatCamel,
            8 => FitFieldWarmUpExerciseName::ElbowToFootLunge,
            9 => FitFieldWarmUpExerciseName::ForwardAndBackwardLegSwings,
            10 => FitFieldWarmUpExerciseName::Groiners,
            11 => FitFieldWarmUpExerciseName::InvertedHamstringStretch,
            12 => FitFieldWarmUpExerciseName::LateralDuckUnder,
            13 => FitFieldWarmUpExerciseName::NeckRotations,
            14 => FitFieldWarmUpExerciseName::OppositeArmAndLegBalance,
            15 => FitFieldWarmUpExerciseName::ReachRollAndLift,
            16 => FitFieldWarmUpExerciseName::Scorpion,
            17 => FitFieldWarmUpExerciseName::ShoulderCircles,
            18 => FitFieldWarmUpExerciseName::SideToSideLegSwings,
            19 => FitFieldWarmUpExerciseName::SleeperStretch,
            20 => FitFieldWarmUpExerciseName::SlideOut,
            21 => FitFieldWarmUpExerciseName::SwissBallHipCrossover,
            22 => FitFieldWarmUpExerciseName::SwissBallReachRollAndLift,
            23 => FitFieldWarmUpExerciseName::SwissBallWindshieldWipers,
            24 => FitFieldWarmUpExerciseName::ThoracicRotation,
            25 => FitFieldWarmUpExerciseName::WalkingHighKicks,
            26 => FitFieldWarmUpExerciseName::WalkingHighKnees,
            27 => FitFieldWarmUpExerciseName::WalkingKneeHugs,
            28 => FitFieldWarmUpExerciseName::WalkingLegCradles,
            29 => FitFieldWarmUpExerciseName::Walkout,
            30 => FitFieldWarmUpExerciseName::WalkoutFromPushUpPosition,
            _ => FitFieldWarmUpExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldShrugExerciseName { // fit base type: uint16
    BarbellJumpShrug, // 0
    BarbellShrug, // 1
    BarbellUprightRow, // 2
    BehindTheBackSmithMachineShrug, // 3
    DumbbellJumpShrug, // 4
    DumbbellShrug, // 5
    DumbbellUprightRow, // 6
    InclineDumbbellShrug, // 7
    OverheadBarbellShrug, // 8
    OverheadDumbbellShrug, // 9
    ScaptionAndShrug, // 10
    ScapularRetraction, // 11
    SerratusChairShrug, // 12
    WeightedSerratusChairShrug, // 13
    SerratusShrug, // 14
    WeightedSerratusShrug, // 15
    WideGripJumpShrug, // 16
    ShrugExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldShrugExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldShrugExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldShrugExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldShrugExerciseName::ShrugExerciseName(v)),
                }
            },
            None => Ok(FitFieldShrugExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldShrugExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldShrugExerciseName::BarbellJumpShrug,
            1 => FitFieldShrugExerciseName::BarbellShrug,
            2 => FitFieldShrugExerciseName::BarbellUprightRow,
            3 => FitFieldShrugExerciseName::BehindTheBackSmithMachineShrug,
            4 => FitFieldShrugExerciseName::DumbbellJumpShrug,
            5 => FitFieldShrugExerciseName::DumbbellShrug,
            6 => FitFieldShrugExerciseName::DumbbellUprightRow,
            7 => FitFieldShrugExerciseName::InclineDumbbellShrug,
            8 => FitFieldShrugExerciseName::OverheadBarbellShrug,
            9 => FitFieldShrugExerciseName::OverheadDumbbellShrug,
            10 => FitFieldShrugExerciseName::ScaptionAndShrug,
            11 => FitFieldShrugExerciseName::ScapularRetraction,
            12 => FitFieldShrugExerciseName::SerratusChairShrug,
            13 => FitFieldShrugExerciseName::WeightedSerratusChairShrug,
            14 => FitFieldShrugExerciseName::SerratusShrug,
            15 => FitFieldShrugExerciseName::WeightedSerratusShrug,
            16 => FitFieldShrugExerciseName::WideGripJumpShrug,
            _ => FitFieldShrugExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDisplayPosition { // fit base type: enum
    Degree = 0,  // dd.dddddd
    DegreeMinute = 1,  // dddmm.mmm
    DegreeMinuteSecond = 2,  // dddmmss
    AustrianGrid = 3,  // Austrian Grid (BMN)
    BritishGrid = 4,  // British National Grid
    DutchGrid = 5,  // Dutch grid system
    HungarianGrid = 6,  // Hungarian grid system
    FinnishGrid = 7,  // Finnish grid system Zone3 KKJ27
    GermanGrid = 8,  // Gausss Krueger (German)
    IcelandicGrid = 9,  // Icelandic Grid
    IndonesianEquatorial = 10,  // Indonesian Equatorial LCO
    IndonesianIrian = 11,  // Indonesian Irian LCO
    IndonesianSouthern = 12,  // Indonesian Southern LCO
    IndiaZone0 = 13,  // India zone 0
    IndiaZoneIA = 14,  // India zone IA
    IndiaZoneIB = 15,  // India zone IB
    IndiaZoneIIA = 16,  // India zone IIA
    IndiaZoneIIB = 17,  // India zone IIB
    IndiaZoneIIIA = 18,  // India zone IIIA
    IndiaZoneIIIB = 19,  // India zone IIIB
    IndiaZoneIVA = 20,  // India zone IVA
    IndiaZoneIVB = 21,  // India zone IVB
    IrishTransverse = 22,  // Irish Transverse Mercator
    IrishGrid = 23,  // Irish Grid
    Loran = 24,  // Loran TD
    MaidenheadGrid = 25,  // Maidenhead grid system
    MgrsGrid = 26,  // MGRS grid system
    NewZealandGrid = 27,  // New Zealand grid system
    NewZealandTransverse = 28,  // New Zealand Transverse Mercator
    QatarGrid = 29,  // Qatar National Grid
    ModifiedSwedishGrid = 30,  // Modified RT-90 (Sweden)
    SwedishGrid = 31,  // RT-90 (Sweden)
    SouthAfricanGrid = 32,  // South African Grid
    SwissGrid = 33,  // Swiss CH-1903 grid
    TaiwanGrid = 34,  // Taiwan Grid
    UnitedStatesGrid = 35,  // United States National Grid
    UtmUpsGrid = 36,  // UTM/UPS grid system
    WestMalayan = 37,  // West Malayan RSO
    BorneoRso = 38,  // Borneo RSO
    EstonianGrid = 39,  // Estonian grid system
    LatvianGrid = 40,  // Latvian Transverse Mercator
    SwedishRef99Grid = 41,  // Reference Grid 99 TM (Swedish)
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDisplayPosition {
    pub fn parse(input: &[u8]) -> Result<FitFieldDisplayPosition> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDisplayPosition::from(valid_val)),
            None => Ok(FitFieldDisplayPosition::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDisplayPosition {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayPosition::Degree,
            1 => FitFieldDisplayPosition::DegreeMinute,
            2 => FitFieldDisplayPosition::DegreeMinuteSecond,
            3 => FitFieldDisplayPosition::AustrianGrid,
            4 => FitFieldDisplayPosition::BritishGrid,
            5 => FitFieldDisplayPosition::DutchGrid,
            6 => FitFieldDisplayPosition::HungarianGrid,
            7 => FitFieldDisplayPosition::FinnishGrid,
            8 => FitFieldDisplayPosition::GermanGrid,
            9 => FitFieldDisplayPosition::IcelandicGrid,
            10 => FitFieldDisplayPosition::IndonesianEquatorial,
            11 => FitFieldDisplayPosition::IndonesianIrian,
            12 => FitFieldDisplayPosition::IndonesianSouthern,
            13 => FitFieldDisplayPosition::IndiaZone0,
            14 => FitFieldDisplayPosition::IndiaZoneIA,
            15 => FitFieldDisplayPosition::IndiaZoneIB,
            16 => FitFieldDisplayPosition::IndiaZoneIIA,
            17 => FitFieldDisplayPosition::IndiaZoneIIB,
            18 => FitFieldDisplayPosition::IndiaZoneIIIA,
            19 => FitFieldDisplayPosition::IndiaZoneIIIB,
            20 => FitFieldDisplayPosition::IndiaZoneIVA,
            21 => FitFieldDisplayPosition::IndiaZoneIVB,
            22 => FitFieldDisplayPosition::IrishTransverse,
            23 => FitFieldDisplayPosition::IrishGrid,
            24 => FitFieldDisplayPosition::Loran,
            25 => FitFieldDisplayPosition::MaidenheadGrid,
            26 => FitFieldDisplayPosition::MgrsGrid,
            27 => FitFieldDisplayPosition::NewZealandGrid,
            28 => FitFieldDisplayPosition::NewZealandTransverse,
            29 => FitFieldDisplayPosition::QatarGrid,
            30 => FitFieldDisplayPosition::ModifiedSwedishGrid,
            31 => FitFieldDisplayPosition::SwedishGrid,
            32 => FitFieldDisplayPosition::SouthAfricanGrid,
            33 => FitFieldDisplayPosition::SwissGrid,
            34 => FitFieldDisplayPosition::TaiwanGrid,
            35 => FitFieldDisplayPosition::UnitedStatesGrid,
            36 => FitFieldDisplayPosition::UtmUpsGrid,
            37 => FitFieldDisplayPosition::WestMalayan,
            38 => FitFieldDisplayPosition::BorneoRso,
            39 => FitFieldDisplayPosition::EstonianGrid,
            40 => FitFieldDisplayPosition::LatvianGrid,
            41 => FitFieldDisplayPosition::SwedishRef99Grid,
            _ => FitFieldDisplayPosition::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldGoalRecurrence { // fit base type: enum
    Off = 0,
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
    Yearly = 4,
    Custom = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldGoalRecurrence {
    pub fn parse(input: &[u8]) -> Result<FitFieldGoalRecurrence> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldGoalRecurrence::from(valid_val)),
            None => Ok(FitFieldGoalRecurrence::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldGoalRecurrence {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGoalRecurrence::Off,
            1 => FitFieldGoalRecurrence::Daily,
            2 => FitFieldGoalRecurrence::Weekly,
            3 => FitFieldGoalRecurrence::Monthly,
            4 => FitFieldGoalRecurrence::Yearly,
            5 => FitFieldGoalRecurrence::Custom,
            _ => FitFieldGoalRecurrence::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSchedule { // fit base type: enum
    Workout = 0,
    Course = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSchedule {
    pub fn parse(input: &[u8]) -> Result<FitFieldSchedule> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSchedule::from(valid_val)),
            None => Ok(FitFieldSchedule::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSchedule {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSchedule::Workout,
            1 => FitFieldSchedule::Course,
            _ => FitFieldSchedule::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSetType { // fit base type: uint8
    Rest, // 0
    Active, // 1
    SetType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSetType {
    pub fn parse(input: &[u8]) -> Result<FitFieldSetType> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldSetType::from(valid_val)),
                    
                    1 => Ok(FitFieldSetType::from(valid_val)),
                    
                    v => Ok(FitFieldSetType::SetType(v)),
                }
            },
            None => Ok(FitFieldSetType::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSetType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSetType::Rest,
            1 => FitFieldSetType::Active,
            _ => FitFieldSetType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLeftRightBalance100 { // fit base type: uint16
    Mask, // 16383  % contribution scaled by 100
    Right, // 32768  data corresponds to right if set, otherwise unknown
    LeftRightBalance100(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLeftRightBalance100 {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldLeftRightBalance100> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    16383 => Ok(FitFieldLeftRightBalance100::from(valid_val)),
                    
                    32768 => Ok(FitFieldLeftRightBalance100::from(valid_val)),
                    
                    v => Ok(FitFieldLeftRightBalance100::LeftRightBalance100(v)),
                }
            },
            None => Ok(FitFieldLeftRightBalance100::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldLeftRightBalance100 {
    fn from(code: u16) -> Self {
        match code {
            16383 => FitFieldLeftRightBalance100::Mask,
            32768 => FitFieldLeftRightBalance100::Right,
            _ => FitFieldLeftRightBalance100::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCommTimeoutType { // fit base type: uint16
    WildcardPairingTimeout, // 0  Timeout pairing to any device
    PairingTimeout, // 1  Timeout pairing to previously paired device
    ConnectionLost, // 2  Temporary loss of communications
    ConnectionTimeout, // 3  Connection closed due to extended bad communications
    CommTimeoutType(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCommTimeoutType {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCommTimeoutType> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCommTimeoutType::from(valid_val)),
                    
                    1 => Ok(FitFieldCommTimeoutType::from(valid_val)),
                    
                    2 => Ok(FitFieldCommTimeoutType::from(valid_val)),
                    
                    3 => Ok(FitFieldCommTimeoutType::from(valid_val)),
                    
                    v => Ok(FitFieldCommTimeoutType::CommTimeoutType(v)),
                }
            },
            None => Ok(FitFieldCommTimeoutType::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCommTimeoutType {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCommTimeoutType::WildcardPairingTimeout,
            1 => FitFieldCommTimeoutType::PairingTimeout,
            2 => FitFieldCommTimeoutType::ConnectionLost,
            3 => FitFieldCommTimeoutType::ConnectionTimeout,
            _ => FitFieldCommTimeoutType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCarryExerciseName { // fit base type: uint16
    BarHolds, // 0
    FarmersWalk, // 1
    FarmersWalkOnToes, // 2
    HexDumbbellHold, // 3
    OverheadCarry, // 4
    CarryExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCarryExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCarryExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCarryExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldCarryExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldCarryExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldCarryExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldCarryExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldCarryExerciseName::CarryExerciseName(v)),
                }
            },
            None => Ok(FitFieldCarryExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCarryExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCarryExerciseName::BarHolds,
            1 => FitFieldCarryExerciseName::FarmersWalk,
            2 => FitFieldCarryExerciseName::FarmersWalkOnToes,
            3 => FitFieldCarryExerciseName::HexDumbbellHold,
            4 => FitFieldCarryExerciseName::OverheadCarry,
            _ => FitFieldCarryExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSegmentLapStatus { // fit base type: enum
    End = 0,
    Fail = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSegmentLapStatus {
    pub fn parse(input: &[u8]) -> Result<FitFieldSegmentLapStatus> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSegmentLapStatus::from(valid_val)),
            None => Ok(FitFieldSegmentLapStatus::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSegmentLapStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentLapStatus::End,
            1 => FitFieldSegmentLapStatus::Fail,
            _ => FitFieldSegmentLapStatus::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSitUpExerciseName { // fit base type: uint16
    AlternatingSitUp, // 0
    WeightedAlternatingSitUp, // 1
    BentKneeVUp, // 2
    WeightedBentKneeVUp, // 3
    ButterflySitUp, // 4
    WeightedButterflySitup, // 5
    CrossPunchRollUp, // 6
    WeightedCrossPunchRollUp, // 7
    CrossedArmsSitUp, // 8
    WeightedCrossedArmsSitUp, // 9
    GetUpSitUp, // 10
    WeightedGetUpSitUp, // 11
    HoveringSitUp, // 12
    WeightedHoveringSitUp, // 13
    KettlebellSitUp, // 14
    MedicineBallAlternatingVUp, // 15
    MedicineBallSitUp, // 16
    MedicineBallVUp, // 17
    ModifiedSitUp, // 18
    NegativeSitUp, // 19
    OneArmFullSitUp, // 20
    RecliningCircle, // 21
    WeightedRecliningCircle, // 22
    ReverseCurlUp, // 23
    WeightedReverseCurlUp, // 24
    SingleLegSwissBallJackknife, // 25
    WeightedSingleLegSwissBallJackknife, // 26
    TheTeaser, // 27
    TheTeaserWeighted, // 28
    ThreePartRollDown, // 29
    WeightedThreePartRollDown, // 30
    VUp, // 31
    WeightedVUp, // 32
    WeightedRussianTwistOnSwissBall, // 33
    WeightedSitUp, // 34
    XAbs, // 35
    WeightedXAbs, // 36
    SitUp, // 37
    SitUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSitUpExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldSitUpExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldSitUpExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldSitUpExerciseName::SitUpExerciseName(v)),
                }
            },
            None => Ok(FitFieldSitUpExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldSitUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldSitUpExerciseName::AlternatingSitUp,
            1 => FitFieldSitUpExerciseName::WeightedAlternatingSitUp,
            2 => FitFieldSitUpExerciseName::BentKneeVUp,
            3 => FitFieldSitUpExerciseName::WeightedBentKneeVUp,
            4 => FitFieldSitUpExerciseName::ButterflySitUp,
            5 => FitFieldSitUpExerciseName::WeightedButterflySitup,
            6 => FitFieldSitUpExerciseName::CrossPunchRollUp,
            7 => FitFieldSitUpExerciseName::WeightedCrossPunchRollUp,
            8 => FitFieldSitUpExerciseName::CrossedArmsSitUp,
            9 => FitFieldSitUpExerciseName::WeightedCrossedArmsSitUp,
            10 => FitFieldSitUpExerciseName::GetUpSitUp,
            11 => FitFieldSitUpExerciseName::WeightedGetUpSitUp,
            12 => FitFieldSitUpExerciseName::HoveringSitUp,
            13 => FitFieldSitUpExerciseName::WeightedHoveringSitUp,
            14 => FitFieldSitUpExerciseName::KettlebellSitUp,
            15 => FitFieldSitUpExerciseName::MedicineBallAlternatingVUp,
            16 => FitFieldSitUpExerciseName::MedicineBallSitUp,
            17 => FitFieldSitUpExerciseName::MedicineBallVUp,
            18 => FitFieldSitUpExerciseName::ModifiedSitUp,
            19 => FitFieldSitUpExerciseName::NegativeSitUp,
            20 => FitFieldSitUpExerciseName::OneArmFullSitUp,
            21 => FitFieldSitUpExerciseName::RecliningCircle,
            22 => FitFieldSitUpExerciseName::WeightedRecliningCircle,
            23 => FitFieldSitUpExerciseName::ReverseCurlUp,
            24 => FitFieldSitUpExerciseName::WeightedReverseCurlUp,
            25 => FitFieldSitUpExerciseName::SingleLegSwissBallJackknife,
            26 => FitFieldSitUpExerciseName::WeightedSingleLegSwissBallJackknife,
            27 => FitFieldSitUpExerciseName::TheTeaser,
            28 => FitFieldSitUpExerciseName::TheTeaserWeighted,
            29 => FitFieldSitUpExerciseName::ThreePartRollDown,
            30 => FitFieldSitUpExerciseName::WeightedThreePartRollDown,
            31 => FitFieldSitUpExerciseName::VUp,
            32 => FitFieldSitUpExerciseName::WeightedVUp,
            33 => FitFieldSitUpExerciseName::WeightedRussianTwistOnSwissBall,
            34 => FitFieldSitUpExerciseName::WeightedSitUp,
            35 => FitFieldSitUpExerciseName::XAbs,
            36 => FitFieldSitUpExerciseName::WeightedXAbs,
            37 => FitFieldSitUpExerciseName::SitUp,
            _ => FitFieldSitUpExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldManufacturer { // fit base type: uint16
    Garmin, // 1
    GarminFr405Antfs, // 2  Do not use.  Used by FR405 for ANTFS man id.
    Zephyr, // 3
    Dayton, // 4
    Idt, // 5
    Srm, // 6
    Quarq, // 7
    Ibike, // 8
    Saris, // 9
    SparkHk, // 10
    Tanita, // 11
    Echowell, // 12
    DynastreamOem, // 13
    Nautilus, // 14
    Dynastream, // 15
    Timex, // 16
    Metrigear, // 17
    Xelic, // 18
    Beurer, // 19
    Cardiosport, // 20
    AAndD, // 21
    Hmm, // 22
    Suunto, // 23
    ThitaElektronik, // 24
    Gpulse, // 25
    CleanMobile, // 26
    PedalBrain, // 27
    Peaksware, // 28
    Saxonar, // 29
    LemondFitness, // 30
    Dexcom, // 31
    WahooFitness, // 32
    OctaneFitness, // 33
    Archinoetics, // 34
    TheHurtBox, // 35
    CitizenSystems, // 36
    Magellan, // 37
    Osynce, // 38
    Holux, // 39
    Concept2, // 40
    OneGiantLeap, // 42
    AceSensor, // 43
    BrimBrothers, // 44
    Xplova, // 45
    PerceptionDigital, // 46
    Bf1systems, // 47
    Pioneer, // 48
    Spantec, // 49
    Metalogics, // 50
    SeikoEpson, // 52
    SeikoEpsonOem, // 53
    IforPowell, // 54
    MaxwellGuider, // 55
    StarTrac, // 56
    Breakaway, // 57
    AlatechTechnologyLtd, // 58
    MioTechnologyEurope, // 59
    Rotor, // 60
    Geonaute, // 61
    IdBike, // 62
    Specialized, // 63
    Wtek, // 64
    PhysicalEnterprises, // 65
    NorthPoleEngineering, // 66
    Bkool, // 67
    Cateye, // 68
    StagesCycling, // 69
    Sigmasport, // 70
    Tomtom, // 71
    Peripedal, // 72
    Wattbike, // 73
    Moxy, // 76
    Ciclosport, // 77
    Powerbahn, // 78
    AcornProjectsAps, // 79
    Lifebeam, // 80
    Bontrager, // 81
    Wellgo, // 82
    Scosche, // 83
    Magura, // 84
    Woodway, // 85
    Elite, // 86
    NielsenKellerman, // 87
    DkCity, // 88
    Tacx, // 89
    DirectionTechnology, // 90
    Magtonic, // 91
    InsideRideTechnologies, // 93
    SoundOfMotion, // 94
    Stryd, // 95
    Icg, // 96  Indoorcycling Group
    MiPulse, // 97
    BsxAthletics, // 98
    Look, // 99
    CampagnoloSrl, // 100
    BodyBikeSmart, // 101
    Praxisworks, // 102
    LimitsTechnology, // 103  Limits Technology Ltd.
    TopactionTechnology, // 104  TopAction Technology Inc.
    Cosinuss, // 105
    Fitcare, // 106
    Magene, // 107
    GiantManufacturingCo, // 108
    Tigrasport, // 109  Tigrasport
    Salutron, // 110
    Technogym, // 111
    BrytonSensors, // 112
    LatitudeLimited, // 113
    SoaringTechnology, // 114
    Igpsport, // 115
    Thinkrider, // 116
    GopherSport, // 117
    Waterrower, // 118
    Orangetheory, // 119
    Inpeak, // 120
    Kinetic, // 121
    JohnsonHealthTech, // 122
    PolarElectro, // 123
    Seesense, // 124
    NciTechnology, // 125
    Iqsquare, // 126
    Development, // 255
    Healthandlife, // 257
    Lezyne, // 258
    ScribeLabs, // 259
    Zwift, // 260
    Watteam, // 261
    Recon, // 262
    FaveroElectronics, // 263
    Dynovelo, // 264
    Strava, // 265
    Precor, // 266  Amer Sports
    Bryton, // 267
    Sram, // 268
    Navman, // 269  MiTAC Global Corporation (Mio Technology)
    Cobi, // 270  COBI GmbH
    Spivi, // 271
    MioMagellan, // 272
    Evesports, // 273
    SensitivusGauge, // 274
    Podoon, // 275
    LifeTimeFitness, // 276
    FalcoEMotors, // 277  Falco eMotors Inc.
    Minoura, // 278
    Cycliq, // 279
    Luxottica, // 280
    TrainerRoad, // 281
    TheSufferfest, // 282
    Fullspeedahead, // 283
    Virtualtraining, // 284
    Feedbacksports, // 285
    Omata, // 286
    Vdo, // 287
    Magneticdays, // 288
    Hammerhead, // 289
    KineticByKurt, // 290
    Shapelog, // 291
    Dabuziduo, // 292
    Jetblack, // 293
    Coros, // 294
    Virtugo, // 295
    Velosense, // 296
    Cycligentinc, // 297
    Trailforks, // 298
    Actigraphcorp, // 5759
    Manufacturer(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldManufacturer {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldManufacturer> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    2 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    3 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    4 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    5 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    6 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    7 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    8 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    9 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    10 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    11 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    12 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    13 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    14 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    15 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    16 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    17 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    18 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    19 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    20 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    21 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    22 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    23 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    24 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    25 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    26 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    27 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    28 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    29 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    30 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    31 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    32 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    33 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    34 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    35 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    36 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    37 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    38 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    39 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    40 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    42 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    43 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    44 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    45 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    46 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    47 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    48 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    49 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    50 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    52 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    53 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    54 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    55 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    56 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    57 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    58 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    59 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    60 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    61 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    62 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    63 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    64 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    65 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    66 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    67 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    68 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    69 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    70 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    71 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    72 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    73 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    76 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    77 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    78 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    79 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    80 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    81 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    82 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    83 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    84 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    85 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    86 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    87 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    88 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    89 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    90 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    91 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    93 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    94 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    95 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    96 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    97 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    98 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    99 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    100 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    101 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    102 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    103 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    104 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    105 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    106 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    107 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    108 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    109 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    110 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    111 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    112 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    113 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    114 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    115 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    116 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    117 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    118 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    119 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    120 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    121 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    122 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    123 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    124 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    125 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    126 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    255 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    257 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    258 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    259 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    260 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    261 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    262 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    263 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    264 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    265 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    266 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    267 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    268 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    269 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    270 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    271 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    272 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    273 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    274 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    275 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    276 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    277 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    278 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    279 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    280 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    281 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    282 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    283 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    284 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    285 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    286 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    287 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    288 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    289 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    290 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    291 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    292 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    293 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    294 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    295 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    296 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    297 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    298 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    5759 => Ok(FitFieldManufacturer::from(valid_val)),
                    
                    v => Ok(FitFieldManufacturer::Manufacturer(v)),
                }
            },
            None => Ok(FitFieldManufacturer::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldManufacturer {
    fn from(code: u16) -> Self {
        match code {
            1 => FitFieldManufacturer::Garmin,
            2 => FitFieldManufacturer::GarminFr405Antfs,
            3 => FitFieldManufacturer::Zephyr,
            4 => FitFieldManufacturer::Dayton,
            5 => FitFieldManufacturer::Idt,
            6 => FitFieldManufacturer::Srm,
            7 => FitFieldManufacturer::Quarq,
            8 => FitFieldManufacturer::Ibike,
            9 => FitFieldManufacturer::Saris,
            10 => FitFieldManufacturer::SparkHk,
            11 => FitFieldManufacturer::Tanita,
            12 => FitFieldManufacturer::Echowell,
            13 => FitFieldManufacturer::DynastreamOem,
            14 => FitFieldManufacturer::Nautilus,
            15 => FitFieldManufacturer::Dynastream,
            16 => FitFieldManufacturer::Timex,
            17 => FitFieldManufacturer::Metrigear,
            18 => FitFieldManufacturer::Xelic,
            19 => FitFieldManufacturer::Beurer,
            20 => FitFieldManufacturer::Cardiosport,
            21 => FitFieldManufacturer::AAndD,
            22 => FitFieldManufacturer::Hmm,
            23 => FitFieldManufacturer::Suunto,
            24 => FitFieldManufacturer::ThitaElektronik,
            25 => FitFieldManufacturer::Gpulse,
            26 => FitFieldManufacturer::CleanMobile,
            27 => FitFieldManufacturer::PedalBrain,
            28 => FitFieldManufacturer::Peaksware,
            29 => FitFieldManufacturer::Saxonar,
            30 => FitFieldManufacturer::LemondFitness,
            31 => FitFieldManufacturer::Dexcom,
            32 => FitFieldManufacturer::WahooFitness,
            33 => FitFieldManufacturer::OctaneFitness,
            34 => FitFieldManufacturer::Archinoetics,
            35 => FitFieldManufacturer::TheHurtBox,
            36 => FitFieldManufacturer::CitizenSystems,
            37 => FitFieldManufacturer::Magellan,
            38 => FitFieldManufacturer::Osynce,
            39 => FitFieldManufacturer::Holux,
            40 => FitFieldManufacturer::Concept2,
            42 => FitFieldManufacturer::OneGiantLeap,
            43 => FitFieldManufacturer::AceSensor,
            44 => FitFieldManufacturer::BrimBrothers,
            45 => FitFieldManufacturer::Xplova,
            46 => FitFieldManufacturer::PerceptionDigital,
            47 => FitFieldManufacturer::Bf1systems,
            48 => FitFieldManufacturer::Pioneer,
            49 => FitFieldManufacturer::Spantec,
            50 => FitFieldManufacturer::Metalogics,
            52 => FitFieldManufacturer::SeikoEpson,
            53 => FitFieldManufacturer::SeikoEpsonOem,
            54 => FitFieldManufacturer::IforPowell,
            55 => FitFieldManufacturer::MaxwellGuider,
            56 => FitFieldManufacturer::StarTrac,
            57 => FitFieldManufacturer::Breakaway,
            58 => FitFieldManufacturer::AlatechTechnologyLtd,
            59 => FitFieldManufacturer::MioTechnologyEurope,
            60 => FitFieldManufacturer::Rotor,
            61 => FitFieldManufacturer::Geonaute,
            62 => FitFieldManufacturer::IdBike,
            63 => FitFieldManufacturer::Specialized,
            64 => FitFieldManufacturer::Wtek,
            65 => FitFieldManufacturer::PhysicalEnterprises,
            66 => FitFieldManufacturer::NorthPoleEngineering,
            67 => FitFieldManufacturer::Bkool,
            68 => FitFieldManufacturer::Cateye,
            69 => FitFieldManufacturer::StagesCycling,
            70 => FitFieldManufacturer::Sigmasport,
            71 => FitFieldManufacturer::Tomtom,
            72 => FitFieldManufacturer::Peripedal,
            73 => FitFieldManufacturer::Wattbike,
            76 => FitFieldManufacturer::Moxy,
            77 => FitFieldManufacturer::Ciclosport,
            78 => FitFieldManufacturer::Powerbahn,
            79 => FitFieldManufacturer::AcornProjectsAps,
            80 => FitFieldManufacturer::Lifebeam,
            81 => FitFieldManufacturer::Bontrager,
            82 => FitFieldManufacturer::Wellgo,
            83 => FitFieldManufacturer::Scosche,
            84 => FitFieldManufacturer::Magura,
            85 => FitFieldManufacturer::Woodway,
            86 => FitFieldManufacturer::Elite,
            87 => FitFieldManufacturer::NielsenKellerman,
            88 => FitFieldManufacturer::DkCity,
            89 => FitFieldManufacturer::Tacx,
            90 => FitFieldManufacturer::DirectionTechnology,
            91 => FitFieldManufacturer::Magtonic,
            93 => FitFieldManufacturer::InsideRideTechnologies,
            94 => FitFieldManufacturer::SoundOfMotion,
            95 => FitFieldManufacturer::Stryd,
            96 => FitFieldManufacturer::Icg,
            97 => FitFieldManufacturer::MiPulse,
            98 => FitFieldManufacturer::BsxAthletics,
            99 => FitFieldManufacturer::Look,
            100 => FitFieldManufacturer::CampagnoloSrl,
            101 => FitFieldManufacturer::BodyBikeSmart,
            102 => FitFieldManufacturer::Praxisworks,
            103 => FitFieldManufacturer::LimitsTechnology,
            104 => FitFieldManufacturer::TopactionTechnology,
            105 => FitFieldManufacturer::Cosinuss,
            106 => FitFieldManufacturer::Fitcare,
            107 => FitFieldManufacturer::Magene,
            108 => FitFieldManufacturer::GiantManufacturingCo,
            109 => FitFieldManufacturer::Tigrasport,
            110 => FitFieldManufacturer::Salutron,
            111 => FitFieldManufacturer::Technogym,
            112 => FitFieldManufacturer::BrytonSensors,
            113 => FitFieldManufacturer::LatitudeLimited,
            114 => FitFieldManufacturer::SoaringTechnology,
            115 => FitFieldManufacturer::Igpsport,
            116 => FitFieldManufacturer::Thinkrider,
            117 => FitFieldManufacturer::GopherSport,
            118 => FitFieldManufacturer::Waterrower,
            119 => FitFieldManufacturer::Orangetheory,
            120 => FitFieldManufacturer::Inpeak,
            121 => FitFieldManufacturer::Kinetic,
            122 => FitFieldManufacturer::JohnsonHealthTech,
            123 => FitFieldManufacturer::PolarElectro,
            124 => FitFieldManufacturer::Seesense,
            125 => FitFieldManufacturer::NciTechnology,
            126 => FitFieldManufacturer::Iqsquare,
            255 => FitFieldManufacturer::Development,
            257 => FitFieldManufacturer::Healthandlife,
            258 => FitFieldManufacturer::Lezyne,
            259 => FitFieldManufacturer::ScribeLabs,
            260 => FitFieldManufacturer::Zwift,
            261 => FitFieldManufacturer::Watteam,
            262 => FitFieldManufacturer::Recon,
            263 => FitFieldManufacturer::FaveroElectronics,
            264 => FitFieldManufacturer::Dynovelo,
            265 => FitFieldManufacturer::Strava,
            266 => FitFieldManufacturer::Precor,
            267 => FitFieldManufacturer::Bryton,
            268 => FitFieldManufacturer::Sram,
            269 => FitFieldManufacturer::Navman,
            270 => FitFieldManufacturer::Cobi,
            271 => FitFieldManufacturer::Spivi,
            272 => FitFieldManufacturer::MioMagellan,
            273 => FitFieldManufacturer::Evesports,
            274 => FitFieldManufacturer::SensitivusGauge,
            275 => FitFieldManufacturer::Podoon,
            276 => FitFieldManufacturer::LifeTimeFitness,
            277 => FitFieldManufacturer::FalcoEMotors,
            278 => FitFieldManufacturer::Minoura,
            279 => FitFieldManufacturer::Cycliq,
            280 => FitFieldManufacturer::Luxottica,
            281 => FitFieldManufacturer::TrainerRoad,
            282 => FitFieldManufacturer::TheSufferfest,
            283 => FitFieldManufacturer::Fullspeedahead,
            284 => FitFieldManufacturer::Virtualtraining,
            285 => FitFieldManufacturer::Feedbacksports,
            286 => FitFieldManufacturer::Omata,
            287 => FitFieldManufacturer::Vdo,
            288 => FitFieldManufacturer::Magneticdays,
            289 => FitFieldManufacturer::Hammerhead,
            290 => FitFieldManufacturer::KineticByKurt,
            291 => FitFieldManufacturer::Shapelog,
            292 => FitFieldManufacturer::Dabuziduo,
            293 => FitFieldManufacturer::Jetblack,
            294 => FitFieldManufacturer::Coros,
            295 => FitFieldManufacturer::Virtugo,
            296 => FitFieldManufacturer::Velosense,
            297 => FitFieldManufacturer::Cycligentinc,
            298 => FitFieldManufacturer::Trailforks,
            5759 => FitFieldManufacturer::Actigraphcorp,
            _ => FitFieldManufacturer::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLengthType { // fit base type: enum
    Idle = 0,  // Rest period. Length with no strokes
    Active = 1,  // Length with strokes.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldLengthType {
    pub fn parse(input: &[u8]) -> Result<FitFieldLengthType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldLengthType::from(valid_val)),
            None => Ok(FitFieldLengthType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldLengthType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldLengthType::Idle,
            1 => FitFieldLengthType::Active,
            _ => FitFieldLengthType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLanguage { // fit base type: enum
    English = 0,
    French = 1,
    Italian = 2,
    German = 3,
    Spanish = 4,
    Croatian = 5,
    Czech = 6,
    Danish = 7,
    Dutch = 8,
    Finnish = 9,
    Greek = 10,
    Hungarian = 11,
    Norwegian = 12,
    Polish = 13,
    Portuguese = 14,
    Slovakian = 15,
    Slovenian = 16,
    Swedish = 17,
    Russian = 18,
    Turkish = 19,
    Latvian = 20,
    Ukrainian = 21,
    Arabic = 22,
    Farsi = 23,
    Bulgarian = 24,
    Romanian = 25,
    Chinese = 26,
    Japanese = 27,
    Korean = 28,
    Taiwanese = 29,
    Thai = 30,
    Hebrew = 31,
    BrazilianPortuguese = 32,
    Indonesian = 33,
    Malaysian = 34,
    Vietnamese = 35,
    Burmese = 36,
    Mongolian = 37,
    Custom = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldLanguage {
    pub fn parse(input: &[u8]) -> Result<FitFieldLanguage> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldLanguage::from(valid_val)),
            None => Ok(FitFieldLanguage::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldLanguage {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldLanguage::English,
            1 => FitFieldLanguage::French,
            2 => FitFieldLanguage::Italian,
            3 => FitFieldLanguage::German,
            4 => FitFieldLanguage::Spanish,
            5 => FitFieldLanguage::Croatian,
            6 => FitFieldLanguage::Czech,
            7 => FitFieldLanguage::Danish,
            8 => FitFieldLanguage::Dutch,
            9 => FitFieldLanguage::Finnish,
            10 => FitFieldLanguage::Greek,
            11 => FitFieldLanguage::Hungarian,
            12 => FitFieldLanguage::Norwegian,
            13 => FitFieldLanguage::Polish,
            14 => FitFieldLanguage::Portuguese,
            15 => FitFieldLanguage::Slovakian,
            16 => FitFieldLanguage::Slovenian,
            17 => FitFieldLanguage::Swedish,
            18 => FitFieldLanguage::Russian,
            19 => FitFieldLanguage::Turkish,
            20 => FitFieldLanguage::Latvian,
            21 => FitFieldLanguage::Ukrainian,
            22 => FitFieldLanguage::Arabic,
            23 => FitFieldLanguage::Farsi,
            24 => FitFieldLanguage::Bulgarian,
            25 => FitFieldLanguage::Romanian,
            26 => FitFieldLanguage::Chinese,
            27 => FitFieldLanguage::Japanese,
            28 => FitFieldLanguage::Korean,
            29 => FitFieldLanguage::Taiwanese,
            30 => FitFieldLanguage::Thai,
            31 => FitFieldLanguage::Hebrew,
            32 => FitFieldLanguage::BrazilianPortuguese,
            33 => FitFieldLanguage::Indonesian,
            34 => FitFieldLanguage::Malaysian,
            35 => FitFieldLanguage::Vietnamese,
            36 => FitFieldLanguage::Burmese,
            37 => FitFieldLanguage::Mongolian,
            254 => FitFieldLanguage::Custom,
            _ => FitFieldLanguage::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldHipStabilityExerciseName { // fit base type: uint16
    BandSideLyingLegRaise, // 0
    DeadBug, // 1
    WeightedDeadBug, // 2
    ExternalHipRaise, // 3
    WeightedExternalHipRaise, // 4
    FireHydrantKicks, // 5
    WeightedFireHydrantKicks, // 6
    HipCircles, // 7
    WeightedHipCircles, // 8
    InnerThighLift, // 9
    WeightedInnerThighLift, // 10
    LateralWalksWithBandAtAnkles, // 11
    PretzelSideKick, // 12
    WeightedPretzelSideKick, // 13
    ProneHipInternalRotation, // 14
    WeightedProneHipInternalRotation, // 15
    Quadruped, // 16
    QuadrupedHipExtension, // 17
    WeightedQuadrupedHipExtension, // 18
    QuadrupedWithLegLift, // 19
    WeightedQuadrupedWithLegLift, // 20
    SideLyingLegRaise, // 21
    WeightedSideLyingLegRaise, // 22
    SlidingHipAdduction, // 23
    WeightedSlidingHipAdduction, // 24
    StandingAdduction, // 25
    WeightedStandingAdduction, // 26
    StandingCableHipAbduction, // 27
    StandingHipAbduction, // 28
    WeightedStandingHipAbduction, // 29
    StandingRearLegRaise, // 30
    WeightedStandingRearLegRaise, // 31
    SupineHipInternalRotation, // 32
    WeightedSupineHipInternalRotation, // 33
    HipStabilityExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldHipStabilityExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldHipStabilityExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldHipStabilityExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldHipStabilityExerciseName::HipStabilityExerciseName(v)),
                }
            },
            None => Ok(FitFieldHipStabilityExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldHipStabilityExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHipStabilityExerciseName::BandSideLyingLegRaise,
            1 => FitFieldHipStabilityExerciseName::DeadBug,
            2 => FitFieldHipStabilityExerciseName::WeightedDeadBug,
            3 => FitFieldHipStabilityExerciseName::ExternalHipRaise,
            4 => FitFieldHipStabilityExerciseName::WeightedExternalHipRaise,
            5 => FitFieldHipStabilityExerciseName::FireHydrantKicks,
            6 => FitFieldHipStabilityExerciseName::WeightedFireHydrantKicks,
            7 => FitFieldHipStabilityExerciseName::HipCircles,
            8 => FitFieldHipStabilityExerciseName::WeightedHipCircles,
            9 => FitFieldHipStabilityExerciseName::InnerThighLift,
            10 => FitFieldHipStabilityExerciseName::WeightedInnerThighLift,
            11 => FitFieldHipStabilityExerciseName::LateralWalksWithBandAtAnkles,
            12 => FitFieldHipStabilityExerciseName::PretzelSideKick,
            13 => FitFieldHipStabilityExerciseName::WeightedPretzelSideKick,
            14 => FitFieldHipStabilityExerciseName::ProneHipInternalRotation,
            15 => FitFieldHipStabilityExerciseName::WeightedProneHipInternalRotation,
            16 => FitFieldHipStabilityExerciseName::Quadruped,
            17 => FitFieldHipStabilityExerciseName::QuadrupedHipExtension,
            18 => FitFieldHipStabilityExerciseName::WeightedQuadrupedHipExtension,
            19 => FitFieldHipStabilityExerciseName::QuadrupedWithLegLift,
            20 => FitFieldHipStabilityExerciseName::WeightedQuadrupedWithLegLift,
            21 => FitFieldHipStabilityExerciseName::SideLyingLegRaise,
            22 => FitFieldHipStabilityExerciseName::WeightedSideLyingLegRaise,
            23 => FitFieldHipStabilityExerciseName::SlidingHipAdduction,
            24 => FitFieldHipStabilityExerciseName::WeightedSlidingHipAdduction,
            25 => FitFieldHipStabilityExerciseName::StandingAdduction,
            26 => FitFieldHipStabilityExerciseName::WeightedStandingAdduction,
            27 => FitFieldHipStabilityExerciseName::StandingCableHipAbduction,
            28 => FitFieldHipStabilityExerciseName::StandingHipAbduction,
            29 => FitFieldHipStabilityExerciseName::WeightedStandingHipAbduction,
            30 => FitFieldHipStabilityExerciseName::StandingRearLegRaise,
            31 => FitFieldHipStabilityExerciseName::WeightedStandingRearLegRaise,
            32 => FitFieldHipStabilityExerciseName::SupineHipInternalRotation,
            33 => FitFieldHipStabilityExerciseName::WeightedSupineHipInternalRotation,
            _ => FitFieldHipStabilityExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldActivityClass { // fit base type: enum
    Level = 127,  // 0 to 100
    LevelMax = 100,
    Athlete = 128,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldActivityClass {
    pub fn parse(input: &[u8]) -> Result<FitFieldActivityClass> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldActivityClass::from(valid_val)),
            None => Ok(FitFieldActivityClass::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldActivityClass {
    fn from(code: u8) -> Self {
        match code {
            127 => FitFieldActivityClass::Level,
            100 => FitFieldActivityClass::LevelMax,
            128 => FitFieldActivityClass::Athlete,
            _ => FitFieldActivityClass::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAttitudeValidity { // fit base type: uint16
    TrackAngleHeadingValid, // 1
    PitchValid, // 2
    RollValid, // 4
    LateralBodyAccelValid, // 8
    NormalBodyAccelValid, // 16
    TurnRateValid, // 32
    HwFail, // 64
    MagInvalid, // 128
    NoGps, // 256
    GpsInvalid, // 512
    SolutionCoasting, // 1024
    TrueTrackAngle, // 2048
    MagneticHeading, // 4096
    AttitudeValidity(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldAttitudeValidity {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldAttitudeValidity> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    2 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    4 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    8 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    16 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    32 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    64 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    128 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    256 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    512 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    1024 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    2048 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    4096 => Ok(FitFieldAttitudeValidity::from(valid_val)),
                    
                    v => Ok(FitFieldAttitudeValidity::AttitudeValidity(v)),
                }
            },
            None => Ok(FitFieldAttitudeValidity::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldAttitudeValidity {
    fn from(code: u16) -> Self {
        match code {
            1 => FitFieldAttitudeValidity::TrackAngleHeadingValid,
            2 => FitFieldAttitudeValidity::PitchValid,
            4 => FitFieldAttitudeValidity::RollValid,
            8 => FitFieldAttitudeValidity::LateralBodyAccelValid,
            16 => FitFieldAttitudeValidity::NormalBodyAccelValid,
            32 => FitFieldAttitudeValidity::TurnRateValid,
            64 => FitFieldAttitudeValidity::HwFail,
            128 => FitFieldAttitudeValidity::MagInvalid,
            256 => FitFieldAttitudeValidity::NoGps,
            512 => FitFieldAttitudeValidity::GpsInvalid,
            1024 => FitFieldAttitudeValidity::SolutionCoasting,
            2048 => FitFieldAttitudeValidity::TrueTrackAngle,
            4096 => FitFieldAttitudeValidity::MagneticHeading,
            _ => FitFieldAttitudeValidity::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFaveroProduct { // fit base type: uint16
    AssiomaUno, // 10
    AssiomaDuo, // 12
    FaveroProduct(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldFaveroProduct {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldFaveroProduct> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    10 => Ok(FitFieldFaveroProduct::from(valid_val)),
                    
                    12 => Ok(FitFieldFaveroProduct::from(valid_val)),
                    
                    v => Ok(FitFieldFaveroProduct::FaveroProduct(v)),
                }
            },
            None => Ok(FitFieldFaveroProduct::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldFaveroProduct {
    fn from(code: u16) -> Self {
        match code {
            10 => FitFieldFaveroProduct::AssiomaUno,
            12 => FitFieldFaveroProduct::AssiomaDuo,
            _ => FitFieldFaveroProduct::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDiveAlarmType { // fit base type: enum
    Depth = 0,
    Time = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDiveAlarmType {
    pub fn parse(input: &[u8]) -> Result<FitFieldDiveAlarmType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDiveAlarmType::from(valid_val)),
            None => Ok(FitFieldDiveAlarmType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDiveAlarmType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDiveAlarmType::Depth,
            1 => FitFieldDiveAlarmType::Time,
            _ => FitFieldDiveAlarmType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTimeZone { // fit base type: enum
    Almaty = 0,
    Bangkok = 1,
    Bombay = 2,
    Brasilia = 3,
    Cairo = 4,
    CapeVerdeIs = 5,
    Darwin = 6,
    Eniwetok = 7,
    Fiji = 8,
    HongKong = 9,
    Islamabad = 10,
    Kabul = 11,
    Magadan = 12,
    MidAtlantic = 13,
    Moscow = 14,
    Muscat = 15,
    Newfoundland = 16,
    Samoa = 17,
    Sydney = 18,
    Tehran = 19,
    Tokyo = 20,
    UsAlaska = 21,
    UsAtlantic = 22,
    UsCentral = 23,
    UsEastern = 24,
    UsHawaii = 25,
    UsMountain = 26,
    UsPacific = 27,
    Other = 28,
    Auckland = 29,
    Kathmandu = 30,
    EuropeWesternWet = 31,
    EuropeCentralCet = 32,
    EuropeEasternEet = 33,
    Jakarta = 34,
    Perth = 35,
    Adelaide = 36,
    Brisbane = 37,
    Tasmania = 38,
    Iceland = 39,
    Amsterdam = 40,
    Athens = 41,
    Barcelona = 42,
    Berlin = 43,
    Brussels = 44,
    Budapest = 45,
    Copenhagen = 46,
    Dublin = 47,
    Helsinki = 48,
    Lisbon = 49,
    London = 50,
    Madrid = 51,
    Munich = 52,
    Oslo = 53,
    Paris = 54,
    Prague = 55,
    Reykjavik = 56,
    Rome = 57,
    Stockholm = 58,
    Vienna = 59,
    Warsaw = 60,
    Zurich = 61,
    Quebec = 62,
    Ontario = 63,
    Manitoba = 64,
    Saskatchewan = 65,
    Alberta = 66,
    BritishColumbia = 67,
    Boise = 68,
    Boston = 69,
    Chicago = 70,
    Dallas = 71,
    Denver = 72,
    KansasCity = 73,
    LasVegas = 74,
    LosAngeles = 75,
    Miami = 76,
    Minneapolis = 77,
    NewYork = 78,
    NewOrleans = 79,
    Phoenix = 80,
    SantaFe = 81,
    Seattle = 82,
    WashingtonDc = 83,
    UsArizona = 84,
    Chita = 85,
    Ekaterinburg = 86,
    Irkutsk = 87,
    Kaliningrad = 88,
    Krasnoyarsk = 89,
    Novosibirsk = 90,
    PetropavlovskKamchatskiy = 91,
    Samara = 92,
    Vladivostok = 93,
    MexicoCentral = 94,
    MexicoMountain = 95,
    MexicoPacific = 96,
    CapeTown = 97,
    Winkhoek = 98,
    Lagos = 99,
    Riyahd = 100,
    Venezuela = 101,
    AustraliaLh = 102,
    Santiago = 103,
    Manual = 253,
    Automatic = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldTimeZone {
    pub fn parse(input: &[u8]) -> Result<FitFieldTimeZone> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldTimeZone::from(valid_val)),
            None => Ok(FitFieldTimeZone::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldTimeZone {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTimeZone::Almaty,
            1 => FitFieldTimeZone::Bangkok,
            2 => FitFieldTimeZone::Bombay,
            3 => FitFieldTimeZone::Brasilia,
            4 => FitFieldTimeZone::Cairo,
            5 => FitFieldTimeZone::CapeVerdeIs,
            6 => FitFieldTimeZone::Darwin,
            7 => FitFieldTimeZone::Eniwetok,
            8 => FitFieldTimeZone::Fiji,
            9 => FitFieldTimeZone::HongKong,
            10 => FitFieldTimeZone::Islamabad,
            11 => FitFieldTimeZone::Kabul,
            12 => FitFieldTimeZone::Magadan,
            13 => FitFieldTimeZone::MidAtlantic,
            14 => FitFieldTimeZone::Moscow,
            15 => FitFieldTimeZone::Muscat,
            16 => FitFieldTimeZone::Newfoundland,
            17 => FitFieldTimeZone::Samoa,
            18 => FitFieldTimeZone::Sydney,
            19 => FitFieldTimeZone::Tehran,
            20 => FitFieldTimeZone::Tokyo,
            21 => FitFieldTimeZone::UsAlaska,
            22 => FitFieldTimeZone::UsAtlantic,
            23 => FitFieldTimeZone::UsCentral,
            24 => FitFieldTimeZone::UsEastern,
            25 => FitFieldTimeZone::UsHawaii,
            26 => FitFieldTimeZone::UsMountain,
            27 => FitFieldTimeZone::UsPacific,
            28 => FitFieldTimeZone::Other,
            29 => FitFieldTimeZone::Auckland,
            30 => FitFieldTimeZone::Kathmandu,
            31 => FitFieldTimeZone::EuropeWesternWet,
            32 => FitFieldTimeZone::EuropeCentralCet,
            33 => FitFieldTimeZone::EuropeEasternEet,
            34 => FitFieldTimeZone::Jakarta,
            35 => FitFieldTimeZone::Perth,
            36 => FitFieldTimeZone::Adelaide,
            37 => FitFieldTimeZone::Brisbane,
            38 => FitFieldTimeZone::Tasmania,
            39 => FitFieldTimeZone::Iceland,
            40 => FitFieldTimeZone::Amsterdam,
            41 => FitFieldTimeZone::Athens,
            42 => FitFieldTimeZone::Barcelona,
            43 => FitFieldTimeZone::Berlin,
            44 => FitFieldTimeZone::Brussels,
            45 => FitFieldTimeZone::Budapest,
            46 => FitFieldTimeZone::Copenhagen,
            47 => FitFieldTimeZone::Dublin,
            48 => FitFieldTimeZone::Helsinki,
            49 => FitFieldTimeZone::Lisbon,
            50 => FitFieldTimeZone::London,
            51 => FitFieldTimeZone::Madrid,
            52 => FitFieldTimeZone::Munich,
            53 => FitFieldTimeZone::Oslo,
            54 => FitFieldTimeZone::Paris,
            55 => FitFieldTimeZone::Prague,
            56 => FitFieldTimeZone::Reykjavik,
            57 => FitFieldTimeZone::Rome,
            58 => FitFieldTimeZone::Stockholm,
            59 => FitFieldTimeZone::Vienna,
            60 => FitFieldTimeZone::Warsaw,
            61 => FitFieldTimeZone::Zurich,
            62 => FitFieldTimeZone::Quebec,
            63 => FitFieldTimeZone::Ontario,
            64 => FitFieldTimeZone::Manitoba,
            65 => FitFieldTimeZone::Saskatchewan,
            66 => FitFieldTimeZone::Alberta,
            67 => FitFieldTimeZone::BritishColumbia,
            68 => FitFieldTimeZone::Boise,
            69 => FitFieldTimeZone::Boston,
            70 => FitFieldTimeZone::Chicago,
            71 => FitFieldTimeZone::Dallas,
            72 => FitFieldTimeZone::Denver,
            73 => FitFieldTimeZone::KansasCity,
            74 => FitFieldTimeZone::LasVegas,
            75 => FitFieldTimeZone::LosAngeles,
            76 => FitFieldTimeZone::Miami,
            77 => FitFieldTimeZone::Minneapolis,
            78 => FitFieldTimeZone::NewYork,
            79 => FitFieldTimeZone::NewOrleans,
            80 => FitFieldTimeZone::Phoenix,
            81 => FitFieldTimeZone::SantaFe,
            82 => FitFieldTimeZone::Seattle,
            83 => FitFieldTimeZone::WashingtonDc,
            84 => FitFieldTimeZone::UsArizona,
            85 => FitFieldTimeZone::Chita,
            86 => FitFieldTimeZone::Ekaterinburg,
            87 => FitFieldTimeZone::Irkutsk,
            88 => FitFieldTimeZone::Kaliningrad,
            89 => FitFieldTimeZone::Krasnoyarsk,
            90 => FitFieldTimeZone::Novosibirsk,
            91 => FitFieldTimeZone::PetropavlovskKamchatskiy,
            92 => FitFieldTimeZone::Samara,
            93 => FitFieldTimeZone::Vladivostok,
            94 => FitFieldTimeZone::MexicoCentral,
            95 => FitFieldTimeZone::MexicoMountain,
            96 => FitFieldTimeZone::MexicoPacific,
            97 => FitFieldTimeZone::CapeTown,
            98 => FitFieldTimeZone::Winkhoek,
            99 => FitFieldTimeZone::Lagos,
            100 => FitFieldTimeZone::Riyahd,
            101 => FitFieldTimeZone::Venezuela,
            102 => FitFieldTimeZone::AustraliaLh,
            103 => FitFieldTimeZone::Santiago,
            253 => FitFieldTimeZone::Manual,
            254 => FitFieldTimeZone::Automatic,
            _ => FitFieldTimeZone::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSegmentSelectionType { // fit base type: enum
    Starred = 0,
    Suggested = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSegmentSelectionType {
    pub fn parse(input: &[u8]) -> Result<FitFieldSegmentSelectionType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSegmentSelectionType::from(valid_val)),
            None => Ok(FitFieldSegmentSelectionType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSegmentSelectionType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentSelectionType::Starred,
            1 => FitFieldSegmentSelectionType::Suggested,
            _ => FitFieldSegmentSelectionType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldUserLocalId { // fit base type: uint16
    LocalMin, // 0
    LocalMax, // 15
    StationaryMin, // 16
    StationaryMax, // 255
    PortableMin, // 256
    PortableMax, // 65534
    UserLocalId(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldUserLocalId {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldUserLocalId> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldUserLocalId::from(valid_val)),
                    
                    15 => Ok(FitFieldUserLocalId::from(valid_val)),
                    
                    16 => Ok(FitFieldUserLocalId::from(valid_val)),
                    
                    255 => Ok(FitFieldUserLocalId::from(valid_val)),
                    
                    256 => Ok(FitFieldUserLocalId::from(valid_val)),
                    
                    65534 => Ok(FitFieldUserLocalId::from(valid_val)),
                    
                    v => Ok(FitFieldUserLocalId::UserLocalId(v)),
                }
            },
            None => Ok(FitFieldUserLocalId::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldUserLocalId {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldUserLocalId::LocalMin,
            15 => FitFieldUserLocalId::LocalMax,
            16 => FitFieldUserLocalId::StationaryMin,
            255 => FitFieldUserLocalId::StationaryMax,
            256 => FitFieldUserLocalId::PortableMin,
            65534 => FitFieldUserLocalId::PortableMax,
            _ => FitFieldUserLocalId::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldHyperextensionExerciseName { // fit base type: uint16
    BackExtensionWithOppositeArmAndLegReach, // 0
    WeightedBackExtensionWithOppositeArmAndLegReach, // 1
    BaseRotations, // 2
    WeightedBaseRotations, // 3
    BentKneeReverseHyperextension, // 4
    WeightedBentKneeReverseHyperextension, // 5
    HollowHoldAndRoll, // 6
    WeightedHollowHoldAndRoll, // 7
    Kicks, // 8
    WeightedKicks, // 9
    KneeRaises, // 10
    WeightedKneeRaises, // 11
    KneelingSuperman, // 12
    WeightedKneelingSuperman, // 13
    LatPullDownWithRow, // 14
    MedicineBallDeadliftToReach, // 15
    OneArmOneLegRow, // 16
    OneArmRowWithBand, // 17
    OverheadLungeWithMedicineBall, // 18
    PlankKneeTucks, // 19
    WeightedPlankKneeTucks, // 20
    SideStep, // 21
    WeightedSideStep, // 22
    SingleLegBackExtension, // 23
    WeightedSingleLegBackExtension, // 24
    SpineExtension, // 25
    WeightedSpineExtension, // 26
    StaticBackExtension, // 27
    WeightedStaticBackExtension, // 28
    SupermanFromFloor, // 29
    WeightedSupermanFromFloor, // 30
    SwissBallBackExtension, // 31
    WeightedSwissBallBackExtension, // 32
    SwissBallHyperextension, // 33
    WeightedSwissBallHyperextension, // 34
    SwissBallOppositeArmAndLegLift, // 35
    WeightedSwissBallOppositeArmAndLegLift, // 36
    SupermanOnSwissBall, // 37
    Cobra, // 38
    SupineFloorBarre, // 39
    HyperextensionExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldHyperextensionExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldHyperextensionExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldHyperextensionExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldHyperextensionExerciseName::HyperextensionExerciseName(v)),
                }
            },
            None => Ok(FitFieldHyperextensionExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldHyperextensionExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach,
            1 => FitFieldHyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach,
            2 => FitFieldHyperextensionExerciseName::BaseRotations,
            3 => FitFieldHyperextensionExerciseName::WeightedBaseRotations,
            4 => FitFieldHyperextensionExerciseName::BentKneeReverseHyperextension,
            5 => FitFieldHyperextensionExerciseName::WeightedBentKneeReverseHyperextension,
            6 => FitFieldHyperextensionExerciseName::HollowHoldAndRoll,
            7 => FitFieldHyperextensionExerciseName::WeightedHollowHoldAndRoll,
            8 => FitFieldHyperextensionExerciseName::Kicks,
            9 => FitFieldHyperextensionExerciseName::WeightedKicks,
            10 => FitFieldHyperextensionExerciseName::KneeRaises,
            11 => FitFieldHyperextensionExerciseName::WeightedKneeRaises,
            12 => FitFieldHyperextensionExerciseName::KneelingSuperman,
            13 => FitFieldHyperextensionExerciseName::WeightedKneelingSuperman,
            14 => FitFieldHyperextensionExerciseName::LatPullDownWithRow,
            15 => FitFieldHyperextensionExerciseName::MedicineBallDeadliftToReach,
            16 => FitFieldHyperextensionExerciseName::OneArmOneLegRow,
            17 => FitFieldHyperextensionExerciseName::OneArmRowWithBand,
            18 => FitFieldHyperextensionExerciseName::OverheadLungeWithMedicineBall,
            19 => FitFieldHyperextensionExerciseName::PlankKneeTucks,
            20 => FitFieldHyperextensionExerciseName::WeightedPlankKneeTucks,
            21 => FitFieldHyperextensionExerciseName::SideStep,
            22 => FitFieldHyperextensionExerciseName::WeightedSideStep,
            23 => FitFieldHyperextensionExerciseName::SingleLegBackExtension,
            24 => FitFieldHyperextensionExerciseName::WeightedSingleLegBackExtension,
            25 => FitFieldHyperextensionExerciseName::SpineExtension,
            26 => FitFieldHyperextensionExerciseName::WeightedSpineExtension,
            27 => FitFieldHyperextensionExerciseName::StaticBackExtension,
            28 => FitFieldHyperextensionExerciseName::WeightedStaticBackExtension,
            29 => FitFieldHyperextensionExerciseName::SupermanFromFloor,
            30 => FitFieldHyperextensionExerciseName::WeightedSupermanFromFloor,
            31 => FitFieldHyperextensionExerciseName::SwissBallBackExtension,
            32 => FitFieldHyperextensionExerciseName::WeightedSwissBallBackExtension,
            33 => FitFieldHyperextensionExerciseName::SwissBallHyperextension,
            34 => FitFieldHyperextensionExerciseName::WeightedSwissBallHyperextension,
            35 => FitFieldHyperextensionExerciseName::SwissBallOppositeArmAndLegLift,
            36 => FitFieldHyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift,
            37 => FitFieldHyperextensionExerciseName::SupermanOnSwissBall,
            38 => FitFieldHyperextensionExerciseName::Cobra,
            39 => FitFieldHyperextensionExerciseName::SupineFloorBarre,
            _ => FitFieldHyperextensionExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldExdDescriptors { // fit base type: enum
    BikeLightBatteryStatus = 0,
    BeamAngleStatus = 1,
    BateryLevel = 2,
    LightNetworkMode = 3,
    NumberLightsConnected = 4,
    Cadence = 5,
    Distance = 6,
    EstimatedTimeOfArrival = 7,
    Heading = 8,
    Time = 9,
    BatteryLevel = 10,
    TrainerResistance = 11,
    TrainerTargetPower = 12,
    TimeSeated = 13,
    TimeStanding = 14,
    Elevation = 15,
    Grade = 16,
    Ascent = 17,
    Descent = 18,
    VerticalSpeed = 19,
    Di2BatteryLevel = 20,
    FrontGear = 21,
    RearGear = 22,
    GearRatio = 23,
    HeartRate = 24,
    HeartRateZone = 25,
    TimeInHeartRateZone = 26,
    HeartRateReserve = 27,
    Calories = 28,
    GpsAccuracy = 29,
    GpsSignalStrength = 30,
    Temperature = 31,
    TimeOfDay = 32,
    Balance = 33,
    PedalSmoothness = 34,
    Power = 35,
    FunctionalThresholdPower = 36,
    IntensityFactor = 37,
    Work = 38,
    PowerRatio = 39,
    NormalizedPower = 40,
    TrainingStressScore = 41,
    TimeOnZone = 42,
    Speed = 43,
    Laps = 44,
    Reps = 45,
    WorkoutStep = 46,
    CourseDistance = 47,
    NavigationDistance = 48,
    CourseEstimatedTimeOfArrival = 49,
    NavigationEstimatedTimeOfArrival = 50,
    CourseTime = 51,
    NavigationTime = 52,
    CourseHeading = 53,
    NavigationHeading = 54,
    PowerZone = 55,
    TorqueEffectiveness = 56,
    TimerTime = 57,
    PowerWeightRatio = 58,
    LeftPlatformCenterOffset = 59,
    RightPlatformCenterOffset = 60,
    LeftPowerPhaseStartAngle = 61,
    RightPowerPhaseStartAngle = 62,
    LeftPowerPhaseFinishAngle = 63,
    RightPowerPhaseFinishAngle = 64,
    Gears = 65,  // Combined gear information
    Pace = 66,
    TrainingEffect = 67,
    VerticalOscillation = 68,
    VerticalRatio = 69,
    GroundContactTime = 70,
    LeftGroundContactTimeBalance = 71,
    RightGroundContactTimeBalance = 72,
    StrideLength = 73,
    RunningCadence = 74,
    PerformanceCondition = 75,
    CourseType = 76,
    TimeInPowerZone = 77,
    NavigationTurn = 78,
    CourseLocation = 79,
    NavigationLocation = 80,
    Compass = 81,
    GearCombo = 82,
    MuscleOxygen = 83,
    Icon = 84,
    CompassHeading = 85,
    GpsHeading = 86,
    GpsElevation = 87,
    AnaerobicTrainingEffect = 88,
    Course = 89,
    OffCourse = 90,
    GlideRatio = 91,
    VerticalDistance = 92,
    Vmg = 93,
    AmbientPressure = 94,
    Pressure = 95,
    Vam = 96,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldExdDescriptors {
    pub fn parse(input: &[u8]) -> Result<FitFieldExdDescriptors> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldExdDescriptors::from(valid_val)),
            None => Ok(FitFieldExdDescriptors::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldExdDescriptors {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdDescriptors::BikeLightBatteryStatus,
            1 => FitFieldExdDescriptors::BeamAngleStatus,
            2 => FitFieldExdDescriptors::BateryLevel,
            3 => FitFieldExdDescriptors::LightNetworkMode,
            4 => FitFieldExdDescriptors::NumberLightsConnected,
            5 => FitFieldExdDescriptors::Cadence,
            6 => FitFieldExdDescriptors::Distance,
            7 => FitFieldExdDescriptors::EstimatedTimeOfArrival,
            8 => FitFieldExdDescriptors::Heading,
            9 => FitFieldExdDescriptors::Time,
            10 => FitFieldExdDescriptors::BatteryLevel,
            11 => FitFieldExdDescriptors::TrainerResistance,
            12 => FitFieldExdDescriptors::TrainerTargetPower,
            13 => FitFieldExdDescriptors::TimeSeated,
            14 => FitFieldExdDescriptors::TimeStanding,
            15 => FitFieldExdDescriptors::Elevation,
            16 => FitFieldExdDescriptors::Grade,
            17 => FitFieldExdDescriptors::Ascent,
            18 => FitFieldExdDescriptors::Descent,
            19 => FitFieldExdDescriptors::VerticalSpeed,
            20 => FitFieldExdDescriptors::Di2BatteryLevel,
            21 => FitFieldExdDescriptors::FrontGear,
            22 => FitFieldExdDescriptors::RearGear,
            23 => FitFieldExdDescriptors::GearRatio,
            24 => FitFieldExdDescriptors::HeartRate,
            25 => FitFieldExdDescriptors::HeartRateZone,
            26 => FitFieldExdDescriptors::TimeInHeartRateZone,
            27 => FitFieldExdDescriptors::HeartRateReserve,
            28 => FitFieldExdDescriptors::Calories,
            29 => FitFieldExdDescriptors::GpsAccuracy,
            30 => FitFieldExdDescriptors::GpsSignalStrength,
            31 => FitFieldExdDescriptors::Temperature,
            32 => FitFieldExdDescriptors::TimeOfDay,
            33 => FitFieldExdDescriptors::Balance,
            34 => FitFieldExdDescriptors::PedalSmoothness,
            35 => FitFieldExdDescriptors::Power,
            36 => FitFieldExdDescriptors::FunctionalThresholdPower,
            37 => FitFieldExdDescriptors::IntensityFactor,
            38 => FitFieldExdDescriptors::Work,
            39 => FitFieldExdDescriptors::PowerRatio,
            40 => FitFieldExdDescriptors::NormalizedPower,
            41 => FitFieldExdDescriptors::TrainingStressScore,
            42 => FitFieldExdDescriptors::TimeOnZone,
            43 => FitFieldExdDescriptors::Speed,
            44 => FitFieldExdDescriptors::Laps,
            45 => FitFieldExdDescriptors::Reps,
            46 => FitFieldExdDescriptors::WorkoutStep,
            47 => FitFieldExdDescriptors::CourseDistance,
            48 => FitFieldExdDescriptors::NavigationDistance,
            49 => FitFieldExdDescriptors::CourseEstimatedTimeOfArrival,
            50 => FitFieldExdDescriptors::NavigationEstimatedTimeOfArrival,
            51 => FitFieldExdDescriptors::CourseTime,
            52 => FitFieldExdDescriptors::NavigationTime,
            53 => FitFieldExdDescriptors::CourseHeading,
            54 => FitFieldExdDescriptors::NavigationHeading,
            55 => FitFieldExdDescriptors::PowerZone,
            56 => FitFieldExdDescriptors::TorqueEffectiveness,
            57 => FitFieldExdDescriptors::TimerTime,
            58 => FitFieldExdDescriptors::PowerWeightRatio,
            59 => FitFieldExdDescriptors::LeftPlatformCenterOffset,
            60 => FitFieldExdDescriptors::RightPlatformCenterOffset,
            61 => FitFieldExdDescriptors::LeftPowerPhaseStartAngle,
            62 => FitFieldExdDescriptors::RightPowerPhaseStartAngle,
            63 => FitFieldExdDescriptors::LeftPowerPhaseFinishAngle,
            64 => FitFieldExdDescriptors::RightPowerPhaseFinishAngle,
            65 => FitFieldExdDescriptors::Gears,
            66 => FitFieldExdDescriptors::Pace,
            67 => FitFieldExdDescriptors::TrainingEffect,
            68 => FitFieldExdDescriptors::VerticalOscillation,
            69 => FitFieldExdDescriptors::VerticalRatio,
            70 => FitFieldExdDescriptors::GroundContactTime,
            71 => FitFieldExdDescriptors::LeftGroundContactTimeBalance,
            72 => FitFieldExdDescriptors::RightGroundContactTimeBalance,
            73 => FitFieldExdDescriptors::StrideLength,
            74 => FitFieldExdDescriptors::RunningCadence,
            75 => FitFieldExdDescriptors::PerformanceCondition,
            76 => FitFieldExdDescriptors::CourseType,
            77 => FitFieldExdDescriptors::TimeInPowerZone,
            78 => FitFieldExdDescriptors::NavigationTurn,
            79 => FitFieldExdDescriptors::CourseLocation,
            80 => FitFieldExdDescriptors::NavigationLocation,
            81 => FitFieldExdDescriptors::Compass,
            82 => FitFieldExdDescriptors::GearCombo,
            83 => FitFieldExdDescriptors::MuscleOxygen,
            84 => FitFieldExdDescriptors::Icon,
            85 => FitFieldExdDescriptors::CompassHeading,
            86 => FitFieldExdDescriptors::GpsHeading,
            87 => FitFieldExdDescriptors::GpsElevation,
            88 => FitFieldExdDescriptors::AnaerobicTrainingEffect,
            89 => FitFieldExdDescriptors::Course,
            90 => FitFieldExdDescriptors::OffCourse,
            91 => FitFieldExdDescriptors::GlideRatio,
            92 => FitFieldExdDescriptors::VerticalDistance,
            93 => FitFieldExdDescriptors::Vmg,
            94 => FitFieldExdDescriptors::AmbientPressure,
            95 => FitFieldExdDescriptors::Pressure,
            96 => FitFieldExdDescriptors::Vam,
            _ => FitFieldExdDescriptors::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldActivityType { // fit base type: enum
    Generic = 0,
    Running = 1,
    Cycling = 2,
    Transition = 3,  // Mulitsport transition
    FitnessEquipment = 4,
    Swimming = 5,
    Walking = 6,
    Sedentary = 8,
    All = 254,  // All is for goals only to include all sports.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldActivityType {
    pub fn parse(input: &[u8]) -> Result<FitFieldActivityType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldActivityType::from(valid_val)),
            None => Ok(FitFieldActivityType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldActivityType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivityType::Generic,
            1 => FitFieldActivityType::Running,
            2 => FitFieldActivityType::Cycling,
            3 => FitFieldActivityType::Transition,
            4 => FitFieldActivityType::FitnessEquipment,
            5 => FitFieldActivityType::Swimming,
            6 => FitFieldActivityType::Walking,
            8 => FitFieldActivityType::Sedentary,
            254 => FitFieldActivityType::All,
            _ => FitFieldActivityType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTone { // fit base type: enum
    Off = 0,
    Tone = 1,
    Vibrate = 2,
    ToneAndVibrate = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldTone {
    pub fn parse(input: &[u8]) -> Result<FitFieldTone> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldTone::from(valid_val)),
            None => Ok(FitFieldTone::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldTone {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTone::Off,
            1 => FitFieldTone::Tone,
            2 => FitFieldTone::Vibrate,
            3 => FitFieldTone::ToneAndVibrate,
            _ => FitFieldTone::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAutolapTrigger { // fit base type: enum
    Time = 0,
    Distance = 1,
    PositionStart = 2,
    PositionLap = 3,
    PositionWaypoint = 4,
    PositionMarked = 5,
    Off = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldAutolapTrigger {
    pub fn parse(input: &[u8]) -> Result<FitFieldAutolapTrigger> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldAutolapTrigger::from(valid_val)),
            None => Ok(FitFieldAutolapTrigger::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldAutolapTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAutolapTrigger::Time,
            1 => FitFieldAutolapTrigger::Distance,
            2 => FitFieldAutolapTrigger::PositionStart,
            3 => FitFieldAutolapTrigger::PositionLap,
            4 => FitFieldAutolapTrigger::PositionWaypoint,
            5 => FitFieldAutolapTrigger::PositionMarked,
            6 => FitFieldAutolapTrigger::Off,
            _ => FitFieldAutolapTrigger::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBacklightMode { // fit base type: enum
    Off = 0,
    Manual = 1,
    KeyAndMessages = 2,
    AutoBrightness = 3,
    SmartNotifications = 4,
    KeyAndMessagesNight = 5,
    KeyAndMessagesAndSmartNotifications = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldBacklightMode {
    pub fn parse(input: &[u8]) -> Result<FitFieldBacklightMode> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldBacklightMode::from(valid_val)),
            None => Ok(FitFieldBacklightMode::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldBacklightMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBacklightMode::Off,
            1 => FitFieldBacklightMode::Manual,
            2 => FitFieldBacklightMode::KeyAndMessages,
            3 => FitFieldBacklightMode::AutoBrightness,
            4 => FitFieldBacklightMode::SmartNotifications,
            5 => FitFieldBacklightMode::KeyAndMessagesNight,
            6 => FitFieldBacklightMode::KeyAndMessagesAndSmartNotifications,
            _ => FitFieldBacklightMode::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDisplayOrientation { // fit base type: enum
    Auto = 0,  // automatic if the device supports it
    Portrait = 1,
    Landscape = 2,
    PortraitFlipped = 3,  // portrait mode but rotated 180 degrees
    LandscapeFlipped = 4,  // landscape mode but rotated 180 degrees
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDisplayOrientation {
    pub fn parse(input: &[u8]) -> Result<FitFieldDisplayOrientation> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDisplayOrientation::from(valid_val)),
            None => Ok(FitFieldDisplayOrientation::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDisplayOrientation {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayOrientation::Auto,
            1 => FitFieldDisplayOrientation::Portrait,
            2 => FitFieldDisplayOrientation::Landscape,
            3 => FitFieldDisplayOrientation::PortraitFlipped,
            4 => FitFieldDisplayOrientation::LandscapeFlipped,
            _ => FitFieldDisplayOrientation::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldHipRaiseExerciseName { // fit base type: uint16
    BarbellHipThrustOnFloor, // 0
    BarbellHipThrustWithBench, // 1
    BentKneeSwissBallReverseHipRaise, // 2
    WeightedBentKneeSwissBallReverseHipRaise, // 3
    BridgeWithLegExtension, // 4
    WeightedBridgeWithLegExtension, // 5
    ClamBridge, // 6
    FrontKickTabletop, // 7
    WeightedFrontKickTabletop, // 8
    HipExtensionAndCross, // 9
    WeightedHipExtensionAndCross, // 10
    HipRaise, // 11
    WeightedHipRaise, // 12
    HipRaiseWithFeetOnSwissBall, // 13
    WeightedHipRaiseWithFeetOnSwissBall, // 14
    HipRaiseWithHeadOnBosuBall, // 15
    WeightedHipRaiseWithHeadOnBosuBall, // 16
    HipRaiseWithHeadOnSwissBall, // 17
    WeightedHipRaiseWithHeadOnSwissBall, // 18
    HipRaiseWithKneeSqueeze, // 19
    WeightedHipRaiseWithKneeSqueeze, // 20
    InclineRearLegExtension, // 21
    WeightedInclineRearLegExtension, // 22
    KettlebellSwing, // 23
    MarchingHipRaise, // 24
    WeightedMarchingHipRaise, // 25
    MarchingHipRaiseWithFeetOnASwissBall, // 26
    WeightedMarchingHipRaiseWithFeetOnASwissBall, // 27
    ReverseHipRaise, // 28
    WeightedReverseHipRaise, // 29
    SingleLegHipRaise, // 30
    WeightedSingleLegHipRaise, // 31
    SingleLegHipRaiseWithFootOnBench, // 32
    WeightedSingleLegHipRaiseWithFootOnBench, // 33
    SingleLegHipRaiseWithFootOnBosuBall, // 34
    WeightedSingleLegHipRaiseWithFootOnBosuBall, // 35
    SingleLegHipRaiseWithFootOnFoamRoller, // 36
    WeightedSingleLegHipRaiseWithFootOnFoamRoller, // 37
    SingleLegHipRaiseWithFootOnMedicineBall, // 38
    WeightedSingleLegHipRaiseWithFootOnMedicineBall, // 39
    SingleLegHipRaiseWithHeadOnBosuBall, // 40
    WeightedSingleLegHipRaiseWithHeadOnBosuBall, // 41
    WeightedClamBridge, // 42
    SingleLegSwissBallHipRaiseAndLegCurl, // 43
    Clams, // 44
    InnerThighCircles, // 45
    InnerThighSideLift, // 46
    LegCircles, // 47
    LegLift, // 48
    LegLiftInExternalRotation, // 49
    HipRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldHipRaiseExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldHipRaiseExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldHipRaiseExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldHipRaiseExerciseName::HipRaiseExerciseName(v)),
                }
            },
            None => Ok(FitFieldHipRaiseExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldHipRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHipRaiseExerciseName::BarbellHipThrustOnFloor,
            1 => FitFieldHipRaiseExerciseName::BarbellHipThrustWithBench,
            2 => FitFieldHipRaiseExerciseName::BentKneeSwissBallReverseHipRaise,
            3 => FitFieldHipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise,
            4 => FitFieldHipRaiseExerciseName::BridgeWithLegExtension,
            5 => FitFieldHipRaiseExerciseName::WeightedBridgeWithLegExtension,
            6 => FitFieldHipRaiseExerciseName::ClamBridge,
            7 => FitFieldHipRaiseExerciseName::FrontKickTabletop,
            8 => FitFieldHipRaiseExerciseName::WeightedFrontKickTabletop,
            9 => FitFieldHipRaiseExerciseName::HipExtensionAndCross,
            10 => FitFieldHipRaiseExerciseName::WeightedHipExtensionAndCross,
            11 => FitFieldHipRaiseExerciseName::HipRaise,
            12 => FitFieldHipRaiseExerciseName::WeightedHipRaise,
            13 => FitFieldHipRaiseExerciseName::HipRaiseWithFeetOnSwissBall,
            14 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall,
            15 => FitFieldHipRaiseExerciseName::HipRaiseWithHeadOnBosuBall,
            16 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall,
            17 => FitFieldHipRaiseExerciseName::HipRaiseWithHeadOnSwissBall,
            18 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall,
            19 => FitFieldHipRaiseExerciseName::HipRaiseWithKneeSqueeze,
            20 => FitFieldHipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze,
            21 => FitFieldHipRaiseExerciseName::InclineRearLegExtension,
            22 => FitFieldHipRaiseExerciseName::WeightedInclineRearLegExtension,
            23 => FitFieldHipRaiseExerciseName::KettlebellSwing,
            24 => FitFieldHipRaiseExerciseName::MarchingHipRaise,
            25 => FitFieldHipRaiseExerciseName::WeightedMarchingHipRaise,
            26 => FitFieldHipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall,
            27 => FitFieldHipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall,
            28 => FitFieldHipRaiseExerciseName::ReverseHipRaise,
            29 => FitFieldHipRaiseExerciseName::WeightedReverseHipRaise,
            30 => FitFieldHipRaiseExerciseName::SingleLegHipRaise,
            31 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaise,
            32 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench,
            33 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench,
            34 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall,
            35 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall,
            36 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller,
            37 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller,
            38 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall,
            39 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall,
            40 => FitFieldHipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall,
            41 => FitFieldHipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall,
            42 => FitFieldHipRaiseExerciseName::WeightedClamBridge,
            43 => FitFieldHipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl,
            44 => FitFieldHipRaiseExerciseName::Clams,
            45 => FitFieldHipRaiseExerciseName::InnerThighCircles,
            46 => FitFieldHipRaiseExerciseName::InnerThighSideLift,
            47 => FitFieldHipRaiseExerciseName::LegCircles,
            48 => FitFieldHipRaiseExerciseName::LegLift,
            49 => FitFieldHipRaiseExerciseName::LegLiftInExternalRotation,
            _ => FitFieldHipRaiseExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLapTrigger { // fit base type: enum
    Manual = 0,
    Time = 1,
    Distance = 2,
    PositionStart = 3,
    PositionLap = 4,
    PositionWaypoint = 5,
    PositionMarked = 6,
    SessionEnd = 7,
    FitnessEquipment = 8,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldLapTrigger {
    pub fn parse(input: &[u8]) -> Result<FitFieldLapTrigger> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldLapTrigger::from(valid_val)),
            None => Ok(FitFieldLapTrigger::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldLapTrigger {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldLapTrigger::Manual,
            1 => FitFieldLapTrigger::Time,
            2 => FitFieldLapTrigger::Distance,
            3 => FitFieldLapTrigger::PositionStart,
            4 => FitFieldLapTrigger::PositionLap,
            5 => FitFieldLapTrigger::PositionWaypoint,
            6 => FitFieldLapTrigger::PositionMarked,
            7 => FitFieldLapTrigger::SessionEnd,
            8 => FitFieldLapTrigger::FitnessEquipment,
            _ => FitFieldLapTrigger::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWaterType { // fit base type: enum
    Fresh = 0,
    Salt = 1,
    En13319 = 2,
    Custom = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWaterType {
    pub fn parse(input: &[u8]) -> Result<FitFieldWaterType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWaterType::from(valid_val)),
            None => Ok(FitFieldWaterType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWaterType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWaterType::Fresh,
            1 => FitFieldWaterType::Salt,
            2 => FitFieldWaterType::En13319,
            3 => FitFieldWaterType::Custom,
            _ => FitFieldWaterType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCourseCapabilities { // fit base type: uint32z
    Processed, // 1
    Valid, // 2
    Time, // 4
    Distance, // 8
    Position, // 16
    HeartRate, // 32
    Power, // 64
    Cadence, // 128
    Training, // 256
    Navigation, // 512
    Bikeway, // 1024
    CourseCapabilities(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCourseCapabilities {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCourseCapabilities> {
        let val = parse_uint32z(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    2 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    4 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    8 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    16 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    32 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    64 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    128 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    256 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    512 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    1024 => Ok(FitFieldCourseCapabilities::from(valid_val)),
                    
                    v => Ok(FitFieldCourseCapabilities::CourseCapabilities(v)),
                }
            },
            None => Ok(FitFieldCourseCapabilities::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldCourseCapabilities {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldCourseCapabilities::Processed,
            2 => FitFieldCourseCapabilities::Valid,
            4 => FitFieldCourseCapabilities::Time,
            8 => FitFieldCourseCapabilities::Distance,
            16 => FitFieldCourseCapabilities::Position,
            32 => FitFieldCourseCapabilities::HeartRate,
            64 => FitFieldCourseCapabilities::Power,
            128 => FitFieldCourseCapabilities::Cadence,
            256 => FitFieldCourseCapabilities::Training,
            512 => FitFieldCourseCapabilities::Navigation,
            1024 => FitFieldCourseCapabilities::Bikeway,
            _ => FitFieldCourseCapabilities::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTricepsExtensionExerciseName { // fit base type: uint16
    BenchDip, // 0
    WeightedBenchDip, // 1
    BodyWeightDip, // 2
    CableKickback, // 3
    CableLyingTricepsExtension, // 4
    CableOverheadTricepsExtension, // 5
    DumbbellKickback, // 6
    DumbbellLyingTricepsExtension, // 7
    EzBarOverheadTricepsExtension, // 8
    InclineDip, // 9
    WeightedInclineDip, // 10
    InclineEzBarLyingTricepsExtension, // 11
    LyingDumbbellPulloverToExtension, // 12
    LyingEzBarTricepsExtension, // 13
    LyingTricepsExtensionToCloseGripBenchPress, // 14
    OverheadDumbbellTricepsExtension, // 15
    RecliningTricepsPress, // 16
    ReverseGripPressdown, // 17
    ReverseGripTricepsPressdown, // 18
    RopePressdown, // 19
    SeatedBarbellOverheadTricepsExtension, // 20
    SeatedDumbbellOverheadTricepsExtension, // 21
    SeatedEzBarOverheadTricepsExtension, // 22
    SeatedSingleArmOverheadDumbbellExtension, // 23
    SingleArmDumbbellOverheadTricepsExtension, // 24
    SingleDumbbellSeatedOverheadTricepsExtension, // 25
    SingleLegBenchDipAndKick, // 26
    WeightedSingleLegBenchDipAndKick, // 27
    SingleLegDip, // 28
    WeightedSingleLegDip, // 29
    StaticLyingTricepsExtension, // 30
    SuspendedDip, // 31
    WeightedSuspendedDip, // 32
    SwissBallDumbbellLyingTricepsExtension, // 33
    SwissBallEzBarLyingTricepsExtension, // 34
    SwissBallEzBarOverheadTricepsExtension, // 35
    TabletopDip, // 36
    WeightedTabletopDip, // 37
    TricepsExtensionOnFloor, // 38
    TricepsPressdown, // 39
    WeightedDip, // 40
    TricepsExtensionExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldTricepsExtensionExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldTricepsExtensionExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldTricepsExtensionExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldTricepsExtensionExerciseName::TricepsExtensionExerciseName(v)),
                }
            },
            None => Ok(FitFieldTricepsExtensionExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldTricepsExtensionExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldTricepsExtensionExerciseName::BenchDip,
            1 => FitFieldTricepsExtensionExerciseName::WeightedBenchDip,
            2 => FitFieldTricepsExtensionExerciseName::BodyWeightDip,
            3 => FitFieldTricepsExtensionExerciseName::CableKickback,
            4 => FitFieldTricepsExtensionExerciseName::CableLyingTricepsExtension,
            5 => FitFieldTricepsExtensionExerciseName::CableOverheadTricepsExtension,
            6 => FitFieldTricepsExtensionExerciseName::DumbbellKickback,
            7 => FitFieldTricepsExtensionExerciseName::DumbbellLyingTricepsExtension,
            8 => FitFieldTricepsExtensionExerciseName::EzBarOverheadTricepsExtension,
            9 => FitFieldTricepsExtensionExerciseName::InclineDip,
            10 => FitFieldTricepsExtensionExerciseName::WeightedInclineDip,
            11 => FitFieldTricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension,
            12 => FitFieldTricepsExtensionExerciseName::LyingDumbbellPulloverToExtension,
            13 => FitFieldTricepsExtensionExerciseName::LyingEzBarTricepsExtension,
            14 => FitFieldTricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress,
            15 => FitFieldTricepsExtensionExerciseName::OverheadDumbbellTricepsExtension,
            16 => FitFieldTricepsExtensionExerciseName::RecliningTricepsPress,
            17 => FitFieldTricepsExtensionExerciseName::ReverseGripPressdown,
            18 => FitFieldTricepsExtensionExerciseName::ReverseGripTricepsPressdown,
            19 => FitFieldTricepsExtensionExerciseName::RopePressdown,
            20 => FitFieldTricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension,
            21 => FitFieldTricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension,
            22 => FitFieldTricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension,
            23 => FitFieldTricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension,
            24 => FitFieldTricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension,
            25 => FitFieldTricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension,
            26 => FitFieldTricepsExtensionExerciseName::SingleLegBenchDipAndKick,
            27 => FitFieldTricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick,
            28 => FitFieldTricepsExtensionExerciseName::SingleLegDip,
            29 => FitFieldTricepsExtensionExerciseName::WeightedSingleLegDip,
            30 => FitFieldTricepsExtensionExerciseName::StaticLyingTricepsExtension,
            31 => FitFieldTricepsExtensionExerciseName::SuspendedDip,
            32 => FitFieldTricepsExtensionExerciseName::WeightedSuspendedDip,
            33 => FitFieldTricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension,
            34 => FitFieldTricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension,
            35 => FitFieldTricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension,
            36 => FitFieldTricepsExtensionExerciseName::TabletopDip,
            37 => FitFieldTricepsExtensionExerciseName::WeightedTabletopDip,
            38 => FitFieldTricepsExtensionExerciseName::TricepsExtensionOnFloor,
            39 => FitFieldTricepsExtensionExerciseName::TricepsPressdown,
            40 => FitFieldTricepsExtensionExerciseName::WeightedDip,
            _ => FitFieldTricepsExtensionExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTimeMode { // fit base type: enum
    Hour12 = 0,
    Hour24 = 1,  // Does not use a leading zero and has a colon
    Military = 2,  // Uses a leading zero and does not have a colon
    Hour12WithSeconds = 3,
    Hour24WithSeconds = 4,
    Utc = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldTimeMode {
    pub fn parse(input: &[u8]) -> Result<FitFieldTimeMode> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldTimeMode::from(valid_val)),
            None => Ok(FitFieldTimeMode::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldTimeMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTimeMode::Hour12,
            1 => FitFieldTimeMode::Hour24,
            2 => FitFieldTimeMode::Military,
            3 => FitFieldTimeMode::Hour12WithSeconds,
            4 => FitFieldTimeMode::Hour24WithSeconds,
            5 => FitFieldTimeMode::Utc,
            _ => FitFieldTimeMode::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldExdQualifiers { // fit base type: enum
    NoQualifier = 0,
    Instantaneous = 1,
    Average = 2,
    Lap = 3,
    Maximum = 4,
    MaximumAverage = 5,
    MaximumLap = 6,
    LastLap = 7,
    AverageLap = 8,
    ToDestination = 9,
    ToGo = 10,
    ToNext = 11,
    NextCoursePoint = 12,
    Total = 13,
    ThreeSecondAverage = 14,
    TenSecondAverage = 15,
    ThirtySecondAverage = 16,
    PercentMaximum = 17,
    PercentMaximumAverage = 18,
    LapPercentMaximum = 19,
    Elapsed = 20,
    Sunrise = 21,
    Sunset = 22,
    ComparedToVirtualPartner = 23,
    Maximum24h = 24,
    Minimum24h = 25,
    Minimum = 26,
    First = 27,
    Second = 28,
    Third = 29,
    Shifter = 30,
    LastSport = 31,
    Moving = 32,
    Stopped = 33,
    EstimatedTotal = 34,
    Zone9 = 242,
    Zone8 = 243,
    Zone7 = 244,
    Zone6 = 245,
    Zone5 = 246,
    Zone4 = 247,
    Zone3 = 248,
    Zone2 = 249,
    Zone1 = 250,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldExdQualifiers {
    pub fn parse(input: &[u8]) -> Result<FitFieldExdQualifiers> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldExdQualifiers::from(valid_val)),
            None => Ok(FitFieldExdQualifiers::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldExdQualifiers {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdQualifiers::NoQualifier,
            1 => FitFieldExdQualifiers::Instantaneous,
            2 => FitFieldExdQualifiers::Average,
            3 => FitFieldExdQualifiers::Lap,
            4 => FitFieldExdQualifiers::Maximum,
            5 => FitFieldExdQualifiers::MaximumAverage,
            6 => FitFieldExdQualifiers::MaximumLap,
            7 => FitFieldExdQualifiers::LastLap,
            8 => FitFieldExdQualifiers::AverageLap,
            9 => FitFieldExdQualifiers::ToDestination,
            10 => FitFieldExdQualifiers::ToGo,
            11 => FitFieldExdQualifiers::ToNext,
            12 => FitFieldExdQualifiers::NextCoursePoint,
            13 => FitFieldExdQualifiers::Total,
            14 => FitFieldExdQualifiers::ThreeSecondAverage,
            15 => FitFieldExdQualifiers::TenSecondAverage,
            16 => FitFieldExdQualifiers::ThirtySecondAverage,
            17 => FitFieldExdQualifiers::PercentMaximum,
            18 => FitFieldExdQualifiers::PercentMaximumAverage,
            19 => FitFieldExdQualifiers::LapPercentMaximum,
            20 => FitFieldExdQualifiers::Elapsed,
            21 => FitFieldExdQualifiers::Sunrise,
            22 => FitFieldExdQualifiers::Sunset,
            23 => FitFieldExdQualifiers::ComparedToVirtualPartner,
            24 => FitFieldExdQualifiers::Maximum24h,
            25 => FitFieldExdQualifiers::Minimum24h,
            26 => FitFieldExdQualifiers::Minimum,
            27 => FitFieldExdQualifiers::First,
            28 => FitFieldExdQualifiers::Second,
            29 => FitFieldExdQualifiers::Third,
            30 => FitFieldExdQualifiers::Shifter,
            31 => FitFieldExdQualifiers::LastSport,
            32 => FitFieldExdQualifiers::Moving,
            33 => FitFieldExdQualifiers::Stopped,
            34 => FitFieldExdQualifiers::EstimatedTotal,
            242 => FitFieldExdQualifiers::Zone9,
            243 => FitFieldExdQualifiers::Zone8,
            244 => FitFieldExdQualifiers::Zone7,
            245 => FitFieldExdQualifiers::Zone6,
            246 => FitFieldExdQualifiers::Zone5,
            247 => FitFieldExdQualifiers::Zone4,
            248 => FitFieldExdQualifiers::Zone3,
            249 => FitFieldExdQualifiers::Zone2,
            250 => FitFieldExdQualifiers::Zone1,
            _ => FitFieldExdQualifiers::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldGoalSource { // fit base type: enum
    Auto = 0,  // Device generated
    Community = 1,  // Social network sourced goal
    User = 2,  // Manually generated
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldGoalSource {
    pub fn parse(input: &[u8]) -> Result<FitFieldGoalSource> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldGoalSource::from(valid_val)),
            None => Ok(FitFieldGoalSource::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldGoalSource {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGoalSource::Auto,
            1 => FitFieldGoalSource::Community,
            2 => FitFieldGoalSource::User,
            _ => FitFieldGoalSource::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDateMode { // fit base type: enum
    DayMonth = 0,
    MonthDay = 1,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDateMode {
    pub fn parse(input: &[u8]) -> Result<FitFieldDateMode> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDateMode::from(valid_val)),
            None => Ok(FitFieldDateMode::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDateMode {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDateMode::DayMonth,
            1 => FitFieldDateMode::MonthDay,
            _ => FitFieldDateMode::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSubSport { // fit base type: enum
    Generic = 0,
    Treadmill = 1,  // Run/Fitness Equipment
    Street = 2,  // Run
    Trail = 3,  // Run
    Track = 4,  // Run
    Spin = 5,  // Cycling
    IndoorCycling = 6,  // Cycling/Fitness Equipment
    Road = 7,  // Cycling
    Mountain = 8,  // Cycling
    Downhill = 9,  // Cycling
    Recumbent = 10,  // Cycling
    Cyclocross = 11,  // Cycling
    HandCycling = 12,  // Cycling
    TrackCycling = 13,  // Cycling
    IndoorRowing = 14,  // Fitness Equipment
    Elliptical = 15,  // Fitness Equipment
    StairClimbing = 16,  // Fitness Equipment
    LapSwimming = 17,  // Swimming
    OpenWater = 18,  // Swimming
    FlexibilityTraining = 19,  // Training
    StrengthTraining = 20,  // Training
    WarmUp = 21,  // Tennis
    Match = 22,  // Tennis
    Exercise = 23,  // Tennis
    Challenge = 24,
    IndoorSkiing = 25,  // Fitness Equipment
    CardioTraining = 26,  // Training
    IndoorWalking = 27,  // Walking/Fitness Equipment
    EBikeFitness = 28,  // E-Biking
    Bmx = 29,  // Cycling
    CasualWalking = 30,  // Walking
    SpeedWalking = 31,  // Walking
    BikeToRunTransition = 32,  // Transition
    RunToBikeTransition = 33,  // Transition
    SwimToBikeTransition = 34,  // Transition
    Atv = 35,  // Motorcycling
    Motocross = 36,  // Motorcycling
    Backcountry = 37,  // Alpine Skiing/Snowboarding
    Resort = 38,  // Alpine Skiing/Snowboarding
    RcDrone = 39,  // Flying
    Wingsuit = 40,  // Flying
    Whitewater = 41,  // Kayaking/Rafting
    SkateSkiing = 42,  // Cross Country Skiing
    Yoga = 43,  // Training
    Pilates = 44,  // Fitness Equipment
    IndoorRunning = 45,  // Run
    GravelCycling = 46,  // Cycling
    EBikeMountain = 47,  // Cycling
    Commuting = 48,  // Cycling
    MixedSurface = 49,  // Cycling
    Navigate = 50,
    TrackMe = 51,
    Map = 52,
    SingleGasDiving = 53,  // Diving
    MultiGasDiving = 54,  // Diving
    GaugeDiving = 55,  // Diving
    ApneaDiving = 56,  // Diving
    ApneaHunting = 57,  // Diving
    VirtualActivity = 58,
    Obstacle = 59,  // Used for events where participants run, crawl through mud, climb over walls, etc.
    All = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSubSport {
    pub fn parse(input: &[u8]) -> Result<FitFieldSubSport> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSubSport::from(valid_val)),
            None => Ok(FitFieldSubSport::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSubSport {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSubSport::Generic,
            1 => FitFieldSubSport::Treadmill,
            2 => FitFieldSubSport::Street,
            3 => FitFieldSubSport::Trail,
            4 => FitFieldSubSport::Track,
            5 => FitFieldSubSport::Spin,
            6 => FitFieldSubSport::IndoorCycling,
            7 => FitFieldSubSport::Road,
            8 => FitFieldSubSport::Mountain,
            9 => FitFieldSubSport::Downhill,
            10 => FitFieldSubSport::Recumbent,
            11 => FitFieldSubSport::Cyclocross,
            12 => FitFieldSubSport::HandCycling,
            13 => FitFieldSubSport::TrackCycling,
            14 => FitFieldSubSport::IndoorRowing,
            15 => FitFieldSubSport::Elliptical,
            16 => FitFieldSubSport::StairClimbing,
            17 => FitFieldSubSport::LapSwimming,
            18 => FitFieldSubSport::OpenWater,
            19 => FitFieldSubSport::FlexibilityTraining,
            20 => FitFieldSubSport::StrengthTraining,
            21 => FitFieldSubSport::WarmUp,
            22 => FitFieldSubSport::Match,
            23 => FitFieldSubSport::Exercise,
            24 => FitFieldSubSport::Challenge,
            25 => FitFieldSubSport::IndoorSkiing,
            26 => FitFieldSubSport::CardioTraining,
            27 => FitFieldSubSport::IndoorWalking,
            28 => FitFieldSubSport::EBikeFitness,
            29 => FitFieldSubSport::Bmx,
            30 => FitFieldSubSport::CasualWalking,
            31 => FitFieldSubSport::SpeedWalking,
            32 => FitFieldSubSport::BikeToRunTransition,
            33 => FitFieldSubSport::RunToBikeTransition,
            34 => FitFieldSubSport::SwimToBikeTransition,
            35 => FitFieldSubSport::Atv,
            36 => FitFieldSubSport::Motocross,
            37 => FitFieldSubSport::Backcountry,
            38 => FitFieldSubSport::Resort,
            39 => FitFieldSubSport::RcDrone,
            40 => FitFieldSubSport::Wingsuit,
            41 => FitFieldSubSport::Whitewater,
            42 => FitFieldSubSport::SkateSkiing,
            43 => FitFieldSubSport::Yoga,
            44 => FitFieldSubSport::Pilates,
            45 => FitFieldSubSport::IndoorRunning,
            46 => FitFieldSubSport::GravelCycling,
            47 => FitFieldSubSport::EBikeMountain,
            48 => FitFieldSubSport::Commuting,
            49 => FitFieldSubSport::MixedSurface,
            50 => FitFieldSubSport::Navigate,
            51 => FitFieldSubSport::TrackMe,
            52 => FitFieldSubSport::Map,
            53 => FitFieldSubSport::SingleGasDiving,
            54 => FitFieldSubSport::MultiGasDiving,
            55 => FitFieldSubSport::GaugeDiving,
            56 => FitFieldSubSport::ApneaDiving,
            57 => FitFieldSubSport::ApneaHunting,
            58 => FitFieldSubSport::VirtualActivity,
            59 => FitFieldSubSport::Obstacle,
            254 => FitFieldSubSport::All,
            _ => FitFieldSubSport::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldExerciseCategory { // fit base type: uint16
    BenchPress, // 0
    CalfRaise, // 1
    Cardio, // 2
    Carry, // 3
    Chop, // 4
    Core, // 5
    Crunch, // 6
    Curl, // 7
    Deadlift, // 8
    Flye, // 9
    HipRaise, // 10
    HipStability, // 11
    HipSwing, // 12
    Hyperextension, // 13
    LateralRaise, // 14
    LegCurl, // 15
    LegRaise, // 16
    Lunge, // 17
    OlympicLift, // 18
    Plank, // 19
    Plyo, // 20
    PullUp, // 21
    PushUp, // 22
    Row, // 23
    ShoulderPress, // 24
    ShoulderStability, // 25
    Shrug, // 26
    SitUp, // 27
    Squat, // 28
    TotalBody, // 29
    TricepsExtension, // 30
    WarmUp, // 31
    Run, // 32
    Unknown, // 65534
    ExerciseCategory(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldExerciseCategory {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldExerciseCategory> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    1 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    2 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    3 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    4 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    5 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    6 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    7 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    8 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    9 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    10 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    11 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    12 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    13 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    14 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    15 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    16 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    17 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    18 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    19 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    20 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    21 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    22 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    23 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    24 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    25 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    26 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    27 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    28 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    29 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    30 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    31 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    32 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    65534 => Ok(FitFieldExerciseCategory::from(valid_val)),
                    
                    v => Ok(FitFieldExerciseCategory::ExerciseCategory(v)),
                }
            },
            None => Ok(FitFieldExerciseCategory::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldExerciseCategory {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldExerciseCategory::BenchPress,
            1 => FitFieldExerciseCategory::CalfRaise,
            2 => FitFieldExerciseCategory::Cardio,
            3 => FitFieldExerciseCategory::Carry,
            4 => FitFieldExerciseCategory::Chop,
            5 => FitFieldExerciseCategory::Core,
            6 => FitFieldExerciseCategory::Crunch,
            7 => FitFieldExerciseCategory::Curl,
            8 => FitFieldExerciseCategory::Deadlift,
            9 => FitFieldExerciseCategory::Flye,
            10 => FitFieldExerciseCategory::HipRaise,
            11 => FitFieldExerciseCategory::HipStability,
            12 => FitFieldExerciseCategory::HipSwing,
            13 => FitFieldExerciseCategory::Hyperextension,
            14 => FitFieldExerciseCategory::LateralRaise,
            15 => FitFieldExerciseCategory::LegCurl,
            16 => FitFieldExerciseCategory::LegRaise,
            17 => FitFieldExerciseCategory::Lunge,
            18 => FitFieldExerciseCategory::OlympicLift,
            19 => FitFieldExerciseCategory::Plank,
            20 => FitFieldExerciseCategory::Plyo,
            21 => FitFieldExerciseCategory::PullUp,
            22 => FitFieldExerciseCategory::PushUp,
            23 => FitFieldExerciseCategory::Row,
            24 => FitFieldExerciseCategory::ShoulderPress,
            25 => FitFieldExerciseCategory::ShoulderStability,
            26 => FitFieldExerciseCategory::Shrug,
            27 => FitFieldExerciseCategory::SitUp,
            28 => FitFieldExerciseCategory::Squat,
            29 => FitFieldExerciseCategory::TotalBody,
            30 => FitFieldExerciseCategory::TricepsExtension,
            31 => FitFieldExerciseCategory::WarmUp,
            32 => FitFieldExerciseCategory::Run,
            65534 => FitFieldExerciseCategory::Unknown,
            _ => FitFieldExerciseCategory::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDeviceIndex { // fit base type: uint8
    Creator, // 0  Creator of the file is always device index 0.
    DeviceIndex(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldDeviceIndex {
    pub fn parse(input: &[u8]) -> Result<FitFieldDeviceIndex> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldDeviceIndex::from(valid_val)),
                    
                    v => Ok(FitFieldDeviceIndex::DeviceIndex(v)),
                }
            },
            None => Ok(FitFieldDeviceIndex::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldDeviceIndex {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDeviceIndex::Creator,
            _ => FitFieldDeviceIndex::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLungeExerciseName { // fit base type: uint16
    OverheadLunge, // 0
    LungeMatrix, // 1
    WeightedLungeMatrix, // 2
    AlternatingBarbellForwardLunge, // 3
    AlternatingDumbbellLungeWithReach, // 4
    BackFootElevatedDumbbellSplitSquat, // 5
    BarbellBoxLunge, // 6
    BarbellBulgarianSplitSquat, // 7
    BarbellCrossoverLunge, // 8
    BarbellFrontSplitSquat, // 9
    BarbellLunge, // 10
    BarbellReverseLunge, // 11
    BarbellSideLunge, // 12
    BarbellSplitSquat, // 13
    CoreControlRearLunge, // 14
    DiagonalLunge, // 15
    DropLunge, // 16
    DumbbellBoxLunge, // 17
    DumbbellBulgarianSplitSquat, // 18
    DumbbellCrossoverLunge, // 19
    DumbbellDiagonalLunge, // 20
    DumbbellLunge, // 21
    DumbbellLungeAndRotation, // 22
    DumbbellOverheadBulgarianSplitSquat, // 23
    DumbbellReverseLungeToHighKneeAndPress, // 24
    DumbbellSideLunge, // 25
    ElevatedFrontFootBarbellSplitSquat, // 26
    FrontFootElevatedDumbbellSplitSquat, // 27
    GunslingerLunge, // 28
    LawnmowerLunge, // 29
    LowLungeWithIsometricAdduction, // 30
    LowSideToSideLunge, // 31
    Lunge, // 32
    WeightedLunge, // 33
    LungeWithArmReach, // 34
    LungeWithDiagonalReach, // 35
    LungeWithSideBend, // 36
    OffsetDumbbellLunge, // 37
    OffsetDumbbellReverseLunge, // 38
    OverheadBulgarianSplitSquat, // 39
    OverheadDumbbellReverseLunge, // 40
    OverheadDumbbellSplitSquat, // 41
    OverheadLungeWithRotation, // 42
    ReverseBarbellBoxLunge, // 43
    ReverseBoxLunge, // 44
    ReverseDumbbellBoxLunge, // 45
    ReverseDumbbellCrossoverLunge, // 46
    ReverseDumbbellDiagonalLunge, // 47
    ReverseLungeWithReachBack, // 48
    WeightedReverseLungeWithReachBack, // 49
    ReverseLungeWithTwistAndOverheadReach, // 50
    WeightedReverseLungeWithTwistAndOverheadReach, // 51
    ReverseSlidingBoxLunge, // 52
    WeightedReverseSlidingBoxLunge, // 53
    ReverseSlidingLunge, // 54
    WeightedReverseSlidingLunge, // 55
    RunnersLungeToBalance, // 56
    WeightedRunnersLungeToBalance, // 57
    ShiftingSideLunge, // 58
    SideAndCrossoverLunge, // 59
    WeightedSideAndCrossoverLunge, // 60
    SideLunge, // 61
    WeightedSideLunge, // 62
    SideLungeAndPress, // 63
    SideLungeJumpOff, // 64
    SideLungeSweep, // 65
    WeightedSideLungeSweep, // 66
    SideLungeToCrossoverTap, // 67
    WeightedSideLungeToCrossoverTap, // 68
    SideToSideLungeChops, // 69
    WeightedSideToSideLungeChops, // 70
    SiffJumpLunge, // 71
    WeightedSiffJumpLunge, // 72
    SingleArmReverseLungeAndPress, // 73
    SlidingLateralLunge, // 74
    WeightedSlidingLateralLunge, // 75
    WalkingBarbellLunge, // 76
    WalkingDumbbellLunge, // 77
    WalkingLunge, // 78
    WeightedWalkingLunge, // 79
    WideGripOverheadBarbellSplitSquat, // 80
    LungeExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLungeExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldLungeExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    50 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    51 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    52 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    53 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    54 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    55 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    56 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    57 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    58 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    59 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    60 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    61 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    62 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    63 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    64 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    65 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    66 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    67 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    68 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    69 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    70 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    71 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    72 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    73 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    74 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    75 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    76 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    77 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    78 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    79 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    80 => Ok(FitFieldLungeExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldLungeExerciseName::LungeExerciseName(v)),
                }
            },
            None => Ok(FitFieldLungeExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldLungeExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLungeExerciseName::OverheadLunge,
            1 => FitFieldLungeExerciseName::LungeMatrix,
            2 => FitFieldLungeExerciseName::WeightedLungeMatrix,
            3 => FitFieldLungeExerciseName::AlternatingBarbellForwardLunge,
            4 => FitFieldLungeExerciseName::AlternatingDumbbellLungeWithReach,
            5 => FitFieldLungeExerciseName::BackFootElevatedDumbbellSplitSquat,
            6 => FitFieldLungeExerciseName::BarbellBoxLunge,
            7 => FitFieldLungeExerciseName::BarbellBulgarianSplitSquat,
            8 => FitFieldLungeExerciseName::BarbellCrossoverLunge,
            9 => FitFieldLungeExerciseName::BarbellFrontSplitSquat,
            10 => FitFieldLungeExerciseName::BarbellLunge,
            11 => FitFieldLungeExerciseName::BarbellReverseLunge,
            12 => FitFieldLungeExerciseName::BarbellSideLunge,
            13 => FitFieldLungeExerciseName::BarbellSplitSquat,
            14 => FitFieldLungeExerciseName::CoreControlRearLunge,
            15 => FitFieldLungeExerciseName::DiagonalLunge,
            16 => FitFieldLungeExerciseName::DropLunge,
            17 => FitFieldLungeExerciseName::DumbbellBoxLunge,
            18 => FitFieldLungeExerciseName::DumbbellBulgarianSplitSquat,
            19 => FitFieldLungeExerciseName::DumbbellCrossoverLunge,
            20 => FitFieldLungeExerciseName::DumbbellDiagonalLunge,
            21 => FitFieldLungeExerciseName::DumbbellLunge,
            22 => FitFieldLungeExerciseName::DumbbellLungeAndRotation,
            23 => FitFieldLungeExerciseName::DumbbellOverheadBulgarianSplitSquat,
            24 => FitFieldLungeExerciseName::DumbbellReverseLungeToHighKneeAndPress,
            25 => FitFieldLungeExerciseName::DumbbellSideLunge,
            26 => FitFieldLungeExerciseName::ElevatedFrontFootBarbellSplitSquat,
            27 => FitFieldLungeExerciseName::FrontFootElevatedDumbbellSplitSquat,
            28 => FitFieldLungeExerciseName::GunslingerLunge,
            29 => FitFieldLungeExerciseName::LawnmowerLunge,
            30 => FitFieldLungeExerciseName::LowLungeWithIsometricAdduction,
            31 => FitFieldLungeExerciseName::LowSideToSideLunge,
            32 => FitFieldLungeExerciseName::Lunge,
            33 => FitFieldLungeExerciseName::WeightedLunge,
            34 => FitFieldLungeExerciseName::LungeWithArmReach,
            35 => FitFieldLungeExerciseName::LungeWithDiagonalReach,
            36 => FitFieldLungeExerciseName::LungeWithSideBend,
            37 => FitFieldLungeExerciseName::OffsetDumbbellLunge,
            38 => FitFieldLungeExerciseName::OffsetDumbbellReverseLunge,
            39 => FitFieldLungeExerciseName::OverheadBulgarianSplitSquat,
            40 => FitFieldLungeExerciseName::OverheadDumbbellReverseLunge,
            41 => FitFieldLungeExerciseName::OverheadDumbbellSplitSquat,
            42 => FitFieldLungeExerciseName::OverheadLungeWithRotation,
            43 => FitFieldLungeExerciseName::ReverseBarbellBoxLunge,
            44 => FitFieldLungeExerciseName::ReverseBoxLunge,
            45 => FitFieldLungeExerciseName::ReverseDumbbellBoxLunge,
            46 => FitFieldLungeExerciseName::ReverseDumbbellCrossoverLunge,
            47 => FitFieldLungeExerciseName::ReverseDumbbellDiagonalLunge,
            48 => FitFieldLungeExerciseName::ReverseLungeWithReachBack,
            49 => FitFieldLungeExerciseName::WeightedReverseLungeWithReachBack,
            50 => FitFieldLungeExerciseName::ReverseLungeWithTwistAndOverheadReach,
            51 => FitFieldLungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach,
            52 => FitFieldLungeExerciseName::ReverseSlidingBoxLunge,
            53 => FitFieldLungeExerciseName::WeightedReverseSlidingBoxLunge,
            54 => FitFieldLungeExerciseName::ReverseSlidingLunge,
            55 => FitFieldLungeExerciseName::WeightedReverseSlidingLunge,
            56 => FitFieldLungeExerciseName::RunnersLungeToBalance,
            57 => FitFieldLungeExerciseName::WeightedRunnersLungeToBalance,
            58 => FitFieldLungeExerciseName::ShiftingSideLunge,
            59 => FitFieldLungeExerciseName::SideAndCrossoverLunge,
            60 => FitFieldLungeExerciseName::WeightedSideAndCrossoverLunge,
            61 => FitFieldLungeExerciseName::SideLunge,
            62 => FitFieldLungeExerciseName::WeightedSideLunge,
            63 => FitFieldLungeExerciseName::SideLungeAndPress,
            64 => FitFieldLungeExerciseName::SideLungeJumpOff,
            65 => FitFieldLungeExerciseName::SideLungeSweep,
            66 => FitFieldLungeExerciseName::WeightedSideLungeSweep,
            67 => FitFieldLungeExerciseName::SideLungeToCrossoverTap,
            68 => FitFieldLungeExerciseName::WeightedSideLungeToCrossoverTap,
            69 => FitFieldLungeExerciseName::SideToSideLungeChops,
            70 => FitFieldLungeExerciseName::WeightedSideToSideLungeChops,
            71 => FitFieldLungeExerciseName::SiffJumpLunge,
            72 => FitFieldLungeExerciseName::WeightedSiffJumpLunge,
            73 => FitFieldLungeExerciseName::SingleArmReverseLungeAndPress,
            74 => FitFieldLungeExerciseName::SlidingLateralLunge,
            75 => FitFieldLungeExerciseName::WeightedSlidingLateralLunge,
            76 => FitFieldLungeExerciseName::WalkingBarbellLunge,
            77 => FitFieldLungeExerciseName::WalkingDumbbellLunge,
            78 => FitFieldLungeExerciseName::WalkingLunge,
            79 => FitFieldLungeExerciseName::WeightedWalkingLunge,
            80 => FitFieldLungeExerciseName::WideGripOverheadBarbellSplitSquat,
            _ => FitFieldLungeExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits0 { // fit base type: uint8z
    Generic, // 1
    Running, // 2
    Cycling, // 4
    Transition, // 8  Mulitsport transition
    FitnessEquipment, // 16
    Swimming, // 32
    Basketball, // 64
    Soccer, // 128
    SportBits0(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits0 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits0> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    2 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    4 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    8 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    16 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    32 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    64 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    128 => Ok(FitFieldSportBits0::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits0::SportBits0(v)),
                }
            },
            None => Ok(FitFieldSportBits0::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits0 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits0::Generic,
            2 => FitFieldSportBits0::Running,
            4 => FitFieldSportBits0::Cycling,
            8 => FitFieldSportBits0::Transition,
            16 => FitFieldSportBits0::FitnessEquipment,
            32 => FitFieldSportBits0::Swimming,
            64 => FitFieldSportBits0::Basketball,
            128 => FitFieldSportBits0::Soccer,
            _ => FitFieldSportBits0::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits1 { // fit base type: uint8z
    Tennis, // 1
    AmericanFootball, // 2
    Training, // 4
    Walking, // 8
    CrossCountrySkiing, // 16
    AlpineSkiing, // 32
    Snowboarding, // 64
    Rowing, // 128
    SportBits1(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits1 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits1> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    2 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    4 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    8 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    16 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    32 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    64 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    128 => Ok(FitFieldSportBits1::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits1::SportBits1(v)),
                }
            },
            None => Ok(FitFieldSportBits1::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits1 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits1::Tennis,
            2 => FitFieldSportBits1::AmericanFootball,
            4 => FitFieldSportBits1::Training,
            8 => FitFieldSportBits1::Walking,
            16 => FitFieldSportBits1::CrossCountrySkiing,
            32 => FitFieldSportBits1::AlpineSkiing,
            64 => FitFieldSportBits1::Snowboarding,
            128 => FitFieldSportBits1::Rowing,
            _ => FitFieldSportBits1::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits2 { // fit base type: uint8z
    Mountaineering, // 1
    Hiking, // 2
    Multisport, // 4
    Paddling, // 8
    Flying, // 16
    EBiking, // 32
    Motorcycling, // 64
    Boating, // 128
    SportBits2(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits2 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits2> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    2 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    4 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    8 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    16 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    32 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    64 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    128 => Ok(FitFieldSportBits2::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits2::SportBits2(v)),
                }
            },
            None => Ok(FitFieldSportBits2::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits2 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits2::Mountaineering,
            2 => FitFieldSportBits2::Hiking,
            4 => FitFieldSportBits2::Multisport,
            8 => FitFieldSportBits2::Paddling,
            16 => FitFieldSportBits2::Flying,
            32 => FitFieldSportBits2::EBiking,
            64 => FitFieldSportBits2::Motorcycling,
            128 => FitFieldSportBits2::Boating,
            _ => FitFieldSportBits2::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits3 { // fit base type: uint8z
    Driving, // 1
    Golf, // 2
    HangGliding, // 4
    HorsebackRiding, // 8
    Hunting, // 16
    Fishing, // 32
    InlineSkating, // 64
    RockClimbing, // 128
    SportBits3(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits3 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits3> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    2 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    4 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    8 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    16 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    32 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    64 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    128 => Ok(FitFieldSportBits3::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits3::SportBits3(v)),
                }
            },
            None => Ok(FitFieldSportBits3::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits3 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits3::Driving,
            2 => FitFieldSportBits3::Golf,
            4 => FitFieldSportBits3::HangGliding,
            8 => FitFieldSportBits3::HorsebackRiding,
            16 => FitFieldSportBits3::Hunting,
            32 => FitFieldSportBits3::Fishing,
            64 => FitFieldSportBits3::InlineSkating,
            128 => FitFieldSportBits3::RockClimbing,
            _ => FitFieldSportBits3::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits4 { // fit base type: uint8z
    Sailing, // 1
    IceSkating, // 2
    SkyDiving, // 4
    Snowshoeing, // 8
    Snowmobiling, // 16
    StandUpPaddleboarding, // 32
    Surfing, // 64
    Wakeboarding, // 128
    SportBits4(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits4 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits4> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    2 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    4 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    8 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    16 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    32 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    64 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    128 => Ok(FitFieldSportBits4::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits4::SportBits4(v)),
                }
            },
            None => Ok(FitFieldSportBits4::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits4 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits4::Sailing,
            2 => FitFieldSportBits4::IceSkating,
            4 => FitFieldSportBits4::SkyDiving,
            8 => FitFieldSportBits4::Snowshoeing,
            16 => FitFieldSportBits4::Snowmobiling,
            32 => FitFieldSportBits4::StandUpPaddleboarding,
            64 => FitFieldSportBits4::Surfing,
            128 => FitFieldSportBits4::Wakeboarding,
            _ => FitFieldSportBits4::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits5 { // fit base type: uint8z
    WaterSkiing, // 1
    Kayaking, // 2
    Rafting, // 4
    Windsurfing, // 8
    Kitesurfing, // 16
    Tactical, // 32
    Jumpmaster, // 64
    Boxing, // 128
    SportBits5(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits5 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits5> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    2 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    4 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    8 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    16 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    32 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    64 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    128 => Ok(FitFieldSportBits5::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits5::SportBits5(v)),
                }
            },
            None => Ok(FitFieldSportBits5::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits5 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits5::WaterSkiing,
            2 => FitFieldSportBits5::Kayaking,
            4 => FitFieldSportBits5::Rafting,
            8 => FitFieldSportBits5::Windsurfing,
            16 => FitFieldSportBits5::Kitesurfing,
            32 => FitFieldSportBits5::Tactical,
            64 => FitFieldSportBits5::Jumpmaster,
            128 => FitFieldSportBits5::Boxing,
            _ => FitFieldSportBits5::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSportBits6 { // fit base type: uint8z
    FloorClimbing, // 1
    SportBits6(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSportBits6 {
    pub fn parse(input: &[u8]) -> Result<FitFieldSportBits6> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSportBits6::from(valid_val)),
                    
                    v => Ok(FitFieldSportBits6::SportBits6(v)),
                }
            },
            None => Ok(FitFieldSportBits6::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldSportBits6 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldSportBits6::FloorClimbing,
            _ => FitFieldSportBits6::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldPullUpExerciseName { // fit base type: uint16
    BandedPullUps, // 0
    ThirtyDegreeLatPulldown, // 1
    BandAssistedChinUp, // 2
    CloseGripChinUp, // 3
    WeightedCloseGripChinUp, // 4
    CloseGripLatPulldown, // 5
    CrossoverChinUp, // 6
    WeightedCrossoverChinUp, // 7
    EzBarPullover, // 8
    HangingHurdle, // 9
    WeightedHangingHurdle, // 10
    KneelingLatPulldown, // 11
    KneelingUnderhandGripLatPulldown, // 12
    LatPulldown, // 13
    MixedGripChinUp, // 14
    WeightedMixedGripChinUp, // 15
    MixedGripPullUp, // 16
    WeightedMixedGripPullUp, // 17
    ReverseGripPulldown, // 18
    StandingCablePullover, // 19
    StraightArmPulldown, // 20
    SwissBallEzBarPullover, // 21
    TowelPullUp, // 22
    WeightedTowelPullUp, // 23
    WeightedPullUp, // 24
    WideGripLatPulldown, // 25
    WideGripPullUp, // 26
    WeightedWideGripPullUp, // 27
    BurpeePullUp, // 28
    WeightedBurpeePullUp, // 29
    JumpingPullUps, // 30
    WeightedJumpingPullUps, // 31
    KippingPullUp, // 32
    WeightedKippingPullUp, // 33
    LPullUp, // 34
    WeightedLPullUp, // 35
    SuspendedChinUp, // 36
    WeightedSuspendedChinUp, // 37
    PullUp, // 38
    PullUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldPullUpExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldPullUpExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldPullUpExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldPullUpExerciseName::PullUpExerciseName(v)),
                }
            },
            None => Ok(FitFieldPullUpExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldPullUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPullUpExerciseName::BandedPullUps,
            1 => FitFieldPullUpExerciseName::ThirtyDegreeLatPulldown,
            2 => FitFieldPullUpExerciseName::BandAssistedChinUp,
            3 => FitFieldPullUpExerciseName::CloseGripChinUp,
            4 => FitFieldPullUpExerciseName::WeightedCloseGripChinUp,
            5 => FitFieldPullUpExerciseName::CloseGripLatPulldown,
            6 => FitFieldPullUpExerciseName::CrossoverChinUp,
            7 => FitFieldPullUpExerciseName::WeightedCrossoverChinUp,
            8 => FitFieldPullUpExerciseName::EzBarPullover,
            9 => FitFieldPullUpExerciseName::HangingHurdle,
            10 => FitFieldPullUpExerciseName::WeightedHangingHurdle,
            11 => FitFieldPullUpExerciseName::KneelingLatPulldown,
            12 => FitFieldPullUpExerciseName::KneelingUnderhandGripLatPulldown,
            13 => FitFieldPullUpExerciseName::LatPulldown,
            14 => FitFieldPullUpExerciseName::MixedGripChinUp,
            15 => FitFieldPullUpExerciseName::WeightedMixedGripChinUp,
            16 => FitFieldPullUpExerciseName::MixedGripPullUp,
            17 => FitFieldPullUpExerciseName::WeightedMixedGripPullUp,
            18 => FitFieldPullUpExerciseName::ReverseGripPulldown,
            19 => FitFieldPullUpExerciseName::StandingCablePullover,
            20 => FitFieldPullUpExerciseName::StraightArmPulldown,
            21 => FitFieldPullUpExerciseName::SwissBallEzBarPullover,
            22 => FitFieldPullUpExerciseName::TowelPullUp,
            23 => FitFieldPullUpExerciseName::WeightedTowelPullUp,
            24 => FitFieldPullUpExerciseName::WeightedPullUp,
            25 => FitFieldPullUpExerciseName::WideGripLatPulldown,
            26 => FitFieldPullUpExerciseName::WideGripPullUp,
            27 => FitFieldPullUpExerciseName::WeightedWideGripPullUp,
            28 => FitFieldPullUpExerciseName::BurpeePullUp,
            29 => FitFieldPullUpExerciseName::WeightedBurpeePullUp,
            30 => FitFieldPullUpExerciseName::JumpingPullUps,
            31 => FitFieldPullUpExerciseName::WeightedJumpingPullUps,
            32 => FitFieldPullUpExerciseName::KippingPullUp,
            33 => FitFieldPullUpExerciseName::WeightedKippingPullUp,
            34 => FitFieldPullUpExerciseName::LPullUp,
            35 => FitFieldPullUpExerciseName::WeightedLPullUp,
            36 => FitFieldPullUpExerciseName::SuspendedChinUp,
            37 => FitFieldPullUpExerciseName::WeightedSuspendedChinUp,
            38 => FitFieldPullUpExerciseName::PullUp,
            _ => FitFieldPullUpExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSegmentDeleteStatus { // fit base type: enum
    DoNotDelete = 0,
    DeleteOne = 1,
    DeleteAll = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSegmentDeleteStatus {
    pub fn parse(input: &[u8]) -> Result<FitFieldSegmentDeleteStatus> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSegmentDeleteStatus::from(valid_val)),
            None => Ok(FitFieldSegmentDeleteStatus::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSegmentDeleteStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSegmentDeleteStatus::DoNotDelete,
            1 => FitFieldSegmentDeleteStatus::DeleteOne,
            2 => FitFieldSegmentDeleteStatus::DeleteAll,
            _ => FitFieldSegmentDeleteStatus::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFitnessEquipmentState { // fit base type: enum
    Ready = 0,
    InUse = 1,
    Paused = 2,
    Unknown = 3,  // lost connection to fitness equipment
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldFitnessEquipmentState {
    pub fn parse(input: &[u8]) -> Result<FitFieldFitnessEquipmentState> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldFitnessEquipmentState::from(valid_val)),
            None => Ok(FitFieldFitnessEquipmentState::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldFitnessEquipmentState {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldFitnessEquipmentState::Ready,
            1 => FitFieldFitnessEquipmentState::InUse,
            2 => FitFieldFitnessEquipmentState::Paused,
            3 => FitFieldFitnessEquipmentState::Unknown,
            _ => FitFieldFitnessEquipmentState::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAutoActivityDetect { // fit base type: uint32
    None, // 0
    Running, // 1
    Cycling, // 2
    Swimming, // 4
    Walking, // 8
    Elliptical, // 32
    Sedentary, // 1024
    AutoActivityDetect(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldAutoActivityDetect {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldAutoActivityDetect> {
        let val = parse_uint32(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    1 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    2 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    4 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    8 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    32 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    1024 => Ok(FitFieldAutoActivityDetect::from(valid_val)),
                    
                    v => Ok(FitFieldAutoActivityDetect::AutoActivityDetect(v)),
                }
            },
            None => Ok(FitFieldAutoActivityDetect::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldAutoActivityDetect {
    fn from(code: u32) -> Self {
        match code {
            0 => FitFieldAutoActivityDetect::None,
            1 => FitFieldAutoActivityDetect::Running,
            2 => FitFieldAutoActivityDetect::Cycling,
            4 => FitFieldAutoActivityDetect::Swimming,
            8 => FitFieldAutoActivityDetect::Walking,
            32 => FitFieldAutoActivityDetect::Elliptical,
            1024 => FitFieldAutoActivityDetect::Sedentary,
            _ => FitFieldAutoActivityDetect::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCalfRaiseExerciseName { // fit base type: uint16
    ThreeWayCalfRaise, // 0
    ThreeWayWeightedCalfRaise, // 1
    ThreeWaySingleLegCalfRaise, // 2
    ThreeWayWeightedSingleLegCalfRaise, // 3
    DonkeyCalfRaise, // 4
    WeightedDonkeyCalfRaise, // 5
    SeatedCalfRaise, // 6
    WeightedSeatedCalfRaise, // 7
    SeatedDumbbellToeRaise, // 8
    SingleLegBentKneeCalfRaise, // 9
    WeightedSingleLegBentKneeCalfRaise, // 10
    SingleLegDeclinePushUp, // 11
    SingleLegDonkeyCalfRaise, // 12
    WeightedSingleLegDonkeyCalfRaise, // 13
    SingleLegHipRaiseWithKneeHold, // 14
    SingleLegStandingCalfRaise, // 15
    SingleLegStandingDumbbellCalfRaise, // 16
    StandingBarbellCalfRaise, // 17
    StandingCalfRaise, // 18
    WeightedStandingCalfRaise, // 19
    StandingDumbbellCalfRaise, // 20
    CalfRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCalfRaiseExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCalfRaiseExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldCalfRaiseExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldCalfRaiseExerciseName::CalfRaiseExerciseName(v)),
                }
            },
            None => Ok(FitFieldCalfRaiseExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCalfRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCalfRaiseExerciseName::ThreeWayCalfRaise,
            1 => FitFieldCalfRaiseExerciseName::ThreeWayWeightedCalfRaise,
            2 => FitFieldCalfRaiseExerciseName::ThreeWaySingleLegCalfRaise,
            3 => FitFieldCalfRaiseExerciseName::ThreeWayWeightedSingleLegCalfRaise,
            4 => FitFieldCalfRaiseExerciseName::DonkeyCalfRaise,
            5 => FitFieldCalfRaiseExerciseName::WeightedDonkeyCalfRaise,
            6 => FitFieldCalfRaiseExerciseName::SeatedCalfRaise,
            7 => FitFieldCalfRaiseExerciseName::WeightedSeatedCalfRaise,
            8 => FitFieldCalfRaiseExerciseName::SeatedDumbbellToeRaise,
            9 => FitFieldCalfRaiseExerciseName::SingleLegBentKneeCalfRaise,
            10 => FitFieldCalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise,
            11 => FitFieldCalfRaiseExerciseName::SingleLegDeclinePushUp,
            12 => FitFieldCalfRaiseExerciseName::SingleLegDonkeyCalfRaise,
            13 => FitFieldCalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise,
            14 => FitFieldCalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold,
            15 => FitFieldCalfRaiseExerciseName::SingleLegStandingCalfRaise,
            16 => FitFieldCalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise,
            17 => FitFieldCalfRaiseExerciseName::StandingBarbellCalfRaise,
            18 => FitFieldCalfRaiseExerciseName::StandingCalfRaise,
            19 => FitFieldCalfRaiseExerciseName::WeightedStandingCalfRaise,
            20 => FitFieldCalfRaiseExerciseName::StandingDumbbellCalfRaise,
            _ => FitFieldCalfRaiseExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldRiderPositionType { // fit base type: enum
    Seated = 0,
    Standing = 1,
    TransitionToSeated = 2,
    TransitionToStanding = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldRiderPositionType {
    pub fn parse(input: &[u8]) -> Result<FitFieldRiderPositionType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldRiderPositionType::from(valid_val)),
            None => Ok(FitFieldRiderPositionType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldRiderPositionType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldRiderPositionType::Seated,
            1 => FitFieldRiderPositionType::Standing,
            2 => FitFieldRiderPositionType::TransitionToSeated,
            3 => FitFieldRiderPositionType::TransitionToStanding,
            _ => FitFieldRiderPositionType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldPlyoExerciseName { // fit base type: uint16
    AlternatingJumpLunge, // 0
    WeightedAlternatingJumpLunge, // 1
    BarbellJumpSquat, // 2
    BodyWeightJumpSquat, // 3
    WeightedJumpSquat, // 4
    CrossKneeStrike, // 5
    WeightedCrossKneeStrike, // 6
    DepthJump, // 7
    WeightedDepthJump, // 8
    DumbbellJumpSquat, // 9
    DumbbellSplitJump, // 10
    FrontKneeStrike, // 11
    WeightedFrontKneeStrike, // 12
    HighBoxJump, // 13
    WeightedHighBoxJump, // 14
    IsometricExplosiveBodyWeightJumpSquat, // 15
    WeightedIsometricExplosiveJumpSquat, // 16
    LateralLeapAndHop, // 17
    WeightedLateralLeapAndHop, // 18
    LateralPlyoSquats, // 19
    WeightedLateralPlyoSquats, // 20
    LateralSlide, // 21
    WeightedLateralSlide, // 22
    MedicineBallOverheadThrows, // 23
    MedicineBallSideThrow, // 24
    MedicineBallSlam, // 25
    SideToSideMedicineBallThrows, // 26
    SideToSideShuffleJump, // 27
    WeightedSideToSideShuffleJump, // 28
    SquatJumpOntoBox, // 29
    WeightedSquatJumpOntoBox, // 30
    SquatJumpsInAndOut, // 31
    WeightedSquatJumpsInAndOut, // 32
    PlyoExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldPlyoExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldPlyoExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldPlyoExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldPlyoExerciseName::PlyoExerciseName(v)),
                }
            },
            None => Ok(FitFieldPlyoExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldPlyoExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPlyoExerciseName::AlternatingJumpLunge,
            1 => FitFieldPlyoExerciseName::WeightedAlternatingJumpLunge,
            2 => FitFieldPlyoExerciseName::BarbellJumpSquat,
            3 => FitFieldPlyoExerciseName::BodyWeightJumpSquat,
            4 => FitFieldPlyoExerciseName::WeightedJumpSquat,
            5 => FitFieldPlyoExerciseName::CrossKneeStrike,
            6 => FitFieldPlyoExerciseName::WeightedCrossKneeStrike,
            7 => FitFieldPlyoExerciseName::DepthJump,
            8 => FitFieldPlyoExerciseName::WeightedDepthJump,
            9 => FitFieldPlyoExerciseName::DumbbellJumpSquat,
            10 => FitFieldPlyoExerciseName::DumbbellSplitJump,
            11 => FitFieldPlyoExerciseName::FrontKneeStrike,
            12 => FitFieldPlyoExerciseName::WeightedFrontKneeStrike,
            13 => FitFieldPlyoExerciseName::HighBoxJump,
            14 => FitFieldPlyoExerciseName::WeightedHighBoxJump,
            15 => FitFieldPlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat,
            16 => FitFieldPlyoExerciseName::WeightedIsometricExplosiveJumpSquat,
            17 => FitFieldPlyoExerciseName::LateralLeapAndHop,
            18 => FitFieldPlyoExerciseName::WeightedLateralLeapAndHop,
            19 => FitFieldPlyoExerciseName::LateralPlyoSquats,
            20 => FitFieldPlyoExerciseName::WeightedLateralPlyoSquats,
            21 => FitFieldPlyoExerciseName::LateralSlide,
            22 => FitFieldPlyoExerciseName::WeightedLateralSlide,
            23 => FitFieldPlyoExerciseName::MedicineBallOverheadThrows,
            24 => FitFieldPlyoExerciseName::MedicineBallSideThrow,
            25 => FitFieldPlyoExerciseName::MedicineBallSlam,
            26 => FitFieldPlyoExerciseName::SideToSideMedicineBallThrows,
            27 => FitFieldPlyoExerciseName::SideToSideShuffleJump,
            28 => FitFieldPlyoExerciseName::WeightedSideToSideShuffleJump,
            29 => FitFieldPlyoExerciseName::SquatJumpOntoBox,
            30 => FitFieldPlyoExerciseName::WeightedSquatJumpOntoBox,
            31 => FitFieldPlyoExerciseName::SquatJumpsInAndOut,
            32 => FitFieldPlyoExerciseName::WeightedSquatJumpsInAndOut,
            _ => FitFieldPlyoExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldGarminProduct { // fit base type: uint16
    Hrm1, // 1
    Axh01, // 2  AXH01 HRM chipset
    Axb01, // 3
    Axb02, // 4
    Hrm2ss, // 5
    DsiAlf02, // 6
    Hrm3ss, // 7
    HrmRunSingleByteProductId, // 8  hrm_run model for HRM ANT+ messaging
    Bsm, // 9  BSM model for ANT+ messaging
    Bcm, // 10  BCM model for ANT+ messaging
    Axs01, // 11  AXS01 HRM Bike Chipset model for ANT+ messaging
    HrmTriSingleByteProductId, // 12  hrm_tri model for HRM ANT+ messaging
    Fr225SingleByteProductId, // 14  fr225 model for HRM ANT+ messaging
    Fr301China, // 473
    Fr301Japan, // 474
    Fr301Korea, // 475
    Fr301Taiwan, // 494
    Fr405, // 717  Forerunner 405
    Fr50, // 782  Forerunner 50
    Fr405Japan, // 987
    Fr60, // 988  Forerunner 60
    DsiAlf01, // 1011
    Fr310xt, // 1018  Forerunner 310
    Edge500, // 1036
    Fr110, // 1124  Forerunner 110
    Edge800, // 1169
    Edge500Taiwan, // 1199
    Edge500Japan, // 1213
    Chirp, // 1253
    Fr110Japan, // 1274
    Edge200, // 1325
    Fr910xt, // 1328
    Edge800Taiwan, // 1333
    Edge800Japan, // 1334
    Alf04, // 1341
    Fr610, // 1345
    Fr210Japan, // 1360
    VectorSs, // 1380
    VectorCp, // 1381
    Edge800China, // 1386
    Edge500China, // 1387
    Fr610Japan, // 1410
    Edge500Korea, // 1422
    Fr70, // 1436
    Fr310xt4t, // 1446
    Amx, // 1461
    Fr10, // 1482
    Edge800Korea, // 1497
    Swim, // 1499
    Fr910xtChina, // 1537
    Fenix, // 1551
    Edge200Taiwan, // 1555
    Edge510, // 1561
    Edge810, // 1567
    Tempe, // 1570
    Fr910xtJapan, // 1600
    Fr620, // 1623
    Fr220, // 1632
    Fr910xtKorea, // 1664
    Fr10Japan, // 1688
    Edge810Japan, // 1721
    VirbElite, // 1735
    EdgeTouring, // 1736  Also Edge Touring Plus
    Edge510Japan, // 1742
    HrmTri, // 1743
    HrmRun, // 1752
    Fr920xt, // 1765
    Edge510Asia, // 1821
    Edge810China, // 1822
    Edge810Taiwan, // 1823
    Edge1000, // 1836
    VivoFit, // 1837
    VirbRemote, // 1853
    VivoKi, // 1885
    Fr15, // 1903
    VivoActive, // 1907
    Edge510Korea, // 1918
    Fr620Japan, // 1928
    Fr620China, // 1929
    Fr220Japan, // 1930
    Fr220China, // 1931
    ApproachS6, // 1936
    VivoSmart, // 1956
    Fenix2, // 1967
    Epix, // 1988
    Fenix3, // 2050
    Edge1000Taiwan, // 2052
    Edge1000Japan, // 2053
    Fr15Japan, // 2061
    Edge520, // 2067
    Edge1000China, // 2070
    Fr620Russia, // 2072
    Fr220Russia, // 2073
    VectorS, // 2079
    Edge1000Korea, // 2100
    Fr920xtTaiwan, // 2130
    Fr920xtChina, // 2131
    Fr920xtJapan, // 2132
    Virbx, // 2134
    VivoSmartApac, // 2135
    EtrexTouch, // 2140
    Edge25, // 2147
    Fr25, // 2148
    VivoFit2, // 2150
    Fr225, // 2153
    Fr630, // 2156
    Fr230, // 2157
    VivoActiveApac, // 2160
    Vector2, // 2161
    Vector2s, // 2162
    Virbxe, // 2172
    Fr620Taiwan, // 2173
    Fr220Taiwan, // 2174
    Truswing, // 2175
    Fenix3China, // 2188
    Fenix3Twn, // 2189
    VariaHeadlight, // 2192
    VariaTaillightOld, // 2193
    EdgeExplore1000, // 2204
    Fr225Asia, // 2219
    VariaRadarTaillight, // 2225
    VariaRadarDisplay, // 2226
    Edge20, // 2238
    D2Bravo, // 2262
    ApproachS20, // 2266
    VariaRemote, // 2276
    Hrm4Run, // 2327
    VivoActiveHr, // 2337
    VivoSmartGpsHr, // 2347
    VivoSmartHr, // 2348
    VivoMove, // 2368
    VariaVision, // 2398
    VivoFit3, // 2406
    Fenix3Hr, // 2413
    VirbUltra30, // 2417
    IndexSmartScale, // 2429
    Fr235, // 2431
    Fenix3Chronos, // 2432
    Oregon7xx, // 2441
    Rino7xx, // 2444
    Nautix, // 2496
    Edge820, // 2530
    EdgeExplore820, // 2531
    Fenix5s, // 2544
    D2BravoTitanium, // 2547
    VariaUt800, // 2567  Varia UT 800 SW
    RunningDynamicsPod, // 2593
    Fenix5x, // 2604
    VivoFitJr, // 2606
    Fr935, // 2691
    Fenix5, // 2697
    Sdm4, // 10007  SDM4 footpod
    EdgeRemote, // 10014
    TrainingCenter, // 20119
    ConnectiqSimulator, // 65531
    AndroidAntplusPlugin, // 65532
    Connect, // 65534  Garmin Connect website
    GarminProduct(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldGarminProduct {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldGarminProduct> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    3 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    4 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    5 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    6 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    7 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    8 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    9 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    10 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    11 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    12 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    14 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    473 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    474 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    475 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    494 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    717 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    782 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    987 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    988 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1011 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1018 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1036 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1124 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1169 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1199 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1213 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1253 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1274 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1325 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1328 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1333 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1334 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1341 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1345 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1360 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1380 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1381 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1386 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1387 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1410 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1422 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1436 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1446 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1461 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1482 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1497 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1499 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1537 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1551 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1555 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1561 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1567 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1570 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1600 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1623 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1632 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1664 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1688 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1721 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1735 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1736 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1742 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1743 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1752 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1765 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1821 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1822 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1823 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1836 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1837 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1853 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1885 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1903 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1907 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1918 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1928 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1929 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1930 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1931 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1936 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1956 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1967 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    1988 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2050 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2052 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2053 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2061 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2067 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2070 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2072 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2073 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2079 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2100 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2130 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2131 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2132 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2134 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2135 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2140 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2147 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2148 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2150 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2153 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2156 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2157 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2160 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2161 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2162 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2172 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2173 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2174 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2175 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2188 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2189 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2192 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2193 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2204 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2219 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2225 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2226 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2238 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2262 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2266 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2276 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2327 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2337 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2347 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2348 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2368 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2398 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2406 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2413 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2417 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2429 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2431 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2432 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2441 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2444 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2496 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2530 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2531 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2544 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2547 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2567 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2593 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2604 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2606 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2691 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    2697 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    10007 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    10014 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    20119 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    65531 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    65532 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    65534 => Ok(FitFieldGarminProduct::from(valid_val)),
                    
                    v => Ok(FitFieldGarminProduct::GarminProduct(v)),
                }
            },
            None => Ok(FitFieldGarminProduct::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldGarminProduct {
    fn from(code: u16) -> Self {
        match code {
            1 => FitFieldGarminProduct::Hrm1,
            2 => FitFieldGarminProduct::Axh01,
            3 => FitFieldGarminProduct::Axb01,
            4 => FitFieldGarminProduct::Axb02,
            5 => FitFieldGarminProduct::Hrm2ss,
            6 => FitFieldGarminProduct::DsiAlf02,
            7 => FitFieldGarminProduct::Hrm3ss,
            8 => FitFieldGarminProduct::HrmRunSingleByteProductId,
            9 => FitFieldGarminProduct::Bsm,
            10 => FitFieldGarminProduct::Bcm,
            11 => FitFieldGarminProduct::Axs01,
            12 => FitFieldGarminProduct::HrmTriSingleByteProductId,
            14 => FitFieldGarminProduct::Fr225SingleByteProductId,
            473 => FitFieldGarminProduct::Fr301China,
            474 => FitFieldGarminProduct::Fr301Japan,
            475 => FitFieldGarminProduct::Fr301Korea,
            494 => FitFieldGarminProduct::Fr301Taiwan,
            717 => FitFieldGarminProduct::Fr405,
            782 => FitFieldGarminProduct::Fr50,
            987 => FitFieldGarminProduct::Fr405Japan,
            988 => FitFieldGarminProduct::Fr60,
            1011 => FitFieldGarminProduct::DsiAlf01,
            1018 => FitFieldGarminProduct::Fr310xt,
            1036 => FitFieldGarminProduct::Edge500,
            1124 => FitFieldGarminProduct::Fr110,
            1169 => FitFieldGarminProduct::Edge800,
            1199 => FitFieldGarminProduct::Edge500Taiwan,
            1213 => FitFieldGarminProduct::Edge500Japan,
            1253 => FitFieldGarminProduct::Chirp,
            1274 => FitFieldGarminProduct::Fr110Japan,
            1325 => FitFieldGarminProduct::Edge200,
            1328 => FitFieldGarminProduct::Fr910xt,
            1333 => FitFieldGarminProduct::Edge800Taiwan,
            1334 => FitFieldGarminProduct::Edge800Japan,
            1341 => FitFieldGarminProduct::Alf04,
            1345 => FitFieldGarminProduct::Fr610,
            1360 => FitFieldGarminProduct::Fr210Japan,
            1380 => FitFieldGarminProduct::VectorSs,
            1381 => FitFieldGarminProduct::VectorCp,
            1386 => FitFieldGarminProduct::Edge800China,
            1387 => FitFieldGarminProduct::Edge500China,
            1410 => FitFieldGarminProduct::Fr610Japan,
            1422 => FitFieldGarminProduct::Edge500Korea,
            1436 => FitFieldGarminProduct::Fr70,
            1446 => FitFieldGarminProduct::Fr310xt4t,
            1461 => FitFieldGarminProduct::Amx,
            1482 => FitFieldGarminProduct::Fr10,
            1497 => FitFieldGarminProduct::Edge800Korea,
            1499 => FitFieldGarminProduct::Swim,
            1537 => FitFieldGarminProduct::Fr910xtChina,
            1551 => FitFieldGarminProduct::Fenix,
            1555 => FitFieldGarminProduct::Edge200Taiwan,
            1561 => FitFieldGarminProduct::Edge510,
            1567 => FitFieldGarminProduct::Edge810,
            1570 => FitFieldGarminProduct::Tempe,
            1600 => FitFieldGarminProduct::Fr910xtJapan,
            1623 => FitFieldGarminProduct::Fr620,
            1632 => FitFieldGarminProduct::Fr220,
            1664 => FitFieldGarminProduct::Fr910xtKorea,
            1688 => FitFieldGarminProduct::Fr10Japan,
            1721 => FitFieldGarminProduct::Edge810Japan,
            1735 => FitFieldGarminProduct::VirbElite,
            1736 => FitFieldGarminProduct::EdgeTouring,
            1742 => FitFieldGarminProduct::Edge510Japan,
            1743 => FitFieldGarminProduct::HrmTri,
            1752 => FitFieldGarminProduct::HrmRun,
            1765 => FitFieldGarminProduct::Fr920xt,
            1821 => FitFieldGarminProduct::Edge510Asia,
            1822 => FitFieldGarminProduct::Edge810China,
            1823 => FitFieldGarminProduct::Edge810Taiwan,
            1836 => FitFieldGarminProduct::Edge1000,
            1837 => FitFieldGarminProduct::VivoFit,
            1853 => FitFieldGarminProduct::VirbRemote,
            1885 => FitFieldGarminProduct::VivoKi,
            1903 => FitFieldGarminProduct::Fr15,
            1907 => FitFieldGarminProduct::VivoActive,
            1918 => FitFieldGarminProduct::Edge510Korea,
            1928 => FitFieldGarminProduct::Fr620Japan,
            1929 => FitFieldGarminProduct::Fr620China,
            1930 => FitFieldGarminProduct::Fr220Japan,
            1931 => FitFieldGarminProduct::Fr220China,
            1936 => FitFieldGarminProduct::ApproachS6,
            1956 => FitFieldGarminProduct::VivoSmart,
            1967 => FitFieldGarminProduct::Fenix2,
            1988 => FitFieldGarminProduct::Epix,
            2050 => FitFieldGarminProduct::Fenix3,
            2052 => FitFieldGarminProduct::Edge1000Taiwan,
            2053 => FitFieldGarminProduct::Edge1000Japan,
            2061 => FitFieldGarminProduct::Fr15Japan,
            2067 => FitFieldGarminProduct::Edge520,
            2070 => FitFieldGarminProduct::Edge1000China,
            2072 => FitFieldGarminProduct::Fr620Russia,
            2073 => FitFieldGarminProduct::Fr220Russia,
            2079 => FitFieldGarminProduct::VectorS,
            2100 => FitFieldGarminProduct::Edge1000Korea,
            2130 => FitFieldGarminProduct::Fr920xtTaiwan,
            2131 => FitFieldGarminProduct::Fr920xtChina,
            2132 => FitFieldGarminProduct::Fr920xtJapan,
            2134 => FitFieldGarminProduct::Virbx,
            2135 => FitFieldGarminProduct::VivoSmartApac,
            2140 => FitFieldGarminProduct::EtrexTouch,
            2147 => FitFieldGarminProduct::Edge25,
            2148 => FitFieldGarminProduct::Fr25,
            2150 => FitFieldGarminProduct::VivoFit2,
            2153 => FitFieldGarminProduct::Fr225,
            2156 => FitFieldGarminProduct::Fr630,
            2157 => FitFieldGarminProduct::Fr230,
            2160 => FitFieldGarminProduct::VivoActiveApac,
            2161 => FitFieldGarminProduct::Vector2,
            2162 => FitFieldGarminProduct::Vector2s,
            2172 => FitFieldGarminProduct::Virbxe,
            2173 => FitFieldGarminProduct::Fr620Taiwan,
            2174 => FitFieldGarminProduct::Fr220Taiwan,
            2175 => FitFieldGarminProduct::Truswing,
            2188 => FitFieldGarminProduct::Fenix3China,
            2189 => FitFieldGarminProduct::Fenix3Twn,
            2192 => FitFieldGarminProduct::VariaHeadlight,
            2193 => FitFieldGarminProduct::VariaTaillightOld,
            2204 => FitFieldGarminProduct::EdgeExplore1000,
            2219 => FitFieldGarminProduct::Fr225Asia,
            2225 => FitFieldGarminProduct::VariaRadarTaillight,
            2226 => FitFieldGarminProduct::VariaRadarDisplay,
            2238 => FitFieldGarminProduct::Edge20,
            2262 => FitFieldGarminProduct::D2Bravo,
            2266 => FitFieldGarminProduct::ApproachS20,
            2276 => FitFieldGarminProduct::VariaRemote,
            2327 => FitFieldGarminProduct::Hrm4Run,
            2337 => FitFieldGarminProduct::VivoActiveHr,
            2347 => FitFieldGarminProduct::VivoSmartGpsHr,
            2348 => FitFieldGarminProduct::VivoSmartHr,
            2368 => FitFieldGarminProduct::VivoMove,
            2398 => FitFieldGarminProduct::VariaVision,
            2406 => FitFieldGarminProduct::VivoFit3,
            2413 => FitFieldGarminProduct::Fenix3Hr,
            2417 => FitFieldGarminProduct::VirbUltra30,
            2429 => FitFieldGarminProduct::IndexSmartScale,
            2431 => FitFieldGarminProduct::Fr235,
            2432 => FitFieldGarminProduct::Fenix3Chronos,
            2441 => FitFieldGarminProduct::Oregon7xx,
            2444 => FitFieldGarminProduct::Rino7xx,
            2496 => FitFieldGarminProduct::Nautix,
            2530 => FitFieldGarminProduct::Edge820,
            2531 => FitFieldGarminProduct::EdgeExplore820,
            2544 => FitFieldGarminProduct::Fenix5s,
            2547 => FitFieldGarminProduct::D2BravoTitanium,
            2567 => FitFieldGarminProduct::VariaUt800,
            2593 => FitFieldGarminProduct::RunningDynamicsPod,
            2604 => FitFieldGarminProduct::Fenix5x,
            2606 => FitFieldGarminProduct::VivoFitJr,
            2691 => FitFieldGarminProduct::Fr935,
            2697 => FitFieldGarminProduct::Fenix5,
            10007 => FitFieldGarminProduct::Sdm4,
            10014 => FitFieldGarminProduct::EdgeRemote,
            20119 => FitFieldGarminProduct::TrainingCenter,
            65531 => FitFieldGarminProduct::ConnectiqSimulator,
            65532 => FitFieldGarminProduct::AndroidAntplusPlugin,
            65534 => FitFieldGarminProduct::Connect,
            _ => FitFieldGarminProduct::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldExdLayout { // fit base type: enum
    FullScreen = 0,
    HalfVertical = 1,
    HalfHorizontal = 2,
    HalfVerticalRightSplit = 3,
    HalfHorizontalBottomSplit = 4,
    FullQuarterSplit = 5,
    HalfVerticalLeftSplit = 6,
    HalfHorizontalTopSplit = 7,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldExdLayout {
    pub fn parse(input: &[u8]) -> Result<FitFieldExdLayout> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldExdLayout::from(valid_val)),
            None => Ok(FitFieldExdLayout::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldExdLayout {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdLayout::FullScreen,
            1 => FitFieldExdLayout::HalfVertical,
            2 => FitFieldExdLayout::HalfHorizontal,
            3 => FitFieldExdLayout::HalfVerticalRightSplit,
            4 => FitFieldExdLayout::HalfHorizontalBottomSplit,
            5 => FitFieldExdLayout::FullQuarterSplit,
            6 => FitFieldExdLayout::HalfVerticalLeftSplit,
            7 => FitFieldExdLayout::HalfHorizontalTopSplit,
            _ => FitFieldExdLayout::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWorkoutPower { // fit base type: uint32
    WattsOffset, // 1000
    WorkoutPower(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldWorkoutPower {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldWorkoutPower> {
        let val = parse_uint32(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1000 => Ok(FitFieldWorkoutPower::from(valid_val)),
                    
                    v => Ok(FitFieldWorkoutPower::WorkoutPower(v)),
                }
            },
            None => Ok(FitFieldWorkoutPower::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldWorkoutPower {
    fn from(code: u32) -> Self {
        match code {
            1000 => FitFieldWorkoutPower::WattsOffset,
            _ => FitFieldWorkoutPower::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldChopExerciseName { // fit base type: uint16
    CablePullThrough, // 0
    CableRotationalLift, // 1
    CableWoodchop, // 2
    CrossChopToKnee, // 3
    WeightedCrossChopToKnee, // 4
    DumbbellChop, // 5
    HalfKneelingRotation, // 6
    WeightedHalfKneelingRotation, // 7
    HalfKneelingRotationalChop, // 8
    HalfKneelingRotationalReverseChop, // 9
    HalfKneelingStabilityChop, // 10
    HalfKneelingStabilityReverseChop, // 11
    KneelingRotationalChop, // 12
    KneelingRotationalReverseChop, // 13
    KneelingStabilityChop, // 14
    KneelingWoodchopper, // 15
    MedicineBallWoodChops, // 16
    PowerSquatChops, // 17
    WeightedPowerSquatChops, // 18
    StandingRotationalChop, // 19
    StandingSplitRotationalChop, // 20
    StandingSplitRotationalReverseChop, // 21
    StandingStabilityReverseChop, // 22
    ChopExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldChopExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldChopExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldChopExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldChopExerciseName::ChopExerciseName(v)),
                }
            },
            None => Ok(FitFieldChopExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldChopExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldChopExerciseName::CablePullThrough,
            1 => FitFieldChopExerciseName::CableRotationalLift,
            2 => FitFieldChopExerciseName::CableWoodchop,
            3 => FitFieldChopExerciseName::CrossChopToKnee,
            4 => FitFieldChopExerciseName::WeightedCrossChopToKnee,
            5 => FitFieldChopExerciseName::DumbbellChop,
            6 => FitFieldChopExerciseName::HalfKneelingRotation,
            7 => FitFieldChopExerciseName::WeightedHalfKneelingRotation,
            8 => FitFieldChopExerciseName::HalfKneelingRotationalChop,
            9 => FitFieldChopExerciseName::HalfKneelingRotationalReverseChop,
            10 => FitFieldChopExerciseName::HalfKneelingStabilityChop,
            11 => FitFieldChopExerciseName::HalfKneelingStabilityReverseChop,
            12 => FitFieldChopExerciseName::KneelingRotationalChop,
            13 => FitFieldChopExerciseName::KneelingRotationalReverseChop,
            14 => FitFieldChopExerciseName::KneelingStabilityChop,
            15 => FitFieldChopExerciseName::KneelingWoodchopper,
            16 => FitFieldChopExerciseName::MedicineBallWoodChops,
            17 => FitFieldChopExerciseName::PowerSquatChops,
            18 => FitFieldChopExerciseName::WeightedPowerSquatChops,
            19 => FitFieldChopExerciseName::StandingRotationalChop,
            20 => FitFieldChopExerciseName::StandingSplitRotationalChop,
            21 => FitFieldChopExerciseName::StandingSplitRotationalReverseChop,
            22 => FitFieldChopExerciseName::StandingStabilityReverseChop,
            _ => FitFieldChopExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWorkoutEquipment { // fit base type: enum
    None = 0,
    SwimFins = 1,
    SwimKickboard = 2,
    SwimPaddles = 3,
    SwimPullBuoy = 4,
    SwimSnorkel = 5,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWorkoutEquipment {
    pub fn parse(input: &[u8]) -> Result<FitFieldWorkoutEquipment> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWorkoutEquipment::from(valid_val)),
            None => Ok(FitFieldWorkoutEquipment::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWorkoutEquipment {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWorkoutEquipment::None,
            1 => FitFieldWorkoutEquipment::SwimFins,
            2 => FitFieldWorkoutEquipment::SwimKickboard,
            3 => FitFieldWorkoutEquipment::SwimPaddles,
            4 => FitFieldWorkoutEquipment::SwimPullBuoy,
            5 => FitFieldWorkoutEquipment::SwimSnorkel,
            _ => FitFieldWorkoutEquipment::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWeatherReport { // fit base type: enum
    Current = 0,
    HourlyForecast = 1,
    DailyForecast = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWeatherReport {
    pub fn parse(input: &[u8]) -> Result<FitFieldWeatherReport> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWeatherReport::from(valid_val)),
            None => Ok(FitFieldWeatherReport::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWeatherReport {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherReport::Current,
            1 => FitFieldWeatherReport::HourlyForecast,
            2 => FitFieldWeatherReport::DailyForecast,
            _ => FitFieldWeatherReport::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldActivitySubtype { // fit base type: enum
    Generic = 0,
    Treadmill = 1,  // Run
    Street = 2,  // Run
    Trail = 3,  // Run
    Track = 4,  // Run
    Spin = 5,  // Cycling
    IndoorCycling = 6,  // Cycling
    Road = 7,  // Cycling
    Mountain = 8,  // Cycling
    Downhill = 9,  // Cycling
    Recumbent = 10,  // Cycling
    Cyclocross = 11,  // Cycling
    HandCycling = 12,  // Cycling
    TrackCycling = 13,  // Cycling
    IndoorRowing = 14,  // Fitness Equipment
    Elliptical = 15,  // Fitness Equipment
    StairClimbing = 16,  // Fitness Equipment
    LapSwimming = 17,  // Swimming
    OpenWater = 18,  // Swimming
    All = 254,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldActivitySubtype {
    pub fn parse(input: &[u8]) -> Result<FitFieldActivitySubtype> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldActivitySubtype::from(valid_val)),
            None => Ok(FitFieldActivitySubtype::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldActivitySubtype {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivitySubtype::Generic,
            1 => FitFieldActivitySubtype::Treadmill,
            2 => FitFieldActivitySubtype::Street,
            3 => FitFieldActivitySubtype::Trail,
            4 => FitFieldActivitySubtype::Track,
            5 => FitFieldActivitySubtype::Spin,
            6 => FitFieldActivitySubtype::IndoorCycling,
            7 => FitFieldActivitySubtype::Road,
            8 => FitFieldActivitySubtype::Mountain,
            9 => FitFieldActivitySubtype::Downhill,
            10 => FitFieldActivitySubtype::Recumbent,
            11 => FitFieldActivitySubtype::Cyclocross,
            12 => FitFieldActivitySubtype::HandCycling,
            13 => FitFieldActivitySubtype::TrackCycling,
            14 => FitFieldActivitySubtype::IndoorRowing,
            15 => FitFieldActivitySubtype::Elliptical,
            16 => FitFieldActivitySubtype::StairClimbing,
            17 => FitFieldActivitySubtype::LapSwimming,
            18 => FitFieldActivitySubtype::OpenWater,
            254 => FitFieldActivitySubtype::All,
            _ => FitFieldActivitySubtype::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDayOfWeek { // fit base type: enum
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDayOfWeek {
    pub fn parse(input: &[u8]) -> Result<FitFieldDayOfWeek> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDayOfWeek::from(valid_val)),
            None => Ok(FitFieldDayOfWeek::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDayOfWeek {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDayOfWeek::Sunday,
            1 => FitFieldDayOfWeek::Monday,
            2 => FitFieldDayOfWeek::Tuesday,
            3 => FitFieldDayOfWeek::Wednesday,
            4 => FitFieldDayOfWeek::Thursday,
            5 => FitFieldDayOfWeek::Friday,
            6 => FitFieldDayOfWeek::Saturday,
            _ => FitFieldDayOfWeek::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLateralRaiseExerciseName { // fit base type: uint16
    FortyFiveDegreeCableExternalRotation, // 0
    AlternatingLateralRaiseWithStaticHold, // 1
    BarMuscleUp, // 2
    BentOverLateralRaise, // 3
    CableDiagonalRaise, // 4
    CableFrontRaise, // 5
    CalorieRow, // 6
    ComboShoulderRaise, // 7
    DumbbellDiagonalRaise, // 8
    DumbbellVRaise, // 9
    FrontRaise, // 10
    LeaningDumbbellLateralRaise, // 11
    LyingDumbbellRaise, // 12
    MuscleUp, // 13
    OneArmCableLateralRaise, // 14
    OverhandGripRearLateralRaise, // 15
    PlateRaises, // 16
    RingDip, // 17
    WeightedRingDip, // 18
    RingMuscleUp, // 19
    WeightedRingMuscleUp, // 20
    RopeClimb, // 21
    WeightedRopeClimb, // 22
    Scaption, // 23
    SeatedLateralRaise, // 24
    SeatedRearLateralRaise, // 25
    SideLyingLateralRaise, // 26
    StandingLift, // 27
    SuspendedRow, // 28
    UnderhandGripRearLateralRaise, // 29
    WallSlide, // 30
    WeightedWallSlide, // 31
    ArmCircles, // 32
    ShavingTheHead, // 33
    LateralRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLateralRaiseExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldLateralRaiseExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldLateralRaiseExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldLateralRaiseExerciseName::LateralRaiseExerciseName(v)),
                }
            },
            None => Ok(FitFieldLateralRaiseExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldLateralRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLateralRaiseExerciseName::FortyFiveDegreeCableExternalRotation,
            1 => FitFieldLateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold,
            2 => FitFieldLateralRaiseExerciseName::BarMuscleUp,
            3 => FitFieldLateralRaiseExerciseName::BentOverLateralRaise,
            4 => FitFieldLateralRaiseExerciseName::CableDiagonalRaise,
            5 => FitFieldLateralRaiseExerciseName::CableFrontRaise,
            6 => FitFieldLateralRaiseExerciseName::CalorieRow,
            7 => FitFieldLateralRaiseExerciseName::ComboShoulderRaise,
            8 => FitFieldLateralRaiseExerciseName::DumbbellDiagonalRaise,
            9 => FitFieldLateralRaiseExerciseName::DumbbellVRaise,
            10 => FitFieldLateralRaiseExerciseName::FrontRaise,
            11 => FitFieldLateralRaiseExerciseName::LeaningDumbbellLateralRaise,
            12 => FitFieldLateralRaiseExerciseName::LyingDumbbellRaise,
            13 => FitFieldLateralRaiseExerciseName::MuscleUp,
            14 => FitFieldLateralRaiseExerciseName::OneArmCableLateralRaise,
            15 => FitFieldLateralRaiseExerciseName::OverhandGripRearLateralRaise,
            16 => FitFieldLateralRaiseExerciseName::PlateRaises,
            17 => FitFieldLateralRaiseExerciseName::RingDip,
            18 => FitFieldLateralRaiseExerciseName::WeightedRingDip,
            19 => FitFieldLateralRaiseExerciseName::RingMuscleUp,
            20 => FitFieldLateralRaiseExerciseName::WeightedRingMuscleUp,
            21 => FitFieldLateralRaiseExerciseName::RopeClimb,
            22 => FitFieldLateralRaiseExerciseName::WeightedRopeClimb,
            23 => FitFieldLateralRaiseExerciseName::Scaption,
            24 => FitFieldLateralRaiseExerciseName::SeatedLateralRaise,
            25 => FitFieldLateralRaiseExerciseName::SeatedRearLateralRaise,
            26 => FitFieldLateralRaiseExerciseName::SideLyingLateralRaise,
            27 => FitFieldLateralRaiseExerciseName::StandingLift,
            28 => FitFieldLateralRaiseExerciseName::SuspendedRow,
            29 => FitFieldLateralRaiseExerciseName::UnderhandGripRearLateralRaise,
            30 => FitFieldLateralRaiseExerciseName::WallSlide,
            31 => FitFieldLateralRaiseExerciseName::WeightedWallSlide,
            32 => FitFieldLateralRaiseExerciseName::ArmCircles,
            33 => FitFieldLateralRaiseExerciseName::ShavingTheHead,
            _ => FitFieldLateralRaiseExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAntplusDeviceType { // fit base type: uint8
    Antfs, // 1
    BikePower, // 11
    EnvironmentSensorLegacy, // 12
    MultiSportSpeedDistance, // 15
    Control, // 16
    FitnessEquipment, // 17
    BloodPressure, // 18
    GeocacheNode, // 19
    LightElectricVehicle, // 20
    EnvSensor, // 25
    Racquet, // 26
    ControlHub, // 27
    MuscleOxygen, // 31
    BikeLightMain, // 35
    BikeLightShared, // 36
    Exd, // 38
    BikeRadar, // 40
    BikeAero, // 46
    WeightScale, // 119
    HeartRate, // 120
    BikeSpeedCadence, // 121
    BikeCadence, // 122
    BikeSpeed, // 123
    StrideSpeedDistance, // 124
    AntplusDeviceType(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldAntplusDeviceType {
    pub fn parse(input: &[u8]) -> Result<FitFieldAntplusDeviceType> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    11 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    12 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    15 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    16 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    17 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    18 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    19 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    20 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    25 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    26 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    27 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    31 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    35 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    36 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    38 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    40 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    46 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    119 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    120 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    121 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    122 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    123 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    124 => Ok(FitFieldAntplusDeviceType::from(valid_val)),
                    
                    v => Ok(FitFieldAntplusDeviceType::AntplusDeviceType(v)),
                }
            },
            None => Ok(FitFieldAntplusDeviceType::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldAntplusDeviceType {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldAntplusDeviceType::Antfs,
            11 => FitFieldAntplusDeviceType::BikePower,
            12 => FitFieldAntplusDeviceType::EnvironmentSensorLegacy,
            15 => FitFieldAntplusDeviceType::MultiSportSpeedDistance,
            16 => FitFieldAntplusDeviceType::Control,
            17 => FitFieldAntplusDeviceType::FitnessEquipment,
            18 => FitFieldAntplusDeviceType::BloodPressure,
            19 => FitFieldAntplusDeviceType::GeocacheNode,
            20 => FitFieldAntplusDeviceType::LightElectricVehicle,
            25 => FitFieldAntplusDeviceType::EnvSensor,
            26 => FitFieldAntplusDeviceType::Racquet,
            27 => FitFieldAntplusDeviceType::ControlHub,
            31 => FitFieldAntplusDeviceType::MuscleOxygen,
            35 => FitFieldAntplusDeviceType::BikeLightMain,
            36 => FitFieldAntplusDeviceType::BikeLightShared,
            38 => FitFieldAntplusDeviceType::Exd,
            40 => FitFieldAntplusDeviceType::BikeRadar,
            46 => FitFieldAntplusDeviceType::BikeAero,
            119 => FitFieldAntplusDeviceType::WeightScale,
            120 => FitFieldAntplusDeviceType::HeartRate,
            121 => FitFieldAntplusDeviceType::BikeSpeedCadence,
            122 => FitFieldAntplusDeviceType::BikeCadence,
            123 => FitFieldAntplusDeviceType::BikeSpeed,
            124 => FitFieldAntplusDeviceType::StrideSpeedDistance,
            _ => FitFieldAntplusDeviceType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTurnType { // fit base type: enum
    ArrivingIdx = 0,
    ArrivingLeftIdx = 1,
    ArrivingRightIdx = 2,
    ArrivingViaIdx = 3,
    ArrivingViaLeftIdx = 4,
    ArrivingViaRightIdx = 5,
    BearKeepLeftIdx = 6,
    BearKeepRightIdx = 7,
    ContinueIdx = 8,
    ExitLeftIdx = 9,
    ExitRightIdx = 10,
    FerryIdx = 11,
    Roundabout45Idx = 12,
    Roundabout90Idx = 13,
    Roundabout135Idx = 14,
    Roundabout180Idx = 15,
    Roundabout225Idx = 16,
    Roundabout270Idx = 17,
    Roundabout315Idx = 18,
    Roundabout360Idx = 19,
    RoundaboutNeg45Idx = 20,
    RoundaboutNeg90Idx = 21,
    RoundaboutNeg135Idx = 22,
    RoundaboutNeg180Idx = 23,
    RoundaboutNeg225Idx = 24,
    RoundaboutNeg270Idx = 25,
    RoundaboutNeg315Idx = 26,
    RoundaboutNeg360Idx = 27,
    RoundaboutGenericIdx = 28,
    RoundaboutNegGenericIdx = 29,
    SharpTurnLeftIdx = 30,
    SharpTurnRightIdx = 31,
    TurnLeftIdx = 32,
    TurnRightIdx = 33,
    UturnLeftIdx = 34,
    UturnRightIdx = 35,
    IconInvIdx = 36,
    IconIdxCnt = 37,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldTurnType {
    pub fn parse(input: &[u8]) -> Result<FitFieldTurnType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldTurnType::from(valid_val)),
            None => Ok(FitFieldTurnType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldTurnType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldTurnType::ArrivingIdx,
            1 => FitFieldTurnType::ArrivingLeftIdx,
            2 => FitFieldTurnType::ArrivingRightIdx,
            3 => FitFieldTurnType::ArrivingViaIdx,
            4 => FitFieldTurnType::ArrivingViaLeftIdx,
            5 => FitFieldTurnType::ArrivingViaRightIdx,
            6 => FitFieldTurnType::BearKeepLeftIdx,
            7 => FitFieldTurnType::BearKeepRightIdx,
            8 => FitFieldTurnType::ContinueIdx,
            9 => FitFieldTurnType::ExitLeftIdx,
            10 => FitFieldTurnType::ExitRightIdx,
            11 => FitFieldTurnType::FerryIdx,
            12 => FitFieldTurnType::Roundabout45Idx,
            13 => FitFieldTurnType::Roundabout90Idx,
            14 => FitFieldTurnType::Roundabout135Idx,
            15 => FitFieldTurnType::Roundabout180Idx,
            16 => FitFieldTurnType::Roundabout225Idx,
            17 => FitFieldTurnType::Roundabout270Idx,
            18 => FitFieldTurnType::Roundabout315Idx,
            19 => FitFieldTurnType::Roundabout360Idx,
            20 => FitFieldTurnType::RoundaboutNeg45Idx,
            21 => FitFieldTurnType::RoundaboutNeg90Idx,
            22 => FitFieldTurnType::RoundaboutNeg135Idx,
            23 => FitFieldTurnType::RoundaboutNeg180Idx,
            24 => FitFieldTurnType::RoundaboutNeg225Idx,
            25 => FitFieldTurnType::RoundaboutNeg270Idx,
            26 => FitFieldTurnType::RoundaboutNeg315Idx,
            27 => FitFieldTurnType::RoundaboutNeg360Idx,
            28 => FitFieldTurnType::RoundaboutGenericIdx,
            29 => FitFieldTurnType::RoundaboutNegGenericIdx,
            30 => FitFieldTurnType::SharpTurnLeftIdx,
            31 => FitFieldTurnType::SharpTurnRightIdx,
            32 => FitFieldTurnType::TurnLeftIdx,
            33 => FitFieldTurnType::TurnRightIdx,
            34 => FitFieldTurnType::UturnLeftIdx,
            35 => FitFieldTurnType::UturnRightIdx,
            36 => FitFieldTurnType::IconInvIdx,
            37 => FitFieldTurnType::IconIdxCnt,
            _ => FitFieldTurnType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFitBaseUnit { // fit base type: uint16
    Other, // 0
    Kilogram, // 1
    Pound, // 2
    FitBaseUnit(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldFitBaseUnit {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldFitBaseUnit> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldFitBaseUnit::from(valid_val)),
                    
                    1 => Ok(FitFieldFitBaseUnit::from(valid_val)),
                    
                    2 => Ok(FitFieldFitBaseUnit::from(valid_val)),
                    
                    v => Ok(FitFieldFitBaseUnit::FitBaseUnit(v)),
                }
            },
            None => Ok(FitFieldFitBaseUnit::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldFitBaseUnit {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldFitBaseUnit::Other,
            1 => FitFieldFitBaseUnit::Kilogram,
            2 => FitFieldFitBaseUnit::Pound,
            _ => FitFieldFitBaseUnit::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBatteryStatus { // fit base type: uint8
    New, // 1
    Good, // 2
    Ok, // 3
    Low, // 4
    Critical, // 5
    Charging, // 6
    Unknown, // 7
    BatteryStatus(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldBatteryStatus {
    pub fn parse(input: &[u8]) -> Result<FitFieldBatteryStatus> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    2 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    3 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    4 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    5 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    6 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    7 => Ok(FitFieldBatteryStatus::from(valid_val)),
                    
                    v => Ok(FitFieldBatteryStatus::BatteryStatus(v)),
                }
            },
            None => Ok(FitFieldBatteryStatus::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldBatteryStatus {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldBatteryStatus::New,
            2 => FitFieldBatteryStatus::Good,
            3 => FitFieldBatteryStatus::Ok,
            4 => FitFieldBatteryStatus::Low,
            5 => FitFieldBatteryStatus::Critical,
            6 => FitFieldBatteryStatus::Charging,
            7 => FitFieldBatteryStatus::Unknown,
            _ => FitFieldBatteryStatus::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldChecksum { // fit base type: uint8
    Clear, // 0  Allows clear of checksum for flash memory where can only write 1 to 0 without erasing sector.
    Ok, // 1  Set to mark checksum as valid if computes to invalid values 0 or 0xFF.  Checksum can also be set to ok to save encoding computation time.
    Checksum(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldChecksum {
    pub fn parse(input: &[u8]) -> Result<FitFieldChecksum> {
        let val = parse_uint8(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldChecksum::from(valid_val)),
                    
                    1 => Ok(FitFieldChecksum::from(valid_val)),
                    
                    v => Ok(FitFieldChecksum::Checksum(v)),
                }
            },
            None => Ok(FitFieldChecksum::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldChecksum {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldChecksum::Clear,
            1 => FitFieldChecksum::Ok,
            _ => FitFieldChecksum::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWorkoutHr { // fit base type: uint32
    BpmOffset, // 100
    WorkoutHr(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldWorkoutHr {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldWorkoutHr> {
        let val = parse_uint32(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    100 => Ok(FitFieldWorkoutHr::from(valid_val)),
                    
                    v => Ok(FitFieldWorkoutHr::WorkoutHr(v)),
                }
            },
            None => Ok(FitFieldWorkoutHr::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldWorkoutHr {
    fn from(code: u32) -> Self {
        match code {
            100 => FitFieldWorkoutHr::BpmOffset,
            _ => FitFieldWorkoutHr::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLegRaiseExerciseName { // fit base type: uint16
    HangingKneeRaise, // 0
    HangingLegRaise, // 1
    WeightedHangingLegRaise, // 2
    HangingSingleLegRaise, // 3
    WeightedHangingSingleLegRaise, // 4
    KettlebellLegRaises, // 5
    LegLoweringDrill, // 6
    WeightedLegLoweringDrill, // 7
    LyingStraightLegRaise, // 8
    WeightedLyingStraightLegRaise, // 9
    MedicineBallLegDrops, // 10
    QuadrupedLegRaise, // 11
    WeightedQuadrupedLegRaise, // 12
    ReverseLegRaise, // 13
    WeightedReverseLegRaise, // 14
    ReverseLegRaiseOnSwissBall, // 15
    WeightedReverseLegRaiseOnSwissBall, // 16
    SingleLegLoweringDrill, // 17
    WeightedSingleLegLoweringDrill, // 18
    WeightedHangingKneeRaise, // 19
    LateralStepover, // 20
    WeightedLateralStepover, // 21
    LegRaiseExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLegRaiseExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldLegRaiseExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldLegRaiseExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldLegRaiseExerciseName::LegRaiseExerciseName(v)),
                }
            },
            None => Ok(FitFieldLegRaiseExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldLegRaiseExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldLegRaiseExerciseName::HangingKneeRaise,
            1 => FitFieldLegRaiseExerciseName::HangingLegRaise,
            2 => FitFieldLegRaiseExerciseName::WeightedHangingLegRaise,
            3 => FitFieldLegRaiseExerciseName::HangingSingleLegRaise,
            4 => FitFieldLegRaiseExerciseName::WeightedHangingSingleLegRaise,
            5 => FitFieldLegRaiseExerciseName::KettlebellLegRaises,
            6 => FitFieldLegRaiseExerciseName::LegLoweringDrill,
            7 => FitFieldLegRaiseExerciseName::WeightedLegLoweringDrill,
            8 => FitFieldLegRaiseExerciseName::LyingStraightLegRaise,
            9 => FitFieldLegRaiseExerciseName::WeightedLyingStraightLegRaise,
            10 => FitFieldLegRaiseExerciseName::MedicineBallLegDrops,
            11 => FitFieldLegRaiseExerciseName::QuadrupedLegRaise,
            12 => FitFieldLegRaiseExerciseName::WeightedQuadrupedLegRaise,
            13 => FitFieldLegRaiseExerciseName::ReverseLegRaise,
            14 => FitFieldLegRaiseExerciseName::WeightedReverseLegRaise,
            15 => FitFieldLegRaiseExerciseName::ReverseLegRaiseOnSwissBall,
            16 => FitFieldLegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall,
            17 => FitFieldLegRaiseExerciseName::SingleLegLoweringDrill,
            18 => FitFieldLegRaiseExerciseName::WeightedSingleLegLoweringDrill,
            19 => FitFieldLegRaiseExerciseName::WeightedHangingKneeRaise,
            20 => FitFieldLegRaiseExerciseName::LateralStepover,
            21 => FitFieldLegRaiseExerciseName::WeightedLateralStepover,
            _ => FitFieldLegRaiseExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLanguageBits3 { // fit base type: uint8z
    Bulgarian, // 1
    Romanian, // 2
    Chinese, // 4
    Japanese, // 8
    Korean, // 16
    Taiwanese, // 32
    Thai, // 64
    Hebrew, // 128
    LanguageBits3(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLanguageBits3 {
    pub fn parse(input: &[u8]) -> Result<FitFieldLanguageBits3> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    2 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    4 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    8 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    16 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    32 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    64 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    128 => Ok(FitFieldLanguageBits3::from(valid_val)),
                    
                    v => Ok(FitFieldLanguageBits3::LanguageBits3(v)),
                }
            },
            None => Ok(FitFieldLanguageBits3::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLanguageBits3 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits3::Bulgarian,
            2 => FitFieldLanguageBits3::Romanian,
            4 => FitFieldLanguageBits3::Chinese,
            8 => FitFieldLanguageBits3::Japanese,
            16 => FitFieldLanguageBits3::Korean,
            32 => FitFieldLanguageBits3::Taiwanese,
            64 => FitFieldLanguageBits3::Thai,
            128 => FitFieldLanguageBits3::Hebrew,
            _ => FitFieldLanguageBits3::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLanguageBits2 { // fit base type: uint8z
    Slovenian, // 1
    Swedish, // 2
    Russian, // 4
    Turkish, // 8
    Latvian, // 16
    Ukrainian, // 32
    Arabic, // 64
    Farsi, // 128
    LanguageBits2(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLanguageBits2 {
    pub fn parse(input: &[u8]) -> Result<FitFieldLanguageBits2> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    2 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    4 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    8 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    16 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    32 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    64 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    128 => Ok(FitFieldLanguageBits2::from(valid_val)),
                    
                    v => Ok(FitFieldLanguageBits2::LanguageBits2(v)),
                }
            },
            None => Ok(FitFieldLanguageBits2::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLanguageBits2 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits2::Slovenian,
            2 => FitFieldLanguageBits2::Swedish,
            4 => FitFieldLanguageBits2::Russian,
            8 => FitFieldLanguageBits2::Turkish,
            16 => FitFieldLanguageBits2::Latvian,
            32 => FitFieldLanguageBits2::Ukrainian,
            64 => FitFieldLanguageBits2::Arabic,
            128 => FitFieldLanguageBits2::Farsi,
            _ => FitFieldLanguageBits2::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLanguageBits1 { // fit base type: uint8z
    Dutch, // 1
    Finnish, // 2
    Greek, // 4
    Hungarian, // 8
    Norwegian, // 16
    Polish, // 32
    Portuguese, // 64
    Slovakian, // 128
    LanguageBits1(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLanguageBits1 {
    pub fn parse(input: &[u8]) -> Result<FitFieldLanguageBits1> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    2 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    4 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    8 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    16 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    32 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    64 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    128 => Ok(FitFieldLanguageBits1::from(valid_val)),
                    
                    v => Ok(FitFieldLanguageBits1::LanguageBits1(v)),
                }
            },
            None => Ok(FitFieldLanguageBits1::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLanguageBits1 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits1::Dutch,
            2 => FitFieldLanguageBits1::Finnish,
            4 => FitFieldLanguageBits1::Greek,
            8 => FitFieldLanguageBits1::Hungarian,
            16 => FitFieldLanguageBits1::Norwegian,
            32 => FitFieldLanguageBits1::Polish,
            64 => FitFieldLanguageBits1::Portuguese,
            128 => FitFieldLanguageBits1::Slovakian,
            _ => FitFieldLanguageBits1::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLanguageBits0 { // fit base type: uint8z
    English, // 1
    French, // 2
    Italian, // 4
    German, // 8
    Spanish, // 16
    Croatian, // 32
    Czech, // 64
    Danish, // 128
    LanguageBits0(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLanguageBits0 {
    pub fn parse(input: &[u8]) -> Result<FitFieldLanguageBits0> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    2 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    4 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    8 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    16 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    32 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    64 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    128 => Ok(FitFieldLanguageBits0::from(valid_val)),
                    
                    v => Ok(FitFieldLanguageBits0::LanguageBits0(v)),
                }
            },
            None => Ok(FitFieldLanguageBits0::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLanguageBits0 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits0::English,
            2 => FitFieldLanguageBits0::French,
            4 => FitFieldLanguageBits0::Italian,
            8 => FitFieldLanguageBits0::German,
            16 => FitFieldLanguageBits0::Spanish,
            32 => FitFieldLanguageBits0::Croatian,
            64 => FitFieldLanguageBits0::Czech,
            128 => FitFieldLanguageBits0::Danish,
            _ => FitFieldLanguageBits0::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldEventType { // fit base type: enum
    Start = 0,
    Stop = 1,
    ConsecutiveDepreciated = 2,
    Marker = 3,
    StopAll = 4,
    BeginDepreciated = 5,
    EndDepreciated = 6,
    EndAllDepreciated = 7,
    StopDisable = 8,
    StopDisableAll = 9,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldEventType {
    pub fn parse(input: &[u8]) -> Result<FitFieldEventType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldEventType::from(valid_val)),
            None => Ok(FitFieldEventType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldEventType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldEventType::Start,
            1 => FitFieldEventType::Stop,
            2 => FitFieldEventType::ConsecutiveDepreciated,
            3 => FitFieldEventType::Marker,
            4 => FitFieldEventType::StopAll,
            5 => FitFieldEventType::BeginDepreciated,
            6 => FitFieldEventType::EndDepreciated,
            7 => FitFieldEventType::EndAllDepreciated,
            8 => FitFieldEventType::StopDisable,
            9 => FitFieldEventType::StopDisableAll,
            _ => FitFieldEventType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldLanguageBits4 { // fit base type: uint8z
    BrazilianPortuguese, // 1
    Indonesian, // 2
    Malaysian, // 4
    Vietnamese, // 8
    Burmese, // 16
    Mongolian, // 32
    LanguageBits4(u8),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldLanguageBits4 {
    pub fn parse(input: &[u8]) -> Result<FitFieldLanguageBits4> {
        let val = parse_uint8z(input)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldLanguageBits4::from(valid_val)),
                    
                    2 => Ok(FitFieldLanguageBits4::from(valid_val)),
                    
                    4 => Ok(FitFieldLanguageBits4::from(valid_val)),
                    
                    8 => Ok(FitFieldLanguageBits4::from(valid_val)),
                    
                    16 => Ok(FitFieldLanguageBits4::from(valid_val)),
                    
                    32 => Ok(FitFieldLanguageBits4::from(valid_val)),
                    
                    v => Ok(FitFieldLanguageBits4::LanguageBits4(v)),
                }
            },
            None => Ok(FitFieldLanguageBits4::InvalidFieldValue),
        }
    }
}


impl From<u8> for FitFieldLanguageBits4 {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldLanguageBits4::BrazilianPortuguese,
            2 => FitFieldLanguageBits4::Indonesian,
            4 => FitFieldLanguageBits4::Malaysian,
            8 => FitFieldLanguageBits4::Vietnamese,
            16 => FitFieldLanguageBits4::Burmese,
            32 => FitFieldLanguageBits4::Mongolian,
            _ => FitFieldLanguageBits4::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBodyLocation { // fit base type: enum
    LeftLeg = 0,
    LeftCalf = 1,
    LeftShin = 2,
    LeftHamstring = 3,
    LeftQuad = 4,
    LeftGlute = 5,
    RightLeg = 6,
    RightCalf = 7,
    RightShin = 8,
    RightHamstring = 9,
    RightQuad = 10,
    RightGlute = 11,
    TorsoBack = 12,
    LeftLowerBack = 13,
    LeftUpperBack = 14,
    RightLowerBack = 15,
    RightUpperBack = 16,
    TorsoFront = 17,
    LeftAbdomen = 18,
    LeftChest = 19,
    RightAbdomen = 20,
    RightChest = 21,
    LeftArm = 22,
    LeftShoulder = 23,
    LeftBicep = 24,
    LeftTricep = 25,
    LeftBrachioradialis = 26,  // Left anterior forearm
    LeftForearmExtensors = 27,  // Left posterior forearm
    RightArm = 28,
    RightShoulder = 29,
    RightBicep = 30,
    RightTricep = 31,
    RightBrachioradialis = 32,  // Right anterior forearm
    RightForearmExtensors = 33,  // Right posterior forearm
    Neck = 34,
    Throat = 35,
    WaistMidBack = 36,
    WaistFront = 37,
    WaistLeft = 38,
    WaistRight = 39,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldBodyLocation {
    pub fn parse(input: &[u8]) -> Result<FitFieldBodyLocation> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldBodyLocation::from(valid_val)),
            None => Ok(FitFieldBodyLocation::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldBodyLocation {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldBodyLocation::LeftLeg,
            1 => FitFieldBodyLocation::LeftCalf,
            2 => FitFieldBodyLocation::LeftShin,
            3 => FitFieldBodyLocation::LeftHamstring,
            4 => FitFieldBodyLocation::LeftQuad,
            5 => FitFieldBodyLocation::LeftGlute,
            6 => FitFieldBodyLocation::RightLeg,
            7 => FitFieldBodyLocation::RightCalf,
            8 => FitFieldBodyLocation::RightShin,
            9 => FitFieldBodyLocation::RightHamstring,
            10 => FitFieldBodyLocation::RightQuad,
            11 => FitFieldBodyLocation::RightGlute,
            12 => FitFieldBodyLocation::TorsoBack,
            13 => FitFieldBodyLocation::LeftLowerBack,
            14 => FitFieldBodyLocation::LeftUpperBack,
            15 => FitFieldBodyLocation::RightLowerBack,
            16 => FitFieldBodyLocation::RightUpperBack,
            17 => FitFieldBodyLocation::TorsoFront,
            18 => FitFieldBodyLocation::LeftAbdomen,
            19 => FitFieldBodyLocation::LeftChest,
            20 => FitFieldBodyLocation::RightAbdomen,
            21 => FitFieldBodyLocation::RightChest,
            22 => FitFieldBodyLocation::LeftArm,
            23 => FitFieldBodyLocation::LeftShoulder,
            24 => FitFieldBodyLocation::LeftBicep,
            25 => FitFieldBodyLocation::LeftTricep,
            26 => FitFieldBodyLocation::LeftBrachioradialis,
            27 => FitFieldBodyLocation::LeftForearmExtensors,
            28 => FitFieldBodyLocation::RightArm,
            29 => FitFieldBodyLocation::RightShoulder,
            30 => FitFieldBodyLocation::RightBicep,
            31 => FitFieldBodyLocation::RightTricep,
            32 => FitFieldBodyLocation::RightBrachioradialis,
            33 => FitFieldBodyLocation::RightForearmExtensors,
            34 => FitFieldBodyLocation::Neck,
            35 => FitFieldBodyLocation::Throat,
            36 => FitFieldBodyLocation::WaistMidBack,
            37 => FitFieldBodyLocation::WaistFront,
            38 => FitFieldBodyLocation::WaistLeft,
            39 => FitFieldBodyLocation::WaistRight,
            _ => FitFieldBodyLocation::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldFile { // fit base type: enum
    Device = 1,  // Read only, single file. Must be in root directory.
    Settings = 2,  // Read/write, single file. Directory=Settings
    Sport = 3,  // Read/write, multiple files, file number = sport type. Directory=Sports
    Activity = 4,  // Read/erase, multiple files. Directory=Activities
    Workout = 5,  // Read/write/erase, multiple files. Directory=Workouts
    Course = 6,  // Read/write/erase, multiple files. Directory=Courses
    Schedules = 7,  // Read/write, single file. Directory=Schedules
    Weight = 9,  // Read only, single file. Circular buffer. All message definitions at start of file. Directory=Weight
    Totals = 10,  // Read only, single file. Directory=Totals
    Goals = 11,  // Read/write, single file. Directory=Goals
    BloodPressure = 14,  // Read only. Directory=Blood Pressure
    MonitoringA = 15,  // Read only. Directory=Monitoring. File number=sub type.
    ActivitySummary = 20,  // Read/erase, multiple files. Directory=Activities
    MonitoringDaily = 28,
    MonitoringB = 32,  // Read only. Directory=Monitoring. File number=identifier
    Segment = 34,  // Read/write/erase. Multiple Files.  Directory=Segments
    SegmentList = 35,  // Read/write/erase. Single File.  Directory=Segments
    ExdConfiguration = 40,  // Read/write/erase. Single File. Directory=Settings
    MfgRangeMin = 247,  // 0xF7 - 0xFE reserved for manufacturer specific file types
    MfgRangeMax = 254,  // 0xF7 - 0xFE reserved for manufacturer specific file types
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldFile {
    pub fn parse(input: &[u8]) -> Result<FitFieldFile> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldFile::from(valid_val)),
            None => Ok(FitFieldFile::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldFile {
    fn from(code: u8) -> Self {
        match code {
            1 => FitFieldFile::Device,
            2 => FitFieldFile::Settings,
            3 => FitFieldFile::Sport,
            4 => FitFieldFile::Activity,
            5 => FitFieldFile::Workout,
            6 => FitFieldFile::Course,
            7 => FitFieldFile::Schedules,
            9 => FitFieldFile::Weight,
            10 => FitFieldFile::Totals,
            11 => FitFieldFile::Goals,
            14 => FitFieldFile::BloodPressure,
            15 => FitFieldFile::MonitoringA,
            20 => FitFieldFile::ActivitySummary,
            28 => FitFieldFile::MonitoringDaily,
            32 => FitFieldFile::MonitoringB,
            34 => FitFieldFile::Segment,
            35 => FitFieldFile::SegmentList,
            40 => FitFieldFile::ExdConfiguration,
            247 => FitFieldFile::MfgRangeMin,
            254 => FitFieldFile::MfgRangeMax,
            _ => FitFieldFile::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDisplayMeasure { // fit base type: enum
    Metric = 0,
    Statute = 1,
    Nautical = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDisplayMeasure {
    pub fn parse(input: &[u8]) -> Result<FitFieldDisplayMeasure> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDisplayMeasure::from(valid_val)),
            None => Ok(FitFieldDisplayMeasure::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDisplayMeasure {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayMeasure::Metric,
            1 => FitFieldDisplayMeasure::Statute,
            2 => FitFieldDisplayMeasure::Nautical,
            _ => FitFieldDisplayMeasure::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCameraEventType { // fit base type: enum
    VideoStart = 0,  // Start of video recording
    VideoSplit = 1,  // Mark of video file split (end of one file, beginning of the other)
    VideoEnd = 2,  // End of video recording
    PhotoTaken = 3,  // Still photo taken
    VideoSecondStreamStart = 4,
    VideoSecondStreamSplit = 5,
    VideoSecondStreamEnd = 6,
    VideoSplitStart = 7,  // Mark of video file split start
    VideoSecondStreamSplitStart = 8,
    VideoPause = 11,  // Mark when a video recording has been paused
    VideoSecondStreamPause = 12,
    VideoResume = 13,  // Mark when a video recording has been resumed
    VideoSecondStreamResume = 14,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldCameraEventType {
    pub fn parse(input: &[u8]) -> Result<FitFieldCameraEventType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldCameraEventType::from(valid_val)),
            None => Ok(FitFieldCameraEventType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldCameraEventType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldCameraEventType::VideoStart,
            1 => FitFieldCameraEventType::VideoSplit,
            2 => FitFieldCameraEventType::VideoEnd,
            3 => FitFieldCameraEventType::PhotoTaken,
            4 => FitFieldCameraEventType::VideoSecondStreamStart,
            5 => FitFieldCameraEventType::VideoSecondStreamSplit,
            6 => FitFieldCameraEventType::VideoSecondStreamEnd,
            7 => FitFieldCameraEventType::VideoSplitStart,
            8 => FitFieldCameraEventType::VideoSecondStreamSplitStart,
            11 => FitFieldCameraEventType::VideoPause,
            12 => FitFieldCameraEventType::VideoSecondStreamPause,
            13 => FitFieldCameraEventType::VideoResume,
            14 => FitFieldCameraEventType::VideoSecondStreamResume,
            _ => FitFieldCameraEventType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAutoSyncFrequency { // fit base type: enum
    Never = 0,
    Occasionally = 1,
    Frequent = 2,
    OnceADay = 3,
    Remote = 4,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldAutoSyncFrequency {
    pub fn parse(input: &[u8]) -> Result<FitFieldAutoSyncFrequency> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldAutoSyncFrequency::from(valid_val)),
            None => Ok(FitFieldAutoSyncFrequency::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldAutoSyncFrequency {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAutoSyncFrequency::Never,
            1 => FitFieldAutoSyncFrequency::Occasionally,
            2 => FitFieldAutoSyncFrequency::Frequent,
            3 => FitFieldAutoSyncFrequency::OnceADay,
            4 => FitFieldAutoSyncFrequency::Remote,
            _ => FitFieldAutoSyncFrequency::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldMessageIndex { // fit base type: uint16
    Selected, // 32768  message is selected if set
    Reserved, // 28672  reserved (default 0)
    Mask, // 4095  index
    MessageIndex(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldMessageIndex {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldMessageIndex> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    32768 => Ok(FitFieldMessageIndex::from(valid_val)),
                    
                    28672 => Ok(FitFieldMessageIndex::from(valid_val)),
                    
                    4095 => Ok(FitFieldMessageIndex::from(valid_val)),
                    
                    v => Ok(FitFieldMessageIndex::MessageIndex(v)),
                }
            },
            None => Ok(FitFieldMessageIndex::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldMessageIndex {
    fn from(code: u16) -> Self {
        match code {
            32768 => FitFieldMessageIndex::Selected,
            28672 => FitFieldMessageIndex::Reserved,
            4095 => FitFieldMessageIndex::Mask,
            _ => FitFieldMessageIndex::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldGoal { // fit base type: enum
    Time = 0,
    Distance = 1,
    Calories = 2,
    Frequency = 3,
    Steps = 4,
    Ascent = 5,
    ActiveMinutes = 6,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldGoal {
    pub fn parse(input: &[u8]) -> Result<FitFieldGoal> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldGoal::from(valid_val)),
            None => Ok(FitFieldGoal::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldGoal {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldGoal::Time,
            1 => FitFieldGoal::Distance,
            2 => FitFieldGoal::Calories,
            3 => FitFieldGoal::Frequency,
            4 => FitFieldGoal::Steps,
            5 => FitFieldGoal::Ascent,
            6 => FitFieldGoal::ActiveMinutes,
            _ => FitFieldGoal::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldBenchPressExerciseName { // fit base type: uint16
    AlternatingDumbbellChestPressOnSwissBall, // 0
    BarbellBenchPress, // 1
    BarbellBoardBenchPress, // 2
    BarbellFloorPress, // 3
    CloseGripBarbellBenchPress, // 4
    DeclineDumbbellBenchPress, // 5
    DumbbellBenchPress, // 6
    DumbbellFloorPress, // 7
    InclineBarbellBenchPress, // 8
    InclineDumbbellBenchPress, // 9
    InclineSmithMachineBenchPress, // 10
    IsometricBarbellBenchPress, // 11
    KettlebellChestPress, // 12
    NeutralGripDumbbellBenchPress, // 13
    NeutralGripDumbbellInclineBenchPress, // 14
    OneArmFloorPress, // 15
    WeightedOneArmFloorPress, // 16
    PartialLockout, // 17
    ReverseGripBarbellBenchPress, // 18
    ReverseGripInclineBenchPress, // 19
    SingleArmCableChestPress, // 20
    SingleArmDumbbellBenchPress, // 21
    SmithMachineBenchPress, // 22
    SwissBallDumbbellChestPress, // 23
    TripleStopBarbellBenchPress, // 24
    WideGripBarbellBenchPress, // 25
    AlternatingDumbbellChestPress, // 26
    BenchPressExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldBenchPressExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldBenchPressExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldBenchPressExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldBenchPressExerciseName::BenchPressExerciseName(v)),
                }
            },
            None => Ok(FitFieldBenchPressExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldBenchPressExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldBenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall,
            1 => FitFieldBenchPressExerciseName::BarbellBenchPress,
            2 => FitFieldBenchPressExerciseName::BarbellBoardBenchPress,
            3 => FitFieldBenchPressExerciseName::BarbellFloorPress,
            4 => FitFieldBenchPressExerciseName::CloseGripBarbellBenchPress,
            5 => FitFieldBenchPressExerciseName::DeclineDumbbellBenchPress,
            6 => FitFieldBenchPressExerciseName::DumbbellBenchPress,
            7 => FitFieldBenchPressExerciseName::DumbbellFloorPress,
            8 => FitFieldBenchPressExerciseName::InclineBarbellBenchPress,
            9 => FitFieldBenchPressExerciseName::InclineDumbbellBenchPress,
            10 => FitFieldBenchPressExerciseName::InclineSmithMachineBenchPress,
            11 => FitFieldBenchPressExerciseName::IsometricBarbellBenchPress,
            12 => FitFieldBenchPressExerciseName::KettlebellChestPress,
            13 => FitFieldBenchPressExerciseName::NeutralGripDumbbellBenchPress,
            14 => FitFieldBenchPressExerciseName::NeutralGripDumbbellInclineBenchPress,
            15 => FitFieldBenchPressExerciseName::OneArmFloorPress,
            16 => FitFieldBenchPressExerciseName::WeightedOneArmFloorPress,
            17 => FitFieldBenchPressExerciseName::PartialLockout,
            18 => FitFieldBenchPressExerciseName::ReverseGripBarbellBenchPress,
            19 => FitFieldBenchPressExerciseName::ReverseGripInclineBenchPress,
            20 => FitFieldBenchPressExerciseName::SingleArmCableChestPress,
            21 => FitFieldBenchPressExerciseName::SingleArmDumbbellBenchPress,
            22 => FitFieldBenchPressExerciseName::SmithMachineBenchPress,
            23 => FitFieldBenchPressExerciseName::SwissBallDumbbellChestPress,
            24 => FitFieldBenchPressExerciseName::TripleStopBarbellBenchPress,
            25 => FitFieldBenchPressExerciseName::WideGripBarbellBenchPress,
            26 => FitFieldBenchPressExerciseName::AlternatingDumbbellChestPress,
            _ => FitFieldBenchPressExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldActivityLevel { // fit base type: enum
    Low = 0,
    Medium = 1,
    High = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldActivityLevel {
    pub fn parse(input: &[u8]) -> Result<FitFieldActivityLevel> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldActivityLevel::from(valid_val)),
            None => Ok(FitFieldActivityLevel::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldActivityLevel {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldActivityLevel::Low,
            1 => FitFieldActivityLevel::Medium,
            2 => FitFieldActivityLevel::High,
            _ => FitFieldActivityLevel::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWktStepDuration { // fit base type: enum
    Time = 0,
    Distance = 1,
    HrLessThan = 2,
    HrGreaterThan = 3,
    Calories = 4,
    Open = 5,
    RepeatUntilStepsCmplt = 6,
    RepeatUntilTime = 7,
    RepeatUntilDistance = 8,
    RepeatUntilCalories = 9,
    RepeatUntilHrLessThan = 10,
    RepeatUntilHrGreaterThan = 11,
    RepeatUntilPowerLessThan = 12,
    RepeatUntilPowerGreaterThan = 13,
    PowerLessThan = 14,
    PowerGreaterThan = 15,
    TrainingPeaksTss = 16,
    RepeatUntilPowerLastLapLessThan = 17,
    RepeatUntilMaxPowerLastLapLessThan = 18,
    Power3sLessThan = 19,
    Power10sLessThan = 20,
    Power30sLessThan = 21,
    Power3sGreaterThan = 22,
    Power10sGreaterThan = 23,
    Power30sGreaterThan = 24,
    PowerLapLessThan = 25,
    PowerLapGreaterThan = 26,
    RepeatUntilTrainingPeaksTss = 27,
    RepetitionTime = 28,
    Reps = 29,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWktStepDuration {
    pub fn parse(input: &[u8]) -> Result<FitFieldWktStepDuration> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWktStepDuration::from(valid_val)),
            None => Ok(FitFieldWktStepDuration::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWktStepDuration {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWktStepDuration::Time,
            1 => FitFieldWktStepDuration::Distance,
            2 => FitFieldWktStepDuration::HrLessThan,
            3 => FitFieldWktStepDuration::HrGreaterThan,
            4 => FitFieldWktStepDuration::Calories,
            5 => FitFieldWktStepDuration::Open,
            6 => FitFieldWktStepDuration::RepeatUntilStepsCmplt,
            7 => FitFieldWktStepDuration::RepeatUntilTime,
            8 => FitFieldWktStepDuration::RepeatUntilDistance,
            9 => FitFieldWktStepDuration::RepeatUntilCalories,
            10 => FitFieldWktStepDuration::RepeatUntilHrLessThan,
            11 => FitFieldWktStepDuration::RepeatUntilHrGreaterThan,
            12 => FitFieldWktStepDuration::RepeatUntilPowerLessThan,
            13 => FitFieldWktStepDuration::RepeatUntilPowerGreaterThan,
            14 => FitFieldWktStepDuration::PowerLessThan,
            15 => FitFieldWktStepDuration::PowerGreaterThan,
            16 => FitFieldWktStepDuration::TrainingPeaksTss,
            17 => FitFieldWktStepDuration::RepeatUntilPowerLastLapLessThan,
            18 => FitFieldWktStepDuration::RepeatUntilMaxPowerLastLapLessThan,
            19 => FitFieldWktStepDuration::Power3sLessThan,
            20 => FitFieldWktStepDuration::Power10sLessThan,
            21 => FitFieldWktStepDuration::Power30sLessThan,
            22 => FitFieldWktStepDuration::Power3sGreaterThan,
            23 => FitFieldWktStepDuration::Power10sGreaterThan,
            24 => FitFieldWktStepDuration::Power30sGreaterThan,
            25 => FitFieldWktStepDuration::PowerLapLessThan,
            26 => FitFieldWktStepDuration::PowerLapGreaterThan,
            27 => FitFieldWktStepDuration::RepeatUntilTrainingPeaksTss,
            28 => FitFieldWktStepDuration::RepetitionTime,
            29 => FitFieldWktStepDuration::Reps,
            _ => FitFieldWktStepDuration::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWeatherSeverity { // fit base type: enum
    Unknown = 0,
    Warning = 1,
    Watch = 2,
    Advisory = 3,
    Statement = 4,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWeatherSeverity {
    pub fn parse(input: &[u8]) -> Result<FitFieldWeatherSeverity> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWeatherSeverity::from(valid_val)),
            None => Ok(FitFieldWeatherSeverity::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWeatherSeverity {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherSeverity::Unknown,
            1 => FitFieldWeatherSeverity::Warning,
            2 => FitFieldWeatherSeverity::Watch,
            3 => FitFieldWeatherSeverity::Advisory,
            4 => FitFieldWeatherSeverity::Statement,
            _ => FitFieldWeatherSeverity::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldPlankExerciseName { // fit base type: uint16
    FortyFiveDegreePlank, // 0
    Weighted45DegreePlank, // 1
    NinetyDegreeStaticHold, // 2
    Weighted90DegreeStaticHold, // 3
    BearCrawl, // 4
    WeightedBearCrawl, // 5
    CrossBodyMountainClimber, // 6
    WeightedCrossBodyMountainClimber, // 7
    ElbowPlankPikeJacks, // 8
    WeightedElbowPlankPikeJacks, // 9
    ElevatedFeetPlank, // 10
    WeightedElevatedFeetPlank, // 11
    ElevatorAbs, // 12
    WeightedElevatorAbs, // 13
    ExtendedPlank, // 14
    WeightedExtendedPlank, // 15
    FullPlankPasseTwist, // 16
    WeightedFullPlankPasseTwist, // 17
    InchingElbowPlank, // 18
    WeightedInchingElbowPlank, // 19
    InchwormToSidePlank, // 20
    WeightedInchwormToSidePlank, // 21
    KneelingPlank, // 22
    WeightedKneelingPlank, // 23
    KneelingSidePlankWithLegLift, // 24
    WeightedKneelingSidePlankWithLegLift, // 25
    LateralRoll, // 26
    WeightedLateralRoll, // 27
    LyingReversePlank, // 28
    WeightedLyingReversePlank, // 29
    MedicineBallMountainClimber, // 30
    WeightedMedicineBallMountainClimber, // 31
    ModifiedMountainClimberAndExtension, // 32
    WeightedModifiedMountainClimberAndExtension, // 33
    MountainClimber, // 34
    WeightedMountainClimber, // 35
    MountainClimberOnSlidingDiscs, // 36
    WeightedMountainClimberOnSlidingDiscs, // 37
    MountainClimberWithFeetOnBosuBall, // 38
    WeightedMountainClimberWithFeetOnBosuBall, // 39
    MountainClimberWithHandsOnBench, // 40
    MountainClimberWithHandsOnSwissBall, // 41
    WeightedMountainClimberWithHandsOnSwissBall, // 42
    Plank, // 43
    PlankJacksWithFeetOnSlidingDiscs, // 44
    WeightedPlankJacksWithFeetOnSlidingDiscs, // 45
    PlankKneeTwist, // 46
    WeightedPlankKneeTwist, // 47
    PlankPikeJumps, // 48
    WeightedPlankPikeJumps, // 49
    PlankPikes, // 50
    WeightedPlankPikes, // 51
    PlankToStandUp, // 52
    WeightedPlankToStandUp, // 53
    PlankWithArmRaise, // 54
    WeightedPlankWithArmRaise, // 55
    PlankWithKneeToElbow, // 56
    WeightedPlankWithKneeToElbow, // 57
    PlankWithObliqueCrunch, // 58
    WeightedPlankWithObliqueCrunch, // 59
    PlyometricSidePlank, // 60
    WeightedPlyometricSidePlank, // 61
    RollingSidePlank, // 62
    WeightedRollingSidePlank, // 63
    SideKickPlank, // 64
    WeightedSideKickPlank, // 65
    SidePlank, // 66
    WeightedSidePlank, // 67
    SidePlankAndRow, // 68
    WeightedSidePlankAndRow, // 69
    SidePlankLift, // 70
    WeightedSidePlankLift, // 71
    SidePlankWithElbowOnBosuBall, // 72
    WeightedSidePlankWithElbowOnBosuBall, // 73
    SidePlankWithFeetOnBench, // 74
    WeightedSidePlankWithFeetOnBench, // 75
    SidePlankWithKneeCircle, // 76
    WeightedSidePlankWithKneeCircle, // 77
    SidePlankWithKneeTuck, // 78
    WeightedSidePlankWithKneeTuck, // 79
    SidePlankWithLegLift, // 80
    WeightedSidePlankWithLegLift, // 81
    SidePlankWithReachUnder, // 82
    WeightedSidePlankWithReachUnder, // 83
    SingleLegElevatedFeetPlank, // 84
    WeightedSingleLegElevatedFeetPlank, // 85
    SingleLegFlexAndExtend, // 86
    WeightedSingleLegFlexAndExtend, // 87
    SingleLegSidePlank, // 88
    WeightedSingleLegSidePlank, // 89
    SpidermanPlank, // 90
    WeightedSpidermanPlank, // 91
    StraightArmPlank, // 92
    WeightedStraightArmPlank, // 93
    StraightArmPlankWithShoulderTouch, // 94
    WeightedStraightArmPlankWithShoulderTouch, // 95
    SwissBallPlank, // 96
    WeightedSwissBallPlank, // 97
    SwissBallPlankLegLift, // 98
    WeightedSwissBallPlankLegLift, // 99
    SwissBallPlankLegLiftAndHold, // 100
    SwissBallPlankWithFeetOnBench, // 101
    WeightedSwissBallPlankWithFeetOnBench, // 102
    SwissBallProneJackknife, // 103
    WeightedSwissBallProneJackknife, // 104
    SwissBallSidePlank, // 105
    WeightedSwissBallSidePlank, // 106
    ThreeWayPlank, // 107
    WeightedThreeWayPlank, // 108
    TowelPlankAndKneeIn, // 109
    WeightedTowelPlankAndKneeIn, // 110
    TStabilization, // 111
    WeightedTStabilization, // 112
    TurkishGetUpToSidePlank, // 113
    WeightedTurkishGetUpToSidePlank, // 114
    TwoPointPlank, // 115
    WeightedTwoPointPlank, // 116
    WeightedPlank, // 117
    WideStancePlankWithDiagonalArmLift, // 118
    WeightedWideStancePlankWithDiagonalArmLift, // 119
    WideStancePlankWithDiagonalLegLift, // 120
    WeightedWideStancePlankWithDiagonalLegLift, // 121
    WideStancePlankWithLegLift, // 122
    WeightedWideStancePlankWithLegLift, // 123
    WideStancePlankWithOppositeArmAndLegLift, // 124
    WeightedMountainClimberWithHandsOnBench, // 125
    WeightedSwissBallPlankLegLiftAndHold, // 126
    WeightedWideStancePlankWithOppositeArmAndLegLift, // 127
    PlankWithFeetOnSwissBall, // 128
    SidePlankToPlankWithReachUnder, // 129
    BridgeWithGluteLowerLift, // 130
    BridgeOneLegBridge, // 131
    PlankWithArmVariations, // 132
    PlankWithLegLift, // 133
    ReversePlankWithLegPull, // 134
    PlankExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldPlankExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldPlankExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    50 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    51 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    52 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    53 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    54 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    55 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    56 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    57 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    58 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    59 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    60 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    61 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    62 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    63 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    64 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    65 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    66 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    67 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    68 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    69 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    70 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    71 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    72 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    73 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    74 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    75 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    76 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    77 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    78 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    79 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    80 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    81 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    82 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    83 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    84 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    85 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    86 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    87 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    88 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    89 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    90 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    91 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    92 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    93 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    94 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    95 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    96 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    97 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    98 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    99 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    100 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    101 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    102 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    103 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    104 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    105 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    106 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    107 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    108 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    109 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    110 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    111 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    112 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    113 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    114 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    115 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    116 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    117 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    118 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    119 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    120 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    121 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    122 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    123 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    124 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    125 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    126 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    127 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    128 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    129 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    130 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    131 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    132 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    133 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    134 => Ok(FitFieldPlankExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldPlankExerciseName::PlankExerciseName(v)),
                }
            },
            None => Ok(FitFieldPlankExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldPlankExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPlankExerciseName::FortyFiveDegreePlank,
            1 => FitFieldPlankExerciseName::Weighted45DegreePlank,
            2 => FitFieldPlankExerciseName::NinetyDegreeStaticHold,
            3 => FitFieldPlankExerciseName::Weighted90DegreeStaticHold,
            4 => FitFieldPlankExerciseName::BearCrawl,
            5 => FitFieldPlankExerciseName::WeightedBearCrawl,
            6 => FitFieldPlankExerciseName::CrossBodyMountainClimber,
            7 => FitFieldPlankExerciseName::WeightedCrossBodyMountainClimber,
            8 => FitFieldPlankExerciseName::ElbowPlankPikeJacks,
            9 => FitFieldPlankExerciseName::WeightedElbowPlankPikeJacks,
            10 => FitFieldPlankExerciseName::ElevatedFeetPlank,
            11 => FitFieldPlankExerciseName::WeightedElevatedFeetPlank,
            12 => FitFieldPlankExerciseName::ElevatorAbs,
            13 => FitFieldPlankExerciseName::WeightedElevatorAbs,
            14 => FitFieldPlankExerciseName::ExtendedPlank,
            15 => FitFieldPlankExerciseName::WeightedExtendedPlank,
            16 => FitFieldPlankExerciseName::FullPlankPasseTwist,
            17 => FitFieldPlankExerciseName::WeightedFullPlankPasseTwist,
            18 => FitFieldPlankExerciseName::InchingElbowPlank,
            19 => FitFieldPlankExerciseName::WeightedInchingElbowPlank,
            20 => FitFieldPlankExerciseName::InchwormToSidePlank,
            21 => FitFieldPlankExerciseName::WeightedInchwormToSidePlank,
            22 => FitFieldPlankExerciseName::KneelingPlank,
            23 => FitFieldPlankExerciseName::WeightedKneelingPlank,
            24 => FitFieldPlankExerciseName::KneelingSidePlankWithLegLift,
            25 => FitFieldPlankExerciseName::WeightedKneelingSidePlankWithLegLift,
            26 => FitFieldPlankExerciseName::LateralRoll,
            27 => FitFieldPlankExerciseName::WeightedLateralRoll,
            28 => FitFieldPlankExerciseName::LyingReversePlank,
            29 => FitFieldPlankExerciseName::WeightedLyingReversePlank,
            30 => FitFieldPlankExerciseName::MedicineBallMountainClimber,
            31 => FitFieldPlankExerciseName::WeightedMedicineBallMountainClimber,
            32 => FitFieldPlankExerciseName::ModifiedMountainClimberAndExtension,
            33 => FitFieldPlankExerciseName::WeightedModifiedMountainClimberAndExtension,
            34 => FitFieldPlankExerciseName::MountainClimber,
            35 => FitFieldPlankExerciseName::WeightedMountainClimber,
            36 => FitFieldPlankExerciseName::MountainClimberOnSlidingDiscs,
            37 => FitFieldPlankExerciseName::WeightedMountainClimberOnSlidingDiscs,
            38 => FitFieldPlankExerciseName::MountainClimberWithFeetOnBosuBall,
            39 => FitFieldPlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall,
            40 => FitFieldPlankExerciseName::MountainClimberWithHandsOnBench,
            41 => FitFieldPlankExerciseName::MountainClimberWithHandsOnSwissBall,
            42 => FitFieldPlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall,
            43 => FitFieldPlankExerciseName::Plank,
            44 => FitFieldPlankExerciseName::PlankJacksWithFeetOnSlidingDiscs,
            45 => FitFieldPlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs,
            46 => FitFieldPlankExerciseName::PlankKneeTwist,
            47 => FitFieldPlankExerciseName::WeightedPlankKneeTwist,
            48 => FitFieldPlankExerciseName::PlankPikeJumps,
            49 => FitFieldPlankExerciseName::WeightedPlankPikeJumps,
            50 => FitFieldPlankExerciseName::PlankPikes,
            51 => FitFieldPlankExerciseName::WeightedPlankPikes,
            52 => FitFieldPlankExerciseName::PlankToStandUp,
            53 => FitFieldPlankExerciseName::WeightedPlankToStandUp,
            54 => FitFieldPlankExerciseName::PlankWithArmRaise,
            55 => FitFieldPlankExerciseName::WeightedPlankWithArmRaise,
            56 => FitFieldPlankExerciseName::PlankWithKneeToElbow,
            57 => FitFieldPlankExerciseName::WeightedPlankWithKneeToElbow,
            58 => FitFieldPlankExerciseName::PlankWithObliqueCrunch,
            59 => FitFieldPlankExerciseName::WeightedPlankWithObliqueCrunch,
            60 => FitFieldPlankExerciseName::PlyometricSidePlank,
            61 => FitFieldPlankExerciseName::WeightedPlyometricSidePlank,
            62 => FitFieldPlankExerciseName::RollingSidePlank,
            63 => FitFieldPlankExerciseName::WeightedRollingSidePlank,
            64 => FitFieldPlankExerciseName::SideKickPlank,
            65 => FitFieldPlankExerciseName::WeightedSideKickPlank,
            66 => FitFieldPlankExerciseName::SidePlank,
            67 => FitFieldPlankExerciseName::WeightedSidePlank,
            68 => FitFieldPlankExerciseName::SidePlankAndRow,
            69 => FitFieldPlankExerciseName::WeightedSidePlankAndRow,
            70 => FitFieldPlankExerciseName::SidePlankLift,
            71 => FitFieldPlankExerciseName::WeightedSidePlankLift,
            72 => FitFieldPlankExerciseName::SidePlankWithElbowOnBosuBall,
            73 => FitFieldPlankExerciseName::WeightedSidePlankWithElbowOnBosuBall,
            74 => FitFieldPlankExerciseName::SidePlankWithFeetOnBench,
            75 => FitFieldPlankExerciseName::WeightedSidePlankWithFeetOnBench,
            76 => FitFieldPlankExerciseName::SidePlankWithKneeCircle,
            77 => FitFieldPlankExerciseName::WeightedSidePlankWithKneeCircle,
            78 => FitFieldPlankExerciseName::SidePlankWithKneeTuck,
            79 => FitFieldPlankExerciseName::WeightedSidePlankWithKneeTuck,
            80 => FitFieldPlankExerciseName::SidePlankWithLegLift,
            81 => FitFieldPlankExerciseName::WeightedSidePlankWithLegLift,
            82 => FitFieldPlankExerciseName::SidePlankWithReachUnder,
            83 => FitFieldPlankExerciseName::WeightedSidePlankWithReachUnder,
            84 => FitFieldPlankExerciseName::SingleLegElevatedFeetPlank,
            85 => FitFieldPlankExerciseName::WeightedSingleLegElevatedFeetPlank,
            86 => FitFieldPlankExerciseName::SingleLegFlexAndExtend,
            87 => FitFieldPlankExerciseName::WeightedSingleLegFlexAndExtend,
            88 => FitFieldPlankExerciseName::SingleLegSidePlank,
            89 => FitFieldPlankExerciseName::WeightedSingleLegSidePlank,
            90 => FitFieldPlankExerciseName::SpidermanPlank,
            91 => FitFieldPlankExerciseName::WeightedSpidermanPlank,
            92 => FitFieldPlankExerciseName::StraightArmPlank,
            93 => FitFieldPlankExerciseName::WeightedStraightArmPlank,
            94 => FitFieldPlankExerciseName::StraightArmPlankWithShoulderTouch,
            95 => FitFieldPlankExerciseName::WeightedStraightArmPlankWithShoulderTouch,
            96 => FitFieldPlankExerciseName::SwissBallPlank,
            97 => FitFieldPlankExerciseName::WeightedSwissBallPlank,
            98 => FitFieldPlankExerciseName::SwissBallPlankLegLift,
            99 => FitFieldPlankExerciseName::WeightedSwissBallPlankLegLift,
            100 => FitFieldPlankExerciseName::SwissBallPlankLegLiftAndHold,
            101 => FitFieldPlankExerciseName::SwissBallPlankWithFeetOnBench,
            102 => FitFieldPlankExerciseName::WeightedSwissBallPlankWithFeetOnBench,
            103 => FitFieldPlankExerciseName::SwissBallProneJackknife,
            104 => FitFieldPlankExerciseName::WeightedSwissBallProneJackknife,
            105 => FitFieldPlankExerciseName::SwissBallSidePlank,
            106 => FitFieldPlankExerciseName::WeightedSwissBallSidePlank,
            107 => FitFieldPlankExerciseName::ThreeWayPlank,
            108 => FitFieldPlankExerciseName::WeightedThreeWayPlank,
            109 => FitFieldPlankExerciseName::TowelPlankAndKneeIn,
            110 => FitFieldPlankExerciseName::WeightedTowelPlankAndKneeIn,
            111 => FitFieldPlankExerciseName::TStabilization,
            112 => FitFieldPlankExerciseName::WeightedTStabilization,
            113 => FitFieldPlankExerciseName::TurkishGetUpToSidePlank,
            114 => FitFieldPlankExerciseName::WeightedTurkishGetUpToSidePlank,
            115 => FitFieldPlankExerciseName::TwoPointPlank,
            116 => FitFieldPlankExerciseName::WeightedTwoPointPlank,
            117 => FitFieldPlankExerciseName::WeightedPlank,
            118 => FitFieldPlankExerciseName::WideStancePlankWithDiagonalArmLift,
            119 => FitFieldPlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift,
            120 => FitFieldPlankExerciseName::WideStancePlankWithDiagonalLegLift,
            121 => FitFieldPlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift,
            122 => FitFieldPlankExerciseName::WideStancePlankWithLegLift,
            123 => FitFieldPlankExerciseName::WeightedWideStancePlankWithLegLift,
            124 => FitFieldPlankExerciseName::WideStancePlankWithOppositeArmAndLegLift,
            125 => FitFieldPlankExerciseName::WeightedMountainClimberWithHandsOnBench,
            126 => FitFieldPlankExerciseName::WeightedSwissBallPlankLegLiftAndHold,
            127 => FitFieldPlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift,
            128 => FitFieldPlankExerciseName::PlankWithFeetOnSwissBall,
            129 => FitFieldPlankExerciseName::SidePlankToPlankWithReachUnder,
            130 => FitFieldPlankExerciseName::BridgeWithGluteLowerLift,
            131 => FitFieldPlankExerciseName::BridgeOneLegBridge,
            132 => FitFieldPlankExerciseName::PlankWithArmVariations,
            133 => FitFieldPlankExerciseName::PlankWithLegLift,
            134 => FitFieldPlankExerciseName::ReversePlankWithLegPull,
            _ => FitFieldPlankExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCameraOrientationType { // fit base type: enum
    CameraOrientation0 = 0,
    CameraOrientation90 = 1,
    CameraOrientation180 = 2,
    CameraOrientation270 = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldCameraOrientationType {
    pub fn parse(input: &[u8]) -> Result<FitFieldCameraOrientationType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldCameraOrientationType::from(valid_val)),
            None => Ok(FitFieldCameraOrientationType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldCameraOrientationType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldCameraOrientationType::CameraOrientation0,
            1 => FitFieldCameraOrientationType::CameraOrientation90,
            2 => FitFieldCameraOrientationType::CameraOrientation180,
            3 => FitFieldCameraOrientationType::CameraOrientation270,
            _ => FitFieldCameraOrientationType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldWeatherStatus { // fit base type: enum
    Clear = 0,
    PartlyCloudy = 1,
    MostlyCloudy = 2,
    Rain = 3,
    Snow = 4,
    Windy = 5,
    Thunderstorms = 6,
    WintryMix = 7,
    Fog = 8,
    Hazy = 11,
    Hail = 12,
    ScatteredShowers = 13,
    ScatteredThunderstorms = 14,
    UnknownPrecipitation = 15,
    LightRain = 16,
    HeavyRain = 17,
    LightSnow = 18,
    HeavySnow = 19,
    LightRainSnow = 20,
    HeavyRainSnow = 21,
    Cloudy = 22,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldWeatherStatus {
    pub fn parse(input: &[u8]) -> Result<FitFieldWeatherStatus> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldWeatherStatus::from(valid_val)),
            None => Ok(FitFieldWeatherStatus::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldWeatherStatus {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldWeatherStatus::Clear,
            1 => FitFieldWeatherStatus::PartlyCloudy,
            2 => FitFieldWeatherStatus::MostlyCloudy,
            3 => FitFieldWeatherStatus::Rain,
            4 => FitFieldWeatherStatus::Snow,
            5 => FitFieldWeatherStatus::Windy,
            6 => FitFieldWeatherStatus::Thunderstorms,
            7 => FitFieldWeatherStatus::WintryMix,
            8 => FitFieldWeatherStatus::Fog,
            11 => FitFieldWeatherStatus::Hazy,
            12 => FitFieldWeatherStatus::Hail,
            13 => FitFieldWeatherStatus::ScatteredShowers,
            14 => FitFieldWeatherStatus::ScatteredThunderstorms,
            15 => FitFieldWeatherStatus::UnknownPrecipitation,
            16 => FitFieldWeatherStatus::LightRain,
            17 => FitFieldWeatherStatus::HeavyRain,
            18 => FitFieldWeatherStatus::LightSnow,
            19 => FitFieldWeatherStatus::HeavySnow,
            20 => FitFieldWeatherStatus::LightRainSnow,
            21 => FitFieldWeatherStatus::HeavyRainSnow,
            22 => FitFieldWeatherStatus::Cloudy,
            _ => FitFieldWeatherStatus::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldExdDisplayType { // fit base type: enum
    Numerical = 0,
    Simple = 1,
    Graph = 2,
    Bar = 3,
    CircleGraph = 4,
    VirtualPartner = 5,
    Balance = 6,
    StringList = 7,
    String = 8,
    SimpleDynamicIcon = 9,
    Gauge = 10,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldExdDisplayType {
    pub fn parse(input: &[u8]) -> Result<FitFieldExdDisplayType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldExdDisplayType::from(valid_val)),
            None => Ok(FitFieldExdDisplayType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldExdDisplayType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdDisplayType::Numerical,
            1 => FitFieldExdDisplayType::Simple,
            2 => FitFieldExdDisplayType::Graph,
            3 => FitFieldExdDisplayType::Bar,
            4 => FitFieldExdDisplayType::CircleGraph,
            5 => FitFieldExdDisplayType::VirtualPartner,
            6 => FitFieldExdDisplayType::Balance,
            7 => FitFieldExdDisplayType::StringList,
            8 => FitFieldExdDisplayType::String,
            9 => FitFieldExdDisplayType::SimpleDynamicIcon,
            10 => FitFieldExdDisplayType::Gauge,
            _ => FitFieldExdDisplayType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSourceType { // fit base type: enum
    Ant = 0,  // External device connected with ANT
    Antplus = 1,  // External device connected with ANT+
    Bluetooth = 2,  // External device connected with BT
    BluetoothLowEnergy = 3,  // External device connected with BLE
    Wifi = 4,  // External device connected with Wifi
    Local = 5,  // Onboard device
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSourceType {
    pub fn parse(input: &[u8]) -> Result<FitFieldSourceType> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSourceType::from(valid_val)),
            None => Ok(FitFieldSourceType::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSourceType {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSourceType::Ant,
            1 => FitFieldSourceType::Antplus,
            2 => FitFieldSourceType::Bluetooth,
            3 => FitFieldSourceType::BluetoothLowEnergy,
            4 => FitFieldSourceType::Wifi,
            5 => FitFieldSourceType::Local,
            _ => FitFieldSourceType::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDisplayHeart { // fit base type: enum
    Bpm = 0,
    Max = 1,
    Reserve = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldDisplayHeart {
    pub fn parse(input: &[u8]) -> Result<FitFieldDisplayHeart> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldDisplayHeart::from(valid_val)),
            None => Ok(FitFieldDisplayHeart::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldDisplayHeart {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldDisplayHeart::Bpm,
            1 => FitFieldDisplayHeart::Max,
            2 => FitFieldDisplayHeart::Reserve,
            _ => FitFieldDisplayHeart::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCoreExerciseName { // fit base type: uint16
    AbsJabs, // 0
    WeightedAbsJabs, // 1
    AlternatingPlateReach, // 2
    BarbellRollout, // 3
    WeightedBarbellRollout, // 4
    BodyBarObliqueTwist, // 5
    CableCorePress, // 6
    CableSideBend, // 7
    SideBend, // 8
    WeightedSideBend, // 9
    CrescentCircle, // 10
    WeightedCrescentCircle, // 11
    CyclingRussianTwist, // 12
    WeightedCyclingRussianTwist, // 13
    ElevatedFeetRussianTwist, // 14
    WeightedElevatedFeetRussianTwist, // 15
    HalfTurkishGetUp, // 16
    KettlebellWindmill, // 17
    KneelingAbWheel, // 18
    WeightedKneelingAbWheel, // 19
    ModifiedFrontLever, // 20
    OpenKneeTucks, // 21
    WeightedOpenKneeTucks, // 22
    SideAbsLegLift, // 23
    WeightedSideAbsLegLift, // 24
    SwissBallJackknife, // 25
    WeightedSwissBallJackknife, // 26
    SwissBallPike, // 27
    WeightedSwissBallPike, // 28
    SwissBallRollout, // 29
    WeightedSwissBallRollout, // 30
    TriangleHipPress, // 31
    WeightedTriangleHipPress, // 32
    TrxSuspendedJackknife, // 33
    WeightedTrxSuspendedJackknife, // 34
    UBoat, // 35
    WeightedUBoat, // 36
    WindmillSwitches, // 37
    WeightedWindmillSwitches, // 38
    AlternatingSlideOut, // 39
    WeightedAlternatingSlideOut, // 40
    GhdBackExtensions, // 41
    WeightedGhdBackExtensions, // 42
    OverheadWalk, // 43
    Inchworm, // 44
    WeightedModifiedFrontLever, // 45
    RussianTwist, // 46
    AbdominalLegRotations, // 47
    ArmAndLegExtensionOnKnees, // 48
    Bicycle, // 49
    BicepCurlWithLegExtension, // 50
    CatCow, // 51
    Corkscrew, // 52
    CrissCross, // 53
    CrissCrossWithBall, // 54
    DoubleLegStretch, // 55
    KneeFolds, // 56
    LowerLift, // 57
    NeckPull, // 58
    PelvicClocks, // 59
    RollOver, // 60
    RollUp, // 61
    Rolling, // 62
    Rowing1, // 63
    Rowing2, // 64
    Scissors, // 65
    SingleLegCircles, // 66
    SingleLegStretch, // 67
    SnakeTwist1And2, // 68
    Swan, // 69
    Swimming, // 70
    Teaser, // 71
    TheHundred, // 72
    CoreExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCoreExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCoreExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    50 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    51 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    52 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    53 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    54 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    55 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    56 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    57 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    58 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    59 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    60 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    61 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    62 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    63 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    64 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    65 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    66 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    67 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    68 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    69 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    70 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    71 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    72 => Ok(FitFieldCoreExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldCoreExerciseName::CoreExerciseName(v)),
                }
            },
            None => Ok(FitFieldCoreExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCoreExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCoreExerciseName::AbsJabs,
            1 => FitFieldCoreExerciseName::WeightedAbsJabs,
            2 => FitFieldCoreExerciseName::AlternatingPlateReach,
            3 => FitFieldCoreExerciseName::BarbellRollout,
            4 => FitFieldCoreExerciseName::WeightedBarbellRollout,
            5 => FitFieldCoreExerciseName::BodyBarObliqueTwist,
            6 => FitFieldCoreExerciseName::CableCorePress,
            7 => FitFieldCoreExerciseName::CableSideBend,
            8 => FitFieldCoreExerciseName::SideBend,
            9 => FitFieldCoreExerciseName::WeightedSideBend,
            10 => FitFieldCoreExerciseName::CrescentCircle,
            11 => FitFieldCoreExerciseName::WeightedCrescentCircle,
            12 => FitFieldCoreExerciseName::CyclingRussianTwist,
            13 => FitFieldCoreExerciseName::WeightedCyclingRussianTwist,
            14 => FitFieldCoreExerciseName::ElevatedFeetRussianTwist,
            15 => FitFieldCoreExerciseName::WeightedElevatedFeetRussianTwist,
            16 => FitFieldCoreExerciseName::HalfTurkishGetUp,
            17 => FitFieldCoreExerciseName::KettlebellWindmill,
            18 => FitFieldCoreExerciseName::KneelingAbWheel,
            19 => FitFieldCoreExerciseName::WeightedKneelingAbWheel,
            20 => FitFieldCoreExerciseName::ModifiedFrontLever,
            21 => FitFieldCoreExerciseName::OpenKneeTucks,
            22 => FitFieldCoreExerciseName::WeightedOpenKneeTucks,
            23 => FitFieldCoreExerciseName::SideAbsLegLift,
            24 => FitFieldCoreExerciseName::WeightedSideAbsLegLift,
            25 => FitFieldCoreExerciseName::SwissBallJackknife,
            26 => FitFieldCoreExerciseName::WeightedSwissBallJackknife,
            27 => FitFieldCoreExerciseName::SwissBallPike,
            28 => FitFieldCoreExerciseName::WeightedSwissBallPike,
            29 => FitFieldCoreExerciseName::SwissBallRollout,
            30 => FitFieldCoreExerciseName::WeightedSwissBallRollout,
            31 => FitFieldCoreExerciseName::TriangleHipPress,
            32 => FitFieldCoreExerciseName::WeightedTriangleHipPress,
            33 => FitFieldCoreExerciseName::TrxSuspendedJackknife,
            34 => FitFieldCoreExerciseName::WeightedTrxSuspendedJackknife,
            35 => FitFieldCoreExerciseName::UBoat,
            36 => FitFieldCoreExerciseName::WeightedUBoat,
            37 => FitFieldCoreExerciseName::WindmillSwitches,
            38 => FitFieldCoreExerciseName::WeightedWindmillSwitches,
            39 => FitFieldCoreExerciseName::AlternatingSlideOut,
            40 => FitFieldCoreExerciseName::WeightedAlternatingSlideOut,
            41 => FitFieldCoreExerciseName::GhdBackExtensions,
            42 => FitFieldCoreExerciseName::WeightedGhdBackExtensions,
            43 => FitFieldCoreExerciseName::OverheadWalk,
            44 => FitFieldCoreExerciseName::Inchworm,
            45 => FitFieldCoreExerciseName::WeightedModifiedFrontLever,
            46 => FitFieldCoreExerciseName::RussianTwist,
            47 => FitFieldCoreExerciseName::AbdominalLegRotations,
            48 => FitFieldCoreExerciseName::ArmAndLegExtensionOnKnees,
            49 => FitFieldCoreExerciseName::Bicycle,
            50 => FitFieldCoreExerciseName::BicepCurlWithLegExtension,
            51 => FitFieldCoreExerciseName::CatCow,
            52 => FitFieldCoreExerciseName::Corkscrew,
            53 => FitFieldCoreExerciseName::CrissCross,
            54 => FitFieldCoreExerciseName::CrissCrossWithBall,
            55 => FitFieldCoreExerciseName::DoubleLegStretch,
            56 => FitFieldCoreExerciseName::KneeFolds,
            57 => FitFieldCoreExerciseName::LowerLift,
            58 => FitFieldCoreExerciseName::NeckPull,
            59 => FitFieldCoreExerciseName::PelvicClocks,
            60 => FitFieldCoreExerciseName::RollOver,
            61 => FitFieldCoreExerciseName::RollUp,
            62 => FitFieldCoreExerciseName::Rolling,
            63 => FitFieldCoreExerciseName::Rowing1,
            64 => FitFieldCoreExerciseName::Rowing2,
            65 => FitFieldCoreExerciseName::Scissors,
            66 => FitFieldCoreExerciseName::SingleLegCircles,
            67 => FitFieldCoreExerciseName::SingleLegStretch,
            68 => FitFieldCoreExerciseName::SnakeTwist1And2,
            69 => FitFieldCoreExerciseName::Swan,
            70 => FitFieldCoreExerciseName::Swimming,
            71 => FitFieldCoreExerciseName::Teaser,
            72 => FitFieldCoreExerciseName::TheHundred,
            _ => FitFieldCoreExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldCrunchExerciseName { // fit base type: uint16
    BicycleCrunch, // 0
    CableCrunch, // 1
    CircularArmCrunch, // 2
    CrossedArmsCrunch, // 3
    WeightedCrossedArmsCrunch, // 4
    CrossLegReverseCrunch, // 5
    WeightedCrossLegReverseCrunch, // 6
    CrunchChop, // 7
    WeightedCrunchChop, // 8
    DoubleCrunch, // 9
    WeightedDoubleCrunch, // 10
    ElbowToKneeCrunch, // 11
    WeightedElbowToKneeCrunch, // 12
    FlutterKicks, // 13
    WeightedFlutterKicks, // 14
    FoamRollerReverseCrunchOnBench, // 15
    WeightedFoamRollerReverseCrunchOnBench, // 16
    FoamRollerReverseCrunchWithDumbbell, // 17
    FoamRollerReverseCrunchWithMedicineBall, // 18
    FrogPress, // 19
    HangingKneeRaiseObliqueCrunch, // 20
    WeightedHangingKneeRaiseObliqueCrunch, // 21
    HipCrossover, // 22
    WeightedHipCrossover, // 23
    HollowRock, // 24
    WeightedHollowRock, // 25
    InclineReverseCrunch, // 26
    WeightedInclineReverseCrunch, // 27
    KneelingCableCrunch, // 28
    KneelingCrossCrunch, // 29
    WeightedKneelingCrossCrunch, // 30
    KneelingObliqueCableCrunch, // 31
    KneesToElbow, // 32
    LegExtensions, // 33
    WeightedLegExtensions, // 34
    LegLevers, // 35
    McgillCurlUp, // 36
    WeightedMcgillCurlUp, // 37
    ModifiedPilatesRollUpWithBall, // 38
    WeightedModifiedPilatesRollUpWithBall, // 39
    PilatesCrunch, // 40
    WeightedPilatesCrunch, // 41
    PilatesRollUpWithBall, // 42
    WeightedPilatesRollUpWithBall, // 43
    RaisedLegsCrunch, // 44
    WeightedRaisedLegsCrunch, // 45
    ReverseCrunch, // 46
    WeightedReverseCrunch, // 47
    ReverseCrunchOnABench, // 48
    WeightedReverseCrunchOnABench, // 49
    ReverseCurlAndLift, // 50
    WeightedReverseCurlAndLift, // 51
    RotationalLift, // 52
    WeightedRotationalLift, // 53
    SeatedAlternatingReverseCrunch, // 54
    WeightedSeatedAlternatingReverseCrunch, // 55
    SeatedLegU, // 56
    WeightedSeatedLegU, // 57
    SideToSideCrunchAndWeave, // 58
    WeightedSideToSideCrunchAndWeave, // 59
    SingleLegReverseCrunch, // 60
    WeightedSingleLegReverseCrunch, // 61
    SkaterCrunchCross, // 62
    WeightedSkaterCrunchCross, // 63
    StandingCableCrunch, // 64
    StandingSideCrunch, // 65
    StepClimb, // 66
    WeightedStepClimb, // 67
    SwissBallCrunch, // 68
    SwissBallReverseCrunch, // 69
    WeightedSwissBallReverseCrunch, // 70
    SwissBallRussianTwist, // 71
    WeightedSwissBallRussianTwist, // 72
    SwissBallSideCrunch, // 73
    WeightedSwissBallSideCrunch, // 74
    ThoracicCrunchesOnFoamRoller, // 75
    WeightedThoracicCrunchesOnFoamRoller, // 76
    TricepsCrunch, // 77
    WeightedBicycleCrunch, // 78
    WeightedCrunch, // 79
    WeightedSwissBallCrunch, // 80
    ToesToBar, // 81
    WeightedToesToBar, // 82
    Crunch, // 83
    StraightLegCrunchWithBall, // 84
    CrunchExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldCrunchExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldCrunchExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    50 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    51 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    52 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    53 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    54 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    55 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    56 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    57 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    58 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    59 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    60 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    61 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    62 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    63 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    64 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    65 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    66 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    67 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    68 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    69 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    70 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    71 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    72 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    73 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    74 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    75 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    76 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    77 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    78 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    79 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    80 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    81 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    82 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    83 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    84 => Ok(FitFieldCrunchExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldCrunchExerciseName::CrunchExerciseName(v)),
                }
            },
            None => Ok(FitFieldCrunchExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldCrunchExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldCrunchExerciseName::BicycleCrunch,
            1 => FitFieldCrunchExerciseName::CableCrunch,
            2 => FitFieldCrunchExerciseName::CircularArmCrunch,
            3 => FitFieldCrunchExerciseName::CrossedArmsCrunch,
            4 => FitFieldCrunchExerciseName::WeightedCrossedArmsCrunch,
            5 => FitFieldCrunchExerciseName::CrossLegReverseCrunch,
            6 => FitFieldCrunchExerciseName::WeightedCrossLegReverseCrunch,
            7 => FitFieldCrunchExerciseName::CrunchChop,
            8 => FitFieldCrunchExerciseName::WeightedCrunchChop,
            9 => FitFieldCrunchExerciseName::DoubleCrunch,
            10 => FitFieldCrunchExerciseName::WeightedDoubleCrunch,
            11 => FitFieldCrunchExerciseName::ElbowToKneeCrunch,
            12 => FitFieldCrunchExerciseName::WeightedElbowToKneeCrunch,
            13 => FitFieldCrunchExerciseName::FlutterKicks,
            14 => FitFieldCrunchExerciseName::WeightedFlutterKicks,
            15 => FitFieldCrunchExerciseName::FoamRollerReverseCrunchOnBench,
            16 => FitFieldCrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench,
            17 => FitFieldCrunchExerciseName::FoamRollerReverseCrunchWithDumbbell,
            18 => FitFieldCrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall,
            19 => FitFieldCrunchExerciseName::FrogPress,
            20 => FitFieldCrunchExerciseName::HangingKneeRaiseObliqueCrunch,
            21 => FitFieldCrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch,
            22 => FitFieldCrunchExerciseName::HipCrossover,
            23 => FitFieldCrunchExerciseName::WeightedHipCrossover,
            24 => FitFieldCrunchExerciseName::HollowRock,
            25 => FitFieldCrunchExerciseName::WeightedHollowRock,
            26 => FitFieldCrunchExerciseName::InclineReverseCrunch,
            27 => FitFieldCrunchExerciseName::WeightedInclineReverseCrunch,
            28 => FitFieldCrunchExerciseName::KneelingCableCrunch,
            29 => FitFieldCrunchExerciseName::KneelingCrossCrunch,
            30 => FitFieldCrunchExerciseName::WeightedKneelingCrossCrunch,
            31 => FitFieldCrunchExerciseName::KneelingObliqueCableCrunch,
            32 => FitFieldCrunchExerciseName::KneesToElbow,
            33 => FitFieldCrunchExerciseName::LegExtensions,
            34 => FitFieldCrunchExerciseName::WeightedLegExtensions,
            35 => FitFieldCrunchExerciseName::LegLevers,
            36 => FitFieldCrunchExerciseName::McgillCurlUp,
            37 => FitFieldCrunchExerciseName::WeightedMcgillCurlUp,
            38 => FitFieldCrunchExerciseName::ModifiedPilatesRollUpWithBall,
            39 => FitFieldCrunchExerciseName::WeightedModifiedPilatesRollUpWithBall,
            40 => FitFieldCrunchExerciseName::PilatesCrunch,
            41 => FitFieldCrunchExerciseName::WeightedPilatesCrunch,
            42 => FitFieldCrunchExerciseName::PilatesRollUpWithBall,
            43 => FitFieldCrunchExerciseName::WeightedPilatesRollUpWithBall,
            44 => FitFieldCrunchExerciseName::RaisedLegsCrunch,
            45 => FitFieldCrunchExerciseName::WeightedRaisedLegsCrunch,
            46 => FitFieldCrunchExerciseName::ReverseCrunch,
            47 => FitFieldCrunchExerciseName::WeightedReverseCrunch,
            48 => FitFieldCrunchExerciseName::ReverseCrunchOnABench,
            49 => FitFieldCrunchExerciseName::WeightedReverseCrunchOnABench,
            50 => FitFieldCrunchExerciseName::ReverseCurlAndLift,
            51 => FitFieldCrunchExerciseName::WeightedReverseCurlAndLift,
            52 => FitFieldCrunchExerciseName::RotationalLift,
            53 => FitFieldCrunchExerciseName::WeightedRotationalLift,
            54 => FitFieldCrunchExerciseName::SeatedAlternatingReverseCrunch,
            55 => FitFieldCrunchExerciseName::WeightedSeatedAlternatingReverseCrunch,
            56 => FitFieldCrunchExerciseName::SeatedLegU,
            57 => FitFieldCrunchExerciseName::WeightedSeatedLegU,
            58 => FitFieldCrunchExerciseName::SideToSideCrunchAndWeave,
            59 => FitFieldCrunchExerciseName::WeightedSideToSideCrunchAndWeave,
            60 => FitFieldCrunchExerciseName::SingleLegReverseCrunch,
            61 => FitFieldCrunchExerciseName::WeightedSingleLegReverseCrunch,
            62 => FitFieldCrunchExerciseName::SkaterCrunchCross,
            63 => FitFieldCrunchExerciseName::WeightedSkaterCrunchCross,
            64 => FitFieldCrunchExerciseName::StandingCableCrunch,
            65 => FitFieldCrunchExerciseName::StandingSideCrunch,
            66 => FitFieldCrunchExerciseName::StepClimb,
            67 => FitFieldCrunchExerciseName::WeightedStepClimb,
            68 => FitFieldCrunchExerciseName::SwissBallCrunch,
            69 => FitFieldCrunchExerciseName::SwissBallReverseCrunch,
            70 => FitFieldCrunchExerciseName::WeightedSwissBallReverseCrunch,
            71 => FitFieldCrunchExerciseName::SwissBallRussianTwist,
            72 => FitFieldCrunchExerciseName::WeightedSwissBallRussianTwist,
            73 => FitFieldCrunchExerciseName::SwissBallSideCrunch,
            74 => FitFieldCrunchExerciseName::WeightedSwissBallSideCrunch,
            75 => FitFieldCrunchExerciseName::ThoracicCrunchesOnFoamRoller,
            76 => FitFieldCrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller,
            77 => FitFieldCrunchExerciseName::TricepsCrunch,
            78 => FitFieldCrunchExerciseName::WeightedBicycleCrunch,
            79 => FitFieldCrunchExerciseName::WeightedCrunch,
            80 => FitFieldCrunchExerciseName::WeightedSwissBallCrunch,
            81 => FitFieldCrunchExerciseName::ToesToBar,
            82 => FitFieldCrunchExerciseName::WeightedToesToBar,
            83 => FitFieldCrunchExerciseName::Crunch,
            84 => FitFieldCrunchExerciseName::StraightLegCrunchWithBall,
            _ => FitFieldCrunchExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldTimeIntoDay { // fit base type: uint32
    TimeIntoDay(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldTimeIntoDay {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldTimeIntoDay> {
        let val = parse_uint32(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    v => Ok(FitFieldTimeIntoDay::TimeIntoDay(v)),
                }
            },
            None => Ok(FitFieldTimeIntoDay::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldTimeIntoDay {
    fn from(code: u32) -> Self {
        match code {
            _ => FitFieldTimeIntoDay::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldRunExerciseName { // fit base type: uint16
    Run, // 0
    Walk, // 1
    Jog, // 2
    Sprint, // 3
    RunExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldRunExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldRunExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldRunExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldRunExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldRunExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldRunExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldRunExerciseName::RunExerciseName(v)),
                }
            },
            None => Ok(FitFieldRunExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldRunExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldRunExerciseName::Run,
            1 => FitFieldRunExerciseName::Walk,
            2 => FitFieldRunExerciseName::Jog,
            3 => FitFieldRunExerciseName::Sprint,
            _ => FitFieldRunExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldHipSwingExerciseName { // fit base type: uint16
    SingleArmKettlebellSwing, // 0
    SingleArmDumbbellSwing, // 1
    StepOutSwing, // 2
    HipSwingExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldHipSwingExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldHipSwingExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldHipSwingExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldHipSwingExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldHipSwingExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldHipSwingExerciseName::HipSwingExerciseName(v)),
                }
            },
            None => Ok(FitFieldHipSwingExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldHipSwingExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldHipSwingExerciseName::SingleArmKettlebellSwing,
            1 => FitFieldHipSwingExerciseName::SingleArmDumbbellSwing,
            2 => FitFieldHipSwingExerciseName::StepOutSwing,
            _ => FitFieldHipSwingExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSwimStroke { // fit base type: enum
    Freestyle = 0,
    Backstroke = 1,
    Breaststroke = 2,
    Butterfly = 3,
    Drill = 4,
    Mixed = 5,
    Im = 6,  // IM is a mixed interval containing the same number of lengths for each of: Butterfly, Backstroke, Breaststroke, Freestyle, swam in that order.
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSwimStroke {
    pub fn parse(input: &[u8]) -> Result<FitFieldSwimStroke> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSwimStroke::from(valid_val)),
            None => Ok(FitFieldSwimStroke::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSwimStroke {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSwimStroke::Freestyle,
            1 => FitFieldSwimStroke::Backstroke,
            2 => FitFieldSwimStroke::Breaststroke,
            3 => FitFieldSwimStroke::Butterfly,
            4 => FitFieldSwimStroke::Drill,
            5 => FitFieldSwimStroke::Mixed,
            6 => FitFieldSwimStroke::Im,
            _ => FitFieldSwimStroke::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSupportedExdScreenLayouts { // fit base type: uint32z
    FullScreen, // 1
    HalfVertical, // 2
    HalfHorizontal, // 4
    HalfVerticalRightSplit, // 8
    HalfHorizontalBottomSplit, // 16
    FullQuarterSplit, // 32
    HalfVerticalLeftSplit, // 64
    HalfHorizontalTopSplit, // 128
    SupportedExdScreenLayouts(u32),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldSupportedExdScreenLayouts {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldSupportedExdScreenLayouts> {
        let val = parse_uint32z(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    1 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    2 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    4 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    8 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    16 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    32 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    64 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    128 => Ok(FitFieldSupportedExdScreenLayouts::from(valid_val)),
                    
                    v => Ok(FitFieldSupportedExdScreenLayouts::SupportedExdScreenLayouts(v)),
                }
            },
            None => Ok(FitFieldSupportedExdScreenLayouts::InvalidFieldValue),
        }
    }
}


impl From<u32> for FitFieldSupportedExdScreenLayouts {
    fn from(code: u32) -> Self {
        match code {
            1 => FitFieldSupportedExdScreenLayouts::FullScreen,
            2 => FitFieldSupportedExdScreenLayouts::HalfVertical,
            4 => FitFieldSupportedExdScreenLayouts::HalfHorizontal,
            8 => FitFieldSupportedExdScreenLayouts::HalfVerticalRightSplit,
            16 => FitFieldSupportedExdScreenLayouts::HalfHorizontalBottomSplit,
            32 => FitFieldSupportedExdScreenLayouts::FullQuarterSplit,
            64 => FitFieldSupportedExdScreenLayouts::HalfVerticalLeftSplit,
            128 => FitFieldSupportedExdScreenLayouts::HalfHorizontalTopSplit,
            _ => FitFieldSupportedExdScreenLayouts::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldSwitch { // fit base type: enum
    Off = 0,
    On = 1,
    Auto = 2,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldSwitch {
    pub fn parse(input: &[u8]) -> Result<FitFieldSwitch> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldSwitch::from(valid_val)),
            None => Ok(FitFieldSwitch::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldSwitch {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldSwitch::Off,
            1 => FitFieldSwitch::On,
            2 => FitFieldSwitch::Auto,
            _ => FitFieldSwitch::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldPushUpExerciseName { // fit base type: uint16
    ChestPressWithBand, // 0
    AlternatingStaggeredPushUp, // 1
    WeightedAlternatingStaggeredPushUp, // 2
    AlternatingHandsMedicineBallPushUp, // 3
    WeightedAlternatingHandsMedicineBallPushUp, // 4
    BosuBallPushUp, // 5
    WeightedBosuBallPushUp, // 6
    ClappingPushUp, // 7
    WeightedClappingPushUp, // 8
    CloseGripMedicineBallPushUp, // 9
    WeightedCloseGripMedicineBallPushUp, // 10
    CloseHandsPushUp, // 11
    WeightedCloseHandsPushUp, // 12
    DeclinePushUp, // 13
    WeightedDeclinePushUp, // 14
    DiamondPushUp, // 15
    WeightedDiamondPushUp, // 16
    ExplosiveCrossoverPushUp, // 17
    WeightedExplosiveCrossoverPushUp, // 18
    ExplosivePushUp, // 19
    WeightedExplosivePushUp, // 20
    FeetElevatedSideToSidePushUp, // 21
    WeightedFeetElevatedSideToSidePushUp, // 22
    HandReleasePushUp, // 23
    WeightedHandReleasePushUp, // 24
    HandstandPushUp, // 25
    WeightedHandstandPushUp, // 26
    InclinePushUp, // 27
    WeightedInclinePushUp, // 28
    IsometricExplosivePushUp, // 29
    WeightedIsometricExplosivePushUp, // 30
    JudoPushUp, // 31
    WeightedJudoPushUp, // 32
    KneelingPushUp, // 33
    WeightedKneelingPushUp, // 34
    MedicineBallChestPass, // 35
    MedicineBallPushUp, // 36
    WeightedMedicineBallPushUp, // 37
    OneArmPushUp, // 38
    WeightedOneArmPushUp, // 39
    WeightedPushUp, // 40
    PushUpAndRow, // 41
    WeightedPushUpAndRow, // 42
    PushUpPlus, // 43
    WeightedPushUpPlus, // 44
    PushUpWithFeetOnSwissBall, // 45
    WeightedPushUpWithFeetOnSwissBall, // 46
    PushUpWithOneHandOnMedicineBall, // 47
    WeightedPushUpWithOneHandOnMedicineBall, // 48
    ShoulderPushUp, // 49
    WeightedShoulderPushUp, // 50
    SingleArmMedicineBallPushUp, // 51
    WeightedSingleArmMedicineBallPushUp, // 52
    SpidermanPushUp, // 53
    WeightedSpidermanPushUp, // 54
    StackedFeetPushUp, // 55
    WeightedStackedFeetPushUp, // 56
    StaggeredHandsPushUp, // 57
    WeightedStaggeredHandsPushUp, // 58
    SuspendedPushUp, // 59
    WeightedSuspendedPushUp, // 60
    SwissBallPushUp, // 61
    WeightedSwissBallPushUp, // 62
    SwissBallPushUpPlus, // 63
    WeightedSwissBallPushUpPlus, // 64
    TPushUp, // 65
    WeightedTPushUp, // 66
    TripleStopPushUp, // 67
    WeightedTripleStopPushUp, // 68
    WideHandsPushUp, // 69
    WeightedWideHandsPushUp, // 70
    ParalletteHandstandPushUp, // 71
    WeightedParalletteHandstandPushUp, // 72
    RingHandstandPushUp, // 73
    WeightedRingHandstandPushUp, // 74
    RingPushUp, // 75
    WeightedRingPushUp, // 76
    PushUp, // 77
    PilatesPushup, // 78
    PushUpExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldPushUpExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldPushUpExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    19 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    20 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    21 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    22 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    23 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    24 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    25 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    26 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    27 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    28 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    29 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    30 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    31 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    32 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    33 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    34 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    35 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    36 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    37 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    38 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    39 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    40 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    41 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    42 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    43 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    44 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    45 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    46 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    47 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    48 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    49 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    50 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    51 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    52 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    53 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    54 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    55 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    56 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    57 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    58 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    59 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    60 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    61 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    62 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    63 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    64 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    65 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    66 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    67 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    68 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    69 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    70 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    71 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    72 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    73 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    74 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    75 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    76 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    77 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    78 => Ok(FitFieldPushUpExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldPushUpExerciseName::PushUpExerciseName(v)),
                }
            },
            None => Ok(FitFieldPushUpExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldPushUpExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldPushUpExerciseName::ChestPressWithBand,
            1 => FitFieldPushUpExerciseName::AlternatingStaggeredPushUp,
            2 => FitFieldPushUpExerciseName::WeightedAlternatingStaggeredPushUp,
            3 => FitFieldPushUpExerciseName::AlternatingHandsMedicineBallPushUp,
            4 => FitFieldPushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp,
            5 => FitFieldPushUpExerciseName::BosuBallPushUp,
            6 => FitFieldPushUpExerciseName::WeightedBosuBallPushUp,
            7 => FitFieldPushUpExerciseName::ClappingPushUp,
            8 => FitFieldPushUpExerciseName::WeightedClappingPushUp,
            9 => FitFieldPushUpExerciseName::CloseGripMedicineBallPushUp,
            10 => FitFieldPushUpExerciseName::WeightedCloseGripMedicineBallPushUp,
            11 => FitFieldPushUpExerciseName::CloseHandsPushUp,
            12 => FitFieldPushUpExerciseName::WeightedCloseHandsPushUp,
            13 => FitFieldPushUpExerciseName::DeclinePushUp,
            14 => FitFieldPushUpExerciseName::WeightedDeclinePushUp,
            15 => FitFieldPushUpExerciseName::DiamondPushUp,
            16 => FitFieldPushUpExerciseName::WeightedDiamondPushUp,
            17 => FitFieldPushUpExerciseName::ExplosiveCrossoverPushUp,
            18 => FitFieldPushUpExerciseName::WeightedExplosiveCrossoverPushUp,
            19 => FitFieldPushUpExerciseName::ExplosivePushUp,
            20 => FitFieldPushUpExerciseName::WeightedExplosivePushUp,
            21 => FitFieldPushUpExerciseName::FeetElevatedSideToSidePushUp,
            22 => FitFieldPushUpExerciseName::WeightedFeetElevatedSideToSidePushUp,
            23 => FitFieldPushUpExerciseName::HandReleasePushUp,
            24 => FitFieldPushUpExerciseName::WeightedHandReleasePushUp,
            25 => FitFieldPushUpExerciseName::HandstandPushUp,
            26 => FitFieldPushUpExerciseName::WeightedHandstandPushUp,
            27 => FitFieldPushUpExerciseName::InclinePushUp,
            28 => FitFieldPushUpExerciseName::WeightedInclinePushUp,
            29 => FitFieldPushUpExerciseName::IsometricExplosivePushUp,
            30 => FitFieldPushUpExerciseName::WeightedIsometricExplosivePushUp,
            31 => FitFieldPushUpExerciseName::JudoPushUp,
            32 => FitFieldPushUpExerciseName::WeightedJudoPushUp,
            33 => FitFieldPushUpExerciseName::KneelingPushUp,
            34 => FitFieldPushUpExerciseName::WeightedKneelingPushUp,
            35 => FitFieldPushUpExerciseName::MedicineBallChestPass,
            36 => FitFieldPushUpExerciseName::MedicineBallPushUp,
            37 => FitFieldPushUpExerciseName::WeightedMedicineBallPushUp,
            38 => FitFieldPushUpExerciseName::OneArmPushUp,
            39 => FitFieldPushUpExerciseName::WeightedOneArmPushUp,
            40 => FitFieldPushUpExerciseName::WeightedPushUp,
            41 => FitFieldPushUpExerciseName::PushUpAndRow,
            42 => FitFieldPushUpExerciseName::WeightedPushUpAndRow,
            43 => FitFieldPushUpExerciseName::PushUpPlus,
            44 => FitFieldPushUpExerciseName::WeightedPushUpPlus,
            45 => FitFieldPushUpExerciseName::PushUpWithFeetOnSwissBall,
            46 => FitFieldPushUpExerciseName::WeightedPushUpWithFeetOnSwissBall,
            47 => FitFieldPushUpExerciseName::PushUpWithOneHandOnMedicineBall,
            48 => FitFieldPushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall,
            49 => FitFieldPushUpExerciseName::ShoulderPushUp,
            50 => FitFieldPushUpExerciseName::WeightedShoulderPushUp,
            51 => FitFieldPushUpExerciseName::SingleArmMedicineBallPushUp,
            52 => FitFieldPushUpExerciseName::WeightedSingleArmMedicineBallPushUp,
            53 => FitFieldPushUpExerciseName::SpidermanPushUp,
            54 => FitFieldPushUpExerciseName::WeightedSpidermanPushUp,
            55 => FitFieldPushUpExerciseName::StackedFeetPushUp,
            56 => FitFieldPushUpExerciseName::WeightedStackedFeetPushUp,
            57 => FitFieldPushUpExerciseName::StaggeredHandsPushUp,
            58 => FitFieldPushUpExerciseName::WeightedStaggeredHandsPushUp,
            59 => FitFieldPushUpExerciseName::SuspendedPushUp,
            60 => FitFieldPushUpExerciseName::WeightedSuspendedPushUp,
            61 => FitFieldPushUpExerciseName::SwissBallPushUp,
            62 => FitFieldPushUpExerciseName::WeightedSwissBallPushUp,
            63 => FitFieldPushUpExerciseName::SwissBallPushUpPlus,
            64 => FitFieldPushUpExerciseName::WeightedSwissBallPushUpPlus,
            65 => FitFieldPushUpExerciseName::TPushUp,
            66 => FitFieldPushUpExerciseName::WeightedTPushUp,
            67 => FitFieldPushUpExerciseName::TripleStopPushUp,
            68 => FitFieldPushUpExerciseName::WeightedTripleStopPushUp,
            69 => FitFieldPushUpExerciseName::WideHandsPushUp,
            70 => FitFieldPushUpExerciseName::WeightedWideHandsPushUp,
            71 => FitFieldPushUpExerciseName::ParalletteHandstandPushUp,
            72 => FitFieldPushUpExerciseName::WeightedParalletteHandstandPushUp,
            73 => FitFieldPushUpExerciseName::RingHandstandPushUp,
            74 => FitFieldPushUpExerciseName::WeightedRingHandstandPushUp,
            75 => FitFieldPushUpExerciseName::RingPushUp,
            76 => FitFieldPushUpExerciseName::WeightedRingPushUp,
            77 => FitFieldPushUpExerciseName::PushUp,
            78 => FitFieldPushUpExerciseName::PilatesPushup,
            _ => FitFieldPushUpExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldMesgNum { // fit base type: uint16
    FileId, // 0
    Capabilities, // 1
    DeviceSettings, // 2
    UserProfile, // 3
    HrmProfile, // 4
    SdmProfile, // 5
    BikeProfile, // 6
    ZonesTarget, // 7
    HrZone, // 8
    PowerZone, // 9
    MetZone, // 10
    Sport, // 12
    Goal, // 15
    Session, // 18
    Lap, // 19
    Record, // 20
    Event, // 21
    DeviceInfo, // 23
    Workout, // 26
    WorkoutStep, // 27
    Schedule, // 28
    WeightScale, // 30
    Course, // 31
    CoursePoint, // 32
    Totals, // 33
    Activity, // 34
    Software, // 35
    FileCapabilities, // 37
    MesgCapabilities, // 38
    FieldCapabilities, // 39
    FileCreator, // 49
    BloodPressure, // 51
    SpeedZone, // 53
    Monitoring, // 55
    TrainingFile, // 72
    Hrv, // 78
    AntRx, // 80
    AntTx, // 81
    AntChannelId, // 82
    Length, // 101
    MonitoringInfo, // 103
    SlaveDevice, // 106
    Connectivity, // 127
    WeatherConditions, // 128
    WeatherAlert, // 129
    CadenceZone, // 131
    Hr, // 132
    SegmentLap, // 142
    MemoGlob, // 145
    SegmentId, // 148
    SegmentLeaderboardEntry, // 149
    SegmentPoint, // 150
    SegmentFile, // 151
    WorkoutSession, // 158
    WatchfaceSettings, // 159
    GpsMetadata, // 160
    CameraEvent, // 161
    TimestampCorrelation, // 162
    GyroscopeData, // 164
    AccelerometerData, // 165
    ThreeDSensorCalibration, // 167
    VideoFrame, // 169
    ObdiiData, // 174
    NmeaSentence, // 177
    AviationAttitude, // 178
    Video, // 184
    VideoTitle, // 185
    VideoDescription, // 186
    VideoClip, // 187
    OhrSettings, // 188
    ExdScreenConfiguration, // 200
    ExdDataFieldConfiguration, // 201
    ExdDataConceptConfiguration, // 202
    FieldDescription, // 206
    DeveloperDataId, // 207
    MagnetometerData, // 208
    BarometerData, // 209
    OneDSensorCalibration, // 210
    Set, // 225
    StressLevel, // 227
    DiveSettings, // 258
    DiveGas, // 259
    DiveAlarm, // 262
    ExerciseTitle, // 264
    DiveSummary, // 268
    MfgRangeMin, // 65280  0xFF00 - 0xFFFE reserved for manufacturer specific messages
    MfgRangeMax, // 65534  0xFF00 - 0xFFFE reserved for manufacturer specific messages
    MesgNum(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldMesgNum {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldMesgNum> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    1 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    2 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    3 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    4 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    5 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    6 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    7 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    8 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    9 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    10 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    12 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    15 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    18 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    19 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    20 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    21 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    23 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    26 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    27 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    28 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    30 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    31 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    32 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    33 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    34 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    35 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    37 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    38 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    39 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    49 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    51 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    53 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    55 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    72 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    78 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    80 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    81 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    82 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    101 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    103 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    106 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    127 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    128 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    129 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    131 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    132 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    142 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    145 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    148 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    149 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    150 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    151 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    158 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    159 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    160 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    161 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    162 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    164 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    165 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    167 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    169 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    174 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    177 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    178 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    184 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    185 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    186 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    187 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    188 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    200 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    201 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    202 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    206 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    207 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    208 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    209 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    210 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    225 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    227 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    258 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    259 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    262 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    264 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    268 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    65280 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    65534 => Ok(FitFieldMesgNum::from(valid_val)),
                    
                    v => Ok(FitFieldMesgNum::MesgNum(v)),
                }
            },
            None => Ok(FitFieldMesgNum::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldMesgNum {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldMesgNum::FileId,
            1 => FitFieldMesgNum::Capabilities,
            2 => FitFieldMesgNum::DeviceSettings,
            3 => FitFieldMesgNum::UserProfile,
            4 => FitFieldMesgNum::HrmProfile,
            5 => FitFieldMesgNum::SdmProfile,
            6 => FitFieldMesgNum::BikeProfile,
            7 => FitFieldMesgNum::ZonesTarget,
            8 => FitFieldMesgNum::HrZone,
            9 => FitFieldMesgNum::PowerZone,
            10 => FitFieldMesgNum::MetZone,
            12 => FitFieldMesgNum::Sport,
            15 => FitFieldMesgNum::Goal,
            18 => FitFieldMesgNum::Session,
            19 => FitFieldMesgNum::Lap,
            20 => FitFieldMesgNum::Record,
            21 => FitFieldMesgNum::Event,
            23 => FitFieldMesgNum::DeviceInfo,
            26 => FitFieldMesgNum::Workout,
            27 => FitFieldMesgNum::WorkoutStep,
            28 => FitFieldMesgNum::Schedule,
            30 => FitFieldMesgNum::WeightScale,
            31 => FitFieldMesgNum::Course,
            32 => FitFieldMesgNum::CoursePoint,
            33 => FitFieldMesgNum::Totals,
            34 => FitFieldMesgNum::Activity,
            35 => FitFieldMesgNum::Software,
            37 => FitFieldMesgNum::FileCapabilities,
            38 => FitFieldMesgNum::MesgCapabilities,
            39 => FitFieldMesgNum::FieldCapabilities,
            49 => FitFieldMesgNum::FileCreator,
            51 => FitFieldMesgNum::BloodPressure,
            53 => FitFieldMesgNum::SpeedZone,
            55 => FitFieldMesgNum::Monitoring,
            72 => FitFieldMesgNum::TrainingFile,
            78 => FitFieldMesgNum::Hrv,
            80 => FitFieldMesgNum::AntRx,
            81 => FitFieldMesgNum::AntTx,
            82 => FitFieldMesgNum::AntChannelId,
            101 => FitFieldMesgNum::Length,
            103 => FitFieldMesgNum::MonitoringInfo,
            106 => FitFieldMesgNum::SlaveDevice,
            127 => FitFieldMesgNum::Connectivity,
            128 => FitFieldMesgNum::WeatherConditions,
            129 => FitFieldMesgNum::WeatherAlert,
            131 => FitFieldMesgNum::CadenceZone,
            132 => FitFieldMesgNum::Hr,
            142 => FitFieldMesgNum::SegmentLap,
            145 => FitFieldMesgNum::MemoGlob,
            148 => FitFieldMesgNum::SegmentId,
            149 => FitFieldMesgNum::SegmentLeaderboardEntry,
            150 => FitFieldMesgNum::SegmentPoint,
            151 => FitFieldMesgNum::SegmentFile,
            158 => FitFieldMesgNum::WorkoutSession,
            159 => FitFieldMesgNum::WatchfaceSettings,
            160 => FitFieldMesgNum::GpsMetadata,
            161 => FitFieldMesgNum::CameraEvent,
            162 => FitFieldMesgNum::TimestampCorrelation,
            164 => FitFieldMesgNum::GyroscopeData,
            165 => FitFieldMesgNum::AccelerometerData,
            167 => FitFieldMesgNum::ThreeDSensorCalibration,
            169 => FitFieldMesgNum::VideoFrame,
            174 => FitFieldMesgNum::ObdiiData,
            177 => FitFieldMesgNum::NmeaSentence,
            178 => FitFieldMesgNum::AviationAttitude,
            184 => FitFieldMesgNum::Video,
            185 => FitFieldMesgNum::VideoTitle,
            186 => FitFieldMesgNum::VideoDescription,
            187 => FitFieldMesgNum::VideoClip,
            188 => FitFieldMesgNum::OhrSettings,
            200 => FitFieldMesgNum::ExdScreenConfiguration,
            201 => FitFieldMesgNum::ExdDataFieldConfiguration,
            202 => FitFieldMesgNum::ExdDataConceptConfiguration,
            206 => FitFieldMesgNum::FieldDescription,
            207 => FitFieldMesgNum::DeveloperDataId,
            208 => FitFieldMesgNum::MagnetometerData,
            209 => FitFieldMesgNum::BarometerData,
            210 => FitFieldMesgNum::OneDSensorCalibration,
            225 => FitFieldMesgNum::Set,
            227 => FitFieldMesgNum::StressLevel,
            258 => FitFieldMesgNum::DiveSettings,
            259 => FitFieldMesgNum::DiveGas,
            262 => FitFieldMesgNum::DiveAlarm,
            264 => FitFieldMesgNum::ExerciseTitle,
            268 => FitFieldMesgNum::DiveSummary,
            65280 => FitFieldMesgNum::MfgRangeMin,
            65534 => FitFieldMesgNum::MfgRangeMax,
            _ => FitFieldMesgNum::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldDeadliftExerciseName { // fit base type: uint16
    BarbellDeadlift, // 0
    BarbellStraightLegDeadlift, // 1
    DumbbellDeadlift, // 2
    DumbbellSingleLegDeadliftToRow, // 3
    DumbbellStraightLegDeadlift, // 4
    KettlebellFloorToShelf, // 5
    OneArmOneLegDeadlift, // 6
    RackPull, // 7
    RotationalDumbbellStraightLegDeadlift, // 8
    SingleArmDeadlift, // 9
    SingleLegBarbellDeadlift, // 10
    SingleLegBarbellStraightLegDeadlift, // 11
    SingleLegDeadliftWithBarbell, // 12
    SingleLegRdlCircuit, // 13
    SingleLegRomanianDeadliftWithDumbbell, // 14
    SumoDeadlift, // 15
    SumoDeadliftHighPull, // 16
    TrapBarDeadlift, // 17
    WideGripBarbellDeadlift, // 18
    DeadliftExerciseName(u16),
    InvalidFieldValue,
    UnknownToSdk,
}

impl FitFieldDeadliftExerciseName {
    pub fn parse(input: &[u8], endianness: Endianness) -> Result<FitFieldDeadliftExerciseName> {
        let val = parse_uint16(input, endianness)?;
        match val {
            Some(valid_val) => {
                match valid_val {
                    
                    0 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    1 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    2 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    3 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    4 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    5 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    6 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    7 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    8 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    9 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    10 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    11 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    12 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    13 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    14 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    15 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    16 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    17 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    18 => Ok(FitFieldDeadliftExerciseName::from(valid_val)),
                    
                    v => Ok(FitFieldDeadliftExerciseName::DeadliftExerciseName(v)),
                }
            },
            None => Ok(FitFieldDeadliftExerciseName::InvalidFieldValue),
        }
    }
}


impl From<u16> for FitFieldDeadliftExerciseName {
    fn from(code: u16) -> Self {
        match code {
            0 => FitFieldDeadliftExerciseName::BarbellDeadlift,
            1 => FitFieldDeadliftExerciseName::BarbellStraightLegDeadlift,
            2 => FitFieldDeadliftExerciseName::DumbbellDeadlift,
            3 => FitFieldDeadliftExerciseName::DumbbellSingleLegDeadliftToRow,
            4 => FitFieldDeadliftExerciseName::DumbbellStraightLegDeadlift,
            5 => FitFieldDeadliftExerciseName::KettlebellFloorToShelf,
            6 => FitFieldDeadliftExerciseName::OneArmOneLegDeadlift,
            7 => FitFieldDeadliftExerciseName::RackPull,
            8 => FitFieldDeadliftExerciseName::RotationalDumbbellStraightLegDeadlift,
            9 => FitFieldDeadliftExerciseName::SingleArmDeadlift,
            10 => FitFieldDeadliftExerciseName::SingleLegBarbellDeadlift,
            11 => FitFieldDeadliftExerciseName::SingleLegBarbellStraightLegDeadlift,
            12 => FitFieldDeadliftExerciseName::SingleLegDeadliftWithBarbell,
            13 => FitFieldDeadliftExerciseName::SingleLegRdlCircuit,
            14 => FitFieldDeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell,
            15 => FitFieldDeadliftExerciseName::SumoDeadlift,
            16 => FitFieldDeadliftExerciseName::SumoDeadliftHighPull,
            17 => FitFieldDeadliftExerciseName::TrapBarDeadlift,
            18 => FitFieldDeadliftExerciseName::WideGripBarbellDeadlift,
            _ => FitFieldDeadliftExerciseName::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldAntNetwork { // fit base type: enum
    Public = 0,
    Antplus = 1,
    Antfs = 2,
    Private = 3,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldAntNetwork {
    pub fn parse(input: &[u8]) -> Result<FitFieldAntNetwork> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldAntNetwork::from(valid_val)),
            None => Ok(FitFieldAntNetwork::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldAntNetwork {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldAntNetwork::Public,
            1 => FitFieldAntNetwork::Antplus,
            2 => FitFieldAntNetwork::Antfs,
            3 => FitFieldAntNetwork::Private,
            _ => FitFieldAntNetwork::UnknownToSdk,
        }
    }
}






#[derive(Debug, PartialEq)]
pub enum FitFieldExdDataUnits { // fit base type: enum
    NoUnits = 0,
    Laps = 1,
    MilesPerHour = 2,
    KilometersPerHour = 3,
    FeetPerHour = 4,
    MetersPerHour = 5,
    DegreesCelsius = 6,
    DegreesFarenheit = 7,
    Zone = 8,
    Gear = 9,
    Rpm = 10,
    Bpm = 11,
    Degrees = 12,
    Millimeters = 13,
    Meters = 14,
    Kilometers = 15,
    Feet = 16,
    Yards = 17,
    Kilofeet = 18,
    Miles = 19,
    Time = 20,
    EnumTurnType = 21,
    Percent = 22,
    Watts = 23,
    WattsPerKilogram = 24,
    EnumBatteryStatus = 25,
    EnumBikeLightBeamAngleMode = 26,
    EnumBikeLightBatteryStatus = 27,
    EnumBikeLightNetworkConfigType = 28,
    Lights = 29,
    Seconds = 30,
    Minutes = 31,
    Hours = 32,
    Calories = 33,
    Kilojoules = 34,
    Milliseconds = 35,
    SecondPerMile = 36,
    SecondPerKilometer = 37,
    Centimeter = 38,
    EnumCoursePoint = 39,
    Bradians = 40,
    EnumSport = 41,
    InchesHg = 42,
    MmHg = 43,
    Mbars = 44,
    HectoPascals = 45,
    FeetPerMin = 46,
    MetersPerMin = 47,
    MetersPerSec = 48,
    EightCardinal = 49,
    InvalidFieldValue = -1,
    UnknownToSdk = -2,
}

impl FitFieldExdDataUnits {
    pub fn parse(input: &[u8]) -> Result<FitFieldExdDataUnits> {
        let val = parse_enum(input)?;
        match val {
            Some(valid_val) => Ok(FitFieldExdDataUnits::from(valid_val)),
            None => Ok(FitFieldExdDataUnits::InvalidFieldValue),
            //None => Err(Error::invalid_fit_base_type_parse())
        }
    }
}

impl From<u8> for FitFieldExdDataUnits {
    fn from(code: u8) -> Self {
        match code {
            0 => FitFieldExdDataUnits::NoUnits,
            1 => FitFieldExdDataUnits::Laps,
            2 => FitFieldExdDataUnits::MilesPerHour,
            3 => FitFieldExdDataUnits::KilometersPerHour,
            4 => FitFieldExdDataUnits::FeetPerHour,
            5 => FitFieldExdDataUnits::MetersPerHour,
            6 => FitFieldExdDataUnits::DegreesCelsius,
            7 => FitFieldExdDataUnits::DegreesFarenheit,
            8 => FitFieldExdDataUnits::Zone,
            9 => FitFieldExdDataUnits::Gear,
            10 => FitFieldExdDataUnits::Rpm,
            11 => FitFieldExdDataUnits::Bpm,
            12 => FitFieldExdDataUnits::Degrees,
            13 => FitFieldExdDataUnits::Millimeters,
            14 => FitFieldExdDataUnits::Meters,
            15 => FitFieldExdDataUnits::Kilometers,
            16 => FitFieldExdDataUnits::Feet,
            17 => FitFieldExdDataUnits::Yards,
            18 => FitFieldExdDataUnits::Kilofeet,
            19 => FitFieldExdDataUnits::Miles,
            20 => FitFieldExdDataUnits::Time,
            21 => FitFieldExdDataUnits::EnumTurnType,
            22 => FitFieldExdDataUnits::Percent,
            23 => FitFieldExdDataUnits::Watts,
            24 => FitFieldExdDataUnits::WattsPerKilogram,
            25 => FitFieldExdDataUnits::EnumBatteryStatus,
            26 => FitFieldExdDataUnits::EnumBikeLightBeamAngleMode,
            27 => FitFieldExdDataUnits::EnumBikeLightBatteryStatus,
            28 => FitFieldExdDataUnits::EnumBikeLightNetworkConfigType,
            29 => FitFieldExdDataUnits::Lights,
            30 => FitFieldExdDataUnits::Seconds,
            31 => FitFieldExdDataUnits::Minutes,
            32 => FitFieldExdDataUnits::Hours,
            33 => FitFieldExdDataUnits::Calories,
            34 => FitFieldExdDataUnits::Kilojoules,
            35 => FitFieldExdDataUnits::Milliseconds,
            36 => FitFieldExdDataUnits::SecondPerMile,
            37 => FitFieldExdDataUnits::SecondPerKilometer,
            38 => FitFieldExdDataUnits::Centimeter,
            39 => FitFieldExdDataUnits::EnumCoursePoint,
            40 => FitFieldExdDataUnits::Bradians,
            41 => FitFieldExdDataUnits::EnumSport,
            42 => FitFieldExdDataUnits::InchesHg,
            43 => FitFieldExdDataUnits::MmHg,
            44 => FitFieldExdDataUnits::Mbars,
            45 => FitFieldExdDataUnits::HectoPascals,
            46 => FitFieldExdDataUnits::FeetPerMin,
            47 => FitFieldExdDataUnits::MetersPerMin,
            48 => FitFieldExdDataUnits::MetersPerSec,
            49 => FitFieldExdDataUnits::EightCardinal,
            _ => FitFieldExdDataUnits::UnknownToSdk,
        }
    }
}
#[derive(Debug)]
pub struct FitMessageAccelerometerData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub sample_time_offset: Option<Vec<Option<u16>>>,  // Each time in the array describes the time at which the accelerometer sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in accel_x and accel_y and accel_z
    pub accel_x: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub accel_y: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub accel_z: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub calibrated_accel_x: Option<Vec<Option<f32>>>,  // Calibrated accel reading
    pub calibrated_accel_y: Option<Vec<Option<f32>>>,  // Calibrated accel reading
    pub calibrated_accel_z: Option<Vec<Option<f32>>>,  // Calibrated accel reading
    pub compressed_calibrated_accel_x: Option<Vec<Option<i16>>>,  // Calibrated accel reading
    pub compressed_calibrated_accel_y: Option<Vec<Option<i16>>>,  // Calibrated accel reading
    pub compressed_calibrated_accel_z: Option<Vec<Option<i16>>>,  // Calibrated accel reading
    
}

impl fmt::Display for FitMessageAccelerometerData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAccelerometerData")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.sample_time_offset { writeln!(f, "  {: >28}: {:?}", "sample_time_offset", v)?; }
        if let Some(v) = &self.accel_x { writeln!(f, "  {: >28}: {:?}", "accel_x", v)?; }
        if let Some(v) = &self.accel_y { writeln!(f, "  {: >28}: {:?}", "accel_y", v)?; }
        if let Some(v) = &self.accel_z { writeln!(f, "  {: >28}: {:?}", "accel_z", v)?; }
        if let Some(v) = &self.calibrated_accel_x { writeln!(f, "  {: >28}: {:?}", "calibrated_accel_x", v)?; }
        if let Some(v) = &self.calibrated_accel_y { writeln!(f, "  {: >28}: {:?}", "calibrated_accel_y", v)?; }
        if let Some(v) = &self.calibrated_accel_z { writeln!(f, "  {: >28}: {:?}", "calibrated_accel_z", v)?; }
        if let Some(v) = &self.compressed_calibrated_accel_x { writeln!(f, "  {: >28}: {:?}", "compressed_calibrated_accel_x", v)?; }
        if let Some(v) = &self.compressed_calibrated_accel_y { writeln!(f, "  {: >28}: {:?}", "compressed_calibrated_accel_y", v)?; }
        if let Some(v) = &self.compressed_calibrated_accel_z { writeln!(f, "  {: >28}: {:?}", "compressed_calibrated_accel_z", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAccelerometerData {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageAccelerometerData>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageAccelerometerData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageAccelerometerData",
            timestamp: None,
            timestamp_ms: None,
            sample_time_offset: None,
            accel_x: None,
            accel_y: None,
            accel_z: None,
            calibrated_accel_x: None,
            calibrated_accel_y: None,
            calibrated_accel_z: None,
            compressed_calibrated_accel_x: None,
            compressed_calibrated_accel_y: None,
            compressed_calibrated_accel_z: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageAccelerometerData::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageAccelerometerData:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageAccelerometerData, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sample_time_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // accel_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // accel_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // accel_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // calibrated_accel_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_accel_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_accel_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // calibrated_accel_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_accel_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_accel_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // calibrated_accel_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_accel_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_accel_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // compressed_calibrated_accel_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.compressed_calibrated_accel_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.compressed_calibrated_accel_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // compressed_calibrated_accel_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.compressed_calibrated_accel_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.compressed_calibrated_accel_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // compressed_calibrated_accel_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.compressed_calibrated_accel_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.compressed_calibrated_accel_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageAccelerometerData {
    fn message_name(&self) -> &'static str {
        return "FitMessageAccelerometerData";
    }
}

#[derive(Debug)]
pub struct FitMessageActivity {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub total_timer_time: Option<f64>,  // Exclude pauses
    pub num_sessions: Option<u16>,  
    pub ftype: Option<FitFieldActivity>,  
    pub event: Option<FitFieldEvent>,  
    pub event_type: Option<FitFieldEventType>,  
    pub local_timestamp: Option<FitFieldLocalDateTime>,  // timestamp epoch expressed in local time, used to convert activity timestamps to local time 
    pub event_group: Option<u8>,  
    
}

impl fmt::Display for FitMessageActivity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageActivity")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.total_timer_time { writeln!(f, "  {: >28}: {:?}", "total_timer_time", v)?; }
        if let Some(v) = &self.num_sessions { writeln!(f, "  {: >28}: {:?}", "num_sessions", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.event { writeln!(f, "  {: >28}: {:?}", "event", v)?; }
        if let Some(v) = &self.event_type { writeln!(f, "  {: >28}: {:?}", "event_type", v)?; }
        if let Some(v) = &self.local_timestamp { writeln!(f, "  {: >28}: {:?}", "local_timestamp", v)?; }
        if let Some(v) = &self.event_group { writeln!(f, "  {: >28}: {:?}", "event_group", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageActivity {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageActivity>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageActivity {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageActivity",
            timestamp: None,
            total_timer_time: None,
            num_sessions: None,
            ftype: None,
            event: None,
            event_type: None,
            local_timestamp: None,
            event_group: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageActivity::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageActivity:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageActivity, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // total_timer_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // num_sessions
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_sessions = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_sessions = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldActivity::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldActivity::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEvent::parse(&inp[0..f.field_size])?;
                                
                                message.event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEventType::parse(&inp[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // local_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocalDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocalDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // event_group
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.event_group = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.event_group = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageActivity {
    fn message_name(&self) -> &'static str {
        return "FitMessageActivity";
    }
}

#[derive(Debug)]
pub struct FitMessageAntChannelId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub channel_number: Option<u8>,  
    pub device_type: Option<u8>,  
    pub device_number: Option<u16>,  
    pub transmission_type: Option<u8>,  
    pub device_index: Option<FitFieldDeviceIndex>,  
    
}

impl fmt::Display for FitMessageAntChannelId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAntChannelId")?;
        if let Some(v) = &self.channel_number { writeln!(f, "  {: >28}: {:?}", "channel_number", v)?; }
        if let Some(v) = &self.device_type { writeln!(f, "  {: >28}: {:?}", "device_type", v)?; }
        if let Some(v) = &self.device_number { writeln!(f, "  {: >28}: {:?}", "device_number", v)?; }
        if let Some(v) = &self.transmission_type { writeln!(f, "  {: >28}: {:?}", "transmission_type", v)?; }
        if let Some(v) = &self.device_index { writeln!(f, "  {: >28}: {:?}", "device_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAntChannelId {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageAntChannelId>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageAntChannelId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageAntChannelId",
            channel_number: None,
            device_type: None,
            device_number: None,
            transmission_type: None,
            device_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageAntChannelId::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageAntChannelId:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageAntChannelId, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // channel_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.channel_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.channel_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // device_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.device_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.device_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // device_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.device_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.device_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // transmission_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.transmission_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.transmission_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // device_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDeviceIndex::parse(&&bytes[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDeviceIndex::parse(&inp[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageAntChannelId {
    fn message_name(&self) -> &'static str {
        return "FitMessageAntChannelId";
    }
}

#[derive(Debug)]
pub struct FitMessageAntRx {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub fractional_timestamp: Option<f64>,  
    pub mesg_id: Option<Vec<u8>>,  
    pub mesg_data: Option<Vec<u8>>,  
    pub channel_number: Option<u8>,  
    pub data: Option<Vec<u8>>,  
    
}

impl fmt::Display for FitMessageAntRx {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAntRx")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.fractional_timestamp { writeln!(f, "  {: >28}: {:?}", "fractional_timestamp", v)?; }
        if let Some(v) = &self.mesg_id { writeln!(f, "  {: >28}: {:?}", "mesg_id", v)?; }
        if let Some(v) = &self.mesg_data { writeln!(f, "  {: >28}: {:?}", "mesg_data", v)?; }
        if let Some(v) = &self.channel_number { writeln!(f, "  {: >28}: {:?}", "channel_number", v)?; }
        if let Some(v) = &self.data { writeln!(f, "  {: >28}: {:?}", "data", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAntRx {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageAntRx>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageAntRx {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageAntRx",
            timestamp: None,
            fractional_timestamp: None,
            mesg_id: None,
            mesg_data: None,
            channel_number: None,
            data: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageAntRx::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageAntRx:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageAntRx, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // fractional_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // mesg_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.mesg_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.mesg_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // mesg_data
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.mesg_data = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.mesg_data = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 3, field_size: 1, base_type: 0}, Some((0, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((8, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((16, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((24, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((32, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((40, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((48, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((56, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((64, 8)) ));
                        Ok(())
                    },
                
                    3 => {  // channel_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.channel_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.channel_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // data
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.data = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.data = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageAntRx {
    fn message_name(&self) -> &'static str {
        return "FitMessageAntRx";
    }
}

#[derive(Debug)]
pub struct FitMessageAntTx {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub fractional_timestamp: Option<f64>,  
    pub mesg_id: Option<Vec<u8>>,  
    pub mesg_data: Option<Vec<u8>>,  
    pub channel_number: Option<u8>,  
    pub data: Option<Vec<u8>>,  
    
}

impl fmt::Display for FitMessageAntTx {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAntTx")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.fractional_timestamp { writeln!(f, "  {: >28}: {:?}", "fractional_timestamp", v)?; }
        if let Some(v) = &self.mesg_id { writeln!(f, "  {: >28}: {:?}", "mesg_id", v)?; }
        if let Some(v) = &self.mesg_data { writeln!(f, "  {: >28}: {:?}", "mesg_data", v)?; }
        if let Some(v) = &self.channel_number { writeln!(f, "  {: >28}: {:?}", "channel_number", v)?; }
        if let Some(v) = &self.data { writeln!(f, "  {: >28}: {:?}", "data", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAntTx {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageAntTx>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageAntTx {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageAntTx",
            timestamp: None,
            fractional_timestamp: None,
            mesg_id: None,
            mesg_data: None,
            channel_number: None,
            data: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageAntTx::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageAntTx:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageAntTx, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // fractional_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // mesg_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.mesg_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.mesg_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // mesg_data
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.mesg_data = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.mesg_data = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 3, field_size: 1, base_type: 0}, Some((0, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((8, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((16, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((24, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((32, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((40, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((48, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((56, 8)) ));
                        actions.push( (FitFieldDefinition{definition_number: 4, field_size: 1, base_type: 0}, Some((64, 8)) ));
                        Ok(())
                    },
                
                    3 => {  // channel_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.channel_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.channel_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // data
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.data = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.data = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageAntTx {
    fn message_name(&self) -> &'static str {
        return "FitMessageAntTx";
    }
}

#[derive(Debug)]
pub struct FitMessageAviationAttitude {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Timestamp message was output
    pub timestamp_ms: Option<u16>,  // Fractional part of timestamp, added to timestamp
    pub system_time: Option<Vec<Option<u32>>>,  // System time associated with sample expressed in ms.
    pub pitch: Option<Vec<Option<f64>>>,  // Range -PI/2 to +PI/2
    pub roll: Option<Vec<Option<f64>>>,  // Range -PI to +PI
    pub accel_lateral: Option<Vec<Option<f64>>>,  // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
    pub accel_normal: Option<Vec<Option<f64>>>,  // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
    pub turn_rate: Option<Vec<Option<f64>>>,  // Range -8.727 to +8.727 (-500 degs/sec to +500 degs/sec)
    pub stage: Option<Vec<FitFieldAttitudeStage>>,  
    pub attitude_stage_complete: Option<Vec<Option<u8>>>,  // The percent complete of the current attitude stage.  Set to 0 for attitude stages 0, 1 and 2 and to 100 for attitude stage 3 by AHRS modules that do not support it.  Range - 100
    pub track: Option<Vec<Option<f64>>>,  // Track Angle/Heading Range 0 - 2pi
    pub validity: Option<Vec<FitFieldAttitudeValidity>>,  
    
}

impl fmt::Display for FitMessageAviationAttitude {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageAviationAttitude")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.system_time { writeln!(f, "  {: >28}: {:?}", "system_time", v)?; }
        if let Some(v) = &self.pitch { writeln!(f, "  {: >28}: {:?}", "pitch", v)?; }
        if let Some(v) = &self.roll { writeln!(f, "  {: >28}: {:?}", "roll", v)?; }
        if let Some(v) = &self.accel_lateral { writeln!(f, "  {: >28}: {:?}", "accel_lateral", v)?; }
        if let Some(v) = &self.accel_normal { writeln!(f, "  {: >28}: {:?}", "accel_normal", v)?; }
        if let Some(v) = &self.turn_rate { writeln!(f, "  {: >28}: {:?}", "turn_rate", v)?; }
        if let Some(v) = &self.stage { writeln!(f, "  {: >28}: {:?}", "stage", v)?; }
        if let Some(v) = &self.attitude_stage_complete { writeln!(f, "  {: >28}: {:?}", "attitude_stage_complete", v)?; }
        if let Some(v) = &self.track { writeln!(f, "  {: >28}: {:?}", "track", v)?; }
        if let Some(v) = &self.validity { writeln!(f, "  {: >28}: {:?}", "validity", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageAviationAttitude {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageAviationAttitude>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageAviationAttitude {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageAviationAttitude",
            timestamp: None,
            timestamp_ms: None,
            system_time: None,
            pitch: None,
            roll: None,
            accel_lateral: None,
            accel_normal: None,
            turn_rate: None,
            stage: None,
            attitude_stage_complete: None,
            track: None,
            validity: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageAviationAttitude::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageAviationAttitude:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageAviationAttitude, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // system_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.system_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.system_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // pitch
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.pitch = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10430.38 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.pitch = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10430.38 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // roll
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.roll = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10430.38 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.roll = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10430.38 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // accel_lateral
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_lateral = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_lateral = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // accel_normal
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_normal = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.accel_normal = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // turn_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.turn_rate = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1024 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.turn_rate = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1024 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // stage
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldAttitudeStage::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stage = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldAttitudeStage::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stage = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // attitude_stage_complete
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.attitude_stage_complete = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.attitude_stage_complete = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // track
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.track = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10430.38 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.track = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10430.38 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // validity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldAttitudeValidity::parse(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.validity = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldAttitudeValidity::parse(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.validity = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageAviationAttitude {
    fn message_name(&self) -> &'static str {
        return "FitMessageAviationAttitude";
    }
}

#[derive(Debug)]
pub struct FitMessageBarometerData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub sample_time_offset: Option<Vec<Option<u16>>>,  // Each time in the array describes the time at which the barometer sample with the corrosponding index was taken. The samples may span across seconds. Array size must match the number of samples in baro_cal
    pub baro_pres: Option<Vec<Option<u32>>>,  // These are the raw ADC reading. The samples may span across seconds. A conversion will need to be done on this data once read.
    
}

impl fmt::Display for FitMessageBarometerData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageBarometerData")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.sample_time_offset { writeln!(f, "  {: >28}: {:?}", "sample_time_offset", v)?; }
        if let Some(v) = &self.baro_pres { writeln!(f, "  {: >28}: {:?}", "baro_pres", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageBarometerData {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageBarometerData>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageBarometerData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageBarometerData",
            timestamp: None,
            timestamp_ms: None,
            sample_time_offset: None,
            baro_pres: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageBarometerData::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageBarometerData:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageBarometerData, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sample_time_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // baro_pres
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.baro_pres = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.baro_pres = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageBarometerData {
    fn message_name(&self) -> &'static str {
        return "FitMessageBarometerData";
    }
}

#[derive(Debug)]
pub struct FitMessageBikeProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub name: Option<String>,  
    pub sport: Option<FitFieldSport>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub odometer: Option<f64>,  
    pub bike_spd_ant_id: Option<u16>,  
    pub bike_cad_ant_id: Option<u16>,  
    pub bike_spdcad_ant_id: Option<u16>,  
    pub bike_power_ant_id: Option<u16>,  
    pub custom_wheelsize: Option<f64>,  
    pub auto_wheelsize: Option<f64>,  
    pub bike_weight: Option<f64>,  
    pub power_cal_factor: Option<f64>,  
    pub auto_wheel_cal: Option<bool>,  
    pub auto_power_zero: Option<bool>,  
    pub id: Option<u8>,  
    pub spd_enabled: Option<bool>,  
    pub cad_enabled: Option<bool>,  
    pub spdcad_enabled: Option<bool>,  
    pub power_enabled: Option<bool>,  
    pub crank_length: Option<f64>,  
    pub enabled: Option<bool>,  
    pub bike_spd_ant_id_trans_type: Option<u8>,  
    pub bike_cad_ant_id_trans_type: Option<u8>,  
    pub bike_spdcad_ant_id_trans_type: Option<u8>,  
    pub bike_power_ant_id_trans_type: Option<u8>,  
    pub odometer_rollover: Option<u8>,  // Rollover counter that can be used to extend the odometer
    pub front_gear_num: Option<u8>,  // Number of front gears
    pub front_gear: Option<Vec<Option<u8>>>,  // Number of teeth on each gear 0 is innermost
    pub rear_gear_num: Option<u8>,  // Number of rear gears
    pub rear_gear: Option<Vec<Option<u8>>>,  // Number of teeth on each gear 0 is innermost
    pub shimano_di2_enabled: Option<bool>,  
    
}

impl fmt::Display for FitMessageBikeProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageBikeProfile")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.odometer { writeln!(f, "  {: >28}: {:?}", "odometer", v)?; }
        if let Some(v) = &self.bike_spd_ant_id { writeln!(f, "  {: >28}: {:?}", "bike_spd_ant_id", v)?; }
        if let Some(v) = &self.bike_cad_ant_id { writeln!(f, "  {: >28}: {:?}", "bike_cad_ant_id", v)?; }
        if let Some(v) = &self.bike_spdcad_ant_id { writeln!(f, "  {: >28}: {:?}", "bike_spdcad_ant_id", v)?; }
        if let Some(v) = &self.bike_power_ant_id { writeln!(f, "  {: >28}: {:?}", "bike_power_ant_id", v)?; }
        if let Some(v) = &self.custom_wheelsize { writeln!(f, "  {: >28}: {:?}", "custom_wheelsize", v)?; }
        if let Some(v) = &self.auto_wheelsize { writeln!(f, "  {: >28}: {:?}", "auto_wheelsize", v)?; }
        if let Some(v) = &self.bike_weight { writeln!(f, "  {: >28}: {:?}", "bike_weight", v)?; }
        if let Some(v) = &self.power_cal_factor { writeln!(f, "  {: >28}: {:?}", "power_cal_factor", v)?; }
        if let Some(v) = &self.auto_wheel_cal { writeln!(f, "  {: >28}: {:?}", "auto_wheel_cal", v)?; }
        if let Some(v) = &self.auto_power_zero { writeln!(f, "  {: >28}: {:?}", "auto_power_zero", v)?; }
        if let Some(v) = &self.id { writeln!(f, "  {: >28}: {:?}", "id", v)?; }
        if let Some(v) = &self.spd_enabled { writeln!(f, "  {: >28}: {:?}", "spd_enabled", v)?; }
        if let Some(v) = &self.cad_enabled { writeln!(f, "  {: >28}: {:?}", "cad_enabled", v)?; }
        if let Some(v) = &self.spdcad_enabled { writeln!(f, "  {: >28}: {:?}", "spdcad_enabled", v)?; }
        if let Some(v) = &self.power_enabled { writeln!(f, "  {: >28}: {:?}", "power_enabled", v)?; }
        if let Some(v) = &self.crank_length { writeln!(f, "  {: >28}: {:?}", "crank_length", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.bike_spd_ant_id_trans_type { writeln!(f, "  {: >28}: {:?}", "bike_spd_ant_id_trans_type", v)?; }
        if let Some(v) = &self.bike_cad_ant_id_trans_type { writeln!(f, "  {: >28}: {:?}", "bike_cad_ant_id_trans_type", v)?; }
        if let Some(v) = &self.bike_spdcad_ant_id_trans_type { writeln!(f, "  {: >28}: {:?}", "bike_spdcad_ant_id_trans_type", v)?; }
        if let Some(v) = &self.bike_power_ant_id_trans_type { writeln!(f, "  {: >28}: {:?}", "bike_power_ant_id_trans_type", v)?; }
        if let Some(v) = &self.odometer_rollover { writeln!(f, "  {: >28}: {:?}", "odometer_rollover", v)?; }
        if let Some(v) = &self.front_gear_num { writeln!(f, "  {: >28}: {:?}", "front_gear_num", v)?; }
        if let Some(v) = &self.front_gear { writeln!(f, "  {: >28}: {:?}", "front_gear", v)?; }
        if let Some(v) = &self.rear_gear_num { writeln!(f, "  {: >28}: {:?}", "rear_gear_num", v)?; }
        if let Some(v) = &self.rear_gear { writeln!(f, "  {: >28}: {:?}", "rear_gear", v)?; }
        if let Some(v) = &self.shimano_di2_enabled { writeln!(f, "  {: >28}: {:?}", "shimano_di2_enabled", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageBikeProfile {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageBikeProfile>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageBikeProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageBikeProfile",
            message_index: None,
            name: None,
            sport: None,
            sub_sport: None,
            odometer: None,
            bike_spd_ant_id: None,
            bike_cad_ant_id: None,
            bike_spdcad_ant_id: None,
            bike_power_ant_id: None,
            custom_wheelsize: None,
            auto_wheelsize: None,
            bike_weight: None,
            power_cal_factor: None,
            auto_wheel_cal: None,
            auto_power_zero: None,
            id: None,
            spd_enabled: None,
            cad_enabled: None,
            spdcad_enabled: None,
            power_enabled: None,
            crank_length: None,
            enabled: None,
            bike_spd_ant_id_trans_type: None,
            bike_cad_ant_id_trans_type: None,
            bike_spdcad_ant_id_trans_type: None,
            bike_power_ant_id_trans_type: None,
            odometer_rollover: None,
            front_gear_num: None,
            front_gear: None,
            rear_gear_num: None,
            rear_gear: None,
            shimano_di2_enabled: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageBikeProfile::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageBikeProfile:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageBikeProfile, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // odometer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.odometer = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.odometer = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.odometer = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.odometer = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // bike_spd_ant_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_spd_ant_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_spd_ant_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // bike_cad_ant_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_cad_ant_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_cad_ant_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // bike_spdcad_ant_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_spdcad_ant_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_spdcad_ant_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // bike_power_ant_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_power_ant_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bike_power_ant_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // custom_wheelsize
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.custom_wheelsize = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.custom_wheelsize = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.custom_wheelsize = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.custom_wheelsize = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // auto_wheelsize
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.auto_wheelsize = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.auto_wheelsize = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.auto_wheelsize = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.auto_wheelsize = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // bike_weight
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.bike_weight = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.bike_weight = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.bike_weight = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.bike_weight = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // power_cal_factor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.power_cal_factor = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.power_cal_factor = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.power_cal_factor = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.power_cal_factor = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // auto_wheel_cal
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.auto_wheel_cal = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.auto_wheel_cal = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // auto_power_zero
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.auto_power_zero = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.auto_power_zero = val;
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.id = val;
                            }
                        }

                        Ok(())
                    },
                
                    15 => {  // spd_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.spd_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.spd_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    16 => {  // cad_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.cad_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.cad_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // spdcad_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.spdcad_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.spdcad_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // power_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.power_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.power_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // crank_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.crank_length = Some(result as f64 / 2 as f64 - (-110 as f64)) 
                                    },
                                    None => message.crank_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.crank_length = Some(result as f64 / 2 as f64 - (-110 as f64)) 
                                    },
                                    None => message.crank_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // bike_spd_ant_id_trans_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.bike_spd_ant_id_trans_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.bike_spd_ant_id_trans_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    22 => {  // bike_cad_ant_id_trans_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.bike_cad_ant_id_trans_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.bike_cad_ant_id_trans_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    23 => {  // bike_spdcad_ant_id_trans_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.bike_spdcad_ant_id_trans_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.bike_spdcad_ant_id_trans_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    24 => {  // bike_power_ant_id_trans_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.bike_power_ant_id_trans_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.bike_power_ant_id_trans_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    37 => {  // odometer_rollover
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.odometer_rollover = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.odometer_rollover = val;
                            }
                        }

                        Ok(())
                    },
                
                    38 => {  // front_gear_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.front_gear_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.front_gear_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    39 => {  // front_gear
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8z(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.front_gear = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8z(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.front_gear = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    40 => {  // rear_gear_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.rear_gear_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.rear_gear_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    41 => {  // rear_gear
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8z(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.rear_gear = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8z(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.rear_gear = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    44 => {  // shimano_di2_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.shimano_di2_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.shimano_di2_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageBikeProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageBikeProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageBloodPressure {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub systolic_pressure: Option<u16>,  
    pub diastolic_pressure: Option<u16>,  
    pub mean_arterial_pressure: Option<u16>,  
    pub map_3_sample_mean: Option<u16>,  
    pub map_morning_values: Option<u16>,  
    pub map_evening_values: Option<u16>,  
    pub heart_rate: Option<u8>,  
    pub heart_rate_type: Option<FitFieldHrType>,  
    pub status: Option<FitFieldBpStatus>,  
    pub user_profile_index: Option<FitFieldMessageIndex>,  // Associates this blood pressure message to a user.  This corresponds to the index of the user profile message in the blood pressure file.
    
}

impl fmt::Display for FitMessageBloodPressure {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageBloodPressure")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.systolic_pressure { writeln!(f, "  {: >28}: {:?}", "systolic_pressure", v)?; }
        if let Some(v) = &self.diastolic_pressure { writeln!(f, "  {: >28}: {:?}", "diastolic_pressure", v)?; }
        if let Some(v) = &self.mean_arterial_pressure { writeln!(f, "  {: >28}: {:?}", "mean_arterial_pressure", v)?; }
        if let Some(v) = &self.map_3_sample_mean { writeln!(f, "  {: >28}: {:?}", "map_3_sample_mean", v)?; }
        if let Some(v) = &self.map_morning_values { writeln!(f, "  {: >28}: {:?}", "map_morning_values", v)?; }
        if let Some(v) = &self.map_evening_values { writeln!(f, "  {: >28}: {:?}", "map_evening_values", v)?; }
        if let Some(v) = &self.heart_rate { writeln!(f, "  {: >28}: {:?}", "heart_rate", v)?; }
        if let Some(v) = &self.heart_rate_type { writeln!(f, "  {: >28}: {:?}", "heart_rate_type", v)?; }
        if let Some(v) = &self.status { writeln!(f, "  {: >28}: {:?}", "status", v)?; }
        if let Some(v) = &self.user_profile_index { writeln!(f, "  {: >28}: {:?}", "user_profile_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageBloodPressure {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageBloodPressure>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageBloodPressure {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageBloodPressure",
            timestamp: None,
            systolic_pressure: None,
            diastolic_pressure: None,
            mean_arterial_pressure: None,
            map_3_sample_mean: None,
            map_morning_values: None,
            map_evening_values: None,
            heart_rate: None,
            heart_rate_type: None,
            status: None,
            user_profile_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageBloodPressure::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageBloodPressure:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageBloodPressure, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // systolic_pressure
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.systolic_pressure = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.systolic_pressure = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // diastolic_pressure
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.diastolic_pressure = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.diastolic_pressure = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // mean_arterial_pressure
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.mean_arterial_pressure = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.mean_arterial_pressure = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // map_3_sample_mean
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.map_3_sample_mean = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.map_3_sample_mean = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // map_morning_values
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.map_morning_values = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.map_morning_values = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // map_evening_values
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.map_evening_values = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.map_evening_values = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // heart_rate_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldHrType::parse(&&bytes[0..f.field_size])?;
                                
                                message.heart_rate_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldHrType::parse(&inp[0..f.field_size])?;
                                
                                message.heart_rate_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // status
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldBpStatus::parse(&&bytes[0..f.field_size])?;
                                
                                message.status = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldBpStatus::parse(&inp[0..f.field_size])?;
                                
                                message.status = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // user_profile_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageBloodPressure {
    fn message_name(&self) -> &'static str {
        return "FitMessageBloodPressure";
    }
}

#[derive(Debug)]
pub struct FitMessageCadenceZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub high_value: Option<u8>,  
    pub name: Option<String>,  
    
}

impl fmt::Display for FitMessageCadenceZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCadenceZone")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.high_value { writeln!(f, "  {: >28}: {:?}", "high_value", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCadenceZone {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageCadenceZone>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageCadenceZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageCadenceZone",
            message_index: None,
            high_value: None,
            name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageCadenceZone::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageCadenceZone:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageCadenceZone, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // high_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.high_value = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.high_value = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageCadenceZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageCadenceZone";
    }
}

#[derive(Debug)]
pub struct FitMessageCameraEvent {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp.
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub camera_event_type: Option<FitFieldCameraEventType>,  
    pub camera_file_uuid: Option<String>,  
    pub camera_orientation: Option<FitFieldCameraOrientationType>,  
    
}

impl fmt::Display for FitMessageCameraEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCameraEvent")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.camera_event_type { writeln!(f, "  {: >28}: {:?}", "camera_event_type", v)?; }
        if let Some(v) = &self.camera_file_uuid { writeln!(f, "  {: >28}: {:?}", "camera_file_uuid", v)?; }
        if let Some(v) = &self.camera_orientation { writeln!(f, "  {: >28}: {:?}", "camera_orientation", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCameraEvent {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageCameraEvent>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageCameraEvent {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageCameraEvent",
            timestamp: None,
            timestamp_ms: None,
            camera_event_type: None,
            camera_file_uuid: None,
            camera_orientation: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageCameraEvent::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageCameraEvent:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageCameraEvent, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // camera_event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldCameraEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.camera_event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldCameraEventType::parse(&inp[0..f.field_size])?;
                                
                                message.camera_event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // camera_file_uuid
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.camera_file_uuid = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.camera_file_uuid = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // camera_orientation
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldCameraOrientationType::parse(&&bytes[0..f.field_size])?;
                                
                                message.camera_orientation = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldCameraOrientationType::parse(&inp[0..f.field_size])?;
                                
                                message.camera_orientation = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageCameraEvent {
    fn message_name(&self) -> &'static str {
        return "FitMessageCameraEvent";
    }
}

#[derive(Debug)]
pub struct FitMessageCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub languages: Option<Vec<Option<u8>>>,  // Use language_bits_x types where x is index of array.
    pub sports: Option<Vec<FitFieldSportBits0>>,  // Use sport_bits_x types where x is index of array.
    pub workouts_supported: Option<FitFieldWorkoutCapabilities>,  
    pub connectivity_supported: Option<FitFieldConnectivityCapabilities>,  
    
}

impl fmt::Display for FitMessageCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCapabilities")?;
        if let Some(v) = &self.languages { writeln!(f, "  {: >28}: {:?}", "languages", v)?; }
        if let Some(v) = &self.sports { writeln!(f, "  {: >28}: {:?}", "sports", v)?; }
        if let Some(v) = &self.workouts_supported { writeln!(f, "  {: >28}: {:?}", "workouts_supported", v)?; }
        if let Some(v) = &self.connectivity_supported { writeln!(f, "  {: >28}: {:?}", "connectivity_supported", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCapabilities {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageCapabilities>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageCapabilities",
            languages: None,
            sports: None,
            workouts_supported: None,
            connectivity_supported: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageCapabilities::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageCapabilities:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageCapabilities, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // languages
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8z(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.languages = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8z(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.languages = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sports
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldSportBits0::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sports = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldSportBits0::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sports = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // workouts_supported
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWorkoutCapabilities::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.workouts_supported = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWorkoutCapabilities::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.workouts_supported = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    23 => {  // connectivity_supported
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldConnectivityCapabilities::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.connectivity_supported = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldConnectivityCapabilities::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.connectivity_supported = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageConnectivity {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub bluetooth_enabled: Option<bool>,  // Use Bluetooth for connectivity features
    pub bluetooth_le_enabled: Option<bool>,  // Use Bluetooth Low Energy for connectivity features
    pub ant_enabled: Option<bool>,  // Use ANT for connectivity features
    pub name: Option<String>,  
    pub live_tracking_enabled: Option<bool>,  
    pub weather_conditions_enabled: Option<bool>,  
    pub weather_alerts_enabled: Option<bool>,  
    pub auto_activity_upload_enabled: Option<bool>,  
    pub course_download_enabled: Option<bool>,  
    pub workout_download_enabled: Option<bool>,  
    pub gps_ephemeris_download_enabled: Option<bool>,  
    pub incident_detection_enabled: Option<bool>,  
    pub grouptrack_enabled: Option<bool>,  
    
}

impl fmt::Display for FitMessageConnectivity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageConnectivity")?;
        if let Some(v) = &self.bluetooth_enabled { writeln!(f, "  {: >28}: {:?}", "bluetooth_enabled", v)?; }
        if let Some(v) = &self.bluetooth_le_enabled { writeln!(f, "  {: >28}: {:?}", "bluetooth_le_enabled", v)?; }
        if let Some(v) = &self.ant_enabled { writeln!(f, "  {: >28}: {:?}", "ant_enabled", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.live_tracking_enabled { writeln!(f, "  {: >28}: {:?}", "live_tracking_enabled", v)?; }
        if let Some(v) = &self.weather_conditions_enabled { writeln!(f, "  {: >28}: {:?}", "weather_conditions_enabled", v)?; }
        if let Some(v) = &self.weather_alerts_enabled { writeln!(f, "  {: >28}: {:?}", "weather_alerts_enabled", v)?; }
        if let Some(v) = &self.auto_activity_upload_enabled { writeln!(f, "  {: >28}: {:?}", "auto_activity_upload_enabled", v)?; }
        if let Some(v) = &self.course_download_enabled { writeln!(f, "  {: >28}: {:?}", "course_download_enabled", v)?; }
        if let Some(v) = &self.workout_download_enabled { writeln!(f, "  {: >28}: {:?}", "workout_download_enabled", v)?; }
        if let Some(v) = &self.gps_ephemeris_download_enabled { writeln!(f, "  {: >28}: {:?}", "gps_ephemeris_download_enabled", v)?; }
        if let Some(v) = &self.incident_detection_enabled { writeln!(f, "  {: >28}: {:?}", "incident_detection_enabled", v)?; }
        if let Some(v) = &self.grouptrack_enabled { writeln!(f, "  {: >28}: {:?}", "grouptrack_enabled", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageConnectivity {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageConnectivity>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageConnectivity {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageConnectivity",
            bluetooth_enabled: None,
            bluetooth_le_enabled: None,
            ant_enabled: None,
            name: None,
            live_tracking_enabled: None,
            weather_conditions_enabled: None,
            weather_alerts_enabled: None,
            auto_activity_upload_enabled: None,
            course_download_enabled: None,
            workout_download_enabled: None,
            gps_ephemeris_download_enabled: None,
            incident_detection_enabled: None,
            grouptrack_enabled: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageConnectivity::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageConnectivity:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageConnectivity, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // bluetooth_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.bluetooth_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.bluetooth_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // bluetooth_le_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.bluetooth_le_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.bluetooth_le_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // ant_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.ant_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.ant_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // live_tracking_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.live_tracking_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.live_tracking_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // weather_conditions_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.weather_conditions_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.weather_conditions_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // weather_alerts_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.weather_alerts_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.weather_alerts_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // auto_activity_upload_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.auto_activity_upload_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.auto_activity_upload_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // course_download_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.course_download_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.course_download_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // workout_download_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.workout_download_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.workout_download_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // gps_ephemeris_download_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.gps_ephemeris_download_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.gps_ephemeris_download_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // incident_detection_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.incident_detection_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.incident_detection_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // grouptrack_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.grouptrack_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.grouptrack_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageConnectivity {
    fn message_name(&self) -> &'static str {
        return "FitMessageConnectivity";
    }
}

#[derive(Debug)]
pub struct FitMessageCourse {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub sport: Option<FitFieldSport>,  
    pub name: Option<String>,  
    pub capabilities: Option<FitFieldCourseCapabilities>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    
}

impl fmt::Display for FitMessageCourse {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCourse")?;
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.capabilities { writeln!(f, "  {: >28}: {:?}", "capabilities", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCourse {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageCourse>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageCourse {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageCourse",
            sport: None,
            name: None,
            capabilities: None,
            sub_sport: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageCourse::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageCourse:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageCourse, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    4 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // capabilities
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldCourseCapabilities::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.capabilities = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldCourseCapabilities::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.capabilities = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageCourse {
    fn message_name(&self) -> &'static str {
        return "FitMessageCourse";
    }
}

#[derive(Debug)]
pub struct FitMessageCoursePoint {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub timestamp: Option<FitFieldDateTime>,  
    pub position_lat: Option<f64>,  
    pub position_long: Option<f64>,  
    pub distance: Option<f64>,  
    pub ftype: Option<FitFieldCoursePoint>,  
    pub name: Option<String>,  
    pub favorite: Option<bool>,  
    
}

impl fmt::Display for FitMessageCoursePoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageCoursePoint")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.position_lat { writeln!(f, "  {: >28}: {:?}", "position_lat", v)?; }
        if let Some(v) = &self.position_long { writeln!(f, "  {: >28}: {:?}", "position_long", v)?; }
        if let Some(v) = &self.distance { writeln!(f, "  {: >28}: {:?}", "distance", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.favorite { writeln!(f, "  {: >28}: {:?}", "favorite", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageCoursePoint {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageCoursePoint>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageCoursePoint {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageCoursePoint",
            message_index: None,
            timestamp: None,
            position_lat: None,
            position_long: None,
            distance: None,
            ftype: None,
            name: None,
            favorite: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageCoursePoint::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageCoursePoint:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageCoursePoint, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldCoursePoint::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldCoursePoint::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // favorite
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.favorite = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.favorite = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageCoursePoint {
    fn message_name(&self) -> &'static str {
        return "FitMessageCoursePoint";
    }
}

#[derive(Debug)]
pub struct FitMessageDeveloperDataId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub developer_id: Option<Vec<u8>>,  
    pub application_id: Option<Vec<u8>>,  
    pub manufacturer_id: Option<FitFieldManufacturer>,  
    pub developer_data_index: Option<u8>,  
    pub application_version: Option<u32>,  
    
}

impl fmt::Display for FitMessageDeveloperDataId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDeveloperDataId")?;
        if let Some(v) = &self.developer_id { writeln!(f, "  {: >28}: {:?}", "developer_id", v)?; }
        if let Some(v) = &self.application_id { writeln!(f, "  {: >28}: {:?}", "application_id", v)?; }
        if let Some(v) = &self.manufacturer_id { writeln!(f, "  {: >28}: {:?}", "manufacturer_id", v)?; }
        if let Some(v) = &self.developer_data_index { writeln!(f, "  {: >28}: {:?}", "developer_data_index", v)?; }
        if let Some(v) = &self.application_version { writeln!(f, "  {: >28}: {:?}", "application_version", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDeveloperDataId {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDeveloperDataId>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDeveloperDataId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDeveloperDataId",
            developer_id: None,
            application_id: None,
            manufacturer_id: None,
            developer_data_index: None,
            application_version: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDeveloperDataId::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDeveloperDataId:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageDeveloperDataId, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // developer_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.developer_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.developer_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // application_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.application_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.application_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // manufacturer_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer_id = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer_id = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // developer_data_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.developer_data_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.developer_data_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // application_version
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.application_version = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.application_version = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDeveloperDataId {
    fn message_name(&self) -> &'static str {
        return "FitMessageDeveloperDataId";
    }
}

#[derive(Debug)]
pub enum FitMessageDeviceInfoSubfieldDeviceType {
    Default(Option<u8>),
    AntplusDeviceType(Option<FitFieldAntplusDeviceType>),
    AntDeviceType(Option<u8>),
}

impl FitMessageDeviceInfoSubfieldDeviceType {
    fn parse<'a>(message: &FitMessageDeviceInfo, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageDeviceInfoSubfieldDeviceType> {
        
        match message.source_type {
        
            Some(FitFieldSourceType::Antplus) => {
                let val = FitFieldAntplusDeviceType::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageDeviceInfoSubfieldDeviceType::AntplusDeviceType(Some(val)))
                },
        
            Some(FitFieldSourceType::Ant) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageDeviceInfoSubfieldDeviceType::AntDeviceType(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint8(&inp[0..f.field_size])?;
        Ok(FitMessageDeviceInfoSubfieldDeviceType::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageDeviceInfoSubfieldProduct {
    Default(Option<u16>),
    FaveroProduct(Option<FitFieldFaveroProduct>),
    GarminProduct(Option<FitFieldGarminProduct>),
}

impl FitMessageDeviceInfoSubfieldProduct {
    fn parse<'a>(message: &FitMessageDeviceInfo, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageDeviceInfoSubfieldProduct> {
        
        match message.manufacturer {
        
            Some(FitFieldManufacturer::FaveroElectronics) => {
                let val = FitFieldFaveroProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageDeviceInfoSubfieldProduct::FaveroProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Garmin) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageDeviceInfoSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Dynastream) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageDeviceInfoSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::DynastreamOem) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageDeviceInfoSubfieldProduct::GarminProduct(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageDeviceInfoSubfieldProduct::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageDeviceInfo {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub device_index: Option<FitFieldDeviceIndex>,  
    pub device_type_subfield_bytes: Vec<u8>,
    pub device_type: Option<FitMessageDeviceInfoSubfieldDeviceType>,  
    pub manufacturer: Option<FitFieldManufacturer>,  
    pub serial_number: Option<u32>,  
    pub product_subfield_bytes: Vec<u8>,
    pub product: Option<FitMessageDeviceInfoSubfieldProduct>,  
    pub software_version: Option<f64>,  
    pub hardware_version: Option<u8>,  
    pub cum_operating_time: Option<u32>,  // Reset by new battery or charge.
    pub battery_voltage: Option<f64>,  
    pub battery_status: Option<FitFieldBatteryStatus>,  
    pub sensor_position: Option<FitFieldBodyLocation>,  // Indicates the location of the sensor
    pub descriptor: Option<String>,  // Used to describe the sensor or location
    pub ant_transmission_type: Option<u8>,  
    pub ant_device_number: Option<u16>,  
    pub ant_network: Option<FitFieldAntNetwork>,  
    pub source_type: Option<FitFieldSourceType>,  
    pub product_name: Option<String>,  // Optional free form string to indicate the devices name or model
    
}

impl fmt::Display for FitMessageDeviceInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDeviceInfo")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.device_index { writeln!(f, "  {: >28}: {:?}", "device_index", v)?; }
        writeln!(f, "  {: >28}: {:?}", "device_type_subfield_bytes", self.device_type_subfield_bytes)?;
        if let Some(v) = &self.device_type { writeln!(f, "  {: >28}: {:?}", "device_type", v)?; }
        if let Some(v) = &self.manufacturer { writeln!(f, "  {: >28}: {:?}", "manufacturer", v)?; }
        if let Some(v) = &self.serial_number { writeln!(f, "  {: >28}: {:?}", "serial_number", v)?; }
        writeln!(f, "  {: >28}: {:?}", "product_subfield_bytes", self.product_subfield_bytes)?;
        if let Some(v) = &self.product { writeln!(f, "  {: >28}: {:?}", "product", v)?; }
        if let Some(v) = &self.software_version { writeln!(f, "  {: >28}: {:?}", "software_version", v)?; }
        if let Some(v) = &self.hardware_version { writeln!(f, "  {: >28}: {:?}", "hardware_version", v)?; }
        if let Some(v) = &self.cum_operating_time { writeln!(f, "  {: >28}: {:?}", "cum_operating_time", v)?; }
        if let Some(v) = &self.battery_voltage { writeln!(f, "  {: >28}: {:?}", "battery_voltage", v)?; }
        if let Some(v) = &self.battery_status { writeln!(f, "  {: >28}: {:?}", "battery_status", v)?; }
        if let Some(v) = &self.sensor_position { writeln!(f, "  {: >28}: {:?}", "sensor_position", v)?; }
        if let Some(v) = &self.descriptor { writeln!(f, "  {: >28}: {:?}", "descriptor", v)?; }
        if let Some(v) = &self.ant_transmission_type { writeln!(f, "  {: >28}: {:?}", "ant_transmission_type", v)?; }
        if let Some(v) = &self.ant_device_number { writeln!(f, "  {: >28}: {:?}", "ant_device_number", v)?; }
        if let Some(v) = &self.ant_network { writeln!(f, "  {: >28}: {:?}", "ant_network", v)?; }
        if let Some(v) = &self.source_type { writeln!(f, "  {: >28}: {:?}", "source_type", v)?; }
        if let Some(v) = &self.product_name { writeln!(f, "  {: >28}: {:?}", "product_name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDeviceInfo {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDeviceInfo>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDeviceInfo {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDeviceInfo",
            timestamp: None,
            device_index: None,
            device_type_subfield_bytes: vec![],
            device_type: None,
            manufacturer: None,
            serial_number: None,
            product_subfield_bytes: vec![],
            product: None,
            software_version: None,
            hardware_version: None,
            cum_operating_time: None,
            battery_voltage: None,
            battery_status: None,
            sensor_position: None,
            descriptor: None,
            ant_transmission_type: None,
            ant_device_number: None,
            ant_network: None,
            source_type: None,
            product_name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDeviceInfo::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDeviceInfo:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageDeviceInfo::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageDeviceInfo:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageDeviceInfo, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 1).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageDeviceInfoSubfieldDeviceType::parse(message, &message.device_type_subfield_bytes, &field, _tz_offset)?;
            message.device_type = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 4).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageDeviceInfoSubfieldProduct::parse(message, &message.product_subfield_bytes, &field, _tz_offset)?;
            message.product = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageDeviceInfo, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // device_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDeviceIndex::parse(&&bytes[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDeviceIndex::parse(&inp[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // device_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.device_type_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.device_type_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // manufacturer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // serial_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // product
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // software_version
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.software_version = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.software_version = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.software_version = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.software_version = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // hardware_version
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.hardware_version = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.hardware_version = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // cum_operating_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.cum_operating_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.cum_operating_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // battery_voltage
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.battery_voltage = Some(result as f64 / 256 as f64) 
                                    },
                                    None => message.battery_voltage = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.battery_voltage = Some(result as f64 / 256 as f64) 
                                    },
                                    None => message.battery_voltage = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // battery_status
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldBatteryStatus::parse(&&bytes[0..f.field_size])?;
                                
                                message.battery_status = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldBatteryStatus::parse(&inp[0..f.field_size])?;
                                
                                message.battery_status = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // sensor_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldBodyLocation::parse(&&bytes[0..f.field_size])?;
                                
                                message.sensor_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldBodyLocation::parse(&inp[0..f.field_size])?;
                                
                                message.sensor_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // descriptor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.descriptor = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.descriptor = val;
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // ant_transmission_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.ant_transmission_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.ant_transmission_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // ant_device_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.ant_device_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.ant_device_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    22 => {  // ant_network
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldAntNetwork::parse(&&bytes[0..f.field_size])?;
                                
                                message.ant_network = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldAntNetwork::parse(&inp[0..f.field_size])?;
                                
                                message.ant_network = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    25 => {  // source_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSourceType::parse(&&bytes[0..f.field_size])?;
                                
                                message.source_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSourceType::parse(&inp[0..f.field_size])?;
                                
                                message.source_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    27 => {  // product_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.product_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.product_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDeviceInfo {
    fn message_name(&self) -> &'static str {
        return "FitMessageDeviceInfo";
    }
}

#[derive(Debug)]
pub struct FitMessageDeviceSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub active_time_zone: Option<u8>,  // Index into time zone arrays.
    pub utc_offset: Option<u32>,  // Offset from system time. Required to convert timestamp from system time to UTC.
    pub time_offset: Option<Vec<Option<u32>>>,  // Offset from system time.
    pub time_mode: Option<Vec<FitFieldTimeMode>>,  // Display mode for the time
    pub time_zone_offset: Option<Vec<Option<f64>>>,  // timezone offset in 1/4 hour increments
    pub backlight_mode: Option<FitFieldBacklightMode>,  // Mode for backlight
    pub activity_tracker_enabled: Option<bool>,  // Enabled state of the activity tracker functionality
    pub clock_time: Option<FitFieldDateTime>,  // UTC timestamp used to set the devices clock and date
    pub pages_enabled: Option<Vec<Option<u16>>>,  // Bitfield  to configure enabled screens for each supported loop
    pub move_alert_enabled: Option<bool>,  // Enabled state of the move alert
    pub date_mode: Option<FitFieldDateMode>,  // Display mode for the date
    pub display_orientation: Option<FitFieldDisplayOrientation>,  
    pub mounting_side: Option<FitFieldSide>,  
    pub default_page: Option<Vec<Option<u16>>>,  // Bitfield to indicate one page as default for each supported loop
    pub autosync_min_steps: Option<u16>,  // Minimum steps before an autosync can occur
    pub autosync_min_time: Option<u16>,  // Minimum minutes before an autosync can occur
    pub lactate_threshold_autodetect_enabled: Option<bool>,  // Enable auto-detect setting for the lactate threshold feature.
    pub ble_auto_upload_enabled: Option<bool>,  // Automatically upload using BLE
    pub auto_sync_frequency: Option<FitFieldAutoSyncFrequency>,  // Helps to conserve battery by changing modes
    pub auto_activity_detect: Option<FitFieldAutoActivityDetect>,  // Allows setting specific activities auto-activity detect enabled/disabled settings
    pub number_of_screens: Option<u8>,  // Number of screens configured to display
    pub smart_notification_display_orientation: Option<FitFieldDisplayOrientation>,  // Smart Notification display orientation
    pub tap_interface: Option<FitFieldSwitch>,  
    
}

impl fmt::Display for FitMessageDeviceSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDeviceSettings")?;
        if let Some(v) = &self.active_time_zone { writeln!(f, "  {: >28}: {:?}", "active_time_zone", v)?; }
        if let Some(v) = &self.utc_offset { writeln!(f, "  {: >28}: {:?}", "utc_offset", v)?; }
        if let Some(v) = &self.time_offset { writeln!(f, "  {: >28}: {:?}", "time_offset", v)?; }
        if let Some(v) = &self.time_mode { writeln!(f, "  {: >28}: {:?}", "time_mode", v)?; }
        if let Some(v) = &self.time_zone_offset { writeln!(f, "  {: >28}: {:?}", "time_zone_offset", v)?; }
        if let Some(v) = &self.backlight_mode { writeln!(f, "  {: >28}: {:?}", "backlight_mode", v)?; }
        if let Some(v) = &self.activity_tracker_enabled { writeln!(f, "  {: >28}: {:?}", "activity_tracker_enabled", v)?; }
        if let Some(v) = &self.clock_time { writeln!(f, "  {: >28}: {:?}", "clock_time", v)?; }
        if let Some(v) = &self.pages_enabled { writeln!(f, "  {: >28}: {:?}", "pages_enabled", v)?; }
        if let Some(v) = &self.move_alert_enabled { writeln!(f, "  {: >28}: {:?}", "move_alert_enabled", v)?; }
        if let Some(v) = &self.date_mode { writeln!(f, "  {: >28}: {:?}", "date_mode", v)?; }
        if let Some(v) = &self.display_orientation { writeln!(f, "  {: >28}: {:?}", "display_orientation", v)?; }
        if let Some(v) = &self.mounting_side { writeln!(f, "  {: >28}: {:?}", "mounting_side", v)?; }
        if let Some(v) = &self.default_page { writeln!(f, "  {: >28}: {:?}", "default_page", v)?; }
        if let Some(v) = &self.autosync_min_steps { writeln!(f, "  {: >28}: {:?}", "autosync_min_steps", v)?; }
        if let Some(v) = &self.autosync_min_time { writeln!(f, "  {: >28}: {:?}", "autosync_min_time", v)?; }
        if let Some(v) = &self.lactate_threshold_autodetect_enabled { writeln!(f, "  {: >28}: {:?}", "lactate_threshold_autodetect_enabled", v)?; }
        if let Some(v) = &self.ble_auto_upload_enabled { writeln!(f, "  {: >28}: {:?}", "ble_auto_upload_enabled", v)?; }
        if let Some(v) = &self.auto_sync_frequency { writeln!(f, "  {: >28}: {:?}", "auto_sync_frequency", v)?; }
        if let Some(v) = &self.auto_activity_detect { writeln!(f, "  {: >28}: {:?}", "auto_activity_detect", v)?; }
        if let Some(v) = &self.number_of_screens { writeln!(f, "  {: >28}: {:?}", "number_of_screens", v)?; }
        if let Some(v) = &self.smart_notification_display_orientation { writeln!(f, "  {: >28}: {:?}", "smart_notification_display_orientation", v)?; }
        if let Some(v) = &self.tap_interface { writeln!(f, "  {: >28}: {:?}", "tap_interface", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDeviceSettings {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDeviceSettings>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDeviceSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDeviceSettings",
            active_time_zone: None,
            utc_offset: None,
            time_offset: None,
            time_mode: None,
            time_zone_offset: None,
            backlight_mode: None,
            activity_tracker_enabled: None,
            clock_time: None,
            pages_enabled: None,
            move_alert_enabled: None,
            date_mode: None,
            display_orientation: None,
            mounting_side: None,
            default_page: None,
            autosync_min_steps: None,
            autosync_min_time: None,
            lactate_threshold_autodetect_enabled: None,
            ble_auto_upload_enabled: None,
            auto_sync_frequency: None,
            auto_activity_detect: None,
            number_of_screens: None,
            smart_notification_display_orientation: None,
            tap_interface: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDeviceSettings::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDeviceSettings:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageDeviceSettings, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // active_time_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.active_time_zone = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.active_time_zone = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // utc_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.utc_offset = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.utc_offset = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // time_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_offset = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_offset = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // time_mode
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldTimeMode::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_mode = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldTimeMode::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_mode = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // time_zone_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_zone_offset = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 4 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_zone_offset = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 4 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // backlight_mode
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldBacklightMode::parse(&&bytes[0..f.field_size])?;
                                
                                message.backlight_mode = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldBacklightMode::parse(&inp[0..f.field_size])?;
                                
                                message.backlight_mode = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    36 => {  // activity_tracker_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.activity_tracker_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.activity_tracker_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    39 => {  // clock_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clock_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clock_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    40 => {  // pages_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.pages_enabled = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.pages_enabled = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    46 => {  // move_alert_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.move_alert_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.move_alert_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    47 => {  // date_mode
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateMode::parse(&&bytes[0..f.field_size])?;
                                
                                message.date_mode = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateMode::parse(&inp[0..f.field_size])?;
                                
                                message.date_mode = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    55 => {  // display_orientation
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayOrientation::parse(&&bytes[0..f.field_size])?;
                                
                                message.display_orientation = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayOrientation::parse(&inp[0..f.field_size])?;
                                
                                message.display_orientation = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    56 => {  // mounting_side
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSide::parse(&&bytes[0..f.field_size])?;
                                
                                message.mounting_side = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSide::parse(&inp[0..f.field_size])?;
                                
                                message.mounting_side = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    57 => {  // default_page
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.default_page = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.default_page = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    58 => {  // autosync_min_steps
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.autosync_min_steps = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.autosync_min_steps = val;
                            }
                        }

                        Ok(())
                    },
                
                    59 => {  // autosync_min_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.autosync_min_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.autosync_min_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    80 => {  // lactate_threshold_autodetect_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.lactate_threshold_autodetect_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.lactate_threshold_autodetect_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    86 => {  // ble_auto_upload_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.ble_auto_upload_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.ble_auto_upload_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    89 => {  // auto_sync_frequency
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldAutoSyncFrequency::parse(&&bytes[0..f.field_size])?;
                                
                                message.auto_sync_frequency = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldAutoSyncFrequency::parse(&inp[0..f.field_size])?;
                                
                                message.auto_sync_frequency = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    90 => {  // auto_activity_detect
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldAutoActivityDetect::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.auto_activity_detect = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldAutoActivityDetect::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.auto_activity_detect = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    94 => {  // number_of_screens
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.number_of_screens = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.number_of_screens = val;
                            }
                        }

                        Ok(())
                    },
                
                    95 => {  // smart_notification_display_orientation
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayOrientation::parse(&&bytes[0..f.field_size])?;
                                
                                message.smart_notification_display_orientation = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayOrientation::parse(&inp[0..f.field_size])?;
                                
                                message.smart_notification_display_orientation = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    134 => {  // tap_interface
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSwitch::parse(&&bytes[0..f.field_size])?;
                                
                                message.tap_interface = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSwitch::parse(&inp[0..f.field_size])?;
                                
                                message.tap_interface = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDeviceSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageDeviceSettings";
    }
}

#[derive(Debug)]
pub struct FitMessageDiveAlarm {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  // Index of the alarm
    pub depth: Option<f64>,  
    pub time: Option<f64>,  
    pub enabled: Option<bool>,  
    pub alarm_type: Option<FitFieldDiveAlarmType>,  
    pub sound: Option<FitFieldTone>,  
    pub dive_types: Option<Vec<FitFieldSubSport>>,  
    
}

impl fmt::Display for FitMessageDiveAlarm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveAlarm")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.depth { writeln!(f, "  {: >28}: {:?}", "depth", v)?; }
        if let Some(v) = &self.time { writeln!(f, "  {: >28}: {:?}", "time", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.alarm_type { writeln!(f, "  {: >28}: {:?}", "alarm_type", v)?; }
        if let Some(v) = &self.sound { writeln!(f, "  {: >28}: {:?}", "sound", v)?; }
        if let Some(v) = &self.dive_types { writeln!(f, "  {: >28}: {:?}", "dive_types", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveAlarm {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDiveAlarm>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDiveAlarm {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDiveAlarm",
            message_index: None,
            depth: None,
            time: None,
            enabled: None,
            alarm_type: None,
            sound: None,
            dive_types: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDiveAlarm::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDiveAlarm:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageDiveAlarm, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // depth
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.depth = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.depth = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // alarm_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDiveAlarmType::parse(&&bytes[0..f.field_size])?;
                                
                                message.alarm_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDiveAlarmType::parse(&inp[0..f.field_size])?;
                                
                                message.alarm_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // sound
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldTone::parse(&&bytes[0..f.field_size])?;
                                
                                message.sound = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldTone::parse(&inp[0..f.field_size])?;
                                
                                message.sound = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // dive_types
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldSubSport::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.dive_types = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldSubSport::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.dive_types = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveAlarm {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveAlarm";
    }
}

#[derive(Debug)]
pub struct FitMessageDiveGas {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub helium_content: Option<u8>,  
    pub oxygen_content: Option<u8>,  
    pub status: Option<FitFieldDiveGasStatus>,  
    
}

impl fmt::Display for FitMessageDiveGas {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveGas")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.helium_content { writeln!(f, "  {: >28}: {:?}", "helium_content", v)?; }
        if let Some(v) = &self.oxygen_content { writeln!(f, "  {: >28}: {:?}", "oxygen_content", v)?; }
        if let Some(v) = &self.status { writeln!(f, "  {: >28}: {:?}", "status", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveGas {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDiveGas>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDiveGas {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDiveGas",
            message_index: None,
            helium_content: None,
            oxygen_content: None,
            status: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDiveGas::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDiveGas:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageDiveGas, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // helium_content
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.helium_content = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.helium_content = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // oxygen_content
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.oxygen_content = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.oxygen_content = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // status
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDiveGasStatus::parse(&&bytes[0..f.field_size])?;
                                
                                message.status = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDiveGasStatus::parse(&inp[0..f.field_size])?;
                                
                                message.status = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveGas {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveGas";
    }
}

#[derive(Debug)]
pub enum FitMessageDiveSettingsSubfieldHeartRateSource {
    Default(Option<u8>),
    HeartRateAntplusDeviceType(Option<FitFieldAntplusDeviceType>),
    HeartRateLocalDeviceType(Option<FitFieldLocalDeviceType>),
}

impl FitMessageDiveSettingsSubfieldHeartRateSource {
    fn parse<'a>(message: &FitMessageDiveSettings, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageDiveSettingsSubfieldHeartRateSource> {
        
        match message.heart_rate_source_type {
        
            Some(FitFieldSourceType::Antplus) => {
                let val = FitFieldAntplusDeviceType::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageDiveSettingsSubfieldHeartRateSource::HeartRateAntplusDeviceType(Some(val)))
                },
        
            Some(FitFieldSourceType::Local) => {
                let val = FitFieldLocalDeviceType::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageDiveSettingsSubfieldHeartRateSource::HeartRateLocalDeviceType(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint8(&inp[0..f.field_size])?;
        Ok(FitMessageDiveSettingsSubfieldHeartRateSource::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageDiveSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub name: Option<String>,  
    pub model: Option<FitFieldTissueModelType>,  
    pub gf_low: Option<u8>,  
    pub gf_high: Option<u8>,  
    pub water_type: Option<FitFieldWaterType>,  
    pub water_density: Option<f32>,  // Fresh water is usually 1000; salt water is usually 1025
    pub po2_warn: Option<f64>,  // Typically 1.40
    pub po2_critical: Option<f64>,  // Typically 1.60
    pub po2_deco: Option<f64>,  
    pub safety_stop_enabled: Option<bool>,  
    pub bottom_depth: Option<f32>,  
    pub bottom_time: Option<u32>,  
    pub apnea_countdown_enabled: Option<bool>,  
    pub apnea_countdown_time: Option<u32>,  
    pub backlight_mode: Option<FitFieldDiveBacklightMode>,  
    pub backlight_brightness: Option<u8>,  
    pub backlight_timeout: Option<FitFieldBacklightTimeout>,  
    pub repeat_dive_interval: Option<f64>,  // Time between surfacing and ending the activity
    pub safety_stop_time: Option<f64>,  // Time at safety stop (if enabled)
    pub heart_rate_source_type: Option<FitFieldSourceType>,  
    pub heart_rate_source_subfield_bytes: Vec<u8>,
    pub heart_rate_source: Option<FitMessageDiveSettingsSubfieldHeartRateSource>,  
    
}

impl fmt::Display for FitMessageDiveSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveSettings")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.model { writeln!(f, "  {: >28}: {:?}", "model", v)?; }
        if let Some(v) = &self.gf_low { writeln!(f, "  {: >28}: {:?}", "gf_low", v)?; }
        if let Some(v) = &self.gf_high { writeln!(f, "  {: >28}: {:?}", "gf_high", v)?; }
        if let Some(v) = &self.water_type { writeln!(f, "  {: >28}: {:?}", "water_type", v)?; }
        if let Some(v) = &self.water_density { writeln!(f, "  {: >28}: {:?}", "water_density", v)?; }
        if let Some(v) = &self.po2_warn { writeln!(f, "  {: >28}: {:?}", "po2_warn", v)?; }
        if let Some(v) = &self.po2_critical { writeln!(f, "  {: >28}: {:?}", "po2_critical", v)?; }
        if let Some(v) = &self.po2_deco { writeln!(f, "  {: >28}: {:?}", "po2_deco", v)?; }
        if let Some(v) = &self.safety_stop_enabled { writeln!(f, "  {: >28}: {:?}", "safety_stop_enabled", v)?; }
        if let Some(v) = &self.bottom_depth { writeln!(f, "  {: >28}: {:?}", "bottom_depth", v)?; }
        if let Some(v) = &self.bottom_time { writeln!(f, "  {: >28}: {:?}", "bottom_time", v)?; }
        if let Some(v) = &self.apnea_countdown_enabled { writeln!(f, "  {: >28}: {:?}", "apnea_countdown_enabled", v)?; }
        if let Some(v) = &self.apnea_countdown_time { writeln!(f, "  {: >28}: {:?}", "apnea_countdown_time", v)?; }
        if let Some(v) = &self.backlight_mode { writeln!(f, "  {: >28}: {:?}", "backlight_mode", v)?; }
        if let Some(v) = &self.backlight_brightness { writeln!(f, "  {: >28}: {:?}", "backlight_brightness", v)?; }
        if let Some(v) = &self.backlight_timeout { writeln!(f, "  {: >28}: {:?}", "backlight_timeout", v)?; }
        if let Some(v) = &self.repeat_dive_interval { writeln!(f, "  {: >28}: {:?}", "repeat_dive_interval", v)?; }
        if let Some(v) = &self.safety_stop_time { writeln!(f, "  {: >28}: {:?}", "safety_stop_time", v)?; }
        if let Some(v) = &self.heart_rate_source_type { writeln!(f, "  {: >28}: {:?}", "heart_rate_source_type", v)?; }
        writeln!(f, "  {: >28}: {:?}", "heart_rate_source_subfield_bytes", self.heart_rate_source_subfield_bytes)?;
        if let Some(v) = &self.heart_rate_source { writeln!(f, "  {: >28}: {:?}", "heart_rate_source", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveSettings {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDiveSettings>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDiveSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDiveSettings",
            message_index: None,
            name: None,
            model: None,
            gf_low: None,
            gf_high: None,
            water_type: None,
            water_density: None,
            po2_warn: None,
            po2_critical: None,
            po2_deco: None,
            safety_stop_enabled: None,
            bottom_depth: None,
            bottom_time: None,
            apnea_countdown_enabled: None,
            apnea_countdown_time: None,
            backlight_mode: None,
            backlight_brightness: None,
            backlight_timeout: None,
            repeat_dive_interval: None,
            safety_stop_time: None,
            heart_rate_source_type: None,
            heart_rate_source_subfield_bytes: vec![],
            heart_rate_source: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDiveSettings::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDiveSettings:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageDiveSettings::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageDiveSettings:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageDiveSettings, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 20).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageDiveSettingsSubfieldHeartRateSource::parse(message, &message.heart_rate_source_subfield_bytes, &field, _tz_offset)?;
            message.heart_rate_source = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageDiveSettings, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // model
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldTissueModelType::parse(&&bytes[0..f.field_size])?;
                                
                                message.model = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldTissueModelType::parse(&inp[0..f.field_size])?;
                                
                                message.model = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // gf_low
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.gf_low = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.gf_low = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // gf_high
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.gf_high = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.gf_high = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // water_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWaterType::parse(&&bytes[0..f.field_size])?;
                                
                                message.water_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWaterType::parse(&inp[0..f.field_size])?;
                                
                                message.water_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // water_density
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_float32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.water_density = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_float32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.water_density = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // po2_warn
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.po2_warn = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.po2_warn = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.po2_warn = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.po2_warn = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // po2_critical
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.po2_critical = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.po2_critical = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.po2_critical = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.po2_critical = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // po2_deco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.po2_deco = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.po2_deco = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.po2_deco = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.po2_deco = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // safety_stop_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.safety_stop_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.safety_stop_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // bottom_depth
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_float32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bottom_depth = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_float32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bottom_depth = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // bottom_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bottom_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.bottom_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // apnea_countdown_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.apnea_countdown_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.apnea_countdown_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // apnea_countdown_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.apnea_countdown_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.apnea_countdown_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // backlight_mode
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDiveBacklightMode::parse(&&bytes[0..f.field_size])?;
                                
                                message.backlight_mode = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDiveBacklightMode::parse(&inp[0..f.field_size])?;
                                
                                message.backlight_mode = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    15 => {  // backlight_brightness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.backlight_brightness = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.backlight_brightness = val;
                            }
                        }

                        Ok(())
                    },
                
                    16 => {  // backlight_timeout
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldBacklightTimeout::parse(&&bytes[0..f.field_size])?;
                                
                                message.backlight_timeout = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldBacklightTimeout::parse(&inp[0..f.field_size])?;
                                
                                message.backlight_timeout = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // repeat_dive_interval
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.repeat_dive_interval = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.repeat_dive_interval = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.repeat_dive_interval = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.repeat_dive_interval = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // safety_stop_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.safety_stop_time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.safety_stop_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.safety_stop_time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.safety_stop_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // heart_rate_source_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSourceType::parse(&&bytes[0..f.field_size])?;
                                
                                message.heart_rate_source_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSourceType::parse(&inp[0..f.field_size])?;
                                
                                message.heart_rate_source_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // heart_rate_source
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.heart_rate_source_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.heart_rate_source_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveSettings";
    }
}

#[derive(Debug)]
pub struct FitMessageDiveSummary {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub reference_mesg: Option<FitFieldMesgNum>,  
    pub reference_index: Option<FitFieldMessageIndex>,  
    pub avg_depth: Option<f64>,  // 0 if above water
    pub max_depth: Option<f64>,  // 0 if above water
    pub surface_interval: Option<f64>,  // Time since end of last dive
    pub start_cns: Option<f64>,  
    pub end_cns: Option<f64>,  
    pub start_n2: Option<f64>,  
    pub end_n2: Option<f64>,  
    pub o2_toxicity: Option<u16>,  
    pub dive_number: Option<u32>,  
    pub bottom_time: Option<f64>,  
    
}

impl fmt::Display for FitMessageDiveSummary {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageDiveSummary")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.reference_mesg { writeln!(f, "  {: >28}: {:?}", "reference_mesg", v)?; }
        if let Some(v) = &self.reference_index { writeln!(f, "  {: >28}: {:?}", "reference_index", v)?; }
        if let Some(v) = &self.avg_depth { writeln!(f, "  {: >28}: {:?}", "avg_depth", v)?; }
        if let Some(v) = &self.max_depth { writeln!(f, "  {: >28}: {:?}", "max_depth", v)?; }
        if let Some(v) = &self.surface_interval { writeln!(f, "  {: >28}: {:?}", "surface_interval", v)?; }
        if let Some(v) = &self.start_cns { writeln!(f, "  {: >28}: {:?}", "start_cns", v)?; }
        if let Some(v) = &self.end_cns { writeln!(f, "  {: >28}: {:?}", "end_cns", v)?; }
        if let Some(v) = &self.start_n2 { writeln!(f, "  {: >28}: {:?}", "start_n2", v)?; }
        if let Some(v) = &self.end_n2 { writeln!(f, "  {: >28}: {:?}", "end_n2", v)?; }
        if let Some(v) = &self.o2_toxicity { writeln!(f, "  {: >28}: {:?}", "o2_toxicity", v)?; }
        if let Some(v) = &self.dive_number { writeln!(f, "  {: >28}: {:?}", "dive_number", v)?; }
        if let Some(v) = &self.bottom_time { writeln!(f, "  {: >28}: {:?}", "bottom_time", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageDiveSummary {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageDiveSummary>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageDiveSummary {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageDiveSummary",
            timestamp: None,
            reference_mesg: None,
            reference_index: None,
            avg_depth: None,
            max_depth: None,
            surface_interval: None,
            start_cns: None,
            end_cns: None,
            start_n2: None,
            end_n2: None,
            o2_toxicity: None,
            dive_number: None,
            bottom_time: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageDiveSummary::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageDiveSummary:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageDiveSummary, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // reference_mesg
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMesgNum::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.reference_mesg = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMesgNum::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.reference_mesg = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // reference_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.reference_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.reference_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // avg_depth
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_depth = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_depth = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // max_depth
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_depth = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_depth = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // surface_interval
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.surface_interval = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.surface_interval = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.surface_interval = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.surface_interval = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // start_cns
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.start_cns = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.start_cns = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.start_cns = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.start_cns = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // end_cns
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.end_cns = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.end_cns = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.end_cns = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.end_cns = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // start_n2
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.start_n2 = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.start_n2 = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.start_n2 = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.start_n2 = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // end_n2
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.end_n2 = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.end_n2 = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.end_n2 = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.end_n2 = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // o2_toxicity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.o2_toxicity = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.o2_toxicity = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // dive_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.dive_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.dive_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // bottom_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.bottom_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.bottom_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.bottom_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.bottom_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageDiveSummary {
    fn message_name(&self) -> &'static str {
        return "FitMessageDiveSummary";
    }
}

#[derive(Debug)]
pub enum FitMessageEventSubfieldData {
    Default(Option<u32>),
    CadLowAlert(Option<u16>),
    DistanceDurationAlert(Option<u32>),
    HrHighAlert(Option<u8>),
    TimeDurationAlert(Option<u32>),
    CommTimeout(Option<FitFieldCommTimeoutType>),
    CoursePointIndex(Option<FitFieldMessageIndex>),
    FitnessEquipmentState(Option<FitFieldFitnessEquipmentState>),
    CalorieDurationAlert(Option<u32>),
    CadHighAlert(Option<u16>),
    VirtualPartnerSpeed(Option<u16>),
    HrLowAlert(Option<u8>),
    RiderPosition(Option<FitFieldRiderPositionType>),
    GearChangeData(Option<u32>),
    SportPoint(Option<u32>),
    BatteryLevel(Option<u16>),
    SpeedHighAlert(Option<u32>),
    PowerLowAlert(Option<u16>),
    SpeedLowAlert(Option<u32>),
    PowerHighAlert(Option<u16>),
    TimerTrigger(Option<FitFieldTimerTrigger>),
}

impl FitMessageEventSubfieldData {
    fn parse<'a>(message: &FitMessageEvent, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageEventSubfieldData> {
        
        match message.event {
        
            Some(FitFieldEvent::Timer) => {
                let val = FitFieldTimerTrigger::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageEventSubfieldData::TimerTrigger(Some(val)))
                },
        
            Some(FitFieldEvent::CoursePoint) => {
                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::CoursePointIndex(Some(val)))
                },
        
            Some(FitFieldEvent::Battery) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::BatteryLevel(val))
                },
        
            Some(FitFieldEvent::VirtualPartnerPace) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::VirtualPartnerSpeed(val))
                },
        
            Some(FitFieldEvent::HrHighAlert) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageEventSubfieldData::HrHighAlert(val))
                },
        
            Some(FitFieldEvent::HrLowAlert) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageEventSubfieldData::HrLowAlert(val))
                },
        
            Some(FitFieldEvent::SpeedHighAlert) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::SpeedHighAlert(val))
                },
        
            Some(FitFieldEvent::SpeedLowAlert) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::SpeedLowAlert(val))
                },
        
            Some(FitFieldEvent::CadHighAlert) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::CadHighAlert(val))
                },
        
            Some(FitFieldEvent::CadLowAlert) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::CadLowAlert(val))
                },
        
            Some(FitFieldEvent::PowerHighAlert) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::PowerHighAlert(val))
                },
        
            Some(FitFieldEvent::PowerLowAlert) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::PowerLowAlert(val))
                },
        
            Some(FitFieldEvent::TimeDurationAlert) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::TimeDurationAlert(val))
                },
        
            Some(FitFieldEvent::DistanceDurationAlert) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::DistanceDurationAlert(val))
                },
        
            Some(FitFieldEvent::CalorieDurationAlert) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::CalorieDurationAlert(val))
                },
        
            Some(FitFieldEvent::FitnessEquipment) => {
                let val = FitFieldFitnessEquipmentState::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageEventSubfieldData::FitnessEquipmentState(Some(val)))
                },
        
            Some(FitFieldEvent::SportPoint) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::SportPoint(val))
                },
        
            Some(FitFieldEvent::FrontGearChange) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::GearChangeData(val))
                },
        
            Some(FitFieldEvent::RearGearChange) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::GearChangeData(val))
                },
        
            Some(FitFieldEvent::RiderPositionChange) => {
                let val = FitFieldRiderPositionType::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageEventSubfieldData::RiderPosition(Some(val)))
                },
        
            Some(FitFieldEvent::CommTimeout) => {
                let val = FitFieldCommTimeoutType::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageEventSubfieldData::CommTimeout(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageEventSubfieldData::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageEvent {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub event: Option<FitFieldEvent>,  
    pub event_type: Option<FitFieldEventType>,  
    pub data16: Option<u16>,  
    pub data_subfield_bytes: Vec<u8>,
    pub data: Option<FitMessageEventSubfieldData>,  
    pub event_group: Option<u8>,  
    pub score: Option<u16>,  // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
    pub opponent_score: Option<u16>,  // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
    pub front_gear_num: Option<u8>,  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Front gear number. 1 is innermost.
    pub front_gear: Option<u8>,  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of front teeth.
    pub rear_gear_num: Option<u8>,  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Rear gear number. 1 is innermost.
    pub rear_gear: Option<u8>,  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of rear teeth.
    pub device_index: Option<FitFieldDeviceIndex>,  
    
}

impl fmt::Display for FitMessageEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageEvent")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.event { writeln!(f, "  {: >28}: {:?}", "event", v)?; }
        if let Some(v) = &self.event_type { writeln!(f, "  {: >28}: {:?}", "event_type", v)?; }
        if let Some(v) = &self.data16 { writeln!(f, "  {: >28}: {:?}", "data16", v)?; }
        writeln!(f, "  {: >28}: {:?}", "data_subfield_bytes", self.data_subfield_bytes)?;
        if let Some(v) = &self.data { writeln!(f, "  {: >28}: {:?}", "data", v)?; }
        if let Some(v) = &self.event_group { writeln!(f, "  {: >28}: {:?}", "event_group", v)?; }
        if let Some(v) = &self.score { writeln!(f, "  {: >28}: {:?}", "score", v)?; }
        if let Some(v) = &self.opponent_score { writeln!(f, "  {: >28}: {:?}", "opponent_score", v)?; }
        if let Some(v) = &self.front_gear_num { writeln!(f, "  {: >28}: {:?}", "front_gear_num", v)?; }
        if let Some(v) = &self.front_gear { writeln!(f, "  {: >28}: {:?}", "front_gear", v)?; }
        if let Some(v) = &self.rear_gear_num { writeln!(f, "  {: >28}: {:?}", "rear_gear_num", v)?; }
        if let Some(v) = &self.rear_gear { writeln!(f, "  {: >28}: {:?}", "rear_gear", v)?; }
        if let Some(v) = &self.device_index { writeln!(f, "  {: >28}: {:?}", "device_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageEvent {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageEvent>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageEvent {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageEvent",
            timestamp: None,
            event: None,
            event_type: None,
            data16: None,
            data_subfield_bytes: vec![],
            data: None,
            event_group: None,
            score: None,
            opponent_score: None,
            front_gear_num: None,
            front_gear: None,
            rear_gear_num: None,
            rear_gear: None,
            device_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageEvent::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageEvent:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageEvent::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageEvent:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageEvent, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 3).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageEventSubfieldData::parse(message, &message.data_subfield_bytes, &field, _tz_offset)?;
            message.data = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageEvent, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEvent::parse(&inp[0..f.field_size])?;
                                
                                message.event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEventType::parse(&inp[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // data16
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.data16 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.data16 = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 3, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    3 => {  // data
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.data_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.data_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // event_group
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.event_group = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.event_group = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.score = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // opponent_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // front_gear_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.front_gear_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.front_gear_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // front_gear
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.front_gear = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.front_gear = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // rear_gear_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.rear_gear_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.rear_gear_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // rear_gear
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.rear_gear = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.rear_gear = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // device_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDeviceIndex::parse(&&bytes[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDeviceIndex::parse(&inp[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageEvent {
    fn message_name(&self) -> &'static str {
        return "FitMessageEvent";
    }
}

#[derive(Debug)]
pub struct FitMessageExdDataConceptConfiguration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub screen_index: Option<u8>,  
    pub concept_field: Option<Vec<u8>>,  
    pub field_id: Option<u8>,  
    pub concept_index: Option<u8>,  
    pub data_page: Option<u8>,  
    pub concept_key: Option<u8>,  
    pub scaling: Option<u8>,  
    pub data_units: Option<FitFieldExdDataUnits>,  
    pub qualifier: Option<FitFieldExdQualifiers>,  
    pub descriptor: Option<FitFieldExdDescriptors>,  
    pub is_signed: Option<bool>,  
    
}

impl fmt::Display for FitMessageExdDataConceptConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExdDataConceptConfiguration")?;
        if let Some(v) = &self.screen_index { writeln!(f, "  {: >28}: {:?}", "screen_index", v)?; }
        if let Some(v) = &self.concept_field { writeln!(f, "  {: >28}: {:?}", "concept_field", v)?; }
        if let Some(v) = &self.field_id { writeln!(f, "  {: >28}: {:?}", "field_id", v)?; }
        if let Some(v) = &self.concept_index { writeln!(f, "  {: >28}: {:?}", "concept_index", v)?; }
        if let Some(v) = &self.data_page { writeln!(f, "  {: >28}: {:?}", "data_page", v)?; }
        if let Some(v) = &self.concept_key { writeln!(f, "  {: >28}: {:?}", "concept_key", v)?; }
        if let Some(v) = &self.scaling { writeln!(f, "  {: >28}: {:?}", "scaling", v)?; }
        if let Some(v) = &self.data_units { writeln!(f, "  {: >28}: {:?}", "data_units", v)?; }
        if let Some(v) = &self.qualifier { writeln!(f, "  {: >28}: {:?}", "qualifier", v)?; }
        if let Some(v) = &self.descriptor { writeln!(f, "  {: >28}: {:?}", "descriptor", v)?; }
        if let Some(v) = &self.is_signed { writeln!(f, "  {: >28}: {:?}", "is_signed", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExdDataConceptConfiguration {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageExdDataConceptConfiguration>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageExdDataConceptConfiguration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageExdDataConceptConfiguration",
            screen_index: None,
            concept_field: None,
            field_id: None,
            concept_index: None,
            data_page: None,
            concept_key: None,
            scaling: None,
            data_units: None,
            qualifier: None,
            descriptor: None,
            is_signed: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageExdDataConceptConfiguration::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageExdDataConceptConfiguration:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageExdDataConceptConfiguration, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // screen_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.screen_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.screen_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // concept_field
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.concept_field = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.concept_field = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 2, field_size: 1, base_type: 0}, Some((0, 4)) ));
                        actions.push( (FitFieldDefinition{definition_number: 3, field_size: 1, base_type: 0}, Some((4, 4)) ));
                        Ok(())
                    },
                
                    2 => {  // field_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.field_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.field_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // concept_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.concept_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.concept_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // data_page
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.data_page = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.data_page = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // concept_key
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.concept_key = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.concept_key = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // scaling
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.scaling = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.scaling = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // data_units
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExdDataUnits::parse(&&bytes[0..f.field_size])?;
                                
                                message.data_units = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExdDataUnits::parse(&inp[0..f.field_size])?;
                                
                                message.data_units = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // qualifier
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExdQualifiers::parse(&&bytes[0..f.field_size])?;
                                
                                message.qualifier = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExdQualifiers::parse(&inp[0..f.field_size])?;
                                
                                message.qualifier = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // descriptor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExdDescriptors::parse(&&bytes[0..f.field_size])?;
                                
                                message.descriptor = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExdDescriptors::parse(&inp[0..f.field_size])?;
                                
                                message.descriptor = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // is_signed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.is_signed = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.is_signed = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageExdDataConceptConfiguration {
    fn message_name(&self) -> &'static str {
        return "FitMessageExdDataConceptConfiguration";
    }
}

#[derive(Debug)]
pub struct FitMessageExdDataFieldConfiguration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub screen_index: Option<u8>,  
    pub concept_field: Option<Vec<u8>>,  
    pub field_id: Option<u8>,  
    pub concept_count: Option<u8>,  
    pub display_type: Option<FitFieldExdDisplayType>,  
    pub title: Option<Vec<Option<String>>>,  
    
}

impl fmt::Display for FitMessageExdDataFieldConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExdDataFieldConfiguration")?;
        if let Some(v) = &self.screen_index { writeln!(f, "  {: >28}: {:?}", "screen_index", v)?; }
        if let Some(v) = &self.concept_field { writeln!(f, "  {: >28}: {:?}", "concept_field", v)?; }
        if let Some(v) = &self.field_id { writeln!(f, "  {: >28}: {:?}", "field_id", v)?; }
        if let Some(v) = &self.concept_count { writeln!(f, "  {: >28}: {:?}", "concept_count", v)?; }
        if let Some(v) = &self.display_type { writeln!(f, "  {: >28}: {:?}", "display_type", v)?; }
        if let Some(v) = &self.title { writeln!(f, "  {: >28}: {:?}", "title", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExdDataFieldConfiguration {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageExdDataFieldConfiguration>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageExdDataFieldConfiguration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageExdDataFieldConfiguration",
            screen_index: None,
            concept_field: None,
            field_id: None,
            concept_count: None,
            display_type: None,
            title: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageExdDataFieldConfiguration::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageExdDataFieldConfiguration:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageExdDataFieldConfiguration, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // screen_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.screen_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.screen_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // concept_field
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.concept_field = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.concept_field = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 2, field_size: 1, base_type: 0}, Some((0, 4)) ));
                        actions.push( (FitFieldDefinition{definition_number: 3, field_size: 1, base_type: 0}, Some((4, 4)) ));
                        Ok(())
                    },
                
                    2 => {  // field_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.field_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.field_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // concept_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.concept_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.concept_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // display_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExdDisplayType::parse(&&bytes[0..f.field_size])?;
                                
                                message.display_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExdDisplayType::parse(&inp[0..f.field_size])?;
                                
                                message.display_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // title
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.title = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.title = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageExdDataFieldConfiguration {
    fn message_name(&self) -> &'static str {
        return "FitMessageExdDataFieldConfiguration";
    }
}

#[derive(Debug)]
pub struct FitMessageExdScreenConfiguration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub screen_index: Option<u8>,  
    pub field_count: Option<u8>,  // number of fields in screen
    pub layout: Option<FitFieldExdLayout>,  
    pub screen_enabled: Option<bool>,  
    
}

impl fmt::Display for FitMessageExdScreenConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExdScreenConfiguration")?;
        if let Some(v) = &self.screen_index { writeln!(f, "  {: >28}: {:?}", "screen_index", v)?; }
        if let Some(v) = &self.field_count { writeln!(f, "  {: >28}: {:?}", "field_count", v)?; }
        if let Some(v) = &self.layout { writeln!(f, "  {: >28}: {:?}", "layout", v)?; }
        if let Some(v) = &self.screen_enabled { writeln!(f, "  {: >28}: {:?}", "screen_enabled", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExdScreenConfiguration {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageExdScreenConfiguration>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageExdScreenConfiguration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageExdScreenConfiguration",
            screen_index: None,
            field_count: None,
            layout: None,
            screen_enabled: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageExdScreenConfiguration::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageExdScreenConfiguration:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageExdScreenConfiguration, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // screen_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.screen_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.screen_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // field_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.field_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.field_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // layout
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExdLayout::parse(&&bytes[0..f.field_size])?;
                                
                                message.layout = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExdLayout::parse(&inp[0..f.field_size])?;
                                
                                message.layout = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // screen_enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.screen_enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.screen_enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageExdScreenConfiguration {
    fn message_name(&self) -> &'static str {
        return "FitMessageExdScreenConfiguration";
    }
}

#[derive(Debug)]
pub struct FitMessageExerciseTitle {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub exercise_category: Option<FitFieldExerciseCategory>,  
    pub exercise_name: Option<u16>,  
    pub wkt_step_name: Option<Vec<Option<String>>>,  
    
}

impl fmt::Display for FitMessageExerciseTitle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageExerciseTitle")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.exercise_category { writeln!(f, "  {: >28}: {:?}", "exercise_category", v)?; }
        if let Some(v) = &self.exercise_name { writeln!(f, "  {: >28}: {:?}", "exercise_name", v)?; }
        if let Some(v) = &self.wkt_step_name { writeln!(f, "  {: >28}: {:?}", "wkt_step_name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageExerciseTitle {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageExerciseTitle>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageExerciseTitle {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageExerciseTitle",
            message_index: None,
            exercise_category: None,
            exercise_name: None,
            wkt_step_name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageExerciseTitle::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageExerciseTitle:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageExerciseTitle, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // exercise_category
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExerciseCategory::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_category = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExerciseCategory::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_category = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // exercise_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // wkt_step_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.wkt_step_name = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.wkt_step_name = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageExerciseTitle {
    fn message_name(&self) -> &'static str {
        return "FitMessageExerciseTitle";
    }
}

#[derive(Debug)]
pub struct FitMessageFieldCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub file: Option<FitFieldFile>,  
    pub mesg_num: Option<FitFieldMesgNum>,  
    pub field_num: Option<u8>,  
    pub count: Option<u16>,  
    
}

impl fmt::Display for FitMessageFieldCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFieldCapabilities")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.file { writeln!(f, "  {: >28}: {:?}", "file", v)?; }
        if let Some(v) = &self.mesg_num { writeln!(f, "  {: >28}: {:?}", "mesg_num", v)?; }
        if let Some(v) = &self.field_num { writeln!(f, "  {: >28}: {:?}", "field_num", v)?; }
        if let Some(v) = &self.count { writeln!(f, "  {: >28}: {:?}", "count", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFieldCapabilities {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageFieldCapabilities>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageFieldCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageFieldCapabilities",
            message_index: None,
            file: None,
            mesg_num: None,
            field_num: None,
            count: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageFieldCapabilities::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageFieldCapabilities:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageFieldCapabilities, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // file
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFile::parse(&&bytes[0..f.field_size])?;
                                
                                message.file = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFile::parse(&inp[0..f.field_size])?;
                                
                                message.file = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // mesg_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMesgNum::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.mesg_num = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMesgNum::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.mesg_num = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // field_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.field_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.field_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.count = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageFieldCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageFieldCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageFieldDescription {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub developer_data_index: Option<u8>,  
    pub field_definition_number: Option<u8>,  
    pub fit_base_type_id: Option<FitFieldFitBaseType>,  
    pub field_name: Option<Vec<Option<String>>>,  
    pub array: Option<u8>,  
    pub components: Option<String>,  
    pub scale: Option<u8>,  
    pub offset: Option<i8>,  
    pub units: Option<Vec<Option<String>>>,  
    pub bits: Option<String>,  
    pub accumulate: Option<String>,  
    pub fit_base_unit_id: Option<FitFieldFitBaseUnit>,  
    pub native_mesg_num: Option<FitFieldMesgNum>,  
    pub native_field_num: Option<u8>,  
    
}

impl fmt::Display for FitMessageFieldDescription {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFieldDescription")?;
        if let Some(v) = &self.developer_data_index { writeln!(f, "  {: >28}: {:?}", "developer_data_index", v)?; }
        if let Some(v) = &self.field_definition_number { writeln!(f, "  {: >28}: {:?}", "field_definition_number", v)?; }
        if let Some(v) = &self.fit_base_type_id { writeln!(f, "  {: >28}: {:?}", "fit_base_type_id", v)?; }
        if let Some(v) = &self.field_name { writeln!(f, "  {: >28}: {:?}", "field_name", v)?; }
        if let Some(v) = &self.array { writeln!(f, "  {: >28}: {:?}", "array", v)?; }
        if let Some(v) = &self.components { writeln!(f, "  {: >28}: {:?}", "components", v)?; }
        if let Some(v) = &self.scale { writeln!(f, "  {: >28}: {:?}", "scale", v)?; }
        if let Some(v) = &self.offset { writeln!(f, "  {: >28}: {:?}", "offset", v)?; }
        if let Some(v) = &self.units { writeln!(f, "  {: >28}: {:?}", "units", v)?; }
        if let Some(v) = &self.bits { writeln!(f, "  {: >28}: {:?}", "bits", v)?; }
        if let Some(v) = &self.accumulate { writeln!(f, "  {: >28}: {:?}", "accumulate", v)?; }
        if let Some(v) = &self.fit_base_unit_id { writeln!(f, "  {: >28}: {:?}", "fit_base_unit_id", v)?; }
        if let Some(v) = &self.native_mesg_num { writeln!(f, "  {: >28}: {:?}", "native_mesg_num", v)?; }
        if let Some(v) = &self.native_field_num { writeln!(f, "  {: >28}: {:?}", "native_field_num", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFieldDescription {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageFieldDescription>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageFieldDescription {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageFieldDescription",
            developer_data_index: None,
            field_definition_number: None,
            fit_base_type_id: None,
            field_name: None,
            array: None,
            components: None,
            scale: None,
            offset: None,
            units: None,
            bits: None,
            accumulate: None,
            fit_base_unit_id: None,
            native_mesg_num: None,
            native_field_num: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageFieldDescription::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageFieldDescription:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageFieldDescription, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // developer_data_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.developer_data_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.developer_data_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // field_definition_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.field_definition_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.field_definition_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // fit_base_type_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFitBaseType::parse(&&bytes[0..f.field_size])?;
                                
                                message.fit_base_type_id = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFitBaseType::parse(&inp[0..f.field_size])?;
                                
                                message.fit_base_type_id = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // field_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.field_name = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.field_name = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // array
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.array = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.array = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // components
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.components = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.components = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // scale
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.scale = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.scale = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.offset = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.offset = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // units
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.units = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.units = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // bits
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.bits = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.bits = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // accumulate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.accumulate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.accumulate = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // fit_base_unit_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFitBaseUnit::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.fit_base_unit_id = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFitBaseUnit::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.fit_base_unit_id = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // native_mesg_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMesgNum::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.native_mesg_num = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMesgNum::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.native_mesg_num = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    15 => {  // native_field_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.native_field_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.native_field_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageFieldDescription {
    fn message_name(&self) -> &'static str {
        return "FitMessageFieldDescription";
    }
}

#[derive(Debug)]
pub struct FitMessageFileCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub ftype: Option<FitFieldFile>,  
    pub flags: Option<FitFieldFileFlags>,  
    pub directory: Option<String>,  
    pub max_count: Option<u16>,  
    pub max_size: Option<u32>,  
    
}

impl fmt::Display for FitMessageFileCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFileCapabilities")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.flags { writeln!(f, "  {: >28}: {:?}", "flags", v)?; }
        if let Some(v) = &self.directory { writeln!(f, "  {: >28}: {:?}", "directory", v)?; }
        if let Some(v) = &self.max_count { writeln!(f, "  {: >28}: {:?}", "max_count", v)?; }
        if let Some(v) = &self.max_size { writeln!(f, "  {: >28}: {:?}", "max_size", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFileCapabilities {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageFileCapabilities>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageFileCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageFileCapabilities",
            message_index: None,
            ftype: None,
            flags: None,
            directory: None,
            max_count: None,
            max_size: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageFileCapabilities::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageFileCapabilities:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageFileCapabilities, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFile::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFile::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // flags
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFileFlags::parse(&&bytes[0..f.field_size])?;
                                
                                message.flags = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFileFlags::parse(&inp[0..f.field_size])?;
                                
                                message.flags = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // directory
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.directory = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.directory = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // max_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // max_size
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_size = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_size = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageFileCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageFileCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageFileCreator {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub software_version: Option<u16>,  
    pub hardware_version: Option<u8>,  
    
}

impl fmt::Display for FitMessageFileCreator {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFileCreator")?;
        if let Some(v) = &self.software_version { writeln!(f, "  {: >28}: {:?}", "software_version", v)?; }
        if let Some(v) = &self.hardware_version { writeln!(f, "  {: >28}: {:?}", "hardware_version", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFileCreator {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageFileCreator>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageFileCreator {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageFileCreator",
            software_version: None,
            hardware_version: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageFileCreator::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageFileCreator:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageFileCreator, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // software_version
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.software_version = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.software_version = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // hardware_version
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.hardware_version = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.hardware_version = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageFileCreator {
    fn message_name(&self) -> &'static str {
        return "FitMessageFileCreator";
    }
}

#[derive(Debug)]
pub enum FitMessageFileIdSubfieldProduct {
    Default(Option<u16>),
    FaveroProduct(Option<FitFieldFaveroProduct>),
    GarminProduct(Option<FitFieldGarminProduct>),
}

impl FitMessageFileIdSubfieldProduct {
    fn parse<'a>(message: &FitMessageFileId, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageFileIdSubfieldProduct> {
        
        match message.manufacturer {
        
            Some(FitFieldManufacturer::FaveroElectronics) => {
                let val = FitFieldFaveroProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageFileIdSubfieldProduct::FaveroProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Garmin) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageFileIdSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Dynastream) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageFileIdSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::DynastreamOem) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageFileIdSubfieldProduct::GarminProduct(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageFileIdSubfieldProduct::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageFileId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub ftype: Option<FitFieldFile>,  
    pub manufacturer: Option<FitFieldManufacturer>,  
    pub product_subfield_bytes: Vec<u8>,
    pub product: Option<FitMessageFileIdSubfieldProduct>,  
    pub serial_number: Option<u32>,  
    pub time_created: Option<FitFieldDateTime>,  // Only set for files that are can be created/erased.
    pub number: Option<u16>,  // Only set for files that are not created/erased.
    pub product_name: Option<String>,  // Optional free form string to indicate the devices name or model
    
}

impl fmt::Display for FitMessageFileId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageFileId")?;
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.manufacturer { writeln!(f, "  {: >28}: {:?}", "manufacturer", v)?; }
        writeln!(f, "  {: >28}: {:?}", "product_subfield_bytes", self.product_subfield_bytes)?;
        if let Some(v) = &self.product { writeln!(f, "  {: >28}: {:?}", "product", v)?; }
        if let Some(v) = &self.serial_number { writeln!(f, "  {: >28}: {:?}", "serial_number", v)?; }
        if let Some(v) = &self.time_created { writeln!(f, "  {: >28}: {:?}", "time_created", v)?; }
        if let Some(v) = &self.number { writeln!(f, "  {: >28}: {:?}", "number", v)?; }
        if let Some(v) = &self.product_name { writeln!(f, "  {: >28}: {:?}", "product_name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageFileId {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageFileId>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageFileId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageFileId",
            ftype: None,
            manufacturer: None,
            product_subfield_bytes: vec![],
            product: None,
            serial_number: None,
            time_created: None,
            number: None,
            product_name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageFileId::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageFileId:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageFileId::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageFileId:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageFileId, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 2).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageFileIdSubfieldProduct::parse(message, &message.product_subfield_bytes, &field, _tz_offset)?;
            message.product = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageFileId, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFile::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFile::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // manufacturer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // product
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // serial_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // time_created
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.time_created = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.time_created = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.number = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // product_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.product_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.product_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageFileId {
    fn message_name(&self) -> &'static str {
        return "FitMessageFileId";
    }
}

#[derive(Debug)]
pub struct FitMessageGoal {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub sport: Option<FitFieldSport>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub start_date: Option<FitFieldDateTime>,  
    pub end_date: Option<FitFieldDateTime>,  
    pub ftype: Option<FitFieldGoal>,  
    pub value: Option<u32>,  
    pub repeat: Option<bool>,  
    pub target_value: Option<u32>,  
    pub recurrence: Option<FitFieldGoalRecurrence>,  
    pub recurrence_value: Option<u16>,  
    pub enabled: Option<bool>,  
    pub source: Option<FitFieldGoalSource>,  
    
}

impl fmt::Display for FitMessageGoal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageGoal")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.start_date { writeln!(f, "  {: >28}: {:?}", "start_date", v)?; }
        if let Some(v) = &self.end_date { writeln!(f, "  {: >28}: {:?}", "end_date", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.value { writeln!(f, "  {: >28}: {:?}", "value", v)?; }
        if let Some(v) = &self.repeat { writeln!(f, "  {: >28}: {:?}", "repeat", v)?; }
        if let Some(v) = &self.target_value { writeln!(f, "  {: >28}: {:?}", "target_value", v)?; }
        if let Some(v) = &self.recurrence { writeln!(f, "  {: >28}: {:?}", "recurrence", v)?; }
        if let Some(v) = &self.recurrence_value { writeln!(f, "  {: >28}: {:?}", "recurrence_value", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.source { writeln!(f, "  {: >28}: {:?}", "source", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageGoal {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageGoal>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageGoal {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageGoal",
            message_index: None,
            sport: None,
            sub_sport: None,
            start_date: None,
            end_date: None,
            ftype: None,
            value: None,
            repeat: None,
            target_value: None,
            recurrence: None,
            recurrence_value: None,
            enabled: None,
            source: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageGoal::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageGoal:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageGoal, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // start_date
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_date = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_date = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // end_date
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.end_date = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.end_date = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldGoal::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldGoal::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.value = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.value = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // repeat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.repeat = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.repeat = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // target_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.target_value = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.target_value = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // recurrence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldGoalRecurrence::parse(&&bytes[0..f.field_size])?;
                                
                                message.recurrence = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldGoalRecurrence::parse(&inp[0..f.field_size])?;
                                
                                message.recurrence = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // recurrence_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.recurrence_value = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.recurrence_value = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // source
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldGoalSource::parse(&&bytes[0..f.field_size])?;
                                
                                message.source = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldGoalSource::parse(&inp[0..f.field_size])?;
                                
                                message.source = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageGoal {
    fn message_name(&self) -> &'static str {
        return "FitMessageGoal";
    }
}

#[derive(Debug)]
pub struct FitMessageGpsMetadata {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp.
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub position_lat: Option<f64>,  
    pub position_long: Option<f64>,  
    pub enhanced_altitude: Option<f64>,  
    pub enhanced_speed: Option<f64>,  
    pub heading: Option<f64>,  
    pub utc_timestamp: Option<FitFieldDateTime>,  // Used to correlate UTC to system time if the timestamp of the message is in system time.  This UTC time is derived from the GPS data.
    pub velocity: Option<Vec<Option<f64>>>,  // velocity[0] is lon velocity.  Velocity[1] is lat velocity.  Velocity[2] is altitude velocity.
    
}

impl fmt::Display for FitMessageGpsMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageGpsMetadata")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.position_lat { writeln!(f, "  {: >28}: {:?}", "position_lat", v)?; }
        if let Some(v) = &self.position_long { writeln!(f, "  {: >28}: {:?}", "position_long", v)?; }
        if let Some(v) = &self.enhanced_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_altitude", v)?; }
        if let Some(v) = &self.enhanced_speed { writeln!(f, "  {: >28}: {:?}", "enhanced_speed", v)?; }
        if let Some(v) = &self.heading { writeln!(f, "  {: >28}: {:?}", "heading", v)?; }
        if let Some(v) = &self.utc_timestamp { writeln!(f, "  {: >28}: {:?}", "utc_timestamp", v)?; }
        if let Some(v) = &self.velocity { writeln!(f, "  {: >28}: {:?}", "velocity", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageGpsMetadata {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageGpsMetadata>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageGpsMetadata {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageGpsMetadata",
            timestamp: None,
            timestamp_ms: None,
            position_lat: None,
            position_long: None,
            enhanced_altitude: None,
            enhanced_speed: None,
            heading: None,
            utc_timestamp: None,
            velocity: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageGpsMetadata::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageGpsMetadata:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageGpsMetadata, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // enhanced_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // enhanced_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // heading
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.heading = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.heading = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.heading = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.heading = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // utc_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.utc_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.utc_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // velocity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.velocity = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.velocity = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageGpsMetadata {
    fn message_name(&self) -> &'static str {
        return "FitMessageGpsMetadata";
    }
}

#[derive(Debug)]
pub struct FitMessageGyroscopeData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub sample_time_offset: Option<Vec<Option<u16>>>,  // Each time in the array describes the time at which the gyro sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in gyro_x and gyro_y and gyro_z
    pub gyro_x: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub gyro_y: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub gyro_z: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub calibrated_gyro_x: Option<Vec<Option<f32>>>,  // Calibrated gyro reading
    pub calibrated_gyro_y: Option<Vec<Option<f32>>>,  // Calibrated gyro reading
    pub calibrated_gyro_z: Option<Vec<Option<f32>>>,  // Calibrated gyro reading
    
}

impl fmt::Display for FitMessageGyroscopeData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageGyroscopeData")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.sample_time_offset { writeln!(f, "  {: >28}: {:?}", "sample_time_offset", v)?; }
        if let Some(v) = &self.gyro_x { writeln!(f, "  {: >28}: {:?}", "gyro_x", v)?; }
        if let Some(v) = &self.gyro_y { writeln!(f, "  {: >28}: {:?}", "gyro_y", v)?; }
        if let Some(v) = &self.gyro_z { writeln!(f, "  {: >28}: {:?}", "gyro_z", v)?; }
        if let Some(v) = &self.calibrated_gyro_x { writeln!(f, "  {: >28}: {:?}", "calibrated_gyro_x", v)?; }
        if let Some(v) = &self.calibrated_gyro_y { writeln!(f, "  {: >28}: {:?}", "calibrated_gyro_y", v)?; }
        if let Some(v) = &self.calibrated_gyro_z { writeln!(f, "  {: >28}: {:?}", "calibrated_gyro_z", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageGyroscopeData {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageGyroscopeData>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageGyroscopeData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageGyroscopeData",
            timestamp: None,
            timestamp_ms: None,
            sample_time_offset: None,
            gyro_x: None,
            gyro_y: None,
            gyro_z: None,
            calibrated_gyro_x: None,
            calibrated_gyro_y: None,
            calibrated_gyro_z: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageGyroscopeData::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageGyroscopeData:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageGyroscopeData, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sample_time_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // gyro_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.gyro_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.gyro_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // gyro_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.gyro_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.gyro_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // gyro_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.gyro_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.gyro_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // calibrated_gyro_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_gyro_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_gyro_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // calibrated_gyro_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_gyro_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_gyro_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // calibrated_gyro_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_gyro_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_gyro_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageGyroscopeData {
    fn message_name(&self) -> &'static str {
        return "FitMessageGyroscopeData";
    }
}

#[derive(Debug)]
pub struct FitMessageHr {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub fractional_timestamp: Option<f64>,  
    pub time256: Option<f64>,  
    pub filtered_bpm: Option<Vec<Option<u8>>>,  
    pub event_timestamp: Option<Vec<Option<f64>>>,  
    pub event_timestamp_12: Option<Vec<u8>>,  
    
}

impl fmt::Display for FitMessageHr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHr")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.fractional_timestamp { writeln!(f, "  {: >28}: {:?}", "fractional_timestamp", v)?; }
        if let Some(v) = &self.time256 { writeln!(f, "  {: >28}: {:?}", "time256", v)?; }
        if let Some(v) = &self.filtered_bpm { writeln!(f, "  {: >28}: {:?}", "filtered_bpm", v)?; }
        if let Some(v) = &self.event_timestamp { writeln!(f, "  {: >28}: {:?}", "event_timestamp", v)?; }
        if let Some(v) = &self.event_timestamp_12 { writeln!(f, "  {: >28}: {:?}", "event_timestamp_12", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHr {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageHr>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageHr {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageHr",
            timestamp: None,
            fractional_timestamp: None,
            time256: None,
            filtered_bpm: None,
            event_timestamp: None,
            event_timestamp_12: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageHr::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageHr:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageHr, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // fractional_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // time256
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time256 = Some(result as f64 / 256 as f64) 
                                    },
                                    None => message.time256 = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time256 = Some(result as f64 / 256 as f64) 
                                    },
                                    None => message.time256 = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 0, field_size: 2, base_type: 0}, Some((0, 8)) ));
                        Ok(())
                    },
                
                    6 => {  // filtered_bpm
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.filtered_bpm = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.filtered_bpm = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // event_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.event_timestamp = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1024 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.event_timestamp = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1024 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // event_timestamp_12
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.event_timestamp_12 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.event_timestamp_12 = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((0, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((12, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((24, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((36, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((48, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((60, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((72, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((84, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((96, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 9, field_size: 4, base_type: 0}, Some((108, 12)) ));
                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageHr {
    fn message_name(&self) -> &'static str {
        return "FitMessageHr";
    }
}

#[derive(Debug)]
pub struct FitMessageHrZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub high_bpm: Option<u8>,  
    pub name: Option<String>,  
    
}

impl fmt::Display for FitMessageHrZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHrZone")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.high_bpm { writeln!(f, "  {: >28}: {:?}", "high_bpm", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHrZone {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageHrZone>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageHrZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageHrZone",
            message_index: None,
            high_bpm: None,
            name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageHrZone::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageHrZone:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageHrZone, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // high_bpm
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.high_bpm = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.high_bpm = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageHrZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageHrZone";
    }
}

#[derive(Debug)]
pub struct FitMessageHrmProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub enabled: Option<bool>,  
    pub hrm_ant_id: Option<u16>,  
    pub log_hrv: Option<bool>,  
    pub hrm_ant_id_trans_type: Option<u8>,  
    
}

impl fmt::Display for FitMessageHrmProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHrmProfile")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.hrm_ant_id { writeln!(f, "  {: >28}: {:?}", "hrm_ant_id", v)?; }
        if let Some(v) = &self.log_hrv { writeln!(f, "  {: >28}: {:?}", "log_hrv", v)?; }
        if let Some(v) = &self.hrm_ant_id_trans_type { writeln!(f, "  {: >28}: {:?}", "hrm_ant_id_trans_type", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHrmProfile {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageHrmProfile>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageHrmProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageHrmProfile",
            message_index: None,
            enabled: None,
            hrm_ant_id: None,
            log_hrv: None,
            hrm_ant_id_trans_type: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageHrmProfile::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageHrmProfile:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageHrmProfile, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // hrm_ant_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.hrm_ant_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.hrm_ant_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // log_hrv
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.log_hrv = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.log_hrv = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // hrm_ant_id_trans_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.hrm_ant_id_trans_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.hrm_ant_id_trans_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageHrmProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageHrmProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageHrv {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub time: Option<Vec<Option<f64>>>,  // Time between beats
    
}

impl fmt::Display for FitMessageHrv {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageHrv")?;
        if let Some(v) = &self.time { writeln!(f, "  {: >28}: {:?}", "time", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageHrv {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageHrv>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageHrv {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageHrv",
            time: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageHrv::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageHrv:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageHrv, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageHrv {
    fn message_name(&self) -> &'static str {
        return "FitMessageHrv";
    }
}

#[derive(Debug)]
pub enum FitMessageLapSubfieldTotalCycles {
    Default(Option<u32>),
    TotalStrides(Option<u32>),
}

impl FitMessageLapSubfieldTotalCycles {
    fn parse<'a>(message: &FitMessageLap, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageLapSubfieldTotalCycles> {
        
        match message.sport {
        
            Some(FitFieldSport::Running) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageLapSubfieldTotalCycles::TotalStrides(val))
                },
        
            Some(FitFieldSport::Walking) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageLapSubfieldTotalCycles::TotalStrides(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageLapSubfieldTotalCycles::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageLapSubfieldAvgCadence {
    Default(Option<u8>),
    AvgRunningCadence(Option<u8>),
}

impl FitMessageLapSubfieldAvgCadence {
    fn parse<'a>(message: &FitMessageLap, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageLapSubfieldAvgCadence> {
        
        match message.sport {
        
            Some(FitFieldSport::Running) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageLapSubfieldAvgCadence::AvgRunningCadence(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint8(&inp[0..f.field_size])?;
        Ok(FitMessageLapSubfieldAvgCadence::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageLapSubfieldMaxCadence {
    Default(Option<u8>),
    MaxRunningCadence(Option<u8>),
}

impl FitMessageLapSubfieldMaxCadence {
    fn parse<'a>(message: &FitMessageLap, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageLapSubfieldMaxCadence> {
        
        match message.sport {
        
            Some(FitFieldSport::Running) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageLapSubfieldMaxCadence::MaxRunningCadence(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint8(&inp[0..f.field_size])?;
        Ok(FitMessageLapSubfieldMaxCadence::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageLap {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub timestamp: Option<FitFieldDateTime>,  // Lap end time.
    pub event: Option<FitFieldEvent>,  
    pub event_type: Option<FitFieldEventType>,  
    pub start_time: Option<FitFieldDateTime>,  
    pub start_position_lat: Option<f64>,  
    pub start_position_long: Option<f64>,  
    pub end_position_lat: Option<f64>,  
    pub end_position_long: Option<f64>,  
    pub total_elapsed_time: Option<f64>,  // Time (includes pauses)
    pub total_timer_time: Option<f64>,  // Timer Time (excludes pauses)
    pub total_distance: Option<f64>,  
    pub total_cycles_subfield_bytes: Vec<u8>,
    pub total_cycles: Option<FitMessageLapSubfieldTotalCycles>,  
    pub total_calories: Option<u16>,  
    pub total_fat_calories: Option<u16>,  // If New Leaf
    pub avg_speed: Option<f64>,  
    pub max_speed: Option<f64>,  
    pub avg_heart_rate: Option<u8>,  
    pub max_heart_rate: Option<u8>,  
    pub avg_cadence_subfield_bytes: Vec<u8>,
    pub avg_cadence: Option<FitMessageLapSubfieldAvgCadence>,  // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
    pub max_cadence_subfield_bytes: Vec<u8>,
    pub max_cadence: Option<FitMessageLapSubfieldMaxCadence>,  
    pub avg_power: Option<u16>,  // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
    pub max_power: Option<u16>,  
    pub total_ascent: Option<u16>,  
    pub total_descent: Option<u16>,  
    pub intensity: Option<FitFieldIntensity>,  
    pub lap_trigger: Option<FitFieldLapTrigger>,  
    pub sport: Option<FitFieldSport>,  
    pub event_group: Option<u8>,  
    pub num_lengths: Option<u16>,  // # of lengths of swim pool
    pub normalized_power: Option<u16>,  
    pub left_right_balance: Option<FitFieldLeftRightBalance100>,  
    pub first_length_index: Option<u16>,  
    pub avg_stroke_distance: Option<f64>,  
    pub swim_stroke: Option<FitFieldSwimStroke>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub num_active_lengths: Option<u16>,  // # of active lengths of swim pool
    pub total_work: Option<u32>,  
    pub avg_altitude: Option<f64>,  
    pub max_altitude: Option<f64>,  
    pub gps_accuracy: Option<u8>,  
    pub avg_grade: Option<f64>,  
    pub avg_pos_grade: Option<f64>,  
    pub avg_neg_grade: Option<f64>,  
    pub max_pos_grade: Option<f64>,  
    pub max_neg_grade: Option<f64>,  
    pub avg_temperature: Option<i8>,  
    pub max_temperature: Option<i8>,  
    pub total_moving_time: Option<f64>,  
    pub avg_pos_vertical_speed: Option<f64>,  
    pub avg_neg_vertical_speed: Option<f64>,  
    pub max_pos_vertical_speed: Option<f64>,  
    pub max_neg_vertical_speed: Option<f64>,  
    pub time_in_hr_zone: Option<Vec<Option<f64>>>,  
    pub time_in_speed_zone: Option<Vec<Option<f64>>>,  
    pub time_in_cadence_zone: Option<Vec<Option<f64>>>,  
    pub time_in_power_zone: Option<Vec<Option<f64>>>,  
    pub repetition_num: Option<u16>,  
    pub min_altitude: Option<f64>,  
    pub min_heart_rate: Option<u8>,  
    pub wkt_step_index: Option<FitFieldMessageIndex>,  
    pub opponent_score: Option<u16>,  
    pub stroke_count: Option<Vec<Option<u16>>>,  // stroke_type enum used as the index
    pub zone_count: Option<Vec<Option<u16>>>,  // zone number used as the index
    pub avg_vertical_oscillation: Option<f64>,  
    pub avg_stance_time_percent: Option<f64>,  
    pub avg_stance_time: Option<f64>,  
    pub avg_fractional_cadence: Option<f64>,  // fractional part of the avg_cadence
    pub max_fractional_cadence: Option<f64>,  // fractional part of the max_cadence
    pub total_fractional_cycles: Option<f64>,  // fractional part of the total_cycles
    pub player_score: Option<u16>,  
    pub avg_total_hemoglobin_conc: Option<Vec<Option<f64>>>,  // Avg saturated and unsaturated hemoglobin
    pub min_total_hemoglobin_conc: Option<Vec<Option<f64>>>,  // Min saturated and unsaturated hemoglobin
    pub max_total_hemoglobin_conc: Option<Vec<Option<f64>>>,  // Max saturated and unsaturated hemoglobin
    pub avg_saturated_hemoglobin_percent: Option<Vec<Option<f64>>>,  // Avg percentage of hemoglobin saturated with oxygen
    pub min_saturated_hemoglobin_percent: Option<Vec<Option<f64>>>,  // Min percentage of hemoglobin saturated with oxygen
    pub max_saturated_hemoglobin_percent: Option<Vec<Option<f64>>>,  // Max percentage of hemoglobin saturated with oxygen
    pub avg_left_torque_effectiveness: Option<f64>,  
    pub avg_right_torque_effectiveness: Option<f64>,  
    pub avg_left_pedal_smoothness: Option<f64>,  
    pub avg_right_pedal_smoothness: Option<f64>,  
    pub avg_combined_pedal_smoothness: Option<f64>,  
    pub time_standing: Option<f64>,  // Total time spent in the standing position
    pub stand_count: Option<u16>,  // Number of transitions to the standing state
    pub avg_left_pco: Option<i8>,  // Average left platform center offset
    pub avg_right_pco: Option<i8>,  // Average right platform center offset
    pub avg_left_power_phase: Option<Vec<Option<f64>>>,  // Average left power phase angles. Data value indexes defined by power_phase_type.
    pub avg_left_power_phase_peak: Option<Vec<Option<f64>>>,  // Average left power phase peak angles. Data value indexes  defined by power_phase_type.
    pub avg_right_power_phase: Option<Vec<Option<f64>>>,  // Average right power phase angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase_peak: Option<Vec<Option<f64>>>,  // Average right power phase peak angles. Data value indexes  defined by power_phase_type.
    pub avg_power_position: Option<Vec<Option<u16>>>,  // Average power by position. Data value indexes defined by rider_position_type.
    pub max_power_position: Option<Vec<Option<u16>>>,  // Maximum power by position. Data value indexes defined by rider_position_type.
    pub avg_cadence_position: Option<Vec<Option<u8>>>,  // Average cadence by position. Data value indexes defined by rider_position_type.
    pub max_cadence_position: Option<Vec<Option<u8>>>,  // Maximum cadence by position. Data value indexes defined by rider_position_type.
    pub enhanced_avg_speed: Option<f64>,  
    pub enhanced_max_speed: Option<f64>,  
    pub enhanced_avg_altitude: Option<f64>,  
    pub enhanced_min_altitude: Option<f64>,  
    pub enhanced_max_altitude: Option<f64>,  
    pub avg_lev_motor_power: Option<u16>,  // lev average motor power during lap
    pub max_lev_motor_power: Option<u16>,  // lev maximum motor power during lap
    pub lev_battery_consumption: Option<f64>,  // lev battery consumption during lap
    pub avg_vertical_ratio: Option<f64>,  
    pub avg_stance_time_balance: Option<f64>,  
    pub avg_step_length: Option<f64>,  
    pub avg_vam: Option<f64>,  
    
}

impl fmt::Display for FitMessageLap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageLap")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.event { writeln!(f, "  {: >28}: {:?}", "event", v)?; }
        if let Some(v) = &self.event_type { writeln!(f, "  {: >28}: {:?}", "event_type", v)?; }
        if let Some(v) = &self.start_time { writeln!(f, "  {: >28}: {:?}", "start_time", v)?; }
        if let Some(v) = &self.start_position_lat { writeln!(f, "  {: >28}: {:?}", "start_position_lat", v)?; }
        if let Some(v) = &self.start_position_long { writeln!(f, "  {: >28}: {:?}", "start_position_long", v)?; }
        if let Some(v) = &self.end_position_lat { writeln!(f, "  {: >28}: {:?}", "end_position_lat", v)?; }
        if let Some(v) = &self.end_position_long { writeln!(f, "  {: >28}: {:?}", "end_position_long", v)?; }
        if let Some(v) = &self.total_elapsed_time { writeln!(f, "  {: >28}: {:?}", "total_elapsed_time", v)?; }
        if let Some(v) = &self.total_timer_time { writeln!(f, "  {: >28}: {:?}", "total_timer_time", v)?; }
        if let Some(v) = &self.total_distance { writeln!(f, "  {: >28}: {:?}", "total_distance", v)?; }
        writeln!(f, "  {: >28}: {:?}", "total_cycles_subfield_bytes", self.total_cycles_subfield_bytes)?;
        if let Some(v) = &self.total_cycles { writeln!(f, "  {: >28}: {:?}", "total_cycles", v)?; }
        if let Some(v) = &self.total_calories { writeln!(f, "  {: >28}: {:?}", "total_calories", v)?; }
        if let Some(v) = &self.total_fat_calories { writeln!(f, "  {: >28}: {:?}", "total_fat_calories", v)?; }
        if let Some(v) = &self.avg_speed { writeln!(f, "  {: >28}: {:?}", "avg_speed", v)?; }
        if let Some(v) = &self.max_speed { writeln!(f, "  {: >28}: {:?}", "max_speed", v)?; }
        if let Some(v) = &self.avg_heart_rate { writeln!(f, "  {: >28}: {:?}", "avg_heart_rate", v)?; }
        if let Some(v) = &self.max_heart_rate { writeln!(f, "  {: >28}: {:?}", "max_heart_rate", v)?; }
        writeln!(f, "  {: >28}: {:?}", "avg_cadence_subfield_bytes", self.avg_cadence_subfield_bytes)?;
        if let Some(v) = &self.avg_cadence { writeln!(f, "  {: >28}: {:?}", "avg_cadence", v)?; }
        writeln!(f, "  {: >28}: {:?}", "max_cadence_subfield_bytes", self.max_cadence_subfield_bytes)?;
        if let Some(v) = &self.max_cadence { writeln!(f, "  {: >28}: {:?}", "max_cadence", v)?; }
        if let Some(v) = &self.avg_power { writeln!(f, "  {: >28}: {:?}", "avg_power", v)?; }
        if let Some(v) = &self.max_power { writeln!(f, "  {: >28}: {:?}", "max_power", v)?; }
        if let Some(v) = &self.total_ascent { writeln!(f, "  {: >28}: {:?}", "total_ascent", v)?; }
        if let Some(v) = &self.total_descent { writeln!(f, "  {: >28}: {:?}", "total_descent", v)?; }
        if let Some(v) = &self.intensity { writeln!(f, "  {: >28}: {:?}", "intensity", v)?; }
        if let Some(v) = &self.lap_trigger { writeln!(f, "  {: >28}: {:?}", "lap_trigger", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.event_group { writeln!(f, "  {: >28}: {:?}", "event_group", v)?; }
        if let Some(v) = &self.num_lengths { writeln!(f, "  {: >28}: {:?}", "num_lengths", v)?; }
        if let Some(v) = &self.normalized_power { writeln!(f, "  {: >28}: {:?}", "normalized_power", v)?; }
        if let Some(v) = &self.left_right_balance { writeln!(f, "  {: >28}: {:?}", "left_right_balance", v)?; }
        if let Some(v) = &self.first_length_index { writeln!(f, "  {: >28}: {:?}", "first_length_index", v)?; }
        if let Some(v) = &self.avg_stroke_distance { writeln!(f, "  {: >28}: {:?}", "avg_stroke_distance", v)?; }
        if let Some(v) = &self.swim_stroke { writeln!(f, "  {: >28}: {:?}", "swim_stroke", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.num_active_lengths { writeln!(f, "  {: >28}: {:?}", "num_active_lengths", v)?; }
        if let Some(v) = &self.total_work { writeln!(f, "  {: >28}: {:?}", "total_work", v)?; }
        if let Some(v) = &self.avg_altitude { writeln!(f, "  {: >28}: {:?}", "avg_altitude", v)?; }
        if let Some(v) = &self.max_altitude { writeln!(f, "  {: >28}: {:?}", "max_altitude", v)?; }
        if let Some(v) = &self.gps_accuracy { writeln!(f, "  {: >28}: {:?}", "gps_accuracy", v)?; }
        if let Some(v) = &self.avg_grade { writeln!(f, "  {: >28}: {:?}", "avg_grade", v)?; }
        if let Some(v) = &self.avg_pos_grade { writeln!(f, "  {: >28}: {:?}", "avg_pos_grade", v)?; }
        if let Some(v) = &self.avg_neg_grade { writeln!(f, "  {: >28}: {:?}", "avg_neg_grade", v)?; }
        if let Some(v) = &self.max_pos_grade { writeln!(f, "  {: >28}: {:?}", "max_pos_grade", v)?; }
        if let Some(v) = &self.max_neg_grade { writeln!(f, "  {: >28}: {:?}", "max_neg_grade", v)?; }
        if let Some(v) = &self.avg_temperature { writeln!(f, "  {: >28}: {:?}", "avg_temperature", v)?; }
        if let Some(v) = &self.max_temperature { writeln!(f, "  {: >28}: {:?}", "max_temperature", v)?; }
        if let Some(v) = &self.total_moving_time { writeln!(f, "  {: >28}: {:?}", "total_moving_time", v)?; }
        if let Some(v) = &self.avg_pos_vertical_speed { writeln!(f, "  {: >28}: {:?}", "avg_pos_vertical_speed", v)?; }
        if let Some(v) = &self.avg_neg_vertical_speed { writeln!(f, "  {: >28}: {:?}", "avg_neg_vertical_speed", v)?; }
        if let Some(v) = &self.max_pos_vertical_speed { writeln!(f, "  {: >28}: {:?}", "max_pos_vertical_speed", v)?; }
        if let Some(v) = &self.max_neg_vertical_speed { writeln!(f, "  {: >28}: {:?}", "max_neg_vertical_speed", v)?; }
        if let Some(v) = &self.time_in_hr_zone { writeln!(f, "  {: >28}: {:?}", "time_in_hr_zone", v)?; }
        if let Some(v) = &self.time_in_speed_zone { writeln!(f, "  {: >28}: {:?}", "time_in_speed_zone", v)?; }
        if let Some(v) = &self.time_in_cadence_zone { writeln!(f, "  {: >28}: {:?}", "time_in_cadence_zone", v)?; }
        if let Some(v) = &self.time_in_power_zone { writeln!(f, "  {: >28}: {:?}", "time_in_power_zone", v)?; }
        if let Some(v) = &self.repetition_num { writeln!(f, "  {: >28}: {:?}", "repetition_num", v)?; }
        if let Some(v) = &self.min_altitude { writeln!(f, "  {: >28}: {:?}", "min_altitude", v)?; }
        if let Some(v) = &self.min_heart_rate { writeln!(f, "  {: >28}: {:?}", "min_heart_rate", v)?; }
        if let Some(v) = &self.wkt_step_index { writeln!(f, "  {: >28}: {:?}", "wkt_step_index", v)?; }
        if let Some(v) = &self.opponent_score { writeln!(f, "  {: >28}: {:?}", "opponent_score", v)?; }
        if let Some(v) = &self.stroke_count { writeln!(f, "  {: >28}: {:?}", "stroke_count", v)?; }
        if let Some(v) = &self.zone_count { writeln!(f, "  {: >28}: {:?}", "zone_count", v)?; }
        if let Some(v) = &self.avg_vertical_oscillation { writeln!(f, "  {: >28}: {:?}", "avg_vertical_oscillation", v)?; }
        if let Some(v) = &self.avg_stance_time_percent { writeln!(f, "  {: >28}: {:?}", "avg_stance_time_percent", v)?; }
        if let Some(v) = &self.avg_stance_time { writeln!(f, "  {: >28}: {:?}", "avg_stance_time", v)?; }
        if let Some(v) = &self.avg_fractional_cadence { writeln!(f, "  {: >28}: {:?}", "avg_fractional_cadence", v)?; }
        if let Some(v) = &self.max_fractional_cadence { writeln!(f, "  {: >28}: {:?}", "max_fractional_cadence", v)?; }
        if let Some(v) = &self.total_fractional_cycles { writeln!(f, "  {: >28}: {:?}", "total_fractional_cycles", v)?; }
        if let Some(v) = &self.player_score { writeln!(f, "  {: >28}: {:?}", "player_score", v)?; }
        if let Some(v) = &self.avg_total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "avg_total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.min_total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "min_total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.max_total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "max_total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.avg_saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "avg_saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.min_saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "min_saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.max_saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "max_saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.avg_left_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "avg_left_torque_effectiveness", v)?; }
        if let Some(v) = &self.avg_right_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "avg_right_torque_effectiveness", v)?; }
        if let Some(v) = &self.avg_left_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_left_pedal_smoothness", v)?; }
        if let Some(v) = &self.avg_right_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_right_pedal_smoothness", v)?; }
        if let Some(v) = &self.avg_combined_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_combined_pedal_smoothness", v)?; }
        if let Some(v) = &self.time_standing { writeln!(f, "  {: >28}: {:?}", "time_standing", v)?; }
        if let Some(v) = &self.stand_count { writeln!(f, "  {: >28}: {:?}", "stand_count", v)?; }
        if let Some(v) = &self.avg_left_pco { writeln!(f, "  {: >28}: {:?}", "avg_left_pco", v)?; }
        if let Some(v) = &self.avg_right_pco { writeln!(f, "  {: >28}: {:?}", "avg_right_pco", v)?; }
        if let Some(v) = &self.avg_left_power_phase { writeln!(f, "  {: >28}: {:?}", "avg_left_power_phase", v)?; }
        if let Some(v) = &self.avg_left_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "avg_left_power_phase_peak", v)?; }
        if let Some(v) = &self.avg_right_power_phase { writeln!(f, "  {: >28}: {:?}", "avg_right_power_phase", v)?; }
        if let Some(v) = &self.avg_right_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "avg_right_power_phase_peak", v)?; }
        if let Some(v) = &self.avg_power_position { writeln!(f, "  {: >28}: {:?}", "avg_power_position", v)?; }
        if let Some(v) = &self.max_power_position { writeln!(f, "  {: >28}: {:?}", "max_power_position", v)?; }
        if let Some(v) = &self.avg_cadence_position { writeln!(f, "  {: >28}: {:?}", "avg_cadence_position", v)?; }
        if let Some(v) = &self.max_cadence_position { writeln!(f, "  {: >28}: {:?}", "max_cadence_position", v)?; }
        if let Some(v) = &self.enhanced_avg_speed { writeln!(f, "  {: >28}: {:?}", "enhanced_avg_speed", v)?; }
        if let Some(v) = &self.enhanced_max_speed { writeln!(f, "  {: >28}: {:?}", "enhanced_max_speed", v)?; }
        if let Some(v) = &self.enhanced_avg_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_avg_altitude", v)?; }
        if let Some(v) = &self.enhanced_min_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_min_altitude", v)?; }
        if let Some(v) = &self.enhanced_max_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_max_altitude", v)?; }
        if let Some(v) = &self.avg_lev_motor_power { writeln!(f, "  {: >28}: {:?}", "avg_lev_motor_power", v)?; }
        if let Some(v) = &self.max_lev_motor_power { writeln!(f, "  {: >28}: {:?}", "max_lev_motor_power", v)?; }
        if let Some(v) = &self.lev_battery_consumption { writeln!(f, "  {: >28}: {:?}", "lev_battery_consumption", v)?; }
        if let Some(v) = &self.avg_vertical_ratio { writeln!(f, "  {: >28}: {:?}", "avg_vertical_ratio", v)?; }
        if let Some(v) = &self.avg_stance_time_balance { writeln!(f, "  {: >28}: {:?}", "avg_stance_time_balance", v)?; }
        if let Some(v) = &self.avg_step_length { writeln!(f, "  {: >28}: {:?}", "avg_step_length", v)?; }
        if let Some(v) = &self.avg_vam { writeln!(f, "  {: >28}: {:?}", "avg_vam", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageLap {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageLap>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageLap {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageLap",
            message_index: None,
            timestamp: None,
            event: None,
            event_type: None,
            start_time: None,
            start_position_lat: None,
            start_position_long: None,
            end_position_lat: None,
            end_position_long: None,
            total_elapsed_time: None,
            total_timer_time: None,
            total_distance: None,
            total_cycles_subfield_bytes: vec![],
            total_cycles: None,
            total_calories: None,
            total_fat_calories: None,
            avg_speed: None,
            max_speed: None,
            avg_heart_rate: None,
            max_heart_rate: None,
            avg_cadence_subfield_bytes: vec![],
            avg_cadence: None,
            max_cadence_subfield_bytes: vec![],
            max_cadence: None,
            avg_power: None,
            max_power: None,
            total_ascent: None,
            total_descent: None,
            intensity: None,
            lap_trigger: None,
            sport: None,
            event_group: None,
            num_lengths: None,
            normalized_power: None,
            left_right_balance: None,
            first_length_index: None,
            avg_stroke_distance: None,
            swim_stroke: None,
            sub_sport: None,
            num_active_lengths: None,
            total_work: None,
            avg_altitude: None,
            max_altitude: None,
            gps_accuracy: None,
            avg_grade: None,
            avg_pos_grade: None,
            avg_neg_grade: None,
            max_pos_grade: None,
            max_neg_grade: None,
            avg_temperature: None,
            max_temperature: None,
            total_moving_time: None,
            avg_pos_vertical_speed: None,
            avg_neg_vertical_speed: None,
            max_pos_vertical_speed: None,
            max_neg_vertical_speed: None,
            time_in_hr_zone: None,
            time_in_speed_zone: None,
            time_in_cadence_zone: None,
            time_in_power_zone: None,
            repetition_num: None,
            min_altitude: None,
            min_heart_rate: None,
            wkt_step_index: None,
            opponent_score: None,
            stroke_count: None,
            zone_count: None,
            avg_vertical_oscillation: None,
            avg_stance_time_percent: None,
            avg_stance_time: None,
            avg_fractional_cadence: None,
            max_fractional_cadence: None,
            total_fractional_cycles: None,
            player_score: None,
            avg_total_hemoglobin_conc: None,
            min_total_hemoglobin_conc: None,
            max_total_hemoglobin_conc: None,
            avg_saturated_hemoglobin_percent: None,
            min_saturated_hemoglobin_percent: None,
            max_saturated_hemoglobin_percent: None,
            avg_left_torque_effectiveness: None,
            avg_right_torque_effectiveness: None,
            avg_left_pedal_smoothness: None,
            avg_right_pedal_smoothness: None,
            avg_combined_pedal_smoothness: None,
            time_standing: None,
            stand_count: None,
            avg_left_pco: None,
            avg_right_pco: None,
            avg_left_power_phase: None,
            avg_left_power_phase_peak: None,
            avg_right_power_phase: None,
            avg_right_power_phase_peak: None,
            avg_power_position: None,
            max_power_position: None,
            avg_cadence_position: None,
            max_cadence_position: None,
            enhanced_avg_speed: None,
            enhanced_max_speed: None,
            enhanced_avg_altitude: None,
            enhanced_min_altitude: None,
            enhanced_max_altitude: None,
            avg_lev_motor_power: None,
            max_lev_motor_power: None,
            lev_battery_consumption: None,
            avg_vertical_ratio: None,
            avg_stance_time_balance: None,
            avg_step_length: None,
            avg_vam: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageLap::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageLap:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageLap::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageLap:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageLap, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 10).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageLapSubfieldTotalCycles::parse(message, &message.total_cycles_subfield_bytes, &field, _tz_offset)?;
            message.total_cycles = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 17).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageLapSubfieldAvgCadence::parse(message, &message.avg_cadence_subfield_bytes, &field, _tz_offset)?;
            message.avg_cadence = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 18).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageLapSubfieldMaxCadence::parse(message, &message.max_cadence_subfield_bytes, &field, _tz_offset)?;
            message.max_cadence = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageLap, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEvent::parse(&inp[0..f.field_size])?;
                                
                                message.event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEventType::parse(&inp[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // start_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // start_position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // start_position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // end_position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // end_position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // total_elapsed_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // total_timer_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // total_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // total_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.total_cycles_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.total_cycles_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // total_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // total_fat_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_fat_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_fat_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // avg_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 110, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    14 => {  // max_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_speed = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 111, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    15 => {  // avg_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.avg_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    16 => {  // max_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // avg_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.avg_cadence_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.avg_cadence_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // max_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.max_cadence_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.max_cadence_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // avg_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // max_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // total_ascent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_ascent = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_ascent = val;
                            }
                        }

                        Ok(())
                    },
                
                    22 => {  // total_descent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_descent = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_descent = val;
                            }
                        }

                        Ok(())
                    },
                
                    23 => {  // intensity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldIntensity::parse(&&bytes[0..f.field_size])?;
                                
                                message.intensity = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldIntensity::parse(&inp[0..f.field_size])?;
                                
                                message.intensity = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    24 => {  // lap_trigger
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLapTrigger::parse(&&bytes[0..f.field_size])?;
                                
                                message.lap_trigger = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLapTrigger::parse(&inp[0..f.field_size])?;
                                
                                message.lap_trigger = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    25 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    26 => {  // event_group
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.event_group = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.event_group = val;
                            }
                        }

                        Ok(())
                    },
                
                    32 => {  // num_lengths
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_lengths = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_lengths = val;
                            }
                        }

                        Ok(())
                    },
                
                    33 => {  // normalized_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.normalized_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.normalized_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    34 => {  // left_right_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLeftRightBalance100::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.left_right_balance = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLeftRightBalance100::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.left_right_balance = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    35 => {  // first_length_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.first_length_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.first_length_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    37 => {  // avg_stroke_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stroke_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stroke_distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stroke_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stroke_distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    38 => {  // swim_stroke
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSwimStroke::parse(&&bytes[0..f.field_size])?;
                                
                                message.swim_stroke = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSwimStroke::parse(&inp[0..f.field_size])?;
                                
                                message.swim_stroke = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    39 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    40 => {  // num_active_lengths
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_active_lengths = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_active_lengths = val;
                            }
                        }

                        Ok(())
                    },
                
                    41 => {  // total_work
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_work = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_work = val;
                            }
                        }

                        Ok(())
                    },
                
                    42 => {  // avg_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.avg_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.avg_altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 112, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    43 => {  // max_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.max_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.max_altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 114, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    44 => {  // gps_accuracy
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            }
                        }

                        Ok(())
                    },
                
                    45 => {  // avg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    46 => {  // avg_pos_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_pos_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_pos_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    47 => {  // avg_neg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_neg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_neg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    48 => {  // max_pos_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_pos_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_pos_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    49 => {  // max_neg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_neg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_neg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    50 => {  // avg_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    51 => {  // max_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.max_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.max_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    52 => {  // total_moving_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_moving_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_moving_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_moving_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_moving_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    53 => {  // avg_pos_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_pos_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_pos_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    54 => {  // avg_neg_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_neg_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_neg_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    55 => {  // max_pos_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_pos_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_pos_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    56 => {  // max_neg_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_neg_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_neg_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    57 => {  // time_in_hr_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_hr_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_hr_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    58 => {  // time_in_speed_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_speed_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_speed_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    59 => {  // time_in_cadence_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_cadence_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_cadence_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    60 => {  // time_in_power_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_power_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_power_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    61 => {  // repetition_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.repetition_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.repetition_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    62 => {  // min_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.min_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.min_altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 113, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    63 => {  // min_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.min_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.min_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    71 => {  // wkt_step_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wkt_step_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wkt_step_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    74 => {  // opponent_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    75 => {  // stroke_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stroke_count = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stroke_count = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    76 => {  // zone_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.zone_count = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.zone_count = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    77 => {  // avg_vertical_oscillation
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_oscillation = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_vertical_oscillation = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_oscillation = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_vertical_oscillation = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    78 => {  // avg_stance_time_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_percent = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_percent = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_percent = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_percent = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    79 => {  // avg_stance_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_stance_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_stance_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    80 => {  // avg_fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.avg_fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.avg_fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    81 => {  // max_fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.max_fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.max_fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    82 => {  // total_fractional_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_fractional_cycles = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.total_fractional_cycles = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_fractional_cycles = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.total_fractional_cycles = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    83 => {  // player_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.player_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.player_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    84 => {  // avg_total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    85 => {  // min_total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    86 => {  // max_total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    87 => {  // avg_saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    88 => {  // min_saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    89 => {  // max_saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    91 => {  // avg_left_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    92 => {  // avg_right_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    93 => {  // avg_left_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    94 => {  // avg_right_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    95 => {  // avg_combined_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_combined_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_combined_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    98 => {  // time_standing
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_standing = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_standing = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_standing = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_standing = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    99 => {  // stand_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stand_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stand_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    100 => {  // avg_left_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_left_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_left_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    101 => {  // avg_right_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_right_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_right_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    102 => {  // avg_left_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    103 => {  // avg_left_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    104 => {  // avg_right_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    105 => {  // avg_right_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    106 => {  // avg_power_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_power_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_power_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    107 => {  // max_power_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_power_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_power_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    108 => {  // avg_cadence_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_cadence_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_cadence_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    109 => {  // max_cadence_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_cadence_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_cadence_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    110 => {  // enhanced_avg_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_avg_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_avg_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    111 => {  // enhanced_max_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_max_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_max_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    112 => {  // enhanced_avg_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_avg_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_avg_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    113 => {  // enhanced_min_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_min_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_min_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    114 => {  // enhanced_max_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_max_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_max_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    115 => {  // avg_lev_motor_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_lev_motor_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_lev_motor_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    116 => {  // max_lev_motor_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_lev_motor_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_lev_motor_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    117 => {  // lev_battery_consumption
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.lev_battery_consumption = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.lev_battery_consumption = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.lev_battery_consumption = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.lev_battery_consumption = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    118 => {  // avg_vertical_ratio
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_ratio = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_vertical_ratio = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_ratio = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_vertical_ratio = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    119 => {  // avg_stance_time_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_balance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_balance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_balance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_balance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    120 => {  // avg_step_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_step_length = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_step_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_step_length = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_step_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    121 => {  // avg_vam
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vam = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_vam = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vam = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_vam = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageLap {
    fn message_name(&self) -> &'static str {
        return "FitMessageLap";
    }
}

#[derive(Debug)]
pub struct FitMessageLength {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub timestamp: Option<FitFieldDateTime>,  
    pub event: Option<FitFieldEvent>,  
    pub event_type: Option<FitFieldEventType>,  
    pub start_time: Option<FitFieldDateTime>,  
    pub total_elapsed_time: Option<f64>,  
    pub total_timer_time: Option<f64>,  
    pub total_strokes: Option<u16>,  
    pub avg_speed: Option<f64>,  
    pub swim_stroke: Option<FitFieldSwimStroke>,  
    pub avg_swimming_cadence: Option<u8>,  
    pub event_group: Option<u8>,  
    pub total_calories: Option<u16>,  
    pub length_type: Option<FitFieldLengthType>,  
    pub player_score: Option<u16>,  
    pub opponent_score: Option<u16>,  
    pub stroke_count: Option<Vec<Option<u16>>>,  // stroke_type enum used as the index
    pub zone_count: Option<Vec<Option<u16>>>,  // zone number used as the index
    
}

impl fmt::Display for FitMessageLength {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageLength")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.event { writeln!(f, "  {: >28}: {:?}", "event", v)?; }
        if let Some(v) = &self.event_type { writeln!(f, "  {: >28}: {:?}", "event_type", v)?; }
        if let Some(v) = &self.start_time { writeln!(f, "  {: >28}: {:?}", "start_time", v)?; }
        if let Some(v) = &self.total_elapsed_time { writeln!(f, "  {: >28}: {:?}", "total_elapsed_time", v)?; }
        if let Some(v) = &self.total_timer_time { writeln!(f, "  {: >28}: {:?}", "total_timer_time", v)?; }
        if let Some(v) = &self.total_strokes { writeln!(f, "  {: >28}: {:?}", "total_strokes", v)?; }
        if let Some(v) = &self.avg_speed { writeln!(f, "  {: >28}: {:?}", "avg_speed", v)?; }
        if let Some(v) = &self.swim_stroke { writeln!(f, "  {: >28}: {:?}", "swim_stroke", v)?; }
        if let Some(v) = &self.avg_swimming_cadence { writeln!(f, "  {: >28}: {:?}", "avg_swimming_cadence", v)?; }
        if let Some(v) = &self.event_group { writeln!(f, "  {: >28}: {:?}", "event_group", v)?; }
        if let Some(v) = &self.total_calories { writeln!(f, "  {: >28}: {:?}", "total_calories", v)?; }
        if let Some(v) = &self.length_type { writeln!(f, "  {: >28}: {:?}", "length_type", v)?; }
        if let Some(v) = &self.player_score { writeln!(f, "  {: >28}: {:?}", "player_score", v)?; }
        if let Some(v) = &self.opponent_score { writeln!(f, "  {: >28}: {:?}", "opponent_score", v)?; }
        if let Some(v) = &self.stroke_count { writeln!(f, "  {: >28}: {:?}", "stroke_count", v)?; }
        if let Some(v) = &self.zone_count { writeln!(f, "  {: >28}: {:?}", "zone_count", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageLength {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageLength>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageLength {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageLength",
            message_index: None,
            timestamp: None,
            event: None,
            event_type: None,
            start_time: None,
            total_elapsed_time: None,
            total_timer_time: None,
            total_strokes: None,
            avg_speed: None,
            swim_stroke: None,
            avg_swimming_cadence: None,
            event_group: None,
            total_calories: None,
            length_type: None,
            player_score: None,
            opponent_score: None,
            stroke_count: None,
            zone_count: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageLength::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageLength:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageLength, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEvent::parse(&inp[0..f.field_size])?;
                                
                                message.event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEventType::parse(&inp[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // start_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // total_elapsed_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // total_timer_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // total_strokes
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_strokes = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_strokes = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // avg_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // swim_stroke
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSwimStroke::parse(&&bytes[0..f.field_size])?;
                                
                                message.swim_stroke = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSwimStroke::parse(&inp[0..f.field_size])?;
                                
                                message.swim_stroke = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // avg_swimming_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_swimming_cadence = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.avg_swimming_cadence = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // event_group
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.event_group = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.event_group = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // total_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // length_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLengthType::parse(&&bytes[0..f.field_size])?;
                                
                                message.length_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLengthType::parse(&inp[0..f.field_size])?;
                                
                                message.length_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // player_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.player_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.player_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // opponent_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // stroke_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stroke_count = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stroke_count = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // zone_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.zone_count = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.zone_count = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageLength {
    fn message_name(&self) -> &'static str {
        return "FitMessageLength";
    }
}

#[derive(Debug)]
pub struct FitMessageMagnetometerData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub sample_time_offset: Option<Vec<Option<u16>>>,  // Each time in the array describes the time at which the compass sample with the corrosponding index was taken. Limited to 30 samples in each message. The samples may span across seconds. Array size must match the number of samples in cmps_x and cmps_y and cmps_z
    pub mag_x: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub mag_y: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub mag_z: Option<Vec<Option<u16>>>,  // These are the raw ADC reading. Maximum number of samples is 30 in each message. The samples may span across seconds. A conversion will need to be done on this data once read.
    pub calibrated_mag_x: Option<Vec<Option<f32>>>,  // Calibrated Magnetometer reading
    pub calibrated_mag_y: Option<Vec<Option<f32>>>,  // Calibrated Magnetometer reading
    pub calibrated_mag_z: Option<Vec<Option<f32>>>,  // Calibrated Magnetometer reading
    
}

impl fmt::Display for FitMessageMagnetometerData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMagnetometerData")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.sample_time_offset { writeln!(f, "  {: >28}: {:?}", "sample_time_offset", v)?; }
        if let Some(v) = &self.mag_x { writeln!(f, "  {: >28}: {:?}", "mag_x", v)?; }
        if let Some(v) = &self.mag_y { writeln!(f, "  {: >28}: {:?}", "mag_y", v)?; }
        if let Some(v) = &self.mag_z { writeln!(f, "  {: >28}: {:?}", "mag_z", v)?; }
        if let Some(v) = &self.calibrated_mag_x { writeln!(f, "  {: >28}: {:?}", "calibrated_mag_x", v)?; }
        if let Some(v) = &self.calibrated_mag_y { writeln!(f, "  {: >28}: {:?}", "calibrated_mag_y", v)?; }
        if let Some(v) = &self.calibrated_mag_z { writeln!(f, "  {: >28}: {:?}", "calibrated_mag_z", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMagnetometerData {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageMagnetometerData>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageMagnetometerData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageMagnetometerData",
            timestamp: None,
            timestamp_ms: None,
            sample_time_offset: None,
            mag_x: None,
            mag_y: None,
            mag_z: None,
            calibrated_mag_x: None,
            calibrated_mag_y: None,
            calibrated_mag_z: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageMagnetometerData::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageMagnetometerData:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageMagnetometerData, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sample_time_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.sample_time_offset = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // mag_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.mag_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.mag_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // mag_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.mag_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.mag_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // mag_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.mag_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.mag_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // calibrated_mag_x
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_mag_x = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_mag_x = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // calibrated_mag_y
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_mag_y = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_mag_y = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // calibrated_mag_z
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_mag_z = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_float32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.calibrated_mag_z = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageMagnetometerData {
    fn message_name(&self) -> &'static str {
        return "FitMessageMagnetometerData";
    }
}

#[derive(Debug)]
pub struct FitMessageMemoGlob {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub part_index: Option<u32>,  // Sequence number of memo blocks
    pub memo: Option<Vec<u8>>,  // Block of utf8 bytes
    pub message_number: Option<u16>,  // Allows relating glob to another mesg  If used only required for first part of each memo_glob
    pub message_index: Option<FitFieldMessageIndex>,  // Index of external mesg
    
}

impl fmt::Display for FitMessageMemoGlob {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMemoGlob")?;
        if let Some(v) = &self.part_index { writeln!(f, "  {: >28}: {:?}", "part_index", v)?; }
        if let Some(v) = &self.memo { writeln!(f, "  {: >28}: {:?}", "memo", v)?; }
        if let Some(v) = &self.message_number { writeln!(f, "  {: >28}: {:?}", "message_number", v)?; }
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMemoGlob {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageMemoGlob>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageMemoGlob {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageMemoGlob",
            part_index: None,
            memo: None,
            message_number: None,
            message_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageMemoGlob::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageMemoGlob:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageMemoGlob, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    250 => {  // part_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.part_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.part_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // memo
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.memo = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.memo = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // message_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageMemoGlob {
    fn message_name(&self) -> &'static str {
        return "FitMessageMemoGlob";
    }
}

#[derive(Debug)]
pub enum FitMessageMesgCapabilitiesSubfieldCount {
    Default(Option<u16>),
    MaxPerFileType(Option<u16>),
    MaxPerFile(Option<u16>),
    NumPerFile(Option<u16>),
}

impl FitMessageMesgCapabilitiesSubfieldCount {
    fn parse<'a>(message: &FitMessageMesgCapabilities, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageMesgCapabilitiesSubfieldCount> {
        
        match message.count_type {
        
            Some(FitFieldMesgCount::NumPerFile) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMesgCapabilitiesSubfieldCount::NumPerFile(val))
                },
        
            Some(FitFieldMesgCount::MaxPerFile) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMesgCapabilitiesSubfieldCount::MaxPerFile(val))
                },
        
            Some(FitFieldMesgCount::MaxPerFileType) => {
                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMesgCapabilitiesSubfieldCount::MaxPerFileType(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageMesgCapabilitiesSubfieldCount::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageMesgCapabilities {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub file: Option<FitFieldFile>,  
    pub mesg_num: Option<FitFieldMesgNum>,  
    pub count_type: Option<FitFieldMesgCount>,  
    pub count_subfield_bytes: Vec<u8>,
    pub count: Option<FitMessageMesgCapabilitiesSubfieldCount>,  
    
}

impl fmt::Display for FitMessageMesgCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMesgCapabilities")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.file { writeln!(f, "  {: >28}: {:?}", "file", v)?; }
        if let Some(v) = &self.mesg_num { writeln!(f, "  {: >28}: {:?}", "mesg_num", v)?; }
        if let Some(v) = &self.count_type { writeln!(f, "  {: >28}: {:?}", "count_type", v)?; }
        writeln!(f, "  {: >28}: {:?}", "count_subfield_bytes", self.count_subfield_bytes)?;
        if let Some(v) = &self.count { writeln!(f, "  {: >28}: {:?}", "count", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMesgCapabilities {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageMesgCapabilities>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageMesgCapabilities {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageMesgCapabilities",
            message_index: None,
            file: None,
            mesg_num: None,
            count_type: None,
            count_subfield_bytes: vec![],
            count: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageMesgCapabilities::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageMesgCapabilities:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageMesgCapabilities::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageMesgCapabilities:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageMesgCapabilities, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 3).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageMesgCapabilitiesSubfieldCount::parse(message, &message.count_subfield_bytes, &field, _tz_offset)?;
            message.count = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageMesgCapabilities, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // file
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFile::parse(&&bytes[0..f.field_size])?;
                                
                                message.file = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFile::parse(&inp[0..f.field_size])?;
                                
                                message.file = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // mesg_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMesgNum::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.mesg_num = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMesgNum::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.mesg_num = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // count_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMesgCount::parse(&&bytes[0..f.field_size])?;
                                
                                message.count_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMesgCount::parse(&inp[0..f.field_size])?;
                                
                                message.count_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.count_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.count_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageMesgCapabilities {
    fn message_name(&self) -> &'static str {
        return "FitMessageMesgCapabilities";
    }
}

#[derive(Debug)]
pub struct FitMessageMetZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub high_bpm: Option<u8>,  
    pub calories: Option<f64>,  
    pub fat_calories: Option<f64>,  
    
}

impl fmt::Display for FitMessageMetZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMetZone")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.high_bpm { writeln!(f, "  {: >28}: {:?}", "high_bpm", v)?; }
        if let Some(v) = &self.calories { writeln!(f, "  {: >28}: {:?}", "calories", v)?; }
        if let Some(v) = &self.fat_calories { writeln!(f, "  {: >28}: {:?}", "fat_calories", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMetZone {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageMetZone>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageMetZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageMetZone",
            message_index: None,
            high_bpm: None,
            calories: None,
            fat_calories: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageMetZone::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageMetZone:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageMetZone, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // high_bpm
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.high_bpm = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.high_bpm = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.calories = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.calories = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.calories = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.calories = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // fat_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fat_calories = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.fat_calories = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fat_calories = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.fat_calories = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageMetZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageMetZone";
    }
}

#[derive(Debug)]
pub enum FitMessageMonitoringSubfieldCycles {
    Default(Option<u32>),
    Steps(Option<u32>),
    Strokes(Option<u32>),
}

impl FitMessageMonitoringSubfieldCycles {
    fn parse<'a>(message: &FitMessageMonitoring, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageMonitoringSubfieldCycles> {
        
        match message.activity_type {
        
            Some(FitFieldActivityType::Walking) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMonitoringSubfieldCycles::Steps(val))
                },
        
            Some(FitFieldActivityType::Running) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMonitoringSubfieldCycles::Steps(val))
                },
        
            Some(FitFieldActivityType::Cycling) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMonitoringSubfieldCycles::Strokes(val))
                },
        
            Some(FitFieldActivityType::Swimming) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageMonitoringSubfieldCycles::Strokes(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageMonitoringSubfieldCycles::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageMonitoring {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Must align to logging interval, for example, time must be 00:00:00 for daily log.
    pub device_index: Option<FitFieldDeviceIndex>,  // Associates this data to device_info message.  Not required for file with single device (sensor).
    pub calories: Option<u16>,  // Accumulated total calories.  Maintained by MonitoringReader for each activity_type.  See SDK documentation
    pub distance: Option<f64>,  // Accumulated distance.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
    pub cycles_subfield_bytes: Vec<u8>,
    pub cycles: Option<FitMessageMonitoringSubfieldCycles>,  // Accumulated cycles.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
    pub active_time: Option<f64>,  
    pub activity_type: Option<FitFieldActivityType>,  
    pub activity_subtype: Option<FitFieldActivitySubtype>,  
    pub activity_level: Option<FitFieldActivityLevel>,  
    pub distance_16: Option<u16>,  
    pub cycles_16: Option<u16>,  
    pub active_time_16: Option<u16>,  
    pub local_timestamp: Option<FitFieldLocalDateTime>,  // Must align to logging interval, for example, time must be 00:00:00 for daily log.
    pub temperature: Option<f64>,  // Avg temperature during the logging interval ended at timestamp
    pub temperature_min: Option<f64>,  // Min temperature during the logging interval ended at timestamp
    pub temperature_max: Option<f64>,  // Max temperature during the logging interval ended at timestamp
    pub activity_time: Option<Vec<Option<u16>>>,  // Indexed using minute_activity_level enum
    pub active_calories: Option<u16>,  
    pub current_activity_type_intensity: Option<Vec<u8>>,  // Indicates single type / intensity for duration since last monitoring message.
    pub timestamp_min_8: Option<u8>,  
    pub timestamp_16: Option<u16>,  
    pub heart_rate: Option<u8>,  
    pub intensity: Option<f64>,  
    pub duration_min: Option<u16>,  
    pub duration: Option<u32>,  
    pub ascent: Option<f64>,  
    pub descent: Option<f64>,  
    pub moderate_activity_minutes: Option<u16>,  
    pub vigorous_activity_minutes: Option<u16>,  
    
}

impl fmt::Display for FitMessageMonitoring {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMonitoring")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.device_index { writeln!(f, "  {: >28}: {:?}", "device_index", v)?; }
        if let Some(v) = &self.calories { writeln!(f, "  {: >28}: {:?}", "calories", v)?; }
        if let Some(v) = &self.distance { writeln!(f, "  {: >28}: {:?}", "distance", v)?; }
        writeln!(f, "  {: >28}: {:?}", "cycles_subfield_bytes", self.cycles_subfield_bytes)?;
        if let Some(v) = &self.cycles { writeln!(f, "  {: >28}: {:?}", "cycles", v)?; }
        if let Some(v) = &self.active_time { writeln!(f, "  {: >28}: {:?}", "active_time", v)?; }
        if let Some(v) = &self.activity_type { writeln!(f, "  {: >28}: {:?}", "activity_type", v)?; }
        if let Some(v) = &self.activity_subtype { writeln!(f, "  {: >28}: {:?}", "activity_subtype", v)?; }
        if let Some(v) = &self.activity_level { writeln!(f, "  {: >28}: {:?}", "activity_level", v)?; }
        if let Some(v) = &self.distance_16 { writeln!(f, "  {: >28}: {:?}", "distance_16", v)?; }
        if let Some(v) = &self.cycles_16 { writeln!(f, "  {: >28}: {:?}", "cycles_16", v)?; }
        if let Some(v) = &self.active_time_16 { writeln!(f, "  {: >28}: {:?}", "active_time_16", v)?; }
        if let Some(v) = &self.local_timestamp { writeln!(f, "  {: >28}: {:?}", "local_timestamp", v)?; }
        if let Some(v) = &self.temperature { writeln!(f, "  {: >28}: {:?}", "temperature", v)?; }
        if let Some(v) = &self.temperature_min { writeln!(f, "  {: >28}: {:?}", "temperature_min", v)?; }
        if let Some(v) = &self.temperature_max { writeln!(f, "  {: >28}: {:?}", "temperature_max", v)?; }
        if let Some(v) = &self.activity_time { writeln!(f, "  {: >28}: {:?}", "activity_time", v)?; }
        if let Some(v) = &self.active_calories { writeln!(f, "  {: >28}: {:?}", "active_calories", v)?; }
        if let Some(v) = &self.current_activity_type_intensity { writeln!(f, "  {: >28}: {:?}", "current_activity_type_intensity", v)?; }
        if let Some(v) = &self.timestamp_min_8 { writeln!(f, "  {: >28}: {:?}", "timestamp_min_8", v)?; }
        if let Some(v) = &self.timestamp_16 { writeln!(f, "  {: >28}: {:?}", "timestamp_16", v)?; }
        if let Some(v) = &self.heart_rate { writeln!(f, "  {: >28}: {:?}", "heart_rate", v)?; }
        if let Some(v) = &self.intensity { writeln!(f, "  {: >28}: {:?}", "intensity", v)?; }
        if let Some(v) = &self.duration_min { writeln!(f, "  {: >28}: {:?}", "duration_min", v)?; }
        if let Some(v) = &self.duration { writeln!(f, "  {: >28}: {:?}", "duration", v)?; }
        if let Some(v) = &self.ascent { writeln!(f, "  {: >28}: {:?}", "ascent", v)?; }
        if let Some(v) = &self.descent { writeln!(f, "  {: >28}: {:?}", "descent", v)?; }
        if let Some(v) = &self.moderate_activity_minutes { writeln!(f, "  {: >28}: {:?}", "moderate_activity_minutes", v)?; }
        if let Some(v) = &self.vigorous_activity_minutes { writeln!(f, "  {: >28}: {:?}", "vigorous_activity_minutes", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMonitoring {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageMonitoring>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageMonitoring {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageMonitoring",
            timestamp: None,
            device_index: None,
            calories: None,
            distance: None,
            cycles_subfield_bytes: vec![],
            cycles: None,
            active_time: None,
            activity_type: None,
            activity_subtype: None,
            activity_level: None,
            distance_16: None,
            cycles_16: None,
            active_time_16: None,
            local_timestamp: None,
            temperature: None,
            temperature_min: None,
            temperature_max: None,
            activity_time: None,
            active_calories: None,
            current_activity_type_intensity: None,
            timestamp_min_8: None,
            timestamp_16: None,
            heart_rate: None,
            intensity: None,
            duration_min: None,
            duration: None,
            ascent: None,
            descent: None,
            moderate_activity_minutes: None,
            vigorous_activity_minutes: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageMonitoring::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageMonitoring:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageMonitoring::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageMonitoring:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageMonitoring, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 3).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageMonitoringSubfieldCycles::parse(message, &message.cycles_subfield_bytes, &field, _tz_offset)?;
            message.cycles = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageMonitoring, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // device_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDeviceIndex::parse(&&bytes[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDeviceIndex::parse(&inp[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.cycles_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.cycles_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // active_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.active_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.active_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.active_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.active_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // activity_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldActivityType::parse(&&bytes[0..f.field_size])?;
                                
                                message.activity_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldActivityType::parse(&inp[0..f.field_size])?;
                                
                                message.activity_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // activity_subtype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldActivitySubtype::parse(&&bytes[0..f.field_size])?;
                                
                                message.activity_subtype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldActivitySubtype::parse(&inp[0..f.field_size])?;
                                
                                message.activity_subtype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // activity_level
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldActivityLevel::parse(&&bytes[0..f.field_size])?;
                                
                                message.activity_level = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldActivityLevel::parse(&inp[0..f.field_size])?;
                                
                                message.activity_level = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // distance_16
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.distance_16 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.distance_16 = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // cycles_16
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.cycles_16 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.cycles_16 = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // active_time_16
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.active_time_16 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.active_time_16 = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // local_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocalDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocalDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.temperature = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.temperature = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.temperature = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.temperature = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // temperature_min
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.temperature_min = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.temperature_min = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.temperature_min = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.temperature_min = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    15 => {  // temperature_max
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.temperature_max = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.temperature_max = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.temperature_max = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.temperature_max = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    16 => {  // activity_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.activity_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.activity_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // active_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.active_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.active_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    24 => {  // current_activity_type_intensity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.current_activity_type_intensity = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.current_activity_type_intensity = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 5, field_size: 1, base_type: 0}, Some((0, 5)) ));
                        actions.push( (FitFieldDefinition{definition_number: 28, field_size: 1, base_type: 0}, Some((5, 3)) ));
                        Ok(())
                    },
                
                    25 => {  // timestamp_min_8
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.timestamp_min_8 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.timestamp_min_8 = val;
                            }
                        }

                        Ok(())
                    },
                
                    26 => {  // timestamp_16
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_16 = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_16 = val;
                            }
                        }

                        Ok(())
                    },
                
                    27 => {  // heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    28 => {  // intensity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.intensity = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.intensity = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.intensity = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.intensity = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    29 => {  // duration_min
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.duration_min = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.duration_min = val;
                            }
                        }

                        Ok(())
                    },
                
                    30 => {  // duration
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.duration = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.duration = val;
                            }
                        }

                        Ok(())
                    },
                
                    31 => {  // ascent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.ascent = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.ascent = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.ascent = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.ascent = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    32 => {  // descent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.descent = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.descent = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.descent = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.descent = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    33 => {  // moderate_activity_minutes
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.moderate_activity_minutes = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.moderate_activity_minutes = val;
                            }
                        }

                        Ok(())
                    },
                
                    34 => {  // vigorous_activity_minutes
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.vigorous_activity_minutes = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.vigorous_activity_minutes = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageMonitoring {
    fn message_name(&self) -> &'static str {
        return "FitMessageMonitoring";
    }
}

#[derive(Debug)]
pub struct FitMessageMonitoringInfo {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub local_timestamp: Option<FitFieldLocalDateTime>,  // Use to convert activity timestamps to local time if device does not support time zone and daylight savings time correction.
    pub activity_type: Option<Vec<FitFieldActivityType>>,  
    pub cycles_to_distance: Option<Vec<Option<f64>>>,  // Indexed by activity_type
    pub cycles_to_calories: Option<Vec<Option<f64>>>,  // Indexed by activity_type
    pub resting_metabolic_rate: Option<u16>,  
    
}

impl fmt::Display for FitMessageMonitoringInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageMonitoringInfo")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.local_timestamp { writeln!(f, "  {: >28}: {:?}", "local_timestamp", v)?; }
        if let Some(v) = &self.activity_type { writeln!(f, "  {: >28}: {:?}", "activity_type", v)?; }
        if let Some(v) = &self.cycles_to_distance { writeln!(f, "  {: >28}: {:?}", "cycles_to_distance", v)?; }
        if let Some(v) = &self.cycles_to_calories { writeln!(f, "  {: >28}: {:?}", "cycles_to_calories", v)?; }
        if let Some(v) = &self.resting_metabolic_rate { writeln!(f, "  {: >28}: {:?}", "resting_metabolic_rate", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageMonitoringInfo {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageMonitoringInfo>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageMonitoringInfo {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageMonitoringInfo",
            timestamp: None,
            local_timestamp: None,
            activity_type: None,
            cycles_to_distance: None,
            cycles_to_calories: None,
            resting_metabolic_rate: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageMonitoringInfo::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageMonitoringInfo:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageMonitoringInfo, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // local_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocalDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocalDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // activity_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldActivityType::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.activity_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldActivityType::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.activity_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // cycles_to_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.cycles_to_distance = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 5000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.cycles_to_distance = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 5000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // cycles_to_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.cycles_to_calories = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 5000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.cycles_to_calories = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 5000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // resting_metabolic_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.resting_metabolic_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.resting_metabolic_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageMonitoringInfo {
    fn message_name(&self) -> &'static str {
        return "FitMessageMonitoringInfo";
    }
}

#[derive(Debug)]
pub struct FitMessageNmeaSentence {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Timestamp message was output
    pub timestamp_ms: Option<u16>,  // Fractional part of timestamp, added to timestamp
    pub sentence: Option<String>,  // NMEA sentence
    
}

impl fmt::Display for FitMessageNmeaSentence {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageNmeaSentence")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.sentence { writeln!(f, "  {: >28}: {:?}", "sentence", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageNmeaSentence {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageNmeaSentence>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageNmeaSentence {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageNmeaSentence",
            timestamp: None,
            timestamp_ms: None,
            sentence: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageNmeaSentence::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageNmeaSentence:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageNmeaSentence, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sentence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.sentence = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.sentence = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageNmeaSentence {
    fn message_name(&self) -> &'static str {
        return "FitMessageNmeaSentence";
    }
}

#[derive(Debug)]
pub struct FitMessageObdiiData {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Timestamp message was output
    pub timestamp_ms: Option<u16>,  // Fractional part of timestamp, added to timestamp
    pub time_offset: Option<Vec<Option<u16>>>,  // Offset of PID reading [i] from start_timestamp+start_timestamp_ms. Readings may span accross seconds.
    pub pid: Option<Vec<u8>>,  // Parameter ID
    pub raw_data: Option<Vec<u8>>,  // Raw parameter data
    pub pid_data_size: Option<Vec<Option<u8>>>,  // Optional, data size of PID[i].  If not specified refer to SAE J1979.
    pub system_time: Option<Vec<Option<u32>>>,  // System time associated with sample expressed in ms, can be used instead of time_offset.  There will be a system_time value for each raw_data element.  For multibyte pids the system_time is repeated.
    pub start_timestamp: Option<FitFieldDateTime>,  // Timestamp of first sample recorded in the message.  Used with time_offset to generate time of each sample
    pub start_timestamp_ms: Option<u16>,  // Fractional part of start_timestamp
    
}

impl fmt::Display for FitMessageObdiiData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageObdiiData")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.time_offset { writeln!(f, "  {: >28}: {:?}", "time_offset", v)?; }
        if let Some(v) = &self.pid { writeln!(f, "  {: >28}: {:?}", "pid", v)?; }
        if let Some(v) = &self.raw_data { writeln!(f, "  {: >28}: {:?}", "raw_data", v)?; }
        if let Some(v) = &self.pid_data_size { writeln!(f, "  {: >28}: {:?}", "pid_data_size", v)?; }
        if let Some(v) = &self.system_time { writeln!(f, "  {: >28}: {:?}", "system_time", v)?; }
        if let Some(v) = &self.start_timestamp { writeln!(f, "  {: >28}: {:?}", "start_timestamp", v)?; }
        if let Some(v) = &self.start_timestamp_ms { writeln!(f, "  {: >28}: {:?}", "start_timestamp_ms", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageObdiiData {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageObdiiData>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageObdiiData {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageObdiiData",
            timestamp: None,
            timestamp_ms: None,
            time_offset: None,
            pid: None,
            raw_data: None,
            pid_data_size: None,
            system_time: None,
            start_timestamp: None,
            start_timestamp_ms: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageObdiiData::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageObdiiData:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageObdiiData, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // time_offset
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_offset = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_offset = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // pid
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.pid = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.pid = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // raw_data
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.raw_data = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.raw_data = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // pid_data_size
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.pid_data_size = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.pid_data_size = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // system_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.system_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.system_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // start_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // start_timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageObdiiData {
    fn message_name(&self) -> &'static str {
        return "FitMessageObdiiData";
    }
}

#[derive(Debug)]
pub struct FitMessageOhrSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub enabled: Option<FitFieldSwitch>,  
    
}

impl fmt::Display for FitMessageOhrSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageOhrSettings")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageOhrSettings {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageOhrSettings>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageOhrSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageOhrSettings",
            timestamp: None,
            enabled: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageOhrSettings::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageOhrSettings:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageOhrSettings, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSwitch::parse(&&bytes[0..f.field_size])?;
                                
                                message.enabled = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSwitch::parse(&inp[0..f.field_size])?;
                                
                                message.enabled = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageOhrSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageOhrSettings";
    }
}

#[derive(Debug)]
pub enum FitMessageOneDSensorCalibrationSubfieldCalibrationFactor {
    Default(Option<u32>),
    BaroCalFactor(Option<u32>),
}

impl FitMessageOneDSensorCalibrationSubfieldCalibrationFactor {
    fn parse<'a>(message: &FitMessageOneDSensorCalibration, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageOneDSensorCalibrationSubfieldCalibrationFactor> {
        
        match message.sensor_type {
        
            Some(FitFieldSensorType::Barometer) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::BaroCalFactor(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageOneDSensorCalibration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub sensor_type: Option<FitFieldSensorType>,  // Indicates which sensor the calibration is for
    pub calibration_factor_subfield_bytes: Vec<u8>,
    pub calibration_factor: Option<FitMessageOneDSensorCalibrationSubfieldCalibrationFactor>,  // Calibration factor used to convert from raw ADC value to degrees, g,  etc.
    pub calibration_divisor: Option<u32>,  // Calibration factor divisor
    pub level_shift: Option<u32>,  // Level shift value used to shift the ADC value back into range
    pub offset_cal: Option<i32>,  // Internal Calibration factor
    
}

impl fmt::Display for FitMessageOneDSensorCalibration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageOneDSensorCalibration")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.sensor_type { writeln!(f, "  {: >28}: {:?}", "sensor_type", v)?; }
        writeln!(f, "  {: >28}: {:?}", "calibration_factor_subfield_bytes", self.calibration_factor_subfield_bytes)?;
        if let Some(v) = &self.calibration_factor { writeln!(f, "  {: >28}: {:?}", "calibration_factor", v)?; }
        if let Some(v) = &self.calibration_divisor { writeln!(f, "  {: >28}: {:?}", "calibration_divisor", v)?; }
        if let Some(v) = &self.level_shift { writeln!(f, "  {: >28}: {:?}", "level_shift", v)?; }
        if let Some(v) = &self.offset_cal { writeln!(f, "  {: >28}: {:?}", "offset_cal", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageOneDSensorCalibration {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageOneDSensorCalibration>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageOneDSensorCalibration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageOneDSensorCalibration",
            timestamp: None,
            sensor_type: None,
            calibration_factor_subfield_bytes: vec![],
            calibration_factor: None,
            calibration_divisor: None,
            level_shift: None,
            offset_cal: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageOneDSensorCalibration::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageOneDSensorCalibration:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageOneDSensorCalibration::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageOneDSensorCalibration:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageOneDSensorCalibration, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 1).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageOneDSensorCalibrationSubfieldCalibrationFactor::parse(message, &message.calibration_factor_subfield_bytes, &field, _tz_offset)?;
            message.calibration_factor = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageOneDSensorCalibration, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // sensor_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSensorType::parse(&&bytes[0..f.field_size])?;
                                
                                message.sensor_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSensorType::parse(&inp[0..f.field_size])?;
                                
                                message.sensor_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // calibration_factor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.calibration_factor_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.calibration_factor_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // calibration_divisor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calibration_divisor = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calibration_divisor = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // level_shift
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.level_shift = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.level_shift = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // offset_cal
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.offset_cal = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.offset_cal = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageOneDSensorCalibration {
    fn message_name(&self) -> &'static str {
        return "FitMessageOneDSensorCalibration";
    }
}

#[derive(Debug)]
pub struct FitMessagePowerZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub high_value: Option<u16>,  
    pub name: Option<String>,  
    
}

impl fmt::Display for FitMessagePowerZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessagePowerZone")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.high_value { writeln!(f, "  {: >28}: {:?}", "high_value", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessagePowerZone {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessagePowerZone>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessagePowerZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessagePowerZone",
            message_index: None,
            high_value: None,
            name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessagePowerZone::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessagePowerZone:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessagePowerZone, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // high_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.high_value = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.high_value = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessagePowerZone {
    fn message_name(&self) -> &'static str {
        return "FitMessagePowerZone";
    }
}

#[derive(Debug)]
pub struct FitMessageRecord {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub position_lat: Option<f64>,  
    pub position_long: Option<f64>,  
    pub altitude: Option<f64>,  
    pub heart_rate: Option<u8>,  
    pub cadence: Option<u8>,  
    pub distance: Option<f64>,  
    pub speed: Option<f64>,  
    pub power: Option<u16>,  
    pub compressed_speed_distance: Option<Vec<u8>>,  
    pub grade: Option<f64>,  
    pub resistance: Option<u8>,  // Relative. 0 is none  254 is Max.
    pub time_from_course: Option<f64>,  
    pub cycle_length: Option<f64>,  
    pub temperature: Option<i8>,  
    pub speed_1s: Option<Vec<Option<f64>>>,  // Speed at 1s intervals.  Timestamp field indicates time of last array element.
    pub cycles: Option<u8>,  
    pub total_cycles: Option<u32>,  
    pub compressed_accumulated_power: Option<u16>,  
    pub accumulated_power: Option<u32>,  
    pub left_right_balance: Option<FitFieldLeftRightBalance>,  
    pub gps_accuracy: Option<u8>,  
    pub vertical_speed: Option<f64>,  
    pub calories: Option<u16>,  
    pub vertical_oscillation: Option<f64>,  
    pub stance_time_percent: Option<f64>,  
    pub stance_time: Option<f64>,  
    pub activity_type: Option<FitFieldActivityType>,  
    pub left_torque_effectiveness: Option<f64>,  
    pub right_torque_effectiveness: Option<f64>,  
    pub left_pedal_smoothness: Option<f64>,  
    pub right_pedal_smoothness: Option<f64>,  
    pub combined_pedal_smoothness: Option<f64>,  
    pub time128: Option<f64>,  
    pub stroke_type: Option<FitFieldStrokeType>,  
    pub zone: Option<u8>,  
    pub ball_speed: Option<f64>,  
    pub cadence256: Option<f64>,  // Log cadence and fractional cadence for backwards compatability
    pub fractional_cadence: Option<f64>,  
    pub total_hemoglobin_conc: Option<f64>,  // Total saturated and unsaturated hemoglobin
    pub total_hemoglobin_conc_min: Option<f64>,  // Min saturated and unsaturated hemoglobin
    pub total_hemoglobin_conc_max: Option<f64>,  // Max saturated and unsaturated hemoglobin
    pub saturated_hemoglobin_percent: Option<f64>,  // Percentage of hemoglobin saturated with oxygen
    pub saturated_hemoglobin_percent_min: Option<f64>,  // Min percentage of hemoglobin saturated with oxygen
    pub saturated_hemoglobin_percent_max: Option<f64>,  // Max percentage of hemoglobin saturated with oxygen
    pub device_index: Option<FitFieldDeviceIndex>,  
    pub left_pco: Option<i8>,  // Left platform center offset
    pub right_pco: Option<i8>,  // Right platform center offset
    pub left_power_phase: Option<Vec<Option<f64>>>,  // Left power phase angles. Data value indexes defined by power_phase_type.
    pub left_power_phase_peak: Option<Vec<Option<f64>>>,  // Left power phase peak angles. Data value indexes defined by power_phase_type.
    pub right_power_phase: Option<Vec<Option<f64>>>,  // Right power phase angles. Data value indexes defined by power_phase_type.
    pub right_power_phase_peak: Option<Vec<Option<f64>>>,  // Right power phase peak angles. Data value indexes defined by power_phase_type.
    pub enhanced_speed: Option<f64>,  
    pub enhanced_altitude: Option<f64>,  
    pub battery_soc: Option<f64>,  // lev battery state of charge
    pub motor_power: Option<u16>,  // lev motor power
    pub vertical_ratio: Option<f64>,  
    pub stance_time_balance: Option<f64>,  
    pub step_length: Option<f64>,  
    pub absolute_pressure: Option<u32>,  // Includes atmospheric pressure
    pub depth: Option<f64>,  // 0 if above water
    pub next_stop_depth: Option<f64>,  // 0 if above water
    pub next_stop_time: Option<f64>,  
    pub time_to_surface: Option<f64>,  
    pub ndl_time: Option<f64>,  
    pub cns_load: Option<u8>,  
    pub n2_load: Option<f64>,  
    
}

impl fmt::Display for FitMessageRecord {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageRecord")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.position_lat { writeln!(f, "  {: >28}: {:?}", "position_lat", v)?; }
        if let Some(v) = &self.position_long { writeln!(f, "  {: >28}: {:?}", "position_long", v)?; }
        if let Some(v) = &self.altitude { writeln!(f, "  {: >28}: {:?}", "altitude", v)?; }
        if let Some(v) = &self.heart_rate { writeln!(f, "  {: >28}: {:?}", "heart_rate", v)?; }
        if let Some(v) = &self.cadence { writeln!(f, "  {: >28}: {:?}", "cadence", v)?; }
        if let Some(v) = &self.distance { writeln!(f, "  {: >28}: {:?}", "distance", v)?; }
        if let Some(v) = &self.speed { writeln!(f, "  {: >28}: {:?}", "speed", v)?; }
        if let Some(v) = &self.power { writeln!(f, "  {: >28}: {:?}", "power", v)?; }
        if let Some(v) = &self.compressed_speed_distance { writeln!(f, "  {: >28}: {:?}", "compressed_speed_distance", v)?; }
        if let Some(v) = &self.grade { writeln!(f, "  {: >28}: {:?}", "grade", v)?; }
        if let Some(v) = &self.resistance { writeln!(f, "  {: >28}: {:?}", "resistance", v)?; }
        if let Some(v) = &self.time_from_course { writeln!(f, "  {: >28}: {:?}", "time_from_course", v)?; }
        if let Some(v) = &self.cycle_length { writeln!(f, "  {: >28}: {:?}", "cycle_length", v)?; }
        if let Some(v) = &self.temperature { writeln!(f, "  {: >28}: {:?}", "temperature", v)?; }
        if let Some(v) = &self.speed_1s { writeln!(f, "  {: >28}: {:?}", "speed_1s", v)?; }
        if let Some(v) = &self.cycles { writeln!(f, "  {: >28}: {:?}", "cycles", v)?; }
        if let Some(v) = &self.total_cycles { writeln!(f, "  {: >28}: {:?}", "total_cycles", v)?; }
        if let Some(v) = &self.compressed_accumulated_power { writeln!(f, "  {: >28}: {:?}", "compressed_accumulated_power", v)?; }
        if let Some(v) = &self.accumulated_power { writeln!(f, "  {: >28}: {:?}", "accumulated_power", v)?; }
        if let Some(v) = &self.left_right_balance { writeln!(f, "  {: >28}: {:?}", "left_right_balance", v)?; }
        if let Some(v) = &self.gps_accuracy { writeln!(f, "  {: >28}: {:?}", "gps_accuracy", v)?; }
        if let Some(v) = &self.vertical_speed { writeln!(f, "  {: >28}: {:?}", "vertical_speed", v)?; }
        if let Some(v) = &self.calories { writeln!(f, "  {: >28}: {:?}", "calories", v)?; }
        if let Some(v) = &self.vertical_oscillation { writeln!(f, "  {: >28}: {:?}", "vertical_oscillation", v)?; }
        if let Some(v) = &self.stance_time_percent { writeln!(f, "  {: >28}: {:?}", "stance_time_percent", v)?; }
        if let Some(v) = &self.stance_time { writeln!(f, "  {: >28}: {:?}", "stance_time", v)?; }
        if let Some(v) = &self.activity_type { writeln!(f, "  {: >28}: {:?}", "activity_type", v)?; }
        if let Some(v) = &self.left_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "left_torque_effectiveness", v)?; }
        if let Some(v) = &self.right_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "right_torque_effectiveness", v)?; }
        if let Some(v) = &self.left_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "left_pedal_smoothness", v)?; }
        if let Some(v) = &self.right_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "right_pedal_smoothness", v)?; }
        if let Some(v) = &self.combined_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "combined_pedal_smoothness", v)?; }
        if let Some(v) = &self.time128 { writeln!(f, "  {: >28}: {:?}", "time128", v)?; }
        if let Some(v) = &self.stroke_type { writeln!(f, "  {: >28}: {:?}", "stroke_type", v)?; }
        if let Some(v) = &self.zone { writeln!(f, "  {: >28}: {:?}", "zone", v)?; }
        if let Some(v) = &self.ball_speed { writeln!(f, "  {: >28}: {:?}", "ball_speed", v)?; }
        if let Some(v) = &self.cadence256 { writeln!(f, "  {: >28}: {:?}", "cadence256", v)?; }
        if let Some(v) = &self.fractional_cadence { writeln!(f, "  {: >28}: {:?}", "fractional_cadence", v)?; }
        if let Some(v) = &self.total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.total_hemoglobin_conc_min { writeln!(f, "  {: >28}: {:?}", "total_hemoglobin_conc_min", v)?; }
        if let Some(v) = &self.total_hemoglobin_conc_max { writeln!(f, "  {: >28}: {:?}", "total_hemoglobin_conc_max", v)?; }
        if let Some(v) = &self.saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.saturated_hemoglobin_percent_min { writeln!(f, "  {: >28}: {:?}", "saturated_hemoglobin_percent_min", v)?; }
        if let Some(v) = &self.saturated_hemoglobin_percent_max { writeln!(f, "  {: >28}: {:?}", "saturated_hemoglobin_percent_max", v)?; }
        if let Some(v) = &self.device_index { writeln!(f, "  {: >28}: {:?}", "device_index", v)?; }
        if let Some(v) = &self.left_pco { writeln!(f, "  {: >28}: {:?}", "left_pco", v)?; }
        if let Some(v) = &self.right_pco { writeln!(f, "  {: >28}: {:?}", "right_pco", v)?; }
        if let Some(v) = &self.left_power_phase { writeln!(f, "  {: >28}: {:?}", "left_power_phase", v)?; }
        if let Some(v) = &self.left_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "left_power_phase_peak", v)?; }
        if let Some(v) = &self.right_power_phase { writeln!(f, "  {: >28}: {:?}", "right_power_phase", v)?; }
        if let Some(v) = &self.right_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "right_power_phase_peak", v)?; }
        if let Some(v) = &self.enhanced_speed { writeln!(f, "  {: >28}: {:?}", "enhanced_speed", v)?; }
        if let Some(v) = &self.enhanced_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_altitude", v)?; }
        if let Some(v) = &self.battery_soc { writeln!(f, "  {: >28}: {:?}", "battery_soc", v)?; }
        if let Some(v) = &self.motor_power { writeln!(f, "  {: >28}: {:?}", "motor_power", v)?; }
        if let Some(v) = &self.vertical_ratio { writeln!(f, "  {: >28}: {:?}", "vertical_ratio", v)?; }
        if let Some(v) = &self.stance_time_balance { writeln!(f, "  {: >28}: {:?}", "stance_time_balance", v)?; }
        if let Some(v) = &self.step_length { writeln!(f, "  {: >28}: {:?}", "step_length", v)?; }
        if let Some(v) = &self.absolute_pressure { writeln!(f, "  {: >28}: {:?}", "absolute_pressure", v)?; }
        if let Some(v) = &self.depth { writeln!(f, "  {: >28}: {:?}", "depth", v)?; }
        if let Some(v) = &self.next_stop_depth { writeln!(f, "  {: >28}: {:?}", "next_stop_depth", v)?; }
        if let Some(v) = &self.next_stop_time { writeln!(f, "  {: >28}: {:?}", "next_stop_time", v)?; }
        if let Some(v) = &self.time_to_surface { writeln!(f, "  {: >28}: {:?}", "time_to_surface", v)?; }
        if let Some(v) = &self.ndl_time { writeln!(f, "  {: >28}: {:?}", "ndl_time", v)?; }
        if let Some(v) = &self.cns_load { writeln!(f, "  {: >28}: {:?}", "cns_load", v)?; }
        if let Some(v) = &self.n2_load { writeln!(f, "  {: >28}: {:?}", "n2_load", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageRecord {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageRecord>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageRecord {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageRecord",
            timestamp: None,
            position_lat: None,
            position_long: None,
            altitude: None,
            heart_rate: None,
            cadence: None,
            distance: None,
            speed: None,
            power: None,
            compressed_speed_distance: None,
            grade: None,
            resistance: None,
            time_from_course: None,
            cycle_length: None,
            temperature: None,
            speed_1s: None,
            cycles: None,
            total_cycles: None,
            compressed_accumulated_power: None,
            accumulated_power: None,
            left_right_balance: None,
            gps_accuracy: None,
            vertical_speed: None,
            calories: None,
            vertical_oscillation: None,
            stance_time_percent: None,
            stance_time: None,
            activity_type: None,
            left_torque_effectiveness: None,
            right_torque_effectiveness: None,
            left_pedal_smoothness: None,
            right_pedal_smoothness: None,
            combined_pedal_smoothness: None,
            time128: None,
            stroke_type: None,
            zone: None,
            ball_speed: None,
            cadence256: None,
            fractional_cadence: None,
            total_hemoglobin_conc: None,
            total_hemoglobin_conc_min: None,
            total_hemoglobin_conc_max: None,
            saturated_hemoglobin_percent: None,
            saturated_hemoglobin_percent_min: None,
            saturated_hemoglobin_percent_max: None,
            device_index: None,
            left_pco: None,
            right_pco: None,
            left_power_phase: None,
            left_power_phase_peak: None,
            right_power_phase: None,
            right_power_phase_peak: None,
            enhanced_speed: None,
            enhanced_altitude: None,
            battery_soc: None,
            motor_power: None,
            vertical_ratio: None,
            stance_time_balance: None,
            step_length: None,
            absolute_pressure: None,
            depth: None,
            next_stop_depth: None,
            next_stop_time: None,
            time_to_surface: None,
            ndl_time: None,
            cns_load: None,
            n2_load: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageRecord::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageRecord:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageRecord, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 78, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    3 => {  // heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.cadence = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.cadence = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.speed = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 73, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    7 => {  // power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.power = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // compressed_speed_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.compressed_speed_distance = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.compressed_speed_distance = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 6, field_size: 2, base_type: 0}, Some((0, 12)) ));
                        actions.push( (FitFieldDefinition{definition_number: 5, field_size: 4, base_type: 0}, Some((12, 12)) ));
                        Ok(())
                    },
                
                    9 => {  // grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // resistance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.resistance = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.resistance = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // time_from_course
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_from_course = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_from_course = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_from_course = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_from_course = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // cycle_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.cycle_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.cycle_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.cycle_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.cycle_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // speed_1s
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.speed_1s = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 16 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.speed_1s = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 16 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.cycles = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.cycles = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 19, field_size: 4, base_type: 0}, Some((0, 8)) ));
                        Ok(())
                    },
                
                    19 => {  // total_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_cycles = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_cycles = val;
                            }
                        }

                        Ok(())
                    },
                
                    28 => {  // compressed_accumulated_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.compressed_accumulated_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.compressed_accumulated_power = val;
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 29, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    29 => {  // accumulated_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.accumulated_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.accumulated_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    30 => {  // left_right_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLeftRightBalance::parse(&&bytes[0..f.field_size])?;
                                
                                message.left_right_balance = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLeftRightBalance::parse(&inp[0..f.field_size])?;
                                
                                message.left_right_balance = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    31 => {  // gps_accuracy
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            }
                        }

                        Ok(())
                    },
                
                    32 => {  // vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    33 => {  // calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    39 => {  // vertical_oscillation
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.vertical_oscillation = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.vertical_oscillation = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.vertical_oscillation = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.vertical_oscillation = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    40 => {  // stance_time_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.stance_time_percent = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.stance_time_percent = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.stance_time_percent = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.stance_time_percent = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    41 => {  // stance_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.stance_time = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.stance_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.stance_time = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.stance_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    42 => {  // activity_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldActivityType::parse(&&bytes[0..f.field_size])?;
                                
                                message.activity_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldActivityType::parse(&inp[0..f.field_size])?;
                                
                                message.activity_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    43 => {  // left_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.left_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.left_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    44 => {  // right_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.right_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.right_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    45 => {  // left_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.left_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.left_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    46 => {  // right_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.right_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.right_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    47 => {  // combined_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.combined_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.combined_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    48 => {  // time128
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time128 = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.time128 = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time128 = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.time128 = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    49 => {  // stroke_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldStrokeType::parse(&&bytes[0..f.field_size])?;
                                
                                message.stroke_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldStrokeType::parse(&inp[0..f.field_size])?;
                                
                                message.stroke_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    50 => {  // zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.zone = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.zone = val;
                            }
                        }

                        Ok(())
                    },
                
                    51 => {  // ball_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.ball_speed = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.ball_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.ball_speed = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.ball_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    52 => {  // cadence256
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.cadence256 = Some(result as f64 / 256 as f64) 
                                    },
                                    None => message.cadence256 = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.cadence256 = Some(result as f64 / 256 as f64) 
                                    },
                                    None => message.cadence256 = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    53 => {  // fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    54 => {  // total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_hemoglobin_conc = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_hemoglobin_conc = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_hemoglobin_conc = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_hemoglobin_conc = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    55 => {  // total_hemoglobin_conc_min
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_hemoglobin_conc_min = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_hemoglobin_conc_min = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_hemoglobin_conc_min = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_hemoglobin_conc_min = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    56 => {  // total_hemoglobin_conc_max
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_hemoglobin_conc_max = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_hemoglobin_conc_max = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_hemoglobin_conc_max = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_hemoglobin_conc_max = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    57 => {  // saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.saturated_hemoglobin_percent = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.saturated_hemoglobin_percent = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.saturated_hemoglobin_percent = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.saturated_hemoglobin_percent = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    58 => {  // saturated_hemoglobin_percent_min
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.saturated_hemoglobin_percent_min = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.saturated_hemoglobin_percent_min = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.saturated_hemoglobin_percent_min = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.saturated_hemoglobin_percent_min = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    59 => {  // saturated_hemoglobin_percent_max
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.saturated_hemoglobin_percent_max = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.saturated_hemoglobin_percent_max = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.saturated_hemoglobin_percent_max = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.saturated_hemoglobin_percent_max = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    62 => {  // device_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDeviceIndex::parse(&&bytes[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDeviceIndex::parse(&inp[0..f.field_size])?;
                                
                                message.device_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    67 => {  // left_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.left_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.left_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    68 => {  // right_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.right_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.right_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    69 => {  // left_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    70 => {  // left_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    71 => {  // right_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    72 => {  // right_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    73 => {  // enhanced_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    78 => {  // enhanced_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    81 => {  // battery_soc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.battery_soc = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.battery_soc = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.battery_soc = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.battery_soc = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    82 => {  // motor_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.motor_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.motor_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    83 => {  // vertical_ratio
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.vertical_ratio = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.vertical_ratio = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.vertical_ratio = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.vertical_ratio = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    84 => {  // stance_time_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.stance_time_balance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.stance_time_balance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.stance_time_balance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.stance_time_balance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    85 => {  // step_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.step_length = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.step_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.step_length = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.step_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    91 => {  // absolute_pressure
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.absolute_pressure = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.absolute_pressure = val;
                            }
                        }

                        Ok(())
                    },
                
                    92 => {  // depth
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.depth = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.depth = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    93 => {  // next_stop_depth
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.next_stop_depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.next_stop_depth = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.next_stop_depth = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.next_stop_depth = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    94 => {  // next_stop_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.next_stop_time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.next_stop_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.next_stop_time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.next_stop_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    95 => {  // time_to_surface
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_to_surface = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.time_to_surface = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_to_surface = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.time_to_surface = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    96 => {  // ndl_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.ndl_time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.ndl_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.ndl_time = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.ndl_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    97 => {  // cns_load
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.cns_load = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.cns_load = val;
                            }
                        }

                        Ok(())
                    },
                
                    98 => {  // n2_load
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.n2_load = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.n2_load = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.n2_load = Some(result as f64 / 1 as f64) 
                                    },
                                    None => message.n2_load = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageRecord {
    fn message_name(&self) -> &'static str {
        return "FitMessageRecord";
    }
}

#[derive(Debug)]
pub enum FitMessageScheduleSubfieldProduct {
    Default(Option<u16>),
    FaveroProduct(Option<FitFieldFaveroProduct>),
    GarminProduct(Option<FitFieldGarminProduct>),
}

impl FitMessageScheduleSubfieldProduct {
    fn parse<'a>(message: &FitMessageSchedule, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageScheduleSubfieldProduct> {
        
        match message.manufacturer {
        
            Some(FitFieldManufacturer::FaveroElectronics) => {
                let val = FitFieldFaveroProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageScheduleSubfieldProduct::FaveroProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Garmin) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageScheduleSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Dynastream) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageScheduleSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::DynastreamOem) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageScheduleSubfieldProduct::GarminProduct(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageScheduleSubfieldProduct::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageSchedule {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub manufacturer: Option<FitFieldManufacturer>,  // Corresponds to file_id of scheduled workout / course.
    pub product_subfield_bytes: Vec<u8>,
    pub product: Option<FitMessageScheduleSubfieldProduct>,  // Corresponds to file_id of scheduled workout / course.
    pub serial_number: Option<u32>,  // Corresponds to file_id of scheduled workout / course.
    pub time_created: Option<FitFieldDateTime>,  // Corresponds to file_id of scheduled workout / course.
    pub completed: Option<bool>,  // TRUE if this activity has been started
    pub ftype: Option<FitFieldSchedule>,  
    pub scheduled_time: Option<FitFieldLocalDateTime>,  
    
}

impl fmt::Display for FitMessageSchedule {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSchedule")?;
        if let Some(v) = &self.manufacturer { writeln!(f, "  {: >28}: {:?}", "manufacturer", v)?; }
        writeln!(f, "  {: >28}: {:?}", "product_subfield_bytes", self.product_subfield_bytes)?;
        if let Some(v) = &self.product { writeln!(f, "  {: >28}: {:?}", "product", v)?; }
        if let Some(v) = &self.serial_number { writeln!(f, "  {: >28}: {:?}", "serial_number", v)?; }
        if let Some(v) = &self.time_created { writeln!(f, "  {: >28}: {:?}", "time_created", v)?; }
        if let Some(v) = &self.completed { writeln!(f, "  {: >28}: {:?}", "completed", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.scheduled_time { writeln!(f, "  {: >28}: {:?}", "scheduled_time", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSchedule {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSchedule>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSchedule {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSchedule",
            manufacturer: None,
            product_subfield_bytes: vec![],
            product: None,
            serial_number: None,
            time_created: None,
            completed: None,
            ftype: None,
            scheduled_time: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSchedule::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSchedule:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageSchedule::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageSchedule:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageSchedule, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 1).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageScheduleSubfieldProduct::parse(message, &message.product_subfield_bytes, &field, _tz_offset)?;
            message.product = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageSchedule, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // manufacturer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // product
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // serial_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // time_created
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.time_created = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.time_created = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // completed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.completed = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.completed = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSchedule::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSchedule::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // scheduled_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocalDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.scheduled_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocalDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.scheduled_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSchedule {
    fn message_name(&self) -> &'static str {
        return "FitMessageSchedule";
    }
}

#[derive(Debug)]
pub struct FitMessageSdmProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub enabled: Option<bool>,  
    pub sdm_ant_id: Option<u16>,  
    pub sdm_cal_factor: Option<f64>,  
    pub odometer: Option<f64>,  
    pub speed_source: Option<bool>,  // Use footpod for speed source instead of GPS
    pub sdm_ant_id_trans_type: Option<u8>,  
    pub odometer_rollover: Option<u8>,  // Rollover counter that can be used to extend the odometer
    
}

impl fmt::Display for FitMessageSdmProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSdmProfile")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.sdm_ant_id { writeln!(f, "  {: >28}: {:?}", "sdm_ant_id", v)?; }
        if let Some(v) = &self.sdm_cal_factor { writeln!(f, "  {: >28}: {:?}", "sdm_cal_factor", v)?; }
        if let Some(v) = &self.odometer { writeln!(f, "  {: >28}: {:?}", "odometer", v)?; }
        if let Some(v) = &self.speed_source { writeln!(f, "  {: >28}: {:?}", "speed_source", v)?; }
        if let Some(v) = &self.sdm_ant_id_trans_type { writeln!(f, "  {: >28}: {:?}", "sdm_ant_id_trans_type", v)?; }
        if let Some(v) = &self.odometer_rollover { writeln!(f, "  {: >28}: {:?}", "odometer_rollover", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSdmProfile {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSdmProfile>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSdmProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSdmProfile",
            message_index: None,
            enabled: None,
            sdm_ant_id: None,
            sdm_cal_factor: None,
            odometer: None,
            speed_source: None,
            sdm_ant_id_trans_type: None,
            odometer_rollover: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSdmProfile::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSdmProfile:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSdmProfile, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sdm_ant_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.sdm_ant_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.sdm_ant_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // sdm_cal_factor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.sdm_cal_factor = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.sdm_cal_factor = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.sdm_cal_factor = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.sdm_cal_factor = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // odometer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.odometer = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.odometer = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.odometer = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.odometer = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // speed_source
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.speed_source = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.speed_source = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // sdm_ant_id_trans_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8z(&&bytes[0..f.field_size])?;
                                
                                message.sdm_ant_id_trans_type = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8z(&inp[0..f.field_size])?;
                                
                                message.sdm_ant_id_trans_type = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // odometer_rollover
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.odometer_rollover = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.odometer_rollover = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSdmProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageSdmProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentFile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub file_uuid: Option<String>,  // UUID of the segment file
    pub enabled: Option<bool>,  // Enabled state of the segment file
    pub user_profile_primary_key: Option<u32>,  // Primary key of the user that created the segment file
    pub leader_type: Option<Vec<FitFieldSegmentLeaderboardType>>,  // Leader type of each leader in the segment file
    pub leader_group_primary_key: Option<Vec<Option<u32>>>,  // Group primary key of each leader in the segment file
    pub leader_activity_id: Option<Vec<Option<u32>>>,  // Activity ID of each leader in the segment file
    pub leader_activity_id_string: Option<Vec<Option<String>>>,  // String version of the activity ID of each leader in the segment file. 21 characters long for each ID, express in decimal
    pub default_race_leader: Option<u8>,  // Index for the Leader Board entry selected as the default race participant
    
}

impl fmt::Display for FitMessageSegmentFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentFile")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.file_uuid { writeln!(f, "  {: >28}: {:?}", "file_uuid", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.user_profile_primary_key { writeln!(f, "  {: >28}: {:?}", "user_profile_primary_key", v)?; }
        if let Some(v) = &self.leader_type { writeln!(f, "  {: >28}: {:?}", "leader_type", v)?; }
        if let Some(v) = &self.leader_group_primary_key { writeln!(f, "  {: >28}: {:?}", "leader_group_primary_key", v)?; }
        if let Some(v) = &self.leader_activity_id { writeln!(f, "  {: >28}: {:?}", "leader_activity_id", v)?; }
        if let Some(v) = &self.leader_activity_id_string { writeln!(f, "  {: >28}: {:?}", "leader_activity_id_string", v)?; }
        if let Some(v) = &self.default_race_leader { writeln!(f, "  {: >28}: {:?}", "default_race_leader", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentFile {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSegmentFile>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSegmentFile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSegmentFile",
            message_index: None,
            file_uuid: None,
            enabled: None,
            user_profile_primary_key: None,
            leader_type: None,
            leader_group_primary_key: None,
            leader_activity_id: None,
            leader_activity_id_string: None,
            default_race_leader: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSegmentFile::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSegmentFile:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSegmentFile, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // file_uuid
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.file_uuid = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.file_uuid = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // user_profile_primary_key
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_primary_key = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_primary_key = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // leader_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldSegmentLeaderboardType::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldSegmentLeaderboardType::parse(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // leader_group_primary_key
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_group_primary_key = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_group_primary_key = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // leader_activity_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_activity_id = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_activity_id = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // leader_activity_id_string
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_activity_id_string = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_string(&tempp[0..f.field_size], field.field_size)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_activity_id_string = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // default_race_leader
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.default_race_leader = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.default_race_leader = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentFile {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentFile";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentId {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub name: Option<String>,  // Friendly name assigned to segment
    pub uuid: Option<String>,  // UUID of the segment
    pub sport: Option<FitFieldSport>,  // Sport associated with the segment
    pub enabled: Option<bool>,  // Segment enabled for evaluation
    pub user_profile_primary_key: Option<u32>,  // Primary key of the user that created the segment
    pub device_id: Option<u32>,  // ID of the device that created the segment
    pub default_race_leader: Option<u8>,  // Index for the Leader Board entry selected as the default race participant
    pub delete_status: Option<FitFieldSegmentDeleteStatus>,  // Indicates if any segments should be deleted
    pub selection_type: Option<FitFieldSegmentSelectionType>,  // Indicates how the segment was selected to be sent to the device
    
}

impl fmt::Display for FitMessageSegmentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentId")?;
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.uuid { writeln!(f, "  {: >28}: {:?}", "uuid", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.enabled { writeln!(f, "  {: >28}: {:?}", "enabled", v)?; }
        if let Some(v) = &self.user_profile_primary_key { writeln!(f, "  {: >28}: {:?}", "user_profile_primary_key", v)?; }
        if let Some(v) = &self.device_id { writeln!(f, "  {: >28}: {:?}", "device_id", v)?; }
        if let Some(v) = &self.default_race_leader { writeln!(f, "  {: >28}: {:?}", "default_race_leader", v)?; }
        if let Some(v) = &self.delete_status { writeln!(f, "  {: >28}: {:?}", "delete_status", v)?; }
        if let Some(v) = &self.selection_type { writeln!(f, "  {: >28}: {:?}", "selection_type", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentId {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSegmentId>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSegmentId {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSegmentId",
            name: None,
            uuid: None,
            sport: None,
            enabled: None,
            user_profile_primary_key: None,
            device_id: None,
            default_race_leader: None,
            delete_status: None,
            selection_type: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSegmentId::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSegmentId:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSegmentId, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // uuid
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.uuid = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.uuid = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // enabled
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_bool(&&bytes[0..f.field_size])?;
                                
                                message.enabled = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_bool(&inp[0..f.field_size])?;
                                
                                message.enabled = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // user_profile_primary_key
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_primary_key = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_primary_key = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // device_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.device_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.device_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // default_race_leader
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.default_race_leader = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.default_race_leader = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // delete_status
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSegmentDeleteStatus::parse(&&bytes[0..f.field_size])?;
                                
                                message.delete_status = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSegmentDeleteStatus::parse(&inp[0..f.field_size])?;
                                
                                message.delete_status = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // selection_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSegmentSelectionType::parse(&&bytes[0..f.field_size])?;
                                
                                message.selection_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSegmentSelectionType::parse(&inp[0..f.field_size])?;
                                
                                message.selection_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentId {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentId";
    }
}

#[derive(Debug)]
pub enum FitMessageSegmentLapSubfieldTotalCycles {
    Default(Option<u32>),
    TotalStrokes(Option<u32>),
}

impl FitMessageSegmentLapSubfieldTotalCycles {
    fn parse<'a>(message: &FitMessageSegmentLap, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageSegmentLapSubfieldTotalCycles> {
        
        match message.sport {
        
            Some(FitFieldSport::Cycling) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSegmentLapSubfieldTotalCycles::TotalStrokes(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageSegmentLapSubfieldTotalCycles::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageSegmentLap {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub timestamp: Option<FitFieldDateTime>,  // Lap end time.
    pub event: Option<FitFieldEvent>,  
    pub event_type: Option<FitFieldEventType>,  
    pub start_time: Option<FitFieldDateTime>,  
    pub start_position_lat: Option<f64>,  
    pub start_position_long: Option<f64>,  
    pub end_position_lat: Option<f64>,  
    pub end_position_long: Option<f64>,  
    pub total_elapsed_time: Option<f64>,  // Time (includes pauses)
    pub total_timer_time: Option<f64>,  // Timer Time (excludes pauses)
    pub total_distance: Option<f64>,  
    pub total_cycles_subfield_bytes: Vec<u8>,
    pub total_cycles: Option<FitMessageSegmentLapSubfieldTotalCycles>,  
    pub total_calories: Option<u16>,  
    pub total_fat_calories: Option<u16>,  // If New Leaf
    pub avg_speed: Option<f64>,  
    pub max_speed: Option<f64>,  
    pub avg_heart_rate: Option<u8>,  
    pub max_heart_rate: Option<u8>,  
    pub avg_cadence: Option<u8>,  // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
    pub max_cadence: Option<u8>,  
    pub avg_power: Option<u16>,  // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
    pub max_power: Option<u16>,  
    pub total_ascent: Option<u16>,  
    pub total_descent: Option<u16>,  
    pub sport: Option<FitFieldSport>,  
    pub event_group: Option<u8>,  
    pub nec_lat: Option<f64>,  // North east corner latitude.
    pub nec_long: Option<f64>,  // North east corner longitude.
    pub swc_lat: Option<f64>,  // South west corner latitude.
    pub swc_long: Option<f64>,  // South west corner latitude.
    pub name: Option<String>,  
    pub normalized_power: Option<u16>,  
    pub left_right_balance: Option<FitFieldLeftRightBalance100>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub total_work: Option<u32>,  
    pub avg_altitude: Option<f64>,  
    pub max_altitude: Option<f64>,  
    pub gps_accuracy: Option<u8>,  
    pub avg_grade: Option<f64>,  
    pub avg_pos_grade: Option<f64>,  
    pub avg_neg_grade: Option<f64>,  
    pub max_pos_grade: Option<f64>,  
    pub max_neg_grade: Option<f64>,  
    pub avg_temperature: Option<i8>,  
    pub max_temperature: Option<i8>,  
    pub total_moving_time: Option<f64>,  
    pub avg_pos_vertical_speed: Option<f64>,  
    pub avg_neg_vertical_speed: Option<f64>,  
    pub max_pos_vertical_speed: Option<f64>,  
    pub max_neg_vertical_speed: Option<f64>,  
    pub time_in_hr_zone: Option<Vec<Option<f64>>>,  
    pub time_in_speed_zone: Option<Vec<Option<f64>>>,  
    pub time_in_cadence_zone: Option<Vec<Option<f64>>>,  
    pub time_in_power_zone: Option<Vec<Option<f64>>>,  
    pub repetition_num: Option<u16>,  
    pub min_altitude: Option<f64>,  
    pub min_heart_rate: Option<u8>,  
    pub active_time: Option<f64>,  
    pub wkt_step_index: Option<FitFieldMessageIndex>,  
    pub sport_event: Option<FitFieldSportEvent>,  
    pub avg_left_torque_effectiveness: Option<f64>,  
    pub avg_right_torque_effectiveness: Option<f64>,  
    pub avg_left_pedal_smoothness: Option<f64>,  
    pub avg_right_pedal_smoothness: Option<f64>,  
    pub avg_combined_pedal_smoothness: Option<f64>,  
    pub status: Option<FitFieldSegmentLapStatus>,  
    pub uuid: Option<String>,  
    pub avg_fractional_cadence: Option<f64>,  // fractional part of the avg_cadence
    pub max_fractional_cadence: Option<f64>,  // fractional part of the max_cadence
    pub total_fractional_cycles: Option<f64>,  // fractional part of the total_cycles
    pub front_gear_shift_count: Option<u16>,  
    pub rear_gear_shift_count: Option<u16>,  
    pub time_standing: Option<f64>,  // Total time spent in the standing position
    pub stand_count: Option<u16>,  // Number of transitions to the standing state
    pub avg_left_pco: Option<i8>,  // Average left platform center offset
    pub avg_right_pco: Option<i8>,  // Average right platform center offset
    pub avg_left_power_phase: Option<Vec<Option<f64>>>,  // Average left power phase angles. Data value indexes defined by power_phase_type.
    pub avg_left_power_phase_peak: Option<Vec<Option<f64>>>,  // Average left power phase peak angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase: Option<Vec<Option<f64>>>,  // Average right power phase angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase_peak: Option<Vec<Option<f64>>>,  // Average right power phase peak angles. Data value indexes defined by power_phase_type.
    pub avg_power_position: Option<Vec<Option<u16>>>,  // Average power by position. Data value indexes defined by rider_position_type.
    pub max_power_position: Option<Vec<Option<u16>>>,  // Maximum power by position. Data value indexes defined by rider_position_type.
    pub avg_cadence_position: Option<Vec<Option<u8>>>,  // Average cadence by position. Data value indexes defined by rider_position_type.
    pub max_cadence_position: Option<Vec<Option<u8>>>,  // Maximum cadence by position. Data value indexes defined by rider_position_type.
    pub manufacturer: Option<FitFieldManufacturer>,  // Manufacturer that produced the segment
    
}

impl fmt::Display for FitMessageSegmentLap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentLap")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.event { writeln!(f, "  {: >28}: {:?}", "event", v)?; }
        if let Some(v) = &self.event_type { writeln!(f, "  {: >28}: {:?}", "event_type", v)?; }
        if let Some(v) = &self.start_time { writeln!(f, "  {: >28}: {:?}", "start_time", v)?; }
        if let Some(v) = &self.start_position_lat { writeln!(f, "  {: >28}: {:?}", "start_position_lat", v)?; }
        if let Some(v) = &self.start_position_long { writeln!(f, "  {: >28}: {:?}", "start_position_long", v)?; }
        if let Some(v) = &self.end_position_lat { writeln!(f, "  {: >28}: {:?}", "end_position_lat", v)?; }
        if let Some(v) = &self.end_position_long { writeln!(f, "  {: >28}: {:?}", "end_position_long", v)?; }
        if let Some(v) = &self.total_elapsed_time { writeln!(f, "  {: >28}: {:?}", "total_elapsed_time", v)?; }
        if let Some(v) = &self.total_timer_time { writeln!(f, "  {: >28}: {:?}", "total_timer_time", v)?; }
        if let Some(v) = &self.total_distance { writeln!(f, "  {: >28}: {:?}", "total_distance", v)?; }
        writeln!(f, "  {: >28}: {:?}", "total_cycles_subfield_bytes", self.total_cycles_subfield_bytes)?;
        if let Some(v) = &self.total_cycles { writeln!(f, "  {: >28}: {:?}", "total_cycles", v)?; }
        if let Some(v) = &self.total_calories { writeln!(f, "  {: >28}: {:?}", "total_calories", v)?; }
        if let Some(v) = &self.total_fat_calories { writeln!(f, "  {: >28}: {:?}", "total_fat_calories", v)?; }
        if let Some(v) = &self.avg_speed { writeln!(f, "  {: >28}: {:?}", "avg_speed", v)?; }
        if let Some(v) = &self.max_speed { writeln!(f, "  {: >28}: {:?}", "max_speed", v)?; }
        if let Some(v) = &self.avg_heart_rate { writeln!(f, "  {: >28}: {:?}", "avg_heart_rate", v)?; }
        if let Some(v) = &self.max_heart_rate { writeln!(f, "  {: >28}: {:?}", "max_heart_rate", v)?; }
        if let Some(v) = &self.avg_cadence { writeln!(f, "  {: >28}: {:?}", "avg_cadence", v)?; }
        if let Some(v) = &self.max_cadence { writeln!(f, "  {: >28}: {:?}", "max_cadence", v)?; }
        if let Some(v) = &self.avg_power { writeln!(f, "  {: >28}: {:?}", "avg_power", v)?; }
        if let Some(v) = &self.max_power { writeln!(f, "  {: >28}: {:?}", "max_power", v)?; }
        if let Some(v) = &self.total_ascent { writeln!(f, "  {: >28}: {:?}", "total_ascent", v)?; }
        if let Some(v) = &self.total_descent { writeln!(f, "  {: >28}: {:?}", "total_descent", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.event_group { writeln!(f, "  {: >28}: {:?}", "event_group", v)?; }
        if let Some(v) = &self.nec_lat { writeln!(f, "  {: >28}: {:?}", "nec_lat", v)?; }
        if let Some(v) = &self.nec_long { writeln!(f, "  {: >28}: {:?}", "nec_long", v)?; }
        if let Some(v) = &self.swc_lat { writeln!(f, "  {: >28}: {:?}", "swc_lat", v)?; }
        if let Some(v) = &self.swc_long { writeln!(f, "  {: >28}: {:?}", "swc_long", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.normalized_power { writeln!(f, "  {: >28}: {:?}", "normalized_power", v)?; }
        if let Some(v) = &self.left_right_balance { writeln!(f, "  {: >28}: {:?}", "left_right_balance", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.total_work { writeln!(f, "  {: >28}: {:?}", "total_work", v)?; }
        if let Some(v) = &self.avg_altitude { writeln!(f, "  {: >28}: {:?}", "avg_altitude", v)?; }
        if let Some(v) = &self.max_altitude { writeln!(f, "  {: >28}: {:?}", "max_altitude", v)?; }
        if let Some(v) = &self.gps_accuracy { writeln!(f, "  {: >28}: {:?}", "gps_accuracy", v)?; }
        if let Some(v) = &self.avg_grade { writeln!(f, "  {: >28}: {:?}", "avg_grade", v)?; }
        if let Some(v) = &self.avg_pos_grade { writeln!(f, "  {: >28}: {:?}", "avg_pos_grade", v)?; }
        if let Some(v) = &self.avg_neg_grade { writeln!(f, "  {: >28}: {:?}", "avg_neg_grade", v)?; }
        if let Some(v) = &self.max_pos_grade { writeln!(f, "  {: >28}: {:?}", "max_pos_grade", v)?; }
        if let Some(v) = &self.max_neg_grade { writeln!(f, "  {: >28}: {:?}", "max_neg_grade", v)?; }
        if let Some(v) = &self.avg_temperature { writeln!(f, "  {: >28}: {:?}", "avg_temperature", v)?; }
        if let Some(v) = &self.max_temperature { writeln!(f, "  {: >28}: {:?}", "max_temperature", v)?; }
        if let Some(v) = &self.total_moving_time { writeln!(f, "  {: >28}: {:?}", "total_moving_time", v)?; }
        if let Some(v) = &self.avg_pos_vertical_speed { writeln!(f, "  {: >28}: {:?}", "avg_pos_vertical_speed", v)?; }
        if let Some(v) = &self.avg_neg_vertical_speed { writeln!(f, "  {: >28}: {:?}", "avg_neg_vertical_speed", v)?; }
        if let Some(v) = &self.max_pos_vertical_speed { writeln!(f, "  {: >28}: {:?}", "max_pos_vertical_speed", v)?; }
        if let Some(v) = &self.max_neg_vertical_speed { writeln!(f, "  {: >28}: {:?}", "max_neg_vertical_speed", v)?; }
        if let Some(v) = &self.time_in_hr_zone { writeln!(f, "  {: >28}: {:?}", "time_in_hr_zone", v)?; }
        if let Some(v) = &self.time_in_speed_zone { writeln!(f, "  {: >28}: {:?}", "time_in_speed_zone", v)?; }
        if let Some(v) = &self.time_in_cadence_zone { writeln!(f, "  {: >28}: {:?}", "time_in_cadence_zone", v)?; }
        if let Some(v) = &self.time_in_power_zone { writeln!(f, "  {: >28}: {:?}", "time_in_power_zone", v)?; }
        if let Some(v) = &self.repetition_num { writeln!(f, "  {: >28}: {:?}", "repetition_num", v)?; }
        if let Some(v) = &self.min_altitude { writeln!(f, "  {: >28}: {:?}", "min_altitude", v)?; }
        if let Some(v) = &self.min_heart_rate { writeln!(f, "  {: >28}: {:?}", "min_heart_rate", v)?; }
        if let Some(v) = &self.active_time { writeln!(f, "  {: >28}: {:?}", "active_time", v)?; }
        if let Some(v) = &self.wkt_step_index { writeln!(f, "  {: >28}: {:?}", "wkt_step_index", v)?; }
        if let Some(v) = &self.sport_event { writeln!(f, "  {: >28}: {:?}", "sport_event", v)?; }
        if let Some(v) = &self.avg_left_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "avg_left_torque_effectiveness", v)?; }
        if let Some(v) = &self.avg_right_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "avg_right_torque_effectiveness", v)?; }
        if let Some(v) = &self.avg_left_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_left_pedal_smoothness", v)?; }
        if let Some(v) = &self.avg_right_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_right_pedal_smoothness", v)?; }
        if let Some(v) = &self.avg_combined_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_combined_pedal_smoothness", v)?; }
        if let Some(v) = &self.status { writeln!(f, "  {: >28}: {:?}", "status", v)?; }
        if let Some(v) = &self.uuid { writeln!(f, "  {: >28}: {:?}", "uuid", v)?; }
        if let Some(v) = &self.avg_fractional_cadence { writeln!(f, "  {: >28}: {:?}", "avg_fractional_cadence", v)?; }
        if let Some(v) = &self.max_fractional_cadence { writeln!(f, "  {: >28}: {:?}", "max_fractional_cadence", v)?; }
        if let Some(v) = &self.total_fractional_cycles { writeln!(f, "  {: >28}: {:?}", "total_fractional_cycles", v)?; }
        if let Some(v) = &self.front_gear_shift_count { writeln!(f, "  {: >28}: {:?}", "front_gear_shift_count", v)?; }
        if let Some(v) = &self.rear_gear_shift_count { writeln!(f, "  {: >28}: {:?}", "rear_gear_shift_count", v)?; }
        if let Some(v) = &self.time_standing { writeln!(f, "  {: >28}: {:?}", "time_standing", v)?; }
        if let Some(v) = &self.stand_count { writeln!(f, "  {: >28}: {:?}", "stand_count", v)?; }
        if let Some(v) = &self.avg_left_pco { writeln!(f, "  {: >28}: {:?}", "avg_left_pco", v)?; }
        if let Some(v) = &self.avg_right_pco { writeln!(f, "  {: >28}: {:?}", "avg_right_pco", v)?; }
        if let Some(v) = &self.avg_left_power_phase { writeln!(f, "  {: >28}: {:?}", "avg_left_power_phase", v)?; }
        if let Some(v) = &self.avg_left_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "avg_left_power_phase_peak", v)?; }
        if let Some(v) = &self.avg_right_power_phase { writeln!(f, "  {: >28}: {:?}", "avg_right_power_phase", v)?; }
        if let Some(v) = &self.avg_right_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "avg_right_power_phase_peak", v)?; }
        if let Some(v) = &self.avg_power_position { writeln!(f, "  {: >28}: {:?}", "avg_power_position", v)?; }
        if let Some(v) = &self.max_power_position { writeln!(f, "  {: >28}: {:?}", "max_power_position", v)?; }
        if let Some(v) = &self.avg_cadence_position { writeln!(f, "  {: >28}: {:?}", "avg_cadence_position", v)?; }
        if let Some(v) = &self.max_cadence_position { writeln!(f, "  {: >28}: {:?}", "max_cadence_position", v)?; }
        if let Some(v) = &self.manufacturer { writeln!(f, "  {: >28}: {:?}", "manufacturer", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentLap {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSegmentLap>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSegmentLap {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSegmentLap",
            message_index: None,
            timestamp: None,
            event: None,
            event_type: None,
            start_time: None,
            start_position_lat: None,
            start_position_long: None,
            end_position_lat: None,
            end_position_long: None,
            total_elapsed_time: None,
            total_timer_time: None,
            total_distance: None,
            total_cycles_subfield_bytes: vec![],
            total_cycles: None,
            total_calories: None,
            total_fat_calories: None,
            avg_speed: None,
            max_speed: None,
            avg_heart_rate: None,
            max_heart_rate: None,
            avg_cadence: None,
            max_cadence: None,
            avg_power: None,
            max_power: None,
            total_ascent: None,
            total_descent: None,
            sport: None,
            event_group: None,
            nec_lat: None,
            nec_long: None,
            swc_lat: None,
            swc_long: None,
            name: None,
            normalized_power: None,
            left_right_balance: None,
            sub_sport: None,
            total_work: None,
            avg_altitude: None,
            max_altitude: None,
            gps_accuracy: None,
            avg_grade: None,
            avg_pos_grade: None,
            avg_neg_grade: None,
            max_pos_grade: None,
            max_neg_grade: None,
            avg_temperature: None,
            max_temperature: None,
            total_moving_time: None,
            avg_pos_vertical_speed: None,
            avg_neg_vertical_speed: None,
            max_pos_vertical_speed: None,
            max_neg_vertical_speed: None,
            time_in_hr_zone: None,
            time_in_speed_zone: None,
            time_in_cadence_zone: None,
            time_in_power_zone: None,
            repetition_num: None,
            min_altitude: None,
            min_heart_rate: None,
            active_time: None,
            wkt_step_index: None,
            sport_event: None,
            avg_left_torque_effectiveness: None,
            avg_right_torque_effectiveness: None,
            avg_left_pedal_smoothness: None,
            avg_right_pedal_smoothness: None,
            avg_combined_pedal_smoothness: None,
            status: None,
            uuid: None,
            avg_fractional_cadence: None,
            max_fractional_cadence: None,
            total_fractional_cycles: None,
            front_gear_shift_count: None,
            rear_gear_shift_count: None,
            time_standing: None,
            stand_count: None,
            avg_left_pco: None,
            avg_right_pco: None,
            avg_left_power_phase: None,
            avg_left_power_phase_peak: None,
            avg_right_power_phase: None,
            avg_right_power_phase_peak: None,
            avg_power_position: None,
            max_power_position: None,
            avg_cadence_position: None,
            max_cadence_position: None,
            manufacturer: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSegmentLap::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSegmentLap:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageSegmentLap::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageSegmentLap:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageSegmentLap, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 10).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageSegmentLapSubfieldTotalCycles::parse(message, &message.total_cycles_subfield_bytes, &field, _tz_offset)?;
            message.total_cycles = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageSegmentLap, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEvent::parse(&inp[0..f.field_size])?;
                                
                                message.event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEventType::parse(&inp[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // start_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // start_position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // start_position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // end_position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // end_position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.end_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.end_position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // total_elapsed_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // total_timer_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // total_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // total_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.total_cycles_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.total_cycles_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // total_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // total_fat_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_fat_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_fat_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // avg_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // max_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    15 => {  // avg_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.avg_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    16 => {  // max_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // avg_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_cadence = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.avg_cadence = val;
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // max_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.max_cadence = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.max_cadence = val;
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // avg_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // max_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // total_ascent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_ascent = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_ascent = val;
                            }
                        }

                        Ok(())
                    },
                
                    22 => {  // total_descent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_descent = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_descent = val;
                            }
                        }

                        Ok(())
                    },
                
                    23 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    24 => {  // event_group
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.event_group = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.event_group = val;
                            }
                        }

                        Ok(())
                    },
                
                    25 => {  // nec_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    26 => {  // nec_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    27 => {  // swc_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    28 => {  // swc_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    29 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    30 => {  // normalized_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.normalized_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.normalized_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    31 => {  // left_right_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLeftRightBalance100::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.left_right_balance = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLeftRightBalance100::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.left_right_balance = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    32 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    33 => {  // total_work
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_work = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_work = val;
                            }
                        }

                        Ok(())
                    },
                
                    34 => {  // avg_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.avg_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.avg_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    35 => {  // max_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.max_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.max_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    36 => {  // gps_accuracy
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            }
                        }

                        Ok(())
                    },
                
                    37 => {  // avg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    38 => {  // avg_pos_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_pos_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_pos_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    39 => {  // avg_neg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_neg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_neg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    40 => {  // max_pos_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_pos_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_pos_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    41 => {  // max_neg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_neg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_neg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    42 => {  // avg_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    43 => {  // max_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.max_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.max_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    44 => {  // total_moving_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_moving_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_moving_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_moving_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_moving_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    45 => {  // avg_pos_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_pos_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_pos_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    46 => {  // avg_neg_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_neg_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_neg_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    47 => {  // max_pos_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_pos_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_pos_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    48 => {  // max_neg_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_neg_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_neg_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    49 => {  // time_in_hr_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_hr_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_hr_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    50 => {  // time_in_speed_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_speed_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_speed_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    51 => {  // time_in_cadence_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_cadence_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_cadence_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    52 => {  // time_in_power_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_power_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_power_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    53 => {  // repetition_num
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.repetition_num = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.repetition_num = val;
                            }
                        }

                        Ok(())
                    },
                
                    54 => {  // min_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.min_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.min_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    55 => {  // min_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.min_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.min_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    56 => {  // active_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.active_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.active_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.active_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.active_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    57 => {  // wkt_step_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wkt_step_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wkt_step_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    58 => {  // sport_event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSportEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport_event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSportEvent::parse(&inp[0..f.field_size])?;
                                
                                message.sport_event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    59 => {  // avg_left_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    60 => {  // avg_right_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    61 => {  // avg_left_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    62 => {  // avg_right_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    63 => {  // avg_combined_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_combined_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_combined_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    64 => {  // status
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSegmentLapStatus::parse(&&bytes[0..f.field_size])?;
                                
                                message.status = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSegmentLapStatus::parse(&inp[0..f.field_size])?;
                                
                                message.status = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    65 => {  // uuid
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.uuid = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.uuid = val;
                            }
                        }

                        Ok(())
                    },
                
                    66 => {  // avg_fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.avg_fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.avg_fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    67 => {  // max_fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.max_fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.max_fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    68 => {  // total_fractional_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_fractional_cycles = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.total_fractional_cycles = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_fractional_cycles = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.total_fractional_cycles = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    69 => {  // front_gear_shift_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.front_gear_shift_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.front_gear_shift_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    70 => {  // rear_gear_shift_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.rear_gear_shift_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.rear_gear_shift_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    71 => {  // time_standing
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_standing = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_standing = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_standing = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_standing = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    72 => {  // stand_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stand_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stand_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    73 => {  // avg_left_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_left_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_left_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    74 => {  // avg_right_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_right_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_right_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    75 => {  // avg_left_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    76 => {  // avg_left_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    77 => {  // avg_right_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    78 => {  // avg_right_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    79 => {  // avg_power_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_power_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_power_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    80 => {  // max_power_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_power_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_power_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    81 => {  // avg_cadence_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_cadence_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_cadence_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    82 => {  // max_cadence_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_cadence_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_cadence_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    83 => {  // manufacturer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentLap {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentLap";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentLeaderboardEntry {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub name: Option<String>,  // Friendly name assigned to leader
    pub ftype: Option<FitFieldSegmentLeaderboardType>,  // Leader classification
    pub group_primary_key: Option<u32>,  // Primary user ID of this leader
    pub activity_id: Option<u32>,  // ID of the activity associated with this leader time
    pub segment_time: Option<f64>,  // Segment Time (includes pauses)
    pub activity_id_string: Option<String>,  // String version of the activity_id. 21 characters long, express in decimal
    
}

impl fmt::Display for FitMessageSegmentLeaderboardEntry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentLeaderboardEntry")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.group_primary_key { writeln!(f, "  {: >28}: {:?}", "group_primary_key", v)?; }
        if let Some(v) = &self.activity_id { writeln!(f, "  {: >28}: {:?}", "activity_id", v)?; }
        if let Some(v) = &self.segment_time { writeln!(f, "  {: >28}: {:?}", "segment_time", v)?; }
        if let Some(v) = &self.activity_id_string { writeln!(f, "  {: >28}: {:?}", "activity_id_string", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentLeaderboardEntry {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSegmentLeaderboardEntry>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSegmentLeaderboardEntry {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSegmentLeaderboardEntry",
            message_index: None,
            name: None,
            ftype: None,
            group_primary_key: None,
            activity_id: None,
            segment_time: None,
            activity_id_string: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSegmentLeaderboardEntry::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSegmentLeaderboardEntry:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSegmentLeaderboardEntry, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSegmentLeaderboardType::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSegmentLeaderboardType::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // group_primary_key
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.group_primary_key = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.group_primary_key = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // activity_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.activity_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.activity_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // segment_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.segment_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.segment_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.segment_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.segment_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // activity_id_string
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.activity_id_string = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.activity_id_string = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentLeaderboardEntry {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentLeaderboardEntry";
    }
}

#[derive(Debug)]
pub struct FitMessageSegmentPoint {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub position_lat: Option<f64>,  
    pub position_long: Option<f64>,  
    pub distance: Option<f64>,  // Accumulated distance along the segment at the described point
    pub altitude: Option<f64>,  // Accumulated altitude along the segment at the described point
    pub leader_time: Option<Vec<Option<f64>>>,  // Accumualted time each leader board member required to reach the described point. This value is zero for all leader board members at the starting point of the segment.
    
}

impl fmt::Display for FitMessageSegmentPoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSegmentPoint")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.position_lat { writeln!(f, "  {: >28}: {:?}", "position_lat", v)?; }
        if let Some(v) = &self.position_long { writeln!(f, "  {: >28}: {:?}", "position_long", v)?; }
        if let Some(v) = &self.distance { writeln!(f, "  {: >28}: {:?}", "distance", v)?; }
        if let Some(v) = &self.altitude { writeln!(f, "  {: >28}: {:?}", "altitude", v)?; }
        if let Some(v) = &self.leader_time { writeln!(f, "  {: >28}: {:?}", "leader_time", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSegmentPoint {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSegmentPoint>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSegmentPoint {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSegmentPoint",
            message_index: None,
            position_lat: None,
            position_long: None,
            distance: None,
            altitude: None,
            leader_time: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSegmentPoint::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSegmentPoint:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSegmentPoint, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // leader_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_time = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.leader_time = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSegmentPoint {
    fn message_name(&self) -> &'static str {
        return "FitMessageSegmentPoint";
    }
}

#[derive(Debug)]
pub enum FitMessageSessionSubfieldTotalCycles {
    Default(Option<u32>),
    TotalStrides(Option<u32>),
}

impl FitMessageSessionSubfieldTotalCycles {
    fn parse<'a>(message: &FitMessageSession, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageSessionSubfieldTotalCycles> {
        
        match message.sport {
        
            Some(FitFieldSport::Running) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSessionSubfieldTotalCycles::TotalStrides(val))
                },
        
            Some(FitFieldSport::Walking) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSessionSubfieldTotalCycles::TotalStrides(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageSessionSubfieldTotalCycles::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageSessionSubfieldAvgCadence {
    Default(Option<u8>),
    AvgRunningCadence(Option<u8>),
}

impl FitMessageSessionSubfieldAvgCadence {
    fn parse<'a>(message: &FitMessageSession, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageSessionSubfieldAvgCadence> {
        
        match message.sport {
        
            Some(FitFieldSport::Running) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageSessionSubfieldAvgCadence::AvgRunningCadence(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint8(&inp[0..f.field_size])?;
        Ok(FitMessageSessionSubfieldAvgCadence::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageSessionSubfieldMaxCadence {
    Default(Option<u8>),
    MaxRunningCadence(Option<u8>),
}

impl FitMessageSessionSubfieldMaxCadence {
    fn parse<'a>(message: &FitMessageSession, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageSessionSubfieldMaxCadence> {
        
        match message.sport {
        
            Some(FitFieldSport::Running) => {
                let val = parse_uint8(&inp[0..f.field_size])?;
                
                return Ok(FitMessageSessionSubfieldMaxCadence::MaxRunningCadence(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint8(&inp[0..f.field_size])?;
        Ok(FitMessageSessionSubfieldMaxCadence::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageSession {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  // Selected bit is set for the current session.
    pub timestamp: Option<FitFieldDateTime>,  // Sesson end time.
    pub event: Option<FitFieldEvent>,  // session
    pub event_type: Option<FitFieldEventType>,  // stop
    pub start_time: Option<FitFieldDateTime>,  
    pub start_position_lat: Option<f64>,  
    pub start_position_long: Option<f64>,  
    pub sport: Option<FitFieldSport>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub total_elapsed_time: Option<f64>,  // Time (includes pauses)
    pub total_timer_time: Option<f64>,  // Timer Time (excludes pauses)
    pub total_distance: Option<f64>,  
    pub total_cycles_subfield_bytes: Vec<u8>,
    pub total_cycles: Option<FitMessageSessionSubfieldTotalCycles>,  
    pub total_calories: Option<u16>,  
    pub total_fat_calories: Option<u16>,  
    pub avg_speed: Option<f64>,  // total_distance / total_timer_time
    pub max_speed: Option<f64>,  
    pub avg_heart_rate: Option<u8>,  // average heart rate (excludes pause time)
    pub max_heart_rate: Option<u8>,  
    pub avg_cadence_subfield_bytes: Vec<u8>,
    pub avg_cadence: Option<FitMessageSessionSubfieldAvgCadence>,  // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
    pub max_cadence_subfield_bytes: Vec<u8>,
    pub max_cadence: Option<FitMessageSessionSubfieldMaxCadence>,  
    pub avg_power: Option<u16>,  // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
    pub max_power: Option<u16>,  
    pub total_ascent: Option<u16>,  
    pub total_descent: Option<u16>,  
    pub total_training_effect: Option<f64>,  
    pub first_lap_index: Option<u16>,  
    pub num_laps: Option<u16>,  
    pub event_group: Option<u8>,  
    pub trigger: Option<FitFieldSessionTrigger>,  
    pub nec_lat: Option<f64>,  
    pub nec_long: Option<f64>,  
    pub swc_lat: Option<f64>,  
    pub swc_long: Option<f64>,  
    pub normalized_power: Option<u16>,  
    pub training_stress_score: Option<f64>,  
    pub intensity_factor: Option<f64>,  
    pub left_right_balance: Option<FitFieldLeftRightBalance100>,  
    pub avg_stroke_count: Option<f64>,  
    pub avg_stroke_distance: Option<f64>,  
    pub swim_stroke: Option<FitFieldSwimStroke>,  
    pub pool_length: Option<f64>,  
    pub threshold_power: Option<u16>,  
    pub pool_length_unit: Option<FitFieldDisplayMeasure>,  
    pub num_active_lengths: Option<u16>,  // # of active lengths of swim pool
    pub total_work: Option<u32>,  
    pub avg_altitude: Option<f64>,  
    pub max_altitude: Option<f64>,  
    pub gps_accuracy: Option<u8>,  
    pub avg_grade: Option<f64>,  
    pub avg_pos_grade: Option<f64>,  
    pub avg_neg_grade: Option<f64>,  
    pub max_pos_grade: Option<f64>,  
    pub max_neg_grade: Option<f64>,  
    pub avg_temperature: Option<i8>,  
    pub max_temperature: Option<i8>,  
    pub total_moving_time: Option<f64>,  
    pub avg_pos_vertical_speed: Option<f64>,  
    pub avg_neg_vertical_speed: Option<f64>,  
    pub max_pos_vertical_speed: Option<f64>,  
    pub max_neg_vertical_speed: Option<f64>,  
    pub min_heart_rate: Option<u8>,  
    pub time_in_hr_zone: Option<Vec<Option<f64>>>,  
    pub time_in_speed_zone: Option<Vec<Option<f64>>>,  
    pub time_in_cadence_zone: Option<Vec<Option<f64>>>,  
    pub time_in_power_zone: Option<Vec<Option<f64>>>,  
    pub avg_lap_time: Option<f64>,  
    pub best_lap_index: Option<u16>,  
    pub min_altitude: Option<f64>,  
    pub player_score: Option<u16>,  
    pub opponent_score: Option<u16>,  
    pub opponent_name: Option<String>,  
    pub stroke_count: Option<Vec<Option<u16>>>,  // stroke_type enum used as the index
    pub zone_count: Option<Vec<Option<u16>>>,  // zone number used as the index
    pub max_ball_speed: Option<f64>,  
    pub avg_ball_speed: Option<f64>,  
    pub avg_vertical_oscillation: Option<f64>,  
    pub avg_stance_time_percent: Option<f64>,  
    pub avg_stance_time: Option<f64>,  
    pub avg_fractional_cadence: Option<f64>,  // fractional part of the avg_cadence
    pub max_fractional_cadence: Option<f64>,  // fractional part of the max_cadence
    pub total_fractional_cycles: Option<f64>,  // fractional part of the total_cycles
    pub avg_total_hemoglobin_conc: Option<Vec<Option<f64>>>,  // Avg saturated and unsaturated hemoglobin
    pub min_total_hemoglobin_conc: Option<Vec<Option<f64>>>,  // Min saturated and unsaturated hemoglobin
    pub max_total_hemoglobin_conc: Option<Vec<Option<f64>>>,  // Max saturated and unsaturated hemoglobin
    pub avg_saturated_hemoglobin_percent: Option<Vec<Option<f64>>>,  // Avg percentage of hemoglobin saturated with oxygen
    pub min_saturated_hemoglobin_percent: Option<Vec<Option<f64>>>,  // Min percentage of hemoglobin saturated with oxygen
    pub max_saturated_hemoglobin_percent: Option<Vec<Option<f64>>>,  // Max percentage of hemoglobin saturated with oxygen
    pub avg_left_torque_effectiveness: Option<f64>,  
    pub avg_right_torque_effectiveness: Option<f64>,  
    pub avg_left_pedal_smoothness: Option<f64>,  
    pub avg_right_pedal_smoothness: Option<f64>,  
    pub avg_combined_pedal_smoothness: Option<f64>,  
    pub sport_index: Option<u8>,  
    pub time_standing: Option<f64>,  // Total time spend in the standing position
    pub stand_count: Option<u16>,  // Number of transitions to the standing state
    pub avg_left_pco: Option<i8>,  // Average platform center offset Left
    pub avg_right_pco: Option<i8>,  // Average platform center offset Right
    pub avg_left_power_phase: Option<Vec<Option<f64>>>,  // Average left power phase angles. Indexes defined by power_phase_type.
    pub avg_left_power_phase_peak: Option<Vec<Option<f64>>>,  // Average left power phase peak angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase: Option<Vec<Option<f64>>>,  // Average right power phase angles. Data value indexes defined by power_phase_type.
    pub avg_right_power_phase_peak: Option<Vec<Option<f64>>>,  // Average right power phase peak angles data value indexes  defined by power_phase_type.
    pub avg_power_position: Option<Vec<Option<u16>>>,  // Average power by position. Data value indexes defined by rider_position_type.
    pub max_power_position: Option<Vec<Option<u16>>>,  // Maximum power by position. Data value indexes defined by rider_position_type.
    pub avg_cadence_position: Option<Vec<Option<u8>>>,  // Average cadence by position. Data value indexes defined by rider_position_type.
    pub max_cadence_position: Option<Vec<Option<u8>>>,  // Maximum cadence by position. Data value indexes defined by rider_position_type.
    pub enhanced_avg_speed: Option<f64>,  // total_distance / total_timer_time
    pub enhanced_max_speed: Option<f64>,  
    pub enhanced_avg_altitude: Option<f64>,  
    pub enhanced_min_altitude: Option<f64>,  
    pub enhanced_max_altitude: Option<f64>,  
    pub avg_lev_motor_power: Option<u16>,  // lev average motor power during session
    pub max_lev_motor_power: Option<u16>,  // lev maximum motor power during session
    pub lev_battery_consumption: Option<f64>,  // lev battery consumption during session
    pub avg_vertical_ratio: Option<f64>,  
    pub avg_stance_time_balance: Option<f64>,  
    pub avg_step_length: Option<f64>,  
    pub total_anaerobic_training_effect: Option<f64>,  
    pub avg_vam: Option<f64>,  
    
}

impl fmt::Display for FitMessageSession {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSession")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.event { writeln!(f, "  {: >28}: {:?}", "event", v)?; }
        if let Some(v) = &self.event_type { writeln!(f, "  {: >28}: {:?}", "event_type", v)?; }
        if let Some(v) = &self.start_time { writeln!(f, "  {: >28}: {:?}", "start_time", v)?; }
        if let Some(v) = &self.start_position_lat { writeln!(f, "  {: >28}: {:?}", "start_position_lat", v)?; }
        if let Some(v) = &self.start_position_long { writeln!(f, "  {: >28}: {:?}", "start_position_long", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.total_elapsed_time { writeln!(f, "  {: >28}: {:?}", "total_elapsed_time", v)?; }
        if let Some(v) = &self.total_timer_time { writeln!(f, "  {: >28}: {:?}", "total_timer_time", v)?; }
        if let Some(v) = &self.total_distance { writeln!(f, "  {: >28}: {:?}", "total_distance", v)?; }
        writeln!(f, "  {: >28}: {:?}", "total_cycles_subfield_bytes", self.total_cycles_subfield_bytes)?;
        if let Some(v) = &self.total_cycles { writeln!(f, "  {: >28}: {:?}", "total_cycles", v)?; }
        if let Some(v) = &self.total_calories { writeln!(f, "  {: >28}: {:?}", "total_calories", v)?; }
        if let Some(v) = &self.total_fat_calories { writeln!(f, "  {: >28}: {:?}", "total_fat_calories", v)?; }
        if let Some(v) = &self.avg_speed { writeln!(f, "  {: >28}: {:?}", "avg_speed", v)?; }
        if let Some(v) = &self.max_speed { writeln!(f, "  {: >28}: {:?}", "max_speed", v)?; }
        if let Some(v) = &self.avg_heart_rate { writeln!(f, "  {: >28}: {:?}", "avg_heart_rate", v)?; }
        if let Some(v) = &self.max_heart_rate { writeln!(f, "  {: >28}: {:?}", "max_heart_rate", v)?; }
        writeln!(f, "  {: >28}: {:?}", "avg_cadence_subfield_bytes", self.avg_cadence_subfield_bytes)?;
        if let Some(v) = &self.avg_cadence { writeln!(f, "  {: >28}: {:?}", "avg_cadence", v)?; }
        writeln!(f, "  {: >28}: {:?}", "max_cadence_subfield_bytes", self.max_cadence_subfield_bytes)?;
        if let Some(v) = &self.max_cadence { writeln!(f, "  {: >28}: {:?}", "max_cadence", v)?; }
        if let Some(v) = &self.avg_power { writeln!(f, "  {: >28}: {:?}", "avg_power", v)?; }
        if let Some(v) = &self.max_power { writeln!(f, "  {: >28}: {:?}", "max_power", v)?; }
        if let Some(v) = &self.total_ascent { writeln!(f, "  {: >28}: {:?}", "total_ascent", v)?; }
        if let Some(v) = &self.total_descent { writeln!(f, "  {: >28}: {:?}", "total_descent", v)?; }
        if let Some(v) = &self.total_training_effect { writeln!(f, "  {: >28}: {:?}", "total_training_effect", v)?; }
        if let Some(v) = &self.first_lap_index { writeln!(f, "  {: >28}: {:?}", "first_lap_index", v)?; }
        if let Some(v) = &self.num_laps { writeln!(f, "  {: >28}: {:?}", "num_laps", v)?; }
        if let Some(v) = &self.event_group { writeln!(f, "  {: >28}: {:?}", "event_group", v)?; }
        if let Some(v) = &self.trigger { writeln!(f, "  {: >28}: {:?}", "trigger", v)?; }
        if let Some(v) = &self.nec_lat { writeln!(f, "  {: >28}: {:?}", "nec_lat", v)?; }
        if let Some(v) = &self.nec_long { writeln!(f, "  {: >28}: {:?}", "nec_long", v)?; }
        if let Some(v) = &self.swc_lat { writeln!(f, "  {: >28}: {:?}", "swc_lat", v)?; }
        if let Some(v) = &self.swc_long { writeln!(f, "  {: >28}: {:?}", "swc_long", v)?; }
        if let Some(v) = &self.normalized_power { writeln!(f, "  {: >28}: {:?}", "normalized_power", v)?; }
        if let Some(v) = &self.training_stress_score { writeln!(f, "  {: >28}: {:?}", "training_stress_score", v)?; }
        if let Some(v) = &self.intensity_factor { writeln!(f, "  {: >28}: {:?}", "intensity_factor", v)?; }
        if let Some(v) = &self.left_right_balance { writeln!(f, "  {: >28}: {:?}", "left_right_balance", v)?; }
        if let Some(v) = &self.avg_stroke_count { writeln!(f, "  {: >28}: {:?}", "avg_stroke_count", v)?; }
        if let Some(v) = &self.avg_stroke_distance { writeln!(f, "  {: >28}: {:?}", "avg_stroke_distance", v)?; }
        if let Some(v) = &self.swim_stroke { writeln!(f, "  {: >28}: {:?}", "swim_stroke", v)?; }
        if let Some(v) = &self.pool_length { writeln!(f, "  {: >28}: {:?}", "pool_length", v)?; }
        if let Some(v) = &self.threshold_power { writeln!(f, "  {: >28}: {:?}", "threshold_power", v)?; }
        if let Some(v) = &self.pool_length_unit { writeln!(f, "  {: >28}: {:?}", "pool_length_unit", v)?; }
        if let Some(v) = &self.num_active_lengths { writeln!(f, "  {: >28}: {:?}", "num_active_lengths", v)?; }
        if let Some(v) = &self.total_work { writeln!(f, "  {: >28}: {:?}", "total_work", v)?; }
        if let Some(v) = &self.avg_altitude { writeln!(f, "  {: >28}: {:?}", "avg_altitude", v)?; }
        if let Some(v) = &self.max_altitude { writeln!(f, "  {: >28}: {:?}", "max_altitude", v)?; }
        if let Some(v) = &self.gps_accuracy { writeln!(f, "  {: >28}: {:?}", "gps_accuracy", v)?; }
        if let Some(v) = &self.avg_grade { writeln!(f, "  {: >28}: {:?}", "avg_grade", v)?; }
        if let Some(v) = &self.avg_pos_grade { writeln!(f, "  {: >28}: {:?}", "avg_pos_grade", v)?; }
        if let Some(v) = &self.avg_neg_grade { writeln!(f, "  {: >28}: {:?}", "avg_neg_grade", v)?; }
        if let Some(v) = &self.max_pos_grade { writeln!(f, "  {: >28}: {:?}", "max_pos_grade", v)?; }
        if let Some(v) = &self.max_neg_grade { writeln!(f, "  {: >28}: {:?}", "max_neg_grade", v)?; }
        if let Some(v) = &self.avg_temperature { writeln!(f, "  {: >28}: {:?}", "avg_temperature", v)?; }
        if let Some(v) = &self.max_temperature { writeln!(f, "  {: >28}: {:?}", "max_temperature", v)?; }
        if let Some(v) = &self.total_moving_time { writeln!(f, "  {: >28}: {:?}", "total_moving_time", v)?; }
        if let Some(v) = &self.avg_pos_vertical_speed { writeln!(f, "  {: >28}: {:?}", "avg_pos_vertical_speed", v)?; }
        if let Some(v) = &self.avg_neg_vertical_speed { writeln!(f, "  {: >28}: {:?}", "avg_neg_vertical_speed", v)?; }
        if let Some(v) = &self.max_pos_vertical_speed { writeln!(f, "  {: >28}: {:?}", "max_pos_vertical_speed", v)?; }
        if let Some(v) = &self.max_neg_vertical_speed { writeln!(f, "  {: >28}: {:?}", "max_neg_vertical_speed", v)?; }
        if let Some(v) = &self.min_heart_rate { writeln!(f, "  {: >28}: {:?}", "min_heart_rate", v)?; }
        if let Some(v) = &self.time_in_hr_zone { writeln!(f, "  {: >28}: {:?}", "time_in_hr_zone", v)?; }
        if let Some(v) = &self.time_in_speed_zone { writeln!(f, "  {: >28}: {:?}", "time_in_speed_zone", v)?; }
        if let Some(v) = &self.time_in_cadence_zone { writeln!(f, "  {: >28}: {:?}", "time_in_cadence_zone", v)?; }
        if let Some(v) = &self.time_in_power_zone { writeln!(f, "  {: >28}: {:?}", "time_in_power_zone", v)?; }
        if let Some(v) = &self.avg_lap_time { writeln!(f, "  {: >28}: {:?}", "avg_lap_time", v)?; }
        if let Some(v) = &self.best_lap_index { writeln!(f, "  {: >28}: {:?}", "best_lap_index", v)?; }
        if let Some(v) = &self.min_altitude { writeln!(f, "  {: >28}: {:?}", "min_altitude", v)?; }
        if let Some(v) = &self.player_score { writeln!(f, "  {: >28}: {:?}", "player_score", v)?; }
        if let Some(v) = &self.opponent_score { writeln!(f, "  {: >28}: {:?}", "opponent_score", v)?; }
        if let Some(v) = &self.opponent_name { writeln!(f, "  {: >28}: {:?}", "opponent_name", v)?; }
        if let Some(v) = &self.stroke_count { writeln!(f, "  {: >28}: {:?}", "stroke_count", v)?; }
        if let Some(v) = &self.zone_count { writeln!(f, "  {: >28}: {:?}", "zone_count", v)?; }
        if let Some(v) = &self.max_ball_speed { writeln!(f, "  {: >28}: {:?}", "max_ball_speed", v)?; }
        if let Some(v) = &self.avg_ball_speed { writeln!(f, "  {: >28}: {:?}", "avg_ball_speed", v)?; }
        if let Some(v) = &self.avg_vertical_oscillation { writeln!(f, "  {: >28}: {:?}", "avg_vertical_oscillation", v)?; }
        if let Some(v) = &self.avg_stance_time_percent { writeln!(f, "  {: >28}: {:?}", "avg_stance_time_percent", v)?; }
        if let Some(v) = &self.avg_stance_time { writeln!(f, "  {: >28}: {:?}", "avg_stance_time", v)?; }
        if let Some(v) = &self.avg_fractional_cadence { writeln!(f, "  {: >28}: {:?}", "avg_fractional_cadence", v)?; }
        if let Some(v) = &self.max_fractional_cadence { writeln!(f, "  {: >28}: {:?}", "max_fractional_cadence", v)?; }
        if let Some(v) = &self.total_fractional_cycles { writeln!(f, "  {: >28}: {:?}", "total_fractional_cycles", v)?; }
        if let Some(v) = &self.avg_total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "avg_total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.min_total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "min_total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.max_total_hemoglobin_conc { writeln!(f, "  {: >28}: {:?}", "max_total_hemoglobin_conc", v)?; }
        if let Some(v) = &self.avg_saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "avg_saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.min_saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "min_saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.max_saturated_hemoglobin_percent { writeln!(f, "  {: >28}: {:?}", "max_saturated_hemoglobin_percent", v)?; }
        if let Some(v) = &self.avg_left_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "avg_left_torque_effectiveness", v)?; }
        if let Some(v) = &self.avg_right_torque_effectiveness { writeln!(f, "  {: >28}: {:?}", "avg_right_torque_effectiveness", v)?; }
        if let Some(v) = &self.avg_left_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_left_pedal_smoothness", v)?; }
        if let Some(v) = &self.avg_right_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_right_pedal_smoothness", v)?; }
        if let Some(v) = &self.avg_combined_pedal_smoothness { writeln!(f, "  {: >28}: {:?}", "avg_combined_pedal_smoothness", v)?; }
        if let Some(v) = &self.sport_index { writeln!(f, "  {: >28}: {:?}", "sport_index", v)?; }
        if let Some(v) = &self.time_standing { writeln!(f, "  {: >28}: {:?}", "time_standing", v)?; }
        if let Some(v) = &self.stand_count { writeln!(f, "  {: >28}: {:?}", "stand_count", v)?; }
        if let Some(v) = &self.avg_left_pco { writeln!(f, "  {: >28}: {:?}", "avg_left_pco", v)?; }
        if let Some(v) = &self.avg_right_pco { writeln!(f, "  {: >28}: {:?}", "avg_right_pco", v)?; }
        if let Some(v) = &self.avg_left_power_phase { writeln!(f, "  {: >28}: {:?}", "avg_left_power_phase", v)?; }
        if let Some(v) = &self.avg_left_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "avg_left_power_phase_peak", v)?; }
        if let Some(v) = &self.avg_right_power_phase { writeln!(f, "  {: >28}: {:?}", "avg_right_power_phase", v)?; }
        if let Some(v) = &self.avg_right_power_phase_peak { writeln!(f, "  {: >28}: {:?}", "avg_right_power_phase_peak", v)?; }
        if let Some(v) = &self.avg_power_position { writeln!(f, "  {: >28}: {:?}", "avg_power_position", v)?; }
        if let Some(v) = &self.max_power_position { writeln!(f, "  {: >28}: {:?}", "max_power_position", v)?; }
        if let Some(v) = &self.avg_cadence_position { writeln!(f, "  {: >28}: {:?}", "avg_cadence_position", v)?; }
        if let Some(v) = &self.max_cadence_position { writeln!(f, "  {: >28}: {:?}", "max_cadence_position", v)?; }
        if let Some(v) = &self.enhanced_avg_speed { writeln!(f, "  {: >28}: {:?}", "enhanced_avg_speed", v)?; }
        if let Some(v) = &self.enhanced_max_speed { writeln!(f, "  {: >28}: {:?}", "enhanced_max_speed", v)?; }
        if let Some(v) = &self.enhanced_avg_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_avg_altitude", v)?; }
        if let Some(v) = &self.enhanced_min_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_min_altitude", v)?; }
        if let Some(v) = &self.enhanced_max_altitude { writeln!(f, "  {: >28}: {:?}", "enhanced_max_altitude", v)?; }
        if let Some(v) = &self.avg_lev_motor_power { writeln!(f, "  {: >28}: {:?}", "avg_lev_motor_power", v)?; }
        if let Some(v) = &self.max_lev_motor_power { writeln!(f, "  {: >28}: {:?}", "max_lev_motor_power", v)?; }
        if let Some(v) = &self.lev_battery_consumption { writeln!(f, "  {: >28}: {:?}", "lev_battery_consumption", v)?; }
        if let Some(v) = &self.avg_vertical_ratio { writeln!(f, "  {: >28}: {:?}", "avg_vertical_ratio", v)?; }
        if let Some(v) = &self.avg_stance_time_balance { writeln!(f, "  {: >28}: {:?}", "avg_stance_time_balance", v)?; }
        if let Some(v) = &self.avg_step_length { writeln!(f, "  {: >28}: {:?}", "avg_step_length", v)?; }
        if let Some(v) = &self.total_anaerobic_training_effect { writeln!(f, "  {: >28}: {:?}", "total_anaerobic_training_effect", v)?; }
        if let Some(v) = &self.avg_vam { writeln!(f, "  {: >28}: {:?}", "avg_vam", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSession {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSession>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSession {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSession",
            message_index: None,
            timestamp: None,
            event: None,
            event_type: None,
            start_time: None,
            start_position_lat: None,
            start_position_long: None,
            sport: None,
            sub_sport: None,
            total_elapsed_time: None,
            total_timer_time: None,
            total_distance: None,
            total_cycles_subfield_bytes: vec![],
            total_cycles: None,
            total_calories: None,
            total_fat_calories: None,
            avg_speed: None,
            max_speed: None,
            avg_heart_rate: None,
            max_heart_rate: None,
            avg_cadence_subfield_bytes: vec![],
            avg_cadence: None,
            max_cadence_subfield_bytes: vec![],
            max_cadence: None,
            avg_power: None,
            max_power: None,
            total_ascent: None,
            total_descent: None,
            total_training_effect: None,
            first_lap_index: None,
            num_laps: None,
            event_group: None,
            trigger: None,
            nec_lat: None,
            nec_long: None,
            swc_lat: None,
            swc_long: None,
            normalized_power: None,
            training_stress_score: None,
            intensity_factor: None,
            left_right_balance: None,
            avg_stroke_count: None,
            avg_stroke_distance: None,
            swim_stroke: None,
            pool_length: None,
            threshold_power: None,
            pool_length_unit: None,
            num_active_lengths: None,
            total_work: None,
            avg_altitude: None,
            max_altitude: None,
            gps_accuracy: None,
            avg_grade: None,
            avg_pos_grade: None,
            avg_neg_grade: None,
            max_pos_grade: None,
            max_neg_grade: None,
            avg_temperature: None,
            max_temperature: None,
            total_moving_time: None,
            avg_pos_vertical_speed: None,
            avg_neg_vertical_speed: None,
            max_pos_vertical_speed: None,
            max_neg_vertical_speed: None,
            min_heart_rate: None,
            time_in_hr_zone: None,
            time_in_speed_zone: None,
            time_in_cadence_zone: None,
            time_in_power_zone: None,
            avg_lap_time: None,
            best_lap_index: None,
            min_altitude: None,
            player_score: None,
            opponent_score: None,
            opponent_name: None,
            stroke_count: None,
            zone_count: None,
            max_ball_speed: None,
            avg_ball_speed: None,
            avg_vertical_oscillation: None,
            avg_stance_time_percent: None,
            avg_stance_time: None,
            avg_fractional_cadence: None,
            max_fractional_cadence: None,
            total_fractional_cycles: None,
            avg_total_hemoglobin_conc: None,
            min_total_hemoglobin_conc: None,
            max_total_hemoglobin_conc: None,
            avg_saturated_hemoglobin_percent: None,
            min_saturated_hemoglobin_percent: None,
            max_saturated_hemoglobin_percent: None,
            avg_left_torque_effectiveness: None,
            avg_right_torque_effectiveness: None,
            avg_left_pedal_smoothness: None,
            avg_right_pedal_smoothness: None,
            avg_combined_pedal_smoothness: None,
            sport_index: None,
            time_standing: None,
            stand_count: None,
            avg_left_pco: None,
            avg_right_pco: None,
            avg_left_power_phase: None,
            avg_left_power_phase_peak: None,
            avg_right_power_phase: None,
            avg_right_power_phase_peak: None,
            avg_power_position: None,
            max_power_position: None,
            avg_cadence_position: None,
            max_cadence_position: None,
            enhanced_avg_speed: None,
            enhanced_max_speed: None,
            enhanced_avg_altitude: None,
            enhanced_min_altitude: None,
            enhanced_max_altitude: None,
            avg_lev_motor_power: None,
            max_lev_motor_power: None,
            lev_battery_consumption: None,
            avg_vertical_ratio: None,
            avg_stance_time_balance: None,
            avg_step_length: None,
            total_anaerobic_training_effect: None,
            avg_vam: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSession::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSession:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageSession::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageSession:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageSession, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 10).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageSessionSubfieldTotalCycles::parse(message, &message.total_cycles_subfield_bytes, &field, _tz_offset)?;
            message.total_cycles = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 18).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageSessionSubfieldAvgCadence::parse(message, &message.avg_cadence_subfield_bytes, &field, _tz_offset)?;
            message.avg_cadence = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 19).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageSessionSubfieldMaxCadence::parse(message, &message.max_cadence_subfield_bytes, &field, _tz_offset)?;
            message.max_cadence = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageSession, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // event
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEvent::parse(&&bytes[0..f.field_size])?;
                                
                                message.event = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEvent::parse(&inp[0..f.field_size])?;
                                
                                message.event = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // event_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldEventType::parse(&&bytes[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldEventType::parse(&inp[0..f.field_size])?;
                                
                                message.event_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // start_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // start_position_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // start_position_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.start_position_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.start_position_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // total_elapsed_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_elapsed_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_elapsed_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // total_timer_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_timer_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_timer_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // total_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.total_distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // total_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.total_cycles_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.total_cycles_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // total_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // total_fat_calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_fat_calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_fat_calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // avg_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_speed = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 124, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    15 => {  // max_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_speed = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 125, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    16 => {  // avg_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.avg_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // max_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // avg_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.avg_cadence_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.avg_cadence_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    19 => {  // max_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.max_cadence_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.max_cadence_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    20 => {  // avg_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // max_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    22 => {  // total_ascent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_ascent = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_ascent = val;
                            }
                        }

                        Ok(())
                    },
                
                    23 => {  // total_descent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_descent = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_descent = val;
                            }
                        }

                        Ok(())
                    },
                
                    24 => {  // total_training_effect
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_training_effect = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.total_training_effect = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_training_effect = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.total_training_effect = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    25 => {  // first_lap_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.first_lap_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.first_lap_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    26 => {  // num_laps
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_laps = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_laps = val;
                            }
                        }

                        Ok(())
                    },
                
                    27 => {  // event_group
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.event_group = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.event_group = val;
                            }
                        }

                        Ok(())
                    },
                
                    28 => {  // trigger
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSessionTrigger::parse(&&bytes[0..f.field_size])?;
                                
                                message.trigger = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSessionTrigger::parse(&inp[0..f.field_size])?;
                                
                                message.trigger = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    29 => {  // nec_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    30 => {  // nec_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.nec_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.nec_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    31 => {  // swc_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    32 => {  // swc_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.swc_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.swc_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    34 => {  // normalized_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.normalized_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.normalized_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    35 => {  // training_stress_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.training_stress_score = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.training_stress_score = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.training_stress_score = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.training_stress_score = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    36 => {  // intensity_factor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.intensity_factor = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.intensity_factor = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.intensity_factor = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.intensity_factor = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    37 => {  // left_right_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLeftRightBalance100::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.left_right_balance = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLeftRightBalance100::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.left_right_balance = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    41 => {  // avg_stroke_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stroke_count = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_stroke_count = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stroke_count = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_stroke_count = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    42 => {  // avg_stroke_distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stroke_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stroke_distance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stroke_distance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stroke_distance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    43 => {  // swim_stroke
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSwimStroke::parse(&&bytes[0..f.field_size])?;
                                
                                message.swim_stroke = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSwimStroke::parse(&inp[0..f.field_size])?;
                                
                                message.swim_stroke = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    44 => {  // pool_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.pool_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.pool_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.pool_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.pool_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    45 => {  // threshold_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.threshold_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.threshold_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    46 => {  // pool_length_unit
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.pool_length_unit = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.pool_length_unit = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    47 => {  // num_active_lengths
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_active_lengths = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_active_lengths = val;
                            }
                        }

                        Ok(())
                    },
                
                    48 => {  // total_work
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_work = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.total_work = val;
                            }
                        }

                        Ok(())
                    },
                
                    49 => {  // avg_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.avg_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.avg_altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 126, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    50 => {  // max_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.max_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.max_altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 128, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    51 => {  // gps_accuracy
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.gps_accuracy = val;
                            }
                        }

                        Ok(())
                    },
                
                    52 => {  // avg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    53 => {  // avg_pos_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_pos_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_pos_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    54 => {  // avg_neg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_neg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_neg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    55 => {  // max_pos_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_pos_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_pos_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    56 => {  // max_neg_grade
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_neg_grade = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_grade = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_neg_grade = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    57 => {  // avg_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    58 => {  // max_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.max_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.max_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    59 => {  // total_moving_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_moving_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_moving_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_moving_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.total_moving_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    60 => {  // avg_pos_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_pos_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_pos_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    61 => {  // avg_neg_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_neg_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_neg_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    62 => {  // max_pos_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_pos_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_pos_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_pos_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    63 => {  // max_neg_vertical_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_neg_vertical_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_neg_vertical_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.max_neg_vertical_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    64 => {  // min_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.min_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.min_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    65 => {  // time_in_hr_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_hr_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_hr_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    66 => {  // time_in_speed_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_speed_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_speed_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    67 => {  // time_in_cadence_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_cadence_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_cadence_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    68 => {  // time_in_power_zone
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_power_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.time_in_power_zone = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 1000 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    69 => {  // avg_lap_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_lap_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_lap_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_lap_time = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_lap_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    70 => {  // best_lap_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.best_lap_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.best_lap_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    71 => {  // min_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.min_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.min_altitude = None
                                }
                            }
                        }

                        actions.push( (FitFieldDefinition{definition_number: 127, field_size: 4, base_type: 0}, Some((0, 16)) ));
                        Ok(())
                    },
                
                    82 => {  // player_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.player_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.player_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    83 => {  // opponent_score
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.opponent_score = val;
                            }
                        }

                        Ok(())
                    },
                
                    84 => {  // opponent_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.opponent_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.opponent_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    85 => {  // stroke_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stroke_count = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.stroke_count = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    86 => {  // zone_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.zone_count = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.zone_count = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    87 => {  // max_ball_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_ball_speed = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_ball_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_ball_speed = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.max_ball_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    88 => {  // avg_ball_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_ball_speed = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_ball_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_ball_speed = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_ball_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    89 => {  // avg_vertical_oscillation
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_oscillation = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_vertical_oscillation = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_oscillation = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_vertical_oscillation = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    90 => {  // avg_stance_time_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_percent = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_percent = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_percent = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_percent = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    91 => {  // avg_stance_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_stance_time = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_stance_time = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    92 => {  // avg_fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.avg_fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.avg_fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    93 => {  // max_fractional_cadence
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.max_fractional_cadence = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.max_fractional_cadence = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.max_fractional_cadence = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    94 => {  // total_fractional_cycles
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_fractional_cycles = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.total_fractional_cycles = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_fractional_cycles = Some(result as f64 / 128 as f64) 
                                    },
                                    None => message.total_fractional_cycles = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    95 => {  // avg_total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    96 => {  // min_total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    97 => {  // max_total_hemoglobin_conc
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_total_hemoglobin_conc = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 100 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    98 => {  // avg_saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    99 => {  // min_saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.min_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    100 => {  // max_saturated_hemoglobin_percent
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_saturated_hemoglobin_percent = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 10 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    101 => {  // avg_left_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    102 => {  // avg_right_torque_effectiveness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_torque_effectiveness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_torque_effectiveness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_torque_effectiveness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    103 => {  // avg_left_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_left_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_left_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    104 => {  // avg_right_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_right_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_right_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    105 => {  // avg_combined_pedal_smoothness
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_combined_pedal_smoothness = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_combined_pedal_smoothness = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.avg_combined_pedal_smoothness = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    111 => {  // sport_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.sport_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.sport_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    112 => {  // time_standing
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_standing = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_standing = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.time_standing = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.time_standing = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    113 => {  // stand_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stand_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stand_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    114 => {  // avg_left_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_left_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_left_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    115 => {  // avg_right_pco
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.avg_right_pco = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.avg_right_pco = val;
                            }
                        }

                        Ok(())
                    },
                
                    116 => {  // avg_left_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    117 => {  // avg_left_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_left_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    118 => {  // avg_right_power_phase
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    119 => {  // avg_right_power_phase_peak
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_right_power_phase_peak = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 0.7111111 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    120 => {  // avg_power_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_power_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_power_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    121 => {  // max_power_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_power_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_power_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    122 => {  // avg_cadence_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_cadence_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.avg_cadence_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    123 => {  // max_cadence_position
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_cadence_position = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint8(&tempp[0..f.field_size])?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.max_cadence_position = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    124 => {  // enhanced_avg_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_avg_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_avg_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    125 => {  // enhanced_max_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_max_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.enhanced_max_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    126 => {  // enhanced_avg_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_avg_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_avg_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_avg_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    127 => {  // enhanced_min_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_min_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_min_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_min_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    128 => {  // enhanced_max_altitude
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_max_altitude = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.enhanced_max_altitude = Some(result as f64 / 5 as f64 - (500 as f64)) 
                                    },
                                    None => message.enhanced_max_altitude = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    129 => {  // avg_lev_motor_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_lev_motor_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.avg_lev_motor_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    130 => {  // max_lev_motor_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_lev_motor_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.max_lev_motor_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    131 => {  // lev_battery_consumption
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.lev_battery_consumption = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.lev_battery_consumption = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.lev_battery_consumption = Some(result as f64 / 2 as f64) 
                                    },
                                    None => message.lev_battery_consumption = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    132 => {  // avg_vertical_ratio
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_ratio = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_vertical_ratio = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vertical_ratio = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_vertical_ratio = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    133 => {  // avg_stance_time_balance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_balance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_balance = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_stance_time_balance = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.avg_stance_time_balance = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    134 => {  // avg_step_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_step_length = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_step_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_step_length = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.avg_step_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    137 => {  // total_anaerobic_training_effect
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_anaerobic_training_effect = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.total_anaerobic_training_effect = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.total_anaerobic_training_effect = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.total_anaerobic_training_effect = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    139 => {  // avg_vam
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vam = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_vam = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.avg_vam = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.avg_vam = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSession {
    fn message_name(&self) -> &'static str {
        return "FitMessageSession";
    }
}

#[derive(Debug)]
pub struct FitMessageSet {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Timestamp of the set
    pub duration: Option<f64>,  
    pub repetitions: Option<u16>,  // # of repitions of the movement
    pub weight: Option<f64>,  // Amount of weight applied for the set
    pub set_type: Option<FitFieldSetType>,  
    pub start_time: Option<FitFieldDateTime>,  // Start time of the set
    pub category: Option<Vec<FitFieldExerciseCategory>>,  
    pub category_subtype: Option<Vec<Option<u16>>>,  // Based on the associated category, see [category]_exercise_names
    pub weight_display_unit: Option<FitFieldFitBaseUnit>,  
    pub message_index: Option<FitFieldMessageIndex>,  
    pub wkt_step_index: Option<FitFieldMessageIndex>,  
    
}

impl fmt::Display for FitMessageSet {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSet")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.duration { writeln!(f, "  {: >28}: {:?}", "duration", v)?; }
        if let Some(v) = &self.repetitions { writeln!(f, "  {: >28}: {:?}", "repetitions", v)?; }
        if let Some(v) = &self.weight { writeln!(f, "  {: >28}: {:?}", "weight", v)?; }
        if let Some(v) = &self.set_type { writeln!(f, "  {: >28}: {:?}", "set_type", v)?; }
        if let Some(v) = &self.start_time { writeln!(f, "  {: >28}: {:?}", "start_time", v)?; }
        if let Some(v) = &self.category { writeln!(f, "  {: >28}: {:?}", "category", v)?; }
        if let Some(v) = &self.category_subtype { writeln!(f, "  {: >28}: {:?}", "category_subtype", v)?; }
        if let Some(v) = &self.weight_display_unit { writeln!(f, "  {: >28}: {:?}", "weight_display_unit", v)?; }
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.wkt_step_index { writeln!(f, "  {: >28}: {:?}", "wkt_step_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSet {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSet>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSet {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSet",
            timestamp: None,
            duration: None,
            repetitions: None,
            weight: None,
            set_type: None,
            start_time: None,
            category: None,
            category_subtype: None,
            weight_display_unit: None,
            message_index: None,
            wkt_step_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSet::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSet:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSet, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // duration
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.duration = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.duration = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.duration = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.duration = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // repetitions
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.repetitions = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.repetitions = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // weight
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.weight = Some(result as f64 / 16 as f64) 
                                    },
                                    None => message.weight = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.weight = Some(result as f64 / 16 as f64) 
                                    },
                                    None => message.weight = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // set_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSetType::parse(&&bytes[0..f.field_size])?;
                                
                                message.set_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSetType::parse(&inp[0..f.field_size])?;
                                
                                message.set_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // start_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // category
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = FitFieldExerciseCategory::parse(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.category = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = FitFieldExerciseCategory::parse(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.category = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // category_subtype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.category_subtype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_uint16(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.category_subtype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // weight_display_unit
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFitBaseUnit::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.weight_display_unit = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFitBaseUnit::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.weight_display_unit = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // wkt_step_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wkt_step_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wkt_step_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSet {
    fn message_name(&self) -> &'static str {
        return "FitMessageSet";
    }
}

#[derive(Debug)]
pub enum FitMessageSlaveDeviceSubfieldProduct {
    Default(Option<u16>),
    FaveroProduct(Option<FitFieldFaveroProduct>),
    GarminProduct(Option<FitFieldGarminProduct>),
}

impl FitMessageSlaveDeviceSubfieldProduct {
    fn parse<'a>(message: &FitMessageSlaveDevice, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageSlaveDeviceSubfieldProduct> {
        
        match message.manufacturer {
        
            Some(FitFieldManufacturer::FaveroElectronics) => {
                let val = FitFieldFaveroProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSlaveDeviceSubfieldProduct::FaveroProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Garmin) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSlaveDeviceSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Dynastream) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSlaveDeviceSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::DynastreamOem) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageSlaveDeviceSubfieldProduct::GarminProduct(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageSlaveDeviceSubfieldProduct::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageSlaveDevice {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub manufacturer: Option<FitFieldManufacturer>,  
    pub product_subfield_bytes: Vec<u8>,
    pub product: Option<FitMessageSlaveDeviceSubfieldProduct>,  
    
}

impl fmt::Display for FitMessageSlaveDevice {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSlaveDevice")?;
        if let Some(v) = &self.manufacturer { writeln!(f, "  {: >28}: {:?}", "manufacturer", v)?; }
        writeln!(f, "  {: >28}: {:?}", "product_subfield_bytes", self.product_subfield_bytes)?;
        if let Some(v) = &self.product { writeln!(f, "  {: >28}: {:?}", "product", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSlaveDevice {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSlaveDevice>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSlaveDevice {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSlaveDevice",
            manufacturer: None,
            product_subfield_bytes: vec![],
            product: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSlaveDevice::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSlaveDevice:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageSlaveDevice::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageSlaveDevice:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageSlaveDevice, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 1).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageSlaveDeviceSubfieldProduct::parse(message, &message.product_subfield_bytes, &field, _tz_offset)?;
            message.product = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageSlaveDevice, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // manufacturer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // product
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSlaveDevice {
    fn message_name(&self) -> &'static str {
        return "FitMessageSlaveDevice";
    }
}

#[derive(Debug)]
pub struct FitMessageSoftware {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub version: Option<f64>,  
    pub part_number: Option<String>,  
    
}

impl fmt::Display for FitMessageSoftware {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSoftware")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.version { writeln!(f, "  {: >28}: {:?}", "version", v)?; }
        if let Some(v) = &self.part_number { writeln!(f, "  {: >28}: {:?}", "part_number", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSoftware {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSoftware>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSoftware {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSoftware",
            message_index: None,
            version: None,
            part_number: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSoftware::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSoftware:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSoftware, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // version
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.version = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.version = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.version = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.version = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // part_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.part_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.part_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSoftware {
    fn message_name(&self) -> &'static str {
        return "FitMessageSoftware";
    }
}

#[derive(Debug)]
pub struct FitMessageSpeedZone {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub high_value: Option<f64>,  
    pub name: Option<String>,  
    
}

impl fmt::Display for FitMessageSpeedZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSpeedZone")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.high_value { writeln!(f, "  {: >28}: {:?}", "high_value", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSpeedZone {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSpeedZone>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSpeedZone {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSpeedZone",
            message_index: None,
            high_value: None,
            name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSpeedZone::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSpeedZone:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSpeedZone, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // high_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.high_value = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.high_value = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.high_value = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.high_value = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSpeedZone {
    fn message_name(&self) -> &'static str {
        return "FitMessageSpeedZone";
    }
}

#[derive(Debug)]
pub struct FitMessageSport {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub sport: Option<FitFieldSport>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub name: Option<String>,  
    
}

impl fmt::Display for FitMessageSport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageSport")?;
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.name { writeln!(f, "  {: >28}: {:?}", "name", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageSport {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageSport>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageSport {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageSport",
            sport: None,
            sub_sport: None,
            name: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageSport::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageSport:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageSport, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.name = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageSport {
    fn message_name(&self) -> &'static str {
        return "FitMessageSport";
    }
}

#[derive(Debug)]
pub struct FitMessageStressLevel {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub stress_level_value: Option<i16>,  
    pub stress_level_time: Option<FitFieldDateTime>,  // Time stress score was calculated
    
}

impl fmt::Display for FitMessageStressLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageStressLevel")?;
        if let Some(v) = &self.stress_level_value { writeln!(f, "  {: >28}: {:?}", "stress_level_value", v)?; }
        if let Some(v) = &self.stress_level_time { writeln!(f, "  {: >28}: {:?}", "stress_level_time", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageStressLevel {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageStressLevel>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageStressLevel {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageStressLevel",
            stress_level_value: None,
            stress_level_time: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageStressLevel::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageStressLevel:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageStressLevel, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // stress_level_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stress_level_value = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stress_level_value = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // stress_level_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stress_level_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.stress_level_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageStressLevel {
    fn message_name(&self) -> &'static str {
        return "FitMessageStressLevel";
    }
}

#[derive(Debug)]
pub enum FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor {
    Default(Option<u32>),
    AccelCalFactor(Option<u32>),
    GyroCalFactor(Option<u32>),
}

impl FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor {
    fn parse<'a>(message: &FitMessageThreeDSensorCalibration, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor> {
        
        match message.sensor_type {
        
            Some(FitFieldSensorType::Accelerometer) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::AccelCalFactor(val))
                },
        
            Some(FitFieldSensorType::Gyroscope) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::GyroCalFactor(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageThreeDSensorCalibration {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub sensor_type: Option<FitFieldSensorType>,  // Indicates which sensor the calibration is for
    pub calibration_factor_subfield_bytes: Vec<u8>,
    pub calibration_factor: Option<FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor>,  // Calibration factor used to convert from raw ADC value to degrees, g,  etc.
    pub calibration_divisor: Option<u32>,  // Calibration factor divisor
    pub level_shift: Option<u32>,  // Level shift value used to shift the ADC value back into range
    pub offset_cal: Option<Vec<Option<i32>>>,  // Internal calibration factors, one for each: xy, yx, zx
    pub orientation_matrix: Option<Vec<Option<f64>>>,  // 3 x 3 rotation matrix (row major)
    
}

impl fmt::Display for FitMessageThreeDSensorCalibration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageThreeDSensorCalibration")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.sensor_type { writeln!(f, "  {: >28}: {:?}", "sensor_type", v)?; }
        writeln!(f, "  {: >28}: {:?}", "calibration_factor_subfield_bytes", self.calibration_factor_subfield_bytes)?;
        if let Some(v) = &self.calibration_factor { writeln!(f, "  {: >28}: {:?}", "calibration_factor", v)?; }
        if let Some(v) = &self.calibration_divisor { writeln!(f, "  {: >28}: {:?}", "calibration_divisor", v)?; }
        if let Some(v) = &self.level_shift { writeln!(f, "  {: >28}: {:?}", "level_shift", v)?; }
        if let Some(v) = &self.offset_cal { writeln!(f, "  {: >28}: {:?}", "offset_cal", v)?; }
        if let Some(v) = &self.orientation_matrix { writeln!(f, "  {: >28}: {:?}", "orientation_matrix", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageThreeDSensorCalibration {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageThreeDSensorCalibration>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageThreeDSensorCalibration {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageThreeDSensorCalibration",
            timestamp: None,
            sensor_type: None,
            calibration_factor_subfield_bytes: vec![],
            calibration_factor: None,
            calibration_divisor: None,
            level_shift: None,
            offset_cal: None,
            orientation_matrix: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageThreeDSensorCalibration::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageThreeDSensorCalibration:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageThreeDSensorCalibration::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageThreeDSensorCalibration:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageThreeDSensorCalibration, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 1).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageThreeDSensorCalibrationSubfieldCalibrationFactor::parse(message, &message.calibration_factor_subfield_bytes, &field, _tz_offset)?;
            message.calibration_factor = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageThreeDSensorCalibration, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // sensor_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSensorType::parse(&&bytes[0..f.field_size])?;
                                
                                message.sensor_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSensorType::parse(&inp[0..f.field_size])?;
                                
                                message.sensor_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // calibration_factor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.calibration_factor_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.calibration_factor_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // calibration_divisor
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calibration_divisor = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calibration_divisor = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // level_shift
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.level_shift = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.level_shift = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // offset_cal
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.offset_cal = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.offset_cal = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // orientation_matrix
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = &bytes[..];
                                while array_size > 0 {
                                    let v = parse_sint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[field.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.orientation_matrix = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 65535 as f64)).collect());
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let mut array_size = field.field_size / field.base_type_size();
                                let mut val = Vec::with_capacity(array_size);
                                let mut tempp = inp;
                                while array_size > 0 {
                                    let v = parse_sint32(&tempp[0..f.field_size], message.definition_message.endianness)?;
                                    tempp = &tempp[f.base_type_size()..];
                                    val.push(v);
                                    array_size = array_size - 1
                                }
                                
                                message.orientation_matrix = Some(val.into_iter().filter_map(|x| x).map(|i| Some(i as f64 / 65535 as f64)).collect());
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageThreeDSensorCalibration {
    fn message_name(&self) -> &'static str {
        return "FitMessageThreeDSensorCalibration";
    }
}

#[derive(Debug)]
pub struct FitMessageTimestampCorrelation {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of UTC timestamp at the time the system timestamp was recorded.
    pub fractional_timestamp: Option<f64>,  // Fractional part of the UTC timestamp at the time the system timestamp was recorded.
    pub system_timestamp: Option<FitFieldDateTime>,  // Whole second part of the system timestamp
    pub fractional_system_timestamp: Option<f64>,  // Fractional part of the system timestamp
    pub local_timestamp: Option<FitFieldLocalDateTime>,  // timestamp epoch expressed in local time used to convert timestamps to local time
    pub timestamp_ms: Option<u16>,  // Millisecond part of the UTC timestamp at the time the system timestamp was recorded.
    pub system_timestamp_ms: Option<u16>,  // Millisecond part of the system timestamp
    
}

impl fmt::Display for FitMessageTimestampCorrelation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageTimestampCorrelation")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.fractional_timestamp { writeln!(f, "  {: >28}: {:?}", "fractional_timestamp", v)?; }
        if let Some(v) = &self.system_timestamp { writeln!(f, "  {: >28}: {:?}", "system_timestamp", v)?; }
        if let Some(v) = &self.fractional_system_timestamp { writeln!(f, "  {: >28}: {:?}", "fractional_system_timestamp", v)?; }
        if let Some(v) = &self.local_timestamp { writeln!(f, "  {: >28}: {:?}", "local_timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.system_timestamp_ms { writeln!(f, "  {: >28}: {:?}", "system_timestamp_ms", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageTimestampCorrelation {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageTimestampCorrelation>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageTimestampCorrelation {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageTimestampCorrelation",
            timestamp: None,
            fractional_timestamp: None,
            system_timestamp: None,
            fractional_system_timestamp: None,
            local_timestamp: None,
            timestamp_ms: None,
            system_timestamp_ms: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageTimestampCorrelation::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageTimestampCorrelation:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageTimestampCorrelation, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // fractional_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_timestamp = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // system_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.system_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.system_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // fractional_system_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_system_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_system_timestamp = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.fractional_system_timestamp = Some(result as f64 / 32768 as f64) 
                                    },
                                    None => message.fractional_system_timestamp = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // local_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocalDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocalDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness, _tz_offset)?;
                                
                                message.local_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // system_timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.system_timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.system_timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageTimestampCorrelation {
    fn message_name(&self) -> &'static str {
        return "FitMessageTimestampCorrelation";
    }
}

#[derive(Debug)]
pub struct FitMessageTotals {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub timestamp: Option<FitFieldDateTime>,  
    pub timer_time: Option<u32>,  // Excludes pauses
    pub distance: Option<u32>,  
    pub calories: Option<u32>,  
    pub sport: Option<FitFieldSport>,  
    pub elapsed_time: Option<u32>,  // Includes pauses
    pub sessions: Option<u16>,  
    pub active_time: Option<u32>,  
    pub sport_index: Option<u8>,  
    
}

impl fmt::Display for FitMessageTotals {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageTotals")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timer_time { writeln!(f, "  {: >28}: {:?}", "timer_time", v)?; }
        if let Some(v) = &self.distance { writeln!(f, "  {: >28}: {:?}", "distance", v)?; }
        if let Some(v) = &self.calories { writeln!(f, "  {: >28}: {:?}", "calories", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.elapsed_time { writeln!(f, "  {: >28}: {:?}", "elapsed_time", v)?; }
        if let Some(v) = &self.sessions { writeln!(f, "  {: >28}: {:?}", "sessions", v)?; }
        if let Some(v) = &self.active_time { writeln!(f, "  {: >28}: {:?}", "active_time", v)?; }
        if let Some(v) = &self.sport_index { writeln!(f, "  {: >28}: {:?}", "sport_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageTotals {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageTotals>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageTotals {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageTotals",
            message_index: None,
            timestamp: None,
            timer_time: None,
            distance: None,
            calories: None,
            sport: None,
            elapsed_time: None,
            sessions: None,
            active_time: None,
            sport_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageTotals::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageTotals:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageTotals, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timer_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timer_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timer_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // distance
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.distance = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.distance = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // calories
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calories = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.calories = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // elapsed_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.elapsed_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.elapsed_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // sessions
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.sessions = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.sessions = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // active_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.active_time = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.active_time = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // sport_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.sport_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.sport_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageTotals {
    fn message_name(&self) -> &'static str {
        return "FitMessageTotals";
    }
}

#[derive(Debug)]
pub enum FitMessageTrainingFileSubfieldProduct {
    Default(Option<u16>),
    FaveroProduct(Option<FitFieldFaveroProduct>),
    GarminProduct(Option<FitFieldGarminProduct>),
}

impl FitMessageTrainingFileSubfieldProduct {
    fn parse<'a>(message: &FitMessageTrainingFile, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageTrainingFileSubfieldProduct> {
        
        match message.manufacturer {
        
            Some(FitFieldManufacturer::FaveroElectronics) => {
                let val = FitFieldFaveroProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageTrainingFileSubfieldProduct::FaveroProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Garmin) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageTrainingFileSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::Dynastream) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageTrainingFileSubfieldProduct::GarminProduct(Some(val)))
                },
        
            Some(FitFieldManufacturer::DynastreamOem) => {
                let val = FitFieldGarminProduct::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageTrainingFileSubfieldProduct::GarminProduct(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageTrainingFileSubfieldProduct::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageTrainingFile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub ftype: Option<FitFieldFile>,  
    pub manufacturer: Option<FitFieldManufacturer>,  
    pub product_subfield_bytes: Vec<u8>,
    pub product: Option<FitMessageTrainingFileSubfieldProduct>,  
    pub serial_number: Option<u32>,  
    pub time_created: Option<FitFieldDateTime>,  
    
}

impl fmt::Display for FitMessageTrainingFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageTrainingFile")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        if let Some(v) = &self.manufacturer { writeln!(f, "  {: >28}: {:?}", "manufacturer", v)?; }
        writeln!(f, "  {: >28}: {:?}", "product_subfield_bytes", self.product_subfield_bytes)?;
        if let Some(v) = &self.product { writeln!(f, "  {: >28}: {:?}", "product", v)?; }
        if let Some(v) = &self.serial_number { writeln!(f, "  {: >28}: {:?}", "serial_number", v)?; }
        if let Some(v) = &self.time_created { writeln!(f, "  {: >28}: {:?}", "time_created", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageTrainingFile {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageTrainingFile>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageTrainingFile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageTrainingFile",
            timestamp: None,
            ftype: None,
            manufacturer: None,
            product_subfield_bytes: vec![],
            product: None,
            serial_number: None,
            time_created: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageTrainingFile::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageTrainingFile:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageTrainingFile::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageTrainingFile:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageTrainingFile, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 2).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageTrainingFileSubfieldProduct::parse(message, &message.product_subfield_bytes, &field, _tz_offset)?;
            message.product = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageTrainingFile, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFile::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFile::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // manufacturer
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldManufacturer::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldManufacturer::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.manufacturer = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // product
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.product_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // serial_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32z(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32z(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.serial_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // time_created
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.time_created = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.time_created = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageTrainingFile {
    fn message_name(&self) -> &'static str {
        return "FitMessageTrainingFile";
    }
}

#[derive(Debug)]
pub struct FitMessageUserProfile {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub friendly_name: Option<String>,  
    pub gender: Option<FitFieldGender>,  
    pub age: Option<u8>,  
    pub height: Option<f64>,  
    pub weight: Option<f64>,  
    pub language: Option<FitFieldLanguage>,  
    pub elev_setting: Option<FitFieldDisplayMeasure>,  
    pub weight_setting: Option<FitFieldDisplayMeasure>,  
    pub resting_heart_rate: Option<u8>,  
    pub default_max_running_heart_rate: Option<u8>,  
    pub default_max_biking_heart_rate: Option<u8>,  
    pub default_max_heart_rate: Option<u8>,  
    pub hr_setting: Option<FitFieldDisplayHeart>,  
    pub speed_setting: Option<FitFieldDisplayMeasure>,  
    pub dist_setting: Option<FitFieldDisplayMeasure>,  
    pub power_setting: Option<FitFieldDisplayPower>,  
    pub activity_class: Option<FitFieldActivityClass>,  
    pub position_setting: Option<FitFieldDisplayPosition>,  
    pub temperature_setting: Option<FitFieldDisplayMeasure>,  
    pub local_id: Option<FitFieldUserLocalId>,  
    pub global_id: Option<Vec<u8>>,  
    pub wake_time: Option<FitFieldLocaltimeIntoDay>,  // Typical wake time
    pub sleep_time: Option<FitFieldLocaltimeIntoDay>,  // Typical bed time
    pub height_setting: Option<FitFieldDisplayMeasure>,  
    pub user_running_step_length: Option<f64>,  // User defined running step length set to 0 for auto length
    pub user_walking_step_length: Option<f64>,  // User defined walking step length set to 0 for auto length
    pub depth_setting: Option<FitFieldDisplayMeasure>,  
    pub dive_count: Option<u32>,  
    
}

impl fmt::Display for FitMessageUserProfile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageUserProfile")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.friendly_name { writeln!(f, "  {: >28}: {:?}", "friendly_name", v)?; }
        if let Some(v) = &self.gender { writeln!(f, "  {: >28}: {:?}", "gender", v)?; }
        if let Some(v) = &self.age { writeln!(f, "  {: >28}: {:?}", "age", v)?; }
        if let Some(v) = &self.height { writeln!(f, "  {: >28}: {:?}", "height", v)?; }
        if let Some(v) = &self.weight { writeln!(f, "  {: >28}: {:?}", "weight", v)?; }
        if let Some(v) = &self.language { writeln!(f, "  {: >28}: {:?}", "language", v)?; }
        if let Some(v) = &self.elev_setting { writeln!(f, "  {: >28}: {:?}", "elev_setting", v)?; }
        if let Some(v) = &self.weight_setting { writeln!(f, "  {: >28}: {:?}", "weight_setting", v)?; }
        if let Some(v) = &self.resting_heart_rate { writeln!(f, "  {: >28}: {:?}", "resting_heart_rate", v)?; }
        if let Some(v) = &self.default_max_running_heart_rate { writeln!(f, "  {: >28}: {:?}", "default_max_running_heart_rate", v)?; }
        if let Some(v) = &self.default_max_biking_heart_rate { writeln!(f, "  {: >28}: {:?}", "default_max_biking_heart_rate", v)?; }
        if let Some(v) = &self.default_max_heart_rate { writeln!(f, "  {: >28}: {:?}", "default_max_heart_rate", v)?; }
        if let Some(v) = &self.hr_setting { writeln!(f, "  {: >28}: {:?}", "hr_setting", v)?; }
        if let Some(v) = &self.speed_setting { writeln!(f, "  {: >28}: {:?}", "speed_setting", v)?; }
        if let Some(v) = &self.dist_setting { writeln!(f, "  {: >28}: {:?}", "dist_setting", v)?; }
        if let Some(v) = &self.power_setting { writeln!(f, "  {: >28}: {:?}", "power_setting", v)?; }
        if let Some(v) = &self.activity_class { writeln!(f, "  {: >28}: {:?}", "activity_class", v)?; }
        if let Some(v) = &self.position_setting { writeln!(f, "  {: >28}: {:?}", "position_setting", v)?; }
        if let Some(v) = &self.temperature_setting { writeln!(f, "  {: >28}: {:?}", "temperature_setting", v)?; }
        if let Some(v) = &self.local_id { writeln!(f, "  {: >28}: {:?}", "local_id", v)?; }
        if let Some(v) = &self.global_id { writeln!(f, "  {: >28}: {:?}", "global_id", v)?; }
        if let Some(v) = &self.wake_time { writeln!(f, "  {: >28}: {:?}", "wake_time", v)?; }
        if let Some(v) = &self.sleep_time { writeln!(f, "  {: >28}: {:?}", "sleep_time", v)?; }
        if let Some(v) = &self.height_setting { writeln!(f, "  {: >28}: {:?}", "height_setting", v)?; }
        if let Some(v) = &self.user_running_step_length { writeln!(f, "  {: >28}: {:?}", "user_running_step_length", v)?; }
        if let Some(v) = &self.user_walking_step_length { writeln!(f, "  {: >28}: {:?}", "user_walking_step_length", v)?; }
        if let Some(v) = &self.depth_setting { writeln!(f, "  {: >28}: {:?}", "depth_setting", v)?; }
        if let Some(v) = &self.dive_count { writeln!(f, "  {: >28}: {:?}", "dive_count", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageUserProfile {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageUserProfile>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageUserProfile {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageUserProfile",
            message_index: None,
            friendly_name: None,
            gender: None,
            age: None,
            height: None,
            weight: None,
            language: None,
            elev_setting: None,
            weight_setting: None,
            resting_heart_rate: None,
            default_max_running_heart_rate: None,
            default_max_biking_heart_rate: None,
            default_max_heart_rate: None,
            hr_setting: None,
            speed_setting: None,
            dist_setting: None,
            power_setting: None,
            activity_class: None,
            position_setting: None,
            temperature_setting: None,
            local_id: None,
            global_id: None,
            wake_time: None,
            sleep_time: None,
            height_setting: None,
            user_running_step_length: None,
            user_walking_step_length: None,
            depth_setting: None,
            dive_count: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageUserProfile::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageUserProfile:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageUserProfile, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // friendly_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.friendly_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.friendly_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // gender
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldGender::parse(&&bytes[0..f.field_size])?;
                                
                                message.gender = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldGender::parse(&inp[0..f.field_size])?;
                                
                                message.gender = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // age
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.age = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.age = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // height
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.height = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.height = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.height = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.height = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // weight
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.weight = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.weight = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.weight = Some(result as f64 / 10 as f64) 
                                    },
                                    None => message.weight = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // language
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLanguage::parse(&&bytes[0..f.field_size])?;
                                
                                message.language = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLanguage::parse(&inp[0..f.field_size])?;
                                
                                message.language = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // elev_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.elev_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.elev_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // weight_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.weight_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.weight_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // resting_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.resting_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.resting_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // default_max_running_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.default_max_running_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.default_max_running_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // default_max_biking_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.default_max_biking_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.default_max_biking_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // default_max_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.default_max_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.default_max_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // hr_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayHeart::parse(&&bytes[0..f.field_size])?;
                                
                                message.hr_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayHeart::parse(&inp[0..f.field_size])?;
                                
                                message.hr_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // speed_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.speed_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.speed_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // dist_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.dist_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.dist_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    16 => {  // power_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayPower::parse(&&bytes[0..f.field_size])?;
                                
                                message.power_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayPower::parse(&inp[0..f.field_size])?;
                                
                                message.power_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    17 => {  // activity_class
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldActivityClass::parse(&&bytes[0..f.field_size])?;
                                
                                message.activity_class = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldActivityClass::parse(&inp[0..f.field_size])?;
                                
                                message.activity_class = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    18 => {  // position_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayPosition::parse(&&bytes[0..f.field_size])?;
                                
                                message.position_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayPosition::parse(&inp[0..f.field_size])?;
                                
                                message.position_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    21 => {  // temperature_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.temperature_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.temperature_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    22 => {  // local_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldUserLocalId::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.local_id = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldUserLocalId::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.local_id = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    23 => {  // global_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.global_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(&inp[0..f.field_size], field.field_size)?;
                                
                                message.global_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    28 => {  // wake_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocaltimeIntoDay::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wake_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocaltimeIntoDay::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wake_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    29 => {  // sleep_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldLocaltimeIntoDay::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.sleep_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldLocaltimeIntoDay::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.sleep_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    30 => {  // height_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.height_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.height_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    31 => {  // user_running_step_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.user_running_step_length = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.user_running_step_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.user_running_step_length = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.user_running_step_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    32 => {  // user_walking_step_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.user_walking_step_length = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.user_walking_step_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.user_walking_step_length = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.user_walking_step_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    47 => {  // depth_setting
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.depth_setting = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.depth_setting = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    49 => {  // dive_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.dive_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.dive_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageUserProfile {
    fn message_name(&self) -> &'static str {
        return "FitMessageUserProfile";
    }
}

#[derive(Debug)]
pub struct FitMessageVideo {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub url: Option<String>,  
    pub hosting_provider: Option<String>,  
    pub duration: Option<u32>,  // Playback time of video
    
}

impl fmt::Display for FitMessageVideo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideo")?;
        if let Some(v) = &self.url { writeln!(f, "  {: >28}: {:?}", "url", v)?; }
        if let Some(v) = &self.hosting_provider { writeln!(f, "  {: >28}: {:?}", "hosting_provider", v)?; }
        if let Some(v) = &self.duration { writeln!(f, "  {: >28}: {:?}", "duration", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideo {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageVideo>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageVideo {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageVideo",
            url: None,
            hosting_provider: None,
            duration: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageVideo::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageVideo:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageVideo, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // url
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.url = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.url = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // hosting_provider
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.hosting_provider = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.hosting_provider = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // duration
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.duration = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.duration = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageVideo {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideo";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoClip {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub clip_number: Option<u16>,  
    pub start_timestamp: Option<FitFieldDateTime>,  
    pub start_timestamp_ms: Option<u16>,  
    pub end_timestamp: Option<FitFieldDateTime>,  
    pub end_timestamp_ms: Option<u16>,  
    pub clip_start: Option<u32>,  // Start of clip in video time
    pub clip_end: Option<u32>,  // End of clip in video time
    
}

impl fmt::Display for FitMessageVideoClip {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoClip")?;
        if let Some(v) = &self.clip_number { writeln!(f, "  {: >28}: {:?}", "clip_number", v)?; }
        if let Some(v) = &self.start_timestamp { writeln!(f, "  {: >28}: {:?}", "start_timestamp", v)?; }
        if let Some(v) = &self.start_timestamp_ms { writeln!(f, "  {: >28}: {:?}", "start_timestamp_ms", v)?; }
        if let Some(v) = &self.end_timestamp { writeln!(f, "  {: >28}: {:?}", "end_timestamp", v)?; }
        if let Some(v) = &self.end_timestamp_ms { writeln!(f, "  {: >28}: {:?}", "end_timestamp_ms", v)?; }
        if let Some(v) = &self.clip_start { writeln!(f, "  {: >28}: {:?}", "clip_start", v)?; }
        if let Some(v) = &self.clip_end { writeln!(f, "  {: >28}: {:?}", "clip_end", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoClip {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageVideoClip>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageVideoClip {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageVideoClip",
            clip_number: None,
            start_timestamp: None,
            start_timestamp_ms: None,
            end_timestamp: None,
            end_timestamp_ms: None,
            clip_start: None,
            clip_end: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageVideoClip::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageVideoClip:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageVideoClip, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    0 => {  // clip_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clip_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clip_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // start_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // start_timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.start_timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // end_timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.end_timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.end_timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // end_timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.end_timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.end_timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // clip_start
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clip_start = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clip_start = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // clip_end
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clip_end = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.clip_end = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoClip {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoClip";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoDescription {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  // Long descriptions will be split into multiple parts
    pub message_count: Option<u16>,  // Total number of description parts
    pub text: Option<String>,  
    
}

impl fmt::Display for FitMessageVideoDescription {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoDescription")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.message_count { writeln!(f, "  {: >28}: {:?}", "message_count", v)?; }
        if let Some(v) = &self.text { writeln!(f, "  {: >28}: {:?}", "text", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoDescription {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageVideoDescription>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageVideoDescription {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageVideoDescription",
            message_index: None,
            message_count: None,
            text: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageVideoDescription::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageVideoDescription:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageVideoDescription, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // message_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // text
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.text = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.text = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoDescription {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoDescription";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoFrame {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // Whole second part of the timestamp
    pub timestamp_ms: Option<u16>,  // Millisecond part of the timestamp.
    pub frame_number: Option<u32>,  // Number of the frame that the timestamp and timestamp_ms correlate to
    
}

impl fmt::Display for FitMessageVideoFrame {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoFrame")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.timestamp_ms { writeln!(f, "  {: >28}: {:?}", "timestamp_ms", v)?; }
        if let Some(v) = &self.frame_number { writeln!(f, "  {: >28}: {:?}", "frame_number", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoFrame {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageVideoFrame>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageVideoFrame {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageVideoFrame",
            timestamp: None,
            timestamp_ms: None,
            frame_number: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageVideoFrame::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageVideoFrame:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageVideoFrame, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // timestamp_ms
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp_ms = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // frame_number
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.frame_number = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.frame_number = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoFrame {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoFrame";
    }
}

#[derive(Debug)]
pub struct FitMessageVideoTitle {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  // Long titles will be split into multiple parts
    pub message_count: Option<u16>,  // Total number of title parts
    pub text: Option<String>,  
    
}

impl fmt::Display for FitMessageVideoTitle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageVideoTitle")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.message_count { writeln!(f, "  {: >28}: {:?}", "message_count", v)?; }
        if let Some(v) = &self.text { writeln!(f, "  {: >28}: {:?}", "text", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageVideoTitle {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageVideoTitle>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageVideoTitle {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageVideoTitle",
            message_index: None,
            message_count: None,
            text: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageVideoTitle::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageVideoTitle:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageVideoTitle, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // message_count
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_count = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_count = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // text
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.text = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.text = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageVideoTitle {
    fn message_name(&self) -> &'static str {
        return "FitMessageVideoTitle";
    }
}

#[derive(Debug)]
pub enum FitMessageWatchfaceSettingsSubfieldLayout {
    Default(Option<Vec<u8>>),
    DigitalLayout(Option<FitFieldDigitalWatchfaceLayout>),
    AnalogLayout(Option<FitFieldAnalogWatchfaceLayout>),
}

impl FitMessageWatchfaceSettingsSubfieldLayout {
    fn parse<'a>(message: &FitMessageWatchfaceSettings, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageWatchfaceSettingsSubfieldLayout> {
        
        match message.mode {
        
            Some(FitFieldWatchfaceMode::Digital) => {
                let val = FitFieldDigitalWatchfaceLayout::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageWatchfaceSettingsSubfieldLayout::DigitalLayout(Some(val)))
                },
        
            Some(FitFieldWatchfaceMode::Analog) => {
                let val = FitFieldAnalogWatchfaceLayout::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageWatchfaceSettingsSubfieldLayout::AnalogLayout(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_byte(&inp[0..f.field_size], f.field_size)?;
        Ok(FitMessageWatchfaceSettingsSubfieldLayout::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageWatchfaceSettings {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub mode: Option<FitFieldWatchfaceMode>,  
    pub layout_subfield_bytes: Vec<u8>,
    pub layout: Option<FitMessageWatchfaceSettingsSubfieldLayout>,  
    
}

impl fmt::Display for FitMessageWatchfaceSettings {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWatchfaceSettings")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.mode { writeln!(f, "  {: >28}: {:?}", "mode", v)?; }
        writeln!(f, "  {: >28}: {:?}", "layout_subfield_bytes", self.layout_subfield_bytes)?;
        if let Some(v) = &self.layout { writeln!(f, "  {: >28}: {:?}", "layout", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWatchfaceSettings {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWatchfaceSettings>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWatchfaceSettings {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWatchfaceSettings",
            message_index: None,
            mode: None,
            layout_subfield_bytes: vec![],
            layout: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWatchfaceSettings::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWatchfaceSettings:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageWatchfaceSettings::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageWatchfaceSettings:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageWatchfaceSettings, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 1).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageWatchfaceSettingsSubfieldLayout::parse(message, &message.layout_subfield_bytes, &field, _tz_offset)?;
            message.layout = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageWatchfaceSettings, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // mode
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWatchfaceMode::parse(&&bytes[0..f.field_size])?;
                                
                                message.mode = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWatchfaceMode::parse(&inp[0..f.field_size])?;
                                
                                message.mode = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // layout
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.layout_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.layout_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWatchfaceSettings {
    fn message_name(&self) -> &'static str {
        return "FitMessageWatchfaceSettings";
    }
}

#[derive(Debug)]
pub struct FitMessageWeatherAlert {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub report_id: Option<String>,  // Unique identifier from GCS report ID string, length is 12
    pub issue_time: Option<FitFieldDateTime>,  // Time alert was issued
    pub expire_time: Option<FitFieldDateTime>,  // Time alert expires
    pub severity: Option<FitFieldWeatherSeverity>,  // Warning, Watch, Advisory, Statement
    pub ftype: Option<FitFieldWeatherSevereType>,  // Tornado, Severe Thunderstorm, etc.
    
}

impl fmt::Display for FitMessageWeatherAlert {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWeatherAlert")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.report_id { writeln!(f, "  {: >28}: {:?}", "report_id", v)?; }
        if let Some(v) = &self.issue_time { writeln!(f, "  {: >28}: {:?}", "issue_time", v)?; }
        if let Some(v) = &self.expire_time { writeln!(f, "  {: >28}: {:?}", "expire_time", v)?; }
        if let Some(v) = &self.severity { writeln!(f, "  {: >28}: {:?}", "severity", v)?; }
        if let Some(v) = &self.ftype { writeln!(f, "  {: >28}: {:?}", "ftype", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWeatherAlert {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWeatherAlert>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWeatherAlert {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWeatherAlert",
            timestamp: None,
            report_id: None,
            issue_time: None,
            expire_time: None,
            severity: None,
            ftype: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWeatherAlert::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWeatherAlert:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageWeatherAlert, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // report_id
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.report_id = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.report_id = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // issue_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.issue_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.issue_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // expire_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.expire_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.expire_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // severity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWeatherSeverity::parse(&&bytes[0..f.field_size])?;
                                
                                message.severity = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWeatherSeverity::parse(&inp[0..f.field_size])?;
                                
                                message.severity = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // ftype
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWeatherSevereType::parse(&&bytes[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWeatherSevereType::parse(&inp[0..f.field_size])?;
                                
                                message.ftype = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWeatherAlert {
    fn message_name(&self) -> &'static str {
        return "FitMessageWeatherAlert";
    }
}

#[derive(Debug)]
pub struct FitMessageWeatherConditions {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  // time of update for current conditions, else forecast time
    pub weather_report: Option<FitFieldWeatherReport>,  // Current or forecast
    pub temperature: Option<i8>,  
    pub condition: Option<FitFieldWeatherStatus>,  // Corresponds to GSC Response weatherIcon field
    pub wind_direction: Option<u16>,  
    pub wind_speed: Option<f64>,  
    pub precipitation_probability: Option<u8>,  // range 0-100
    pub temperature_feels_like: Option<i8>,  // Heat Index if  GCS heatIdx above or equal to 90F or wind chill if GCS windChill below or equal to 32F
    pub relative_humidity: Option<u8>,  
    pub location: Option<String>,  // string corresponding to GCS response location string
    pub observed_at_time: Option<FitFieldDateTime>,  
    pub observed_location_lat: Option<f64>,  
    pub observed_location_long: Option<f64>,  
    pub day_of_week: Option<FitFieldDayOfWeek>,  
    pub high_temperature: Option<i8>,  
    pub low_temperature: Option<i8>,  
    
}

impl fmt::Display for FitMessageWeatherConditions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWeatherConditions")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.weather_report { writeln!(f, "  {: >28}: {:?}", "weather_report", v)?; }
        if let Some(v) = &self.temperature { writeln!(f, "  {: >28}: {:?}", "temperature", v)?; }
        if let Some(v) = &self.condition { writeln!(f, "  {: >28}: {:?}", "condition", v)?; }
        if let Some(v) = &self.wind_direction { writeln!(f, "  {: >28}: {:?}", "wind_direction", v)?; }
        if let Some(v) = &self.wind_speed { writeln!(f, "  {: >28}: {:?}", "wind_speed", v)?; }
        if let Some(v) = &self.precipitation_probability { writeln!(f, "  {: >28}: {:?}", "precipitation_probability", v)?; }
        if let Some(v) = &self.temperature_feels_like { writeln!(f, "  {: >28}: {:?}", "temperature_feels_like", v)?; }
        if let Some(v) = &self.relative_humidity { writeln!(f, "  {: >28}: {:?}", "relative_humidity", v)?; }
        if let Some(v) = &self.location { writeln!(f, "  {: >28}: {:?}", "location", v)?; }
        if let Some(v) = &self.observed_at_time { writeln!(f, "  {: >28}: {:?}", "observed_at_time", v)?; }
        if let Some(v) = &self.observed_location_lat { writeln!(f, "  {: >28}: {:?}", "observed_location_lat", v)?; }
        if let Some(v) = &self.observed_location_long { writeln!(f, "  {: >28}: {:?}", "observed_location_long", v)?; }
        if let Some(v) = &self.day_of_week { writeln!(f, "  {: >28}: {:?}", "day_of_week", v)?; }
        if let Some(v) = &self.high_temperature { writeln!(f, "  {: >28}: {:?}", "high_temperature", v)?; }
        if let Some(v) = &self.low_temperature { writeln!(f, "  {: >28}: {:?}", "low_temperature", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWeatherConditions {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWeatherConditions>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWeatherConditions {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWeatherConditions",
            timestamp: None,
            weather_report: None,
            temperature: None,
            condition: None,
            wind_direction: None,
            wind_speed: None,
            precipitation_probability: None,
            temperature_feels_like: None,
            relative_humidity: None,
            location: None,
            observed_at_time: None,
            observed_location_lat: None,
            observed_location_long: None,
            day_of_week: None,
            high_temperature: None,
            low_temperature: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWeatherConditions::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWeatherConditions:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageWeatherConditions, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // weather_report
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWeatherReport::parse(&&bytes[0..f.field_size])?;
                                
                                message.weather_report = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWeatherReport::parse(&inp[0..f.field_size])?;
                                
                                message.weather_report = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // condition
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWeatherStatus::parse(&&bytes[0..f.field_size])?;
                                
                                message.condition = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWeatherStatus::parse(&inp[0..f.field_size])?;
                                
                                message.condition = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // wind_direction
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wind_direction = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.wind_direction = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // wind_speed
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.wind_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.wind_speed = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.wind_speed = Some(result as f64 / 1000 as f64) 
                                    },
                                    None => message.wind_speed = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // precipitation_probability
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.precipitation_probability = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.precipitation_probability = val;
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // temperature_feels_like
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.temperature_feels_like = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.temperature_feels_like = val;
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // relative_humidity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.relative_humidity = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.relative_humidity = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // location
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.location = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.location = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // observed_at_time
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.observed_at_time = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.observed_at_time = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // observed_location_lat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.observed_location_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.observed_location_lat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.observed_location_lat = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.observed_location_lat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // observed_location_long
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint32(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.observed_location_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.observed_location_long = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                        message.observed_location_long = Some((result as f64) * (180.0_f64 / 2_f64.powf(31.0)))
                                    },
                                    None => message.observed_location_long = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // day_of_week
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDayOfWeek::parse(&&bytes[0..f.field_size])?;
                                
                                message.day_of_week = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDayOfWeek::parse(&inp[0..f.field_size])?;
                                
                                message.day_of_week = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // high_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.high_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.high_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // low_temperature
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_sint8(&&bytes[0..f.field_size])?;
                                
                                message.low_temperature = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_sint8(&inp[0..f.field_size])?;
                                
                                message.low_temperature = val;
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWeatherConditions {
    fn message_name(&self) -> &'static str {
        return "FitMessageWeatherConditions";
    }
}

#[derive(Debug)]
pub struct FitMessageWeightScale {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub timestamp: Option<FitFieldDateTime>,  
    pub weight: Option<FitFieldWeight>,  
    pub percent_fat: Option<f64>,  
    pub percent_hydration: Option<f64>,  
    pub visceral_fat_mass: Option<f64>,  
    pub bone_mass: Option<f64>,  
    pub muscle_mass: Option<f64>,  
    pub basal_met: Option<f64>,  
    pub physique_rating: Option<u8>,  
    pub active_met: Option<f64>,  // ~4kJ per kcal, 0.25 allows max 16384 kcal
    pub metabolic_age: Option<u8>,  
    pub visceral_fat_rating: Option<u8>,  
    pub user_profile_index: Option<FitFieldMessageIndex>,  // Associates this weight scale message to a user.  This corresponds to the index of the user profile message in the weight scale file.
    
}

impl fmt::Display for FitMessageWeightScale {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWeightScale")?;
        if let Some(v) = &self.timestamp { writeln!(f, "  {: >28}: {:?}", "timestamp", v)?; }
        if let Some(v) = &self.weight { writeln!(f, "  {: >28}: {:?}", "weight", v)?; }
        if let Some(v) = &self.percent_fat { writeln!(f, "  {: >28}: {:?}", "percent_fat", v)?; }
        if let Some(v) = &self.percent_hydration { writeln!(f, "  {: >28}: {:?}", "percent_hydration", v)?; }
        if let Some(v) = &self.visceral_fat_mass { writeln!(f, "  {: >28}: {:?}", "visceral_fat_mass", v)?; }
        if let Some(v) = &self.bone_mass { writeln!(f, "  {: >28}: {:?}", "bone_mass", v)?; }
        if let Some(v) = &self.muscle_mass { writeln!(f, "  {: >28}: {:?}", "muscle_mass", v)?; }
        if let Some(v) = &self.basal_met { writeln!(f, "  {: >28}: {:?}", "basal_met", v)?; }
        if let Some(v) = &self.physique_rating { writeln!(f, "  {: >28}: {:?}", "physique_rating", v)?; }
        if let Some(v) = &self.active_met { writeln!(f, "  {: >28}: {:?}", "active_met", v)?; }
        if let Some(v) = &self.metabolic_age { writeln!(f, "  {: >28}: {:?}", "metabolic_age", v)?; }
        if let Some(v) = &self.visceral_fat_rating { writeln!(f, "  {: >28}: {:?}", "visceral_fat_rating", v)?; }
        if let Some(v) = &self.user_profile_index { writeln!(f, "  {: >28}: {:?}", "user_profile_index", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWeightScale {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWeightScale>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWeightScale {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWeightScale",
            timestamp: None,
            weight: None,
            percent_fat: None,
            percent_hydration: None,
            visceral_fat_mass: None,
            bone_mass: None,
            muscle_mass: None,
            basal_met: None,
            physique_rating: None,
            active_met: None,
            metabolic_age: None,
            visceral_fat_rating: None,
            user_profile_index: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWeightScale::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWeightScale:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        
        match _timestamp {
            Some(ts) => {
                message.timestamp = Some(ts);
            },
            None => {
                match message.timestamp {
                    Some(ts) => {
                        parsing_state.set_last_timestamp(ts);
                    },
                    None => return Err(Error::missing_timestamp_field())
                }
            }
        }
        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageWeightScale, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    253 => {  // timestamp
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDateTime::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDateTime::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.timestamp = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // weight
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWeight::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.weight = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWeight::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.weight = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // percent_fat
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.percent_fat = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.percent_fat = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.percent_fat = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.percent_fat = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // percent_hydration
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.percent_hydration = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.percent_hydration = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.percent_hydration = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.percent_hydration = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // visceral_fat_mass
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.visceral_fat_mass = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.visceral_fat_mass = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.visceral_fat_mass = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.visceral_fat_mass = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // bone_mass
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.bone_mass = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.bone_mass = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.bone_mass = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.bone_mass = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // muscle_mass
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.muscle_mass = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.muscle_mass = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.muscle_mass = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.muscle_mass = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // basal_met
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.basal_met = Some(result as f64 / 4 as f64) 
                                    },
                                    None => message.basal_met = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.basal_met = Some(result as f64 / 4 as f64) 
                                    },
                                    None => message.basal_met = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // physique_rating
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.physique_rating = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.physique_rating = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // active_met
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.active_met = Some(result as f64 / 4 as f64) 
                                    },
                                    None => message.active_met = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.active_met = Some(result as f64 / 4 as f64) 
                                    },
                                    None => message.active_met = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // metabolic_age
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.metabolic_age = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.metabolic_age = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // visceral_fat_rating
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.visceral_fat_rating = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.visceral_fat_rating = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // user_profile_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.user_profile_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWeightScale {
    fn message_name(&self) -> &'static str {
        return "FitMessageWeightScale";
    }
}

#[derive(Debug)]
pub struct FitMessageWorkout {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub sport: Option<FitFieldSport>,  
    pub capabilities: Option<FitFieldWorkoutCapabilities>,  
    pub num_valid_steps: Option<u16>,  // number of valid steps
    pub wkt_name: Option<String>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub pool_length: Option<f64>,  
    pub pool_length_unit: Option<FitFieldDisplayMeasure>,  
    
}

impl fmt::Display for FitMessageWorkout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWorkout")?;
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.capabilities { writeln!(f, "  {: >28}: {:?}", "capabilities", v)?; }
        if let Some(v) = &self.num_valid_steps { writeln!(f, "  {: >28}: {:?}", "num_valid_steps", v)?; }
        if let Some(v) = &self.wkt_name { writeln!(f, "  {: >28}: {:?}", "wkt_name", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.pool_length { writeln!(f, "  {: >28}: {:?}", "pool_length", v)?; }
        if let Some(v) = &self.pool_length_unit { writeln!(f, "  {: >28}: {:?}", "pool_length_unit", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWorkout {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWorkout>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWorkout {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWorkout",
            sport: None,
            capabilities: None,
            num_valid_steps: None,
            wkt_name: None,
            sub_sport: None,
            pool_length: None,
            pool_length_unit: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWorkout::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWorkout:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageWorkout, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    4 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // capabilities
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWorkoutCapabilities::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.capabilities = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWorkoutCapabilities::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.capabilities = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // num_valid_steps
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_valid_steps = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_valid_steps = val;
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // wkt_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.wkt_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.wkt_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    14 => {  // pool_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.pool_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.pool_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.pool_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.pool_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    15 => {  // pool_length_unit
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.pool_length_unit = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.pool_length_unit = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWorkout {
    fn message_name(&self) -> &'static str {
        return "FitMessageWorkout";
    }
}

#[derive(Debug)]
pub struct FitMessageWorkoutSession {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub sport: Option<FitFieldSport>,  
    pub sub_sport: Option<FitFieldSubSport>,  
    pub num_valid_steps: Option<u16>,  
    pub first_step_index: Option<u16>,  
    pub pool_length: Option<f64>,  
    pub pool_length_unit: Option<FitFieldDisplayMeasure>,  
    
}

impl fmt::Display for FitMessageWorkoutSession {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWorkoutSession")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.sport { writeln!(f, "  {: >28}: {:?}", "sport", v)?; }
        if let Some(v) = &self.sub_sport { writeln!(f, "  {: >28}: {:?}", "sub_sport", v)?; }
        if let Some(v) = &self.num_valid_steps { writeln!(f, "  {: >28}: {:?}", "num_valid_steps", v)?; }
        if let Some(v) = &self.first_step_index { writeln!(f, "  {: >28}: {:?}", "first_step_index", v)?; }
        if let Some(v) = &self.pool_length { writeln!(f, "  {: >28}: {:?}", "pool_length", v)?; }
        if let Some(v) = &self.pool_length_unit { writeln!(f, "  {: >28}: {:?}", "pool_length_unit", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWorkoutSession {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWorkoutSession>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWorkoutSession {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWorkoutSession",
            message_index: None,
            sport: None,
            sub_sport: None,
            num_valid_steps: None,
            first_step_index: None,
            pool_length: None,
            pool_length_unit: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWorkoutSession::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWorkoutSession:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageWorkoutSession, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSport::parse(&inp[0..f.field_size])?;
                                
                                message.sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // sub_sport
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldSubSport::parse(&&bytes[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldSubSport::parse(&inp[0..f.field_size])?;
                                
                                message.sub_sport = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // num_valid_steps
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_valid_steps = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.num_valid_steps = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // first_step_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.first_step_index = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.first_step_index = val;
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // pool_length
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.pool_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.pool_length = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.pool_length = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.pool_length = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // pool_length_unit
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldDisplayMeasure::parse(&&bytes[0..f.field_size])?;
                                
                                message.pool_length_unit = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldDisplayMeasure::parse(&inp[0..f.field_size])?;
                                
                                message.pool_length_unit = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWorkoutSession {
    fn message_name(&self) -> &'static str {
        return "FitMessageWorkoutSession";
    }
}

#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldDurationValue {
    Default(Option<u32>),
    DurationCalories(Option<u32>),
    DurationStep(Option<u32>),
    DurationHr(Option<FitFieldWorkoutHr>),
    DurationTime(Option<u32>),
    DurationDistance(Option<u32>),
    DurationReps(Option<u32>),
    DurationPower(Option<FitFieldWorkoutPower>),
}

impl FitMessageWorkoutStepSubfieldDurationValue {
    fn parse<'a>(message: &FitMessageWorkoutStep, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageWorkoutStepSubfieldDurationValue> {
        
        match message.duration_type {
        
            Some(FitFieldWktStepDuration::Time) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationTime(val))
                },
        
            Some(FitFieldWktStepDuration::RepetitionTime) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationTime(val))
                },
        
            Some(FitFieldWktStepDuration::Distance) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationDistance(val))
                },
        
            Some(FitFieldWktStepDuration::HrLessThan) => {
                let val = FitFieldWorkoutHr::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationHr(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::HrGreaterThan) => {
                let val = FitFieldWorkoutHr::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationHr(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::Calories) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationCalories(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilStepsCmplt) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilTime) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilDistance) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilCalories) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilHrLessThan) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilHrGreaterThan) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilPowerLessThan) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilPowerGreaterThan) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationStep(val))
                },
        
            Some(FitFieldWktStepDuration::PowerLessThan) => {
                let val = FitFieldWorkoutPower::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationPower(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::PowerGreaterThan) => {
                let val = FitFieldWorkoutPower::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationPower(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::Reps) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldDurationValue::DurationReps(val))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageWorkoutStepSubfieldDurationValue::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldTargetValue {
    Default(Option<u32>),
    TargetSpeedZone(Option<u32>),
    TargetStrokeType(Option<FitFieldSwimStroke>),
    TargetCadenceZone(Option<u32>),
    RepeatSteps(Option<u32>),
    RepeatPower(Option<FitFieldWorkoutPower>),
    RepeatTime(Option<u32>),
    RepeatCalories(Option<u32>),
    RepeatHr(Option<FitFieldWorkoutHr>),
    TargetPowerZone(Option<u32>),
    RepeatDistance(Option<u32>),
    TargetHrZone(Option<u32>),
}

impl FitMessageWorkoutStepSubfieldTargetValue {
    fn parse<'a>(message: &FitMessageWorkoutStep, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageWorkoutStepSubfieldTargetValue> {
        
        match message.duration_type {
        
            Some(FitFieldWktStepDuration::RepeatUntilStepsCmplt) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatSteps(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilTime) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatTime(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilDistance) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatDistance(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilCalories) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatCalories(val))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilHrLessThan) => {
                let val = FitFieldWorkoutHr::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatHr(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilHrGreaterThan) => {
                let val = FitFieldWorkoutHr::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatHr(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilPowerLessThan) => {
                let val = FitFieldWorkoutPower::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatPower(Some(val)))
                },
        
            Some(FitFieldWktStepDuration::RepeatUntilPowerGreaterThan) => {
                let val = FitFieldWorkoutPower::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::RepeatPower(Some(val)))
                },
        
            _ => (),
        }
        
        match message.target_type {
        
            Some(FitFieldWktStepTarget::Speed) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::TargetSpeedZone(val))
                },
        
            Some(FitFieldWktStepTarget::HeartRate) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::TargetHrZone(val))
                },
        
            Some(FitFieldWktStepTarget::Cadence) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::TargetCadenceZone(val))
                },
        
            Some(FitFieldWktStepTarget::Power) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::TargetPowerZone(val))
                },
        
            Some(FitFieldWktStepTarget::SwimStroke) => {
                let val = FitFieldSwimStroke::parse(&inp[0..f.field_size])?;
                
                return Ok(FitMessageWorkoutStepSubfieldTargetValue::TargetStrokeType(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageWorkoutStepSubfieldTargetValue::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldCustomTargetValueLow {
    Default(Option<u32>),
    CustomTargetCadenceLow(Option<u32>),
    CustomTargetHeartRateLow(Option<FitFieldWorkoutHr>),
    CustomTargetSpeedLow(Option<u32>),
    CustomTargetPowerLow(Option<FitFieldWorkoutPower>),
}

impl FitMessageWorkoutStepSubfieldCustomTargetValueLow {
    fn parse<'a>(message: &FitMessageWorkoutStep, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageWorkoutStepSubfieldCustomTargetValueLow> {
        
        match message.target_type {
        
            Some(FitFieldWktStepTarget::Speed) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetSpeedLow(val))
                },
        
            Some(FitFieldWktStepTarget::HeartRate) => {
                let val = FitFieldWorkoutHr::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetHeartRateLow(Some(val)))
                },
        
            Some(FitFieldWktStepTarget::Cadence) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetCadenceLow(val))
                },
        
            Some(FitFieldWktStepTarget::Power) => {
                let val = FitFieldWorkoutPower::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueLow::CustomTargetPowerLow(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageWorkoutStepSubfieldCustomTargetValueLow::Default(val))
    }
}
#[derive(Debug)]
pub enum FitMessageWorkoutStepSubfieldCustomTargetValueHigh {
    Default(Option<u32>),
    CustomTargetCadenceHigh(Option<u32>),
    CustomTargetHeartRateHigh(Option<FitFieldWorkoutHr>),
    CustomTargetSpeedHigh(Option<u32>),
    CustomTargetPowerHigh(Option<FitFieldWorkoutPower>),
}

impl FitMessageWorkoutStepSubfieldCustomTargetValueHigh {
    fn parse<'a>(message: &FitMessageWorkoutStep, inp: &'a [u8], f: &FitFieldDefinition, _tz_offset: f64) -> Result<FitMessageWorkoutStepSubfieldCustomTargetValueHigh> {
        
        match message.target_type {
        
            Some(FitFieldWktStepTarget::Speed) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetSpeedHigh(val))
                },
        
            Some(FitFieldWktStepTarget::HeartRate) => {
                let val = FitFieldWorkoutHr::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetHeartRateHigh(Some(val)))
                },
        
            Some(FitFieldWktStepTarget::Cadence) => {
                let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetCadenceHigh(val))
                },
        
            Some(FitFieldWktStepTarget::Power) => {
                let val = FitFieldWorkoutPower::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                
                return Ok(FitMessageWorkoutStepSubfieldCustomTargetValueHigh::CustomTargetPowerHigh(Some(val)))
                },
        
            _ => (),
        }
        
        let val = parse_uint32(&inp[0..f.field_size], message.definition_message.endianness)?;
        Ok(FitMessageWorkoutStepSubfieldCustomTargetValueHigh::Default(val))
    }
}
#[derive(Debug)]
pub struct FitMessageWorkoutStep {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub message_index: Option<FitFieldMessageIndex>,  
    pub wkt_step_name: Option<String>,  
    pub duration_type: Option<FitFieldWktStepDuration>,  
    pub duration_value_subfield_bytes: Vec<u8>,
    pub duration_value: Option<FitMessageWorkoutStepSubfieldDurationValue>,  
    pub target_type: Option<FitFieldWktStepTarget>,  
    pub target_value_subfield_bytes: Vec<u8>,
    pub target_value: Option<FitMessageWorkoutStepSubfieldTargetValue>,  
    pub custom_target_value_low_subfield_bytes: Vec<u8>,
    pub custom_target_value_low: Option<FitMessageWorkoutStepSubfieldCustomTargetValueLow>,  
    pub custom_target_value_high_subfield_bytes: Vec<u8>,
    pub custom_target_value_high: Option<FitMessageWorkoutStepSubfieldCustomTargetValueHigh>,  
    pub intensity: Option<FitFieldIntensity>,  
    pub notes: Option<String>,  
    pub equipment: Option<FitFieldWorkoutEquipment>,  
    pub exercise_category: Option<FitFieldExerciseCategory>,  
    pub exercise_name: Option<u16>,  
    pub exercise_weight: Option<f64>,  
    pub weight_display_unit: Option<FitFieldFitBaseUnit>,  
    
}

impl fmt::Display for FitMessageWorkoutStep {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageWorkoutStep")?;
        if let Some(v) = &self.message_index { writeln!(f, "  {: >28}: {:?}", "message_index", v)?; }
        if let Some(v) = &self.wkt_step_name { writeln!(f, "  {: >28}: {:?}", "wkt_step_name", v)?; }
        if let Some(v) = &self.duration_type { writeln!(f, "  {: >28}: {:?}", "duration_type", v)?; }
        writeln!(f, "  {: >28}: {:?}", "duration_value_subfield_bytes", self.duration_value_subfield_bytes)?;
        if let Some(v) = &self.duration_value { writeln!(f, "  {: >28}: {:?}", "duration_value", v)?; }
        if let Some(v) = &self.target_type { writeln!(f, "  {: >28}: {:?}", "target_type", v)?; }
        writeln!(f, "  {: >28}: {:?}", "target_value_subfield_bytes", self.target_value_subfield_bytes)?;
        if let Some(v) = &self.target_value { writeln!(f, "  {: >28}: {:?}", "target_value", v)?; }
        writeln!(f, "  {: >28}: {:?}", "custom_target_value_low_subfield_bytes", self.custom_target_value_low_subfield_bytes)?;
        if let Some(v) = &self.custom_target_value_low { writeln!(f, "  {: >28}: {:?}", "custom_target_value_low", v)?; }
        writeln!(f, "  {: >28}: {:?}", "custom_target_value_high_subfield_bytes", self.custom_target_value_high_subfield_bytes)?;
        if let Some(v) = &self.custom_target_value_high { writeln!(f, "  {: >28}: {:?}", "custom_target_value_high", v)?; }
        if let Some(v) = &self.intensity { writeln!(f, "  {: >28}: {:?}", "intensity", v)?; }
        if let Some(v) = &self.notes { writeln!(f, "  {: >28}: {:?}", "notes", v)?; }
        if let Some(v) = &self.equipment { writeln!(f, "  {: >28}: {:?}", "equipment", v)?; }
        if let Some(v) = &self.exercise_category { writeln!(f, "  {: >28}: {:?}", "exercise_category", v)?; }
        if let Some(v) = &self.exercise_name { writeln!(f, "  {: >28}: {:?}", "exercise_name", v)?; }
        if let Some(v) = &self.exercise_weight { writeln!(f, "  {: >28}: {:?}", "exercise_weight", v)?; }
        if let Some(v) = &self.weight_display_unit { writeln!(f, "  {: >28}: {:?}", "weight_display_unit", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageWorkoutStep {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageWorkoutStep>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageWorkoutStep {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageWorkoutStep",
            message_index: None,
            wkt_step_name: None,
            duration_type: None,
            duration_value_subfield_bytes: vec![],
            duration_value: None,
            target_type: None,
            target_value_subfield_bytes: vec![],
            target_value: None,
            custom_target_value_low_subfield_bytes: vec![],
            custom_target_value_low: None,
            custom_target_value_high_subfield_bytes: vec![],
            custom_target_value_high: None,
            intensity: None,
            notes: None,
            equipment: None,
            exercise_category: None,
            exercise_name: None,
            exercise_weight: None,
            weight_display_unit: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageWorkoutStep::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageWorkoutStep:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        
        match FitMessageWorkoutStep::parse_subfields(&mut message, tz_offset) {
            Err(e) => {
                let mut err_string = String::from("Error parsing subfields for FitMessageWorkoutStep:");
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            },
            Ok(_) => (),
        }
        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    
    fn parse_subfields(message: &mut FitMessageWorkoutStep, _tz_offset: f64) -> Result<()> {
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 2).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageWorkoutStepSubfieldDurationValue::parse(message, &message.duration_value_subfield_bytes, &field, _tz_offset)?;
            message.duration_value = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 4).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageWorkoutStepSubfieldTargetValue::parse(message, &message.target_value_subfield_bytes, &field, _tz_offset)?;
            message.target_value = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 5).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageWorkoutStepSubfieldCustomTargetValueLow::parse(message, &message.custom_target_value_low_subfield_bytes, &field, _tz_offset)?;
            message.custom_target_value_low = Some(val);
        }
        let fds: Vec<_> = message.definition_message.field_definitions.iter().filter(|f| f.definition_number == 6).collect();
        if fds.len() == 1 {
            let field = fds[0];
            let val = FitMessageWorkoutStepSubfieldCustomTargetValueHigh::parse(message, &message.custom_target_value_high_subfield_bytes, &field, _tz_offset)?;
            message.custom_target_value_high = Some(val);
        }

        Ok(())
    }
    

    fn parse_internal<'a>(message: &mut FitMessageWorkoutStep, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    254 => {  // message_index
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldMessageIndex::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldMessageIndex::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.message_index = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    0 => {  // wkt_step_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.wkt_step_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.wkt_step_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    1 => {  // duration_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWktStepDuration::parse(&&bytes[0..f.field_size])?;
                                
                                message.duration_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWktStepDuration::parse(&inp[0..f.field_size])?;
                                
                                message.duration_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // duration_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.duration_value_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.duration_value_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // target_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWktStepTarget::parse(&&bytes[0..f.field_size])?;
                                
                                message.target_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWktStepTarget::parse(&inp[0..f.field_size])?;
                                
                                message.target_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    4 => {  // target_value
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.target_value_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.target_value_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // custom_target_value_low
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.custom_target_value_low_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.custom_target_value_low_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    6 => {  // custom_target_value_high
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_byte(&bytes, field.field_size)?;
                                
                                if let Some(v) = val { message.custom_target_value_high_subfield_bytes = v.into(); }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_byte(inp, field.field_size)?;
                                
                                if let Some(v) = val { message.custom_target_value_high_subfield_bytes = v.into(); }
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // intensity
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldIntensity::parse(&&bytes[0..f.field_size])?;
                                
                                message.intensity = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldIntensity::parse(&inp[0..f.field_size])?;
                                
                                message.intensity = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    8 => {  // notes
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_string(&&bytes[0..f.field_size], field.field_size)?;
                                
                                message.notes = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_string(&inp[0..f.field_size], field.field_size)?;
                                
                                message.notes = val;
                            }
                        }

                        Ok(())
                    },
                
                    9 => {  // equipment
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldWorkoutEquipment::parse(&&bytes[0..f.field_size])?;
                                
                                message.equipment = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldWorkoutEquipment::parse(&inp[0..f.field_size])?;
                                
                                message.equipment = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    10 => {  // exercise_category
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldExerciseCategory::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_category = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldExerciseCategory::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_category = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    11 => {  // exercise_name
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_name = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.exercise_name = val;
                            }
                        }

                        Ok(())
                    },
                
                    12 => {  // exercise_weight
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.exercise_weight = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.exercise_weight = None
                                }
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                
                                match val {
                                    Some(result) => {
                                       message.exercise_weight = Some(result as f64 / 100 as f64) 
                                    },
                                    None => message.exercise_weight = None
                                }
                            }
                        }

                        Ok(())
                    },
                
                    13 => {  // weight_display_unit
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldFitBaseUnit::parse(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.weight_display_unit = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldFitBaseUnit::parse(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.weight_display_unit = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageWorkoutStep {
    fn message_name(&self) -> &'static str {
        return "FitMessageWorkoutStep";
    }
}

#[derive(Debug)]
pub struct FitMessageZonesTarget {
    header: FitRecordHeader,
    definition_message: Rc<FitDefinitionMessage>,
    developer_fields: Vec<FitFieldDeveloperData>,
    unknown_fields: HashMap<u8, FitBaseValue>,
    pub raw_bytes: Vec<u8>,
    pub message_name: &'static str,
    pub max_heart_rate: Option<u8>,  
    pub threshold_heart_rate: Option<u8>,  
    pub functional_threshold_power: Option<u16>,  
    pub hr_calc_type: Option<FitFieldHrZoneCalc>,  
    pub pwr_calc_type: Option<FitFieldPwrZoneCalc>,  
    
}

impl fmt::Display for FitMessageZonesTarget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FitMessageZonesTarget")?;
        if let Some(v) = &self.max_heart_rate { writeln!(f, "  {: >28}: {:?}", "max_heart_rate", v)?; }
        if let Some(v) = &self.threshold_heart_rate { writeln!(f, "  {: >28}: {:?}", "threshold_heart_rate", v)?; }
        if let Some(v) = &self.functional_threshold_power { writeln!(f, "  {: >28}: {:?}", "functional_threshold_power", v)?; }
        if let Some(v) = &self.hr_calc_type { writeln!(f, "  {: >28}: {:?}", "hr_calc_type", v)?; }
        if let Some(v) = &self.pwr_calc_type { writeln!(f, "  {: >28}: {:?}", "pwr_calc_type", v)?; }
        
            
        fmt_developer_fields!(self, f);
        fmt_raw_bytes!(self, f);
        Ok(())
    }
}

impl FitMessageZonesTarget {

    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, _timestamp: Option<FitFieldDateTime>) -> Result<(Rc<FitMessageZonesTarget>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        let mut message = FitMessageZonesTarget {
            header: header,
            definition_message: Rc::clone(&definition_message),
            developer_fields: vec![],
            unknown_fields: HashMap::new(),
            raw_bytes: Vec::with_capacity(definition_message.message_size),
            message_name: "FitMessageZonesTarget",
            max_heart_rate: None,
            threshold_heart_rate: None,
            functional_threshold_power: None,
            hr_calc_type: None,
            pwr_calc_type: None,
            
        };

        let inp = &input[..(message.definition_message.message_size)];
        if parsing_state.retain_bytes == true {
            message.raw_bytes.resize(message.definition_message.message_size, 0);
            message.raw_bytes.copy_from_slice(inp);
        }
        let tz_offset = parsing_state.get_timezone_offset();
        let o = match FitMessageZonesTarget::parse_internal(&mut message, input, tz_offset) {
            Ok(o) => o,
            Err(e) => {
                let mut err_string = String::from("Error parsing FitMessageZonesTarget:");
                err_string.push_str(&format!("  parsing these bytes: '{:x?}'", inp));
                err_string.push_str(&format!("  specific error: {:?}", e));
                return Err(Error::message_parse_failed(err_string))
            }
        };

        

        

        let mut inp2 = o;
        for dev_field in &message.definition_message.developer_field_definitions {
            let dev_data_definition = parsing_state.get_developer_data_definition(dev_field.developer_data_index)?;
            let field_description = dev_data_definition.get_field_description(dev_field.definition_number)?;
            let (dd, outp) = FitFieldDeveloperData::parse(inp2, field_description.clone(), message.definition_message.endianness, dev_field.field_size)?;
            message.developer_fields.push(dd);
            inp2 = outp;
        }

        Ok((Rc::new(message), inp2))
    }

    

    fn parse_internal<'a>(message: &mut FitMessageZonesTarget, input: &'a [u8], _tz_offset: f64) -> Result<&'a [u8]> {
        let mut inp = input;
        let mut saved_outp = input;
        for field in &message.definition_message.field_definitions {
            let mut actions: Vec<(FitFieldDefinition, Option<(usize, usize)>)> = vec![(*field, None)];

            while actions.len() > 0 {

                let (f, components_bit_range) = actions.remove(0);

                let _parse_result: Result<()> = match f.definition_number {
                
                    1 => {  // max_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.max_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    2 => {  // threshold_heart_rate
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint8(&&bytes[0..f.field_size])?;
                                
                                message.threshold_heart_rate = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint8(&inp[0..f.field_size])?;
                                
                                message.threshold_heart_rate = val;
                            }
                        }

                        Ok(())
                    },
                
                    3 => {  // functional_threshold_power
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = parse_uint16(&&bytes[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.functional_threshold_power = val;
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = parse_uint16(&inp[0..f.field_size], message.definition_message.endianness)?;
                                
                                message.functional_threshold_power = val;
                            }
                        }

                        Ok(())
                    },
                
                    5 => {  // hr_calc_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldHrZoneCalc::parse(&&bytes[0..f.field_size])?;
                                
                                message.hr_calc_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldHrZoneCalc::parse(&inp[0..f.field_size])?;
                                
                                message.hr_calc_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    7 => {  // pwr_calc_type
                        match components_bit_range {
                            Some((bit_range_start, num_bits)) => {
                                let bytes = subset_with_pad(&inp[0..f.field_size], bit_range_start, num_bits, message.definition_message.endianness)?;
                                
                                let val = FitFieldPwrZoneCalc::parse(&&bytes[0..f.field_size])?;
                                
                                message.pwr_calc_type = Some(val);
                            },
                            None => {
                                saved_outp = &inp[f.field_size..];
                                
                                let val = FitFieldPwrZoneCalc::parse(&inp[0..f.field_size])?;
                                
                                message.pwr_calc_type = Some(val);
                            }
                        }

                        Ok(())
                    },
                
                    unknown_field_num => {
                        let base_type = FitFieldFitBaseType::from(f.base_type);
                        let val = FitBaseValue::parse(inp, &base_type, message.definition_message.endianness, f.field_size)?;
                        message.unknown_fields.insert(unknown_field_num, val);
                        saved_outp = &inp[f.field_size..];
                        Ok(())
                    }
                };
            }
            inp = saved_outp;
        }
        Ok(inp)
    }
}

impl FitRecord for FitMessageZonesTarget {
    fn message_name(&self) -> &'static str {
        return "FitMessageZonesTarget";
    }
}

#[derive(Debug)]
pub enum FitDataMessage {
    
    AccelerometerData(Rc<FitMessageAccelerometerData>),
    Activity(Rc<FitMessageActivity>),
    AntChannelId(Rc<FitMessageAntChannelId>),
    AntRx(Rc<FitMessageAntRx>),
    AntTx(Rc<FitMessageAntTx>),
    AviationAttitude(Rc<FitMessageAviationAttitude>),
    BarometerData(Rc<FitMessageBarometerData>),
    BikeProfile(Rc<FitMessageBikeProfile>),
    BloodPressure(Rc<FitMessageBloodPressure>),
    CadenceZone(Rc<FitMessageCadenceZone>),
    CameraEvent(Rc<FitMessageCameraEvent>),
    Capabilities(Rc<FitMessageCapabilities>),
    Connectivity(Rc<FitMessageConnectivity>),
    Course(Rc<FitMessageCourse>),
    CoursePoint(Rc<FitMessageCoursePoint>),
    DeveloperDataId(Rc<FitMessageDeveloperDataId>),
    DeviceInfo(Rc<FitMessageDeviceInfo>),
    DeviceSettings(Rc<FitMessageDeviceSettings>),
    DiveAlarm(Rc<FitMessageDiveAlarm>),
    DiveGas(Rc<FitMessageDiveGas>),
    DiveSettings(Rc<FitMessageDiveSettings>),
    DiveSummary(Rc<FitMessageDiveSummary>),
    Event(Rc<FitMessageEvent>),
    ExdDataConceptConfiguration(Rc<FitMessageExdDataConceptConfiguration>),
    ExdDataFieldConfiguration(Rc<FitMessageExdDataFieldConfiguration>),
    ExdScreenConfiguration(Rc<FitMessageExdScreenConfiguration>),
    ExerciseTitle(Rc<FitMessageExerciseTitle>),
    FieldCapabilities(Rc<FitMessageFieldCapabilities>),
    FieldDescription(Rc<FitMessageFieldDescription>),
    FileCapabilities(Rc<FitMessageFileCapabilities>),
    FileCreator(Rc<FitMessageFileCreator>),
    FileId(Rc<FitMessageFileId>),
    Goal(Rc<FitMessageGoal>),
    GpsMetadata(Rc<FitMessageGpsMetadata>),
    GyroscopeData(Rc<FitMessageGyroscopeData>),
    Hr(Rc<FitMessageHr>),
    HrZone(Rc<FitMessageHrZone>),
    HrmProfile(Rc<FitMessageHrmProfile>),
    Hrv(Rc<FitMessageHrv>),
    Lap(Rc<FitMessageLap>),
    Length(Rc<FitMessageLength>),
    MagnetometerData(Rc<FitMessageMagnetometerData>),
    MemoGlob(Rc<FitMessageMemoGlob>),
    MesgCapabilities(Rc<FitMessageMesgCapabilities>),
    MetZone(Rc<FitMessageMetZone>),
    Monitoring(Rc<FitMessageMonitoring>),
    MonitoringInfo(Rc<FitMessageMonitoringInfo>),
    NmeaSentence(Rc<FitMessageNmeaSentence>),
    ObdiiData(Rc<FitMessageObdiiData>),
    OhrSettings(Rc<FitMessageOhrSettings>),
    OneDSensorCalibration(Rc<FitMessageOneDSensorCalibration>),
    PowerZone(Rc<FitMessagePowerZone>),
    Record(Rc<FitMessageRecord>),
    Schedule(Rc<FitMessageSchedule>),
    SdmProfile(Rc<FitMessageSdmProfile>),
    SegmentFile(Rc<FitMessageSegmentFile>),
    SegmentId(Rc<FitMessageSegmentId>),
    SegmentLap(Rc<FitMessageSegmentLap>),
    SegmentLeaderboardEntry(Rc<FitMessageSegmentLeaderboardEntry>),
    SegmentPoint(Rc<FitMessageSegmentPoint>),
    Session(Rc<FitMessageSession>),
    Set(Rc<FitMessageSet>),
    SlaveDevice(Rc<FitMessageSlaveDevice>),
    Software(Rc<FitMessageSoftware>),
    SpeedZone(Rc<FitMessageSpeedZone>),
    Sport(Rc<FitMessageSport>),
    StressLevel(Rc<FitMessageStressLevel>),
    ThreeDSensorCalibration(Rc<FitMessageThreeDSensorCalibration>),
    TimestampCorrelation(Rc<FitMessageTimestampCorrelation>),
    Totals(Rc<FitMessageTotals>),
    TrainingFile(Rc<FitMessageTrainingFile>),
    UserProfile(Rc<FitMessageUserProfile>),
    Video(Rc<FitMessageVideo>),
    VideoClip(Rc<FitMessageVideoClip>),
    VideoDescription(Rc<FitMessageVideoDescription>),
    VideoFrame(Rc<FitMessageVideoFrame>),
    VideoTitle(Rc<FitMessageVideoTitle>),
    WatchfaceSettings(Rc<FitMessageWatchfaceSettings>),
    WeatherAlert(Rc<FitMessageWeatherAlert>),
    WeatherConditions(Rc<FitMessageWeatherConditions>),
    WeightScale(Rc<FitMessageWeightScale>),
    Workout(Rc<FitMessageWorkout>),
    WorkoutSession(Rc<FitMessageWorkoutSession>),
    WorkoutStep(Rc<FitMessageWorkoutStep>),
    ZonesTarget(Rc<FitMessageZonesTarget>),
    UnknownToSdk(Rc<FitMessageUnknownToSdk>),
}

impl fmt::Display for FitDataMessage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {FitDataMessage::AccelerometerData(m) => write!(f, "{}", m),
            FitDataMessage::Activity(m) => write!(f, "{}", m),
            FitDataMessage::AntChannelId(m) => write!(f, "{}", m),
            FitDataMessage::AntRx(m) => write!(f, "{}", m),
            FitDataMessage::AntTx(m) => write!(f, "{}", m),
            FitDataMessage::AviationAttitude(m) => write!(f, "{}", m),
            FitDataMessage::BarometerData(m) => write!(f, "{}", m),
            FitDataMessage::BikeProfile(m) => write!(f, "{}", m),
            FitDataMessage::BloodPressure(m) => write!(f, "{}", m),
            FitDataMessage::CadenceZone(m) => write!(f, "{}", m),
            FitDataMessage::CameraEvent(m) => write!(f, "{}", m),
            FitDataMessage::Capabilities(m) => write!(f, "{}", m),
            FitDataMessage::Connectivity(m) => write!(f, "{}", m),
            FitDataMessage::Course(m) => write!(f, "{}", m),
            FitDataMessage::CoursePoint(m) => write!(f, "{}", m),
            FitDataMessage::DeveloperDataId(m) => write!(f, "{}", m),
            FitDataMessage::DeviceInfo(m) => write!(f, "{}", m),
            FitDataMessage::DeviceSettings(m) => write!(f, "{}", m),
            FitDataMessage::DiveAlarm(m) => write!(f, "{}", m),
            FitDataMessage::DiveGas(m) => write!(f, "{}", m),
            FitDataMessage::DiveSettings(m) => write!(f, "{}", m),
            FitDataMessage::DiveSummary(m) => write!(f, "{}", m),
            FitDataMessage::Event(m) => write!(f, "{}", m),
            FitDataMessage::ExdDataConceptConfiguration(m) => write!(f, "{}", m),
            FitDataMessage::ExdDataFieldConfiguration(m) => write!(f, "{}", m),
            FitDataMessage::ExdScreenConfiguration(m) => write!(f, "{}", m),
            FitDataMessage::ExerciseTitle(m) => write!(f, "{}", m),
            FitDataMessage::FieldCapabilities(m) => write!(f, "{}", m),
            FitDataMessage::FieldDescription(m) => write!(f, "{}", m),
            FitDataMessage::FileCapabilities(m) => write!(f, "{}", m),
            FitDataMessage::FileCreator(m) => write!(f, "{}", m),
            FitDataMessage::FileId(m) => write!(f, "{}", m),
            FitDataMessage::Goal(m) => write!(f, "{}", m),
            FitDataMessage::GpsMetadata(m) => write!(f, "{}", m),
            FitDataMessage::GyroscopeData(m) => write!(f, "{}", m),
            FitDataMessage::Hr(m) => write!(f, "{}", m),
            FitDataMessage::HrZone(m) => write!(f, "{}", m),
            FitDataMessage::HrmProfile(m) => write!(f, "{}", m),
            FitDataMessage::Hrv(m) => write!(f, "{}", m),
            FitDataMessage::Lap(m) => write!(f, "{}", m),
            FitDataMessage::Length(m) => write!(f, "{}", m),
            FitDataMessage::MagnetometerData(m) => write!(f, "{}", m),
            FitDataMessage::MemoGlob(m) => write!(f, "{}", m),
            FitDataMessage::MesgCapabilities(m) => write!(f, "{}", m),
            FitDataMessage::MetZone(m) => write!(f, "{}", m),
            FitDataMessage::Monitoring(m) => write!(f, "{}", m),
            FitDataMessage::MonitoringInfo(m) => write!(f, "{}", m),
            FitDataMessage::NmeaSentence(m) => write!(f, "{}", m),
            FitDataMessage::ObdiiData(m) => write!(f, "{}", m),
            FitDataMessage::OhrSettings(m) => write!(f, "{}", m),
            FitDataMessage::OneDSensorCalibration(m) => write!(f, "{}", m),
            FitDataMessage::PowerZone(m) => write!(f, "{}", m),
            FitDataMessage::Record(m) => write!(f, "{}", m),
            FitDataMessage::Schedule(m) => write!(f, "{}", m),
            FitDataMessage::SdmProfile(m) => write!(f, "{}", m),
            FitDataMessage::SegmentFile(m) => write!(f, "{}", m),
            FitDataMessage::SegmentId(m) => write!(f, "{}", m),
            FitDataMessage::SegmentLap(m) => write!(f, "{}", m),
            FitDataMessage::SegmentLeaderboardEntry(m) => write!(f, "{}", m),
            FitDataMessage::SegmentPoint(m) => write!(f, "{}", m),
            FitDataMessage::Session(m) => write!(f, "{}", m),
            FitDataMessage::Set(m) => write!(f, "{}", m),
            FitDataMessage::SlaveDevice(m) => write!(f, "{}", m),
            FitDataMessage::Software(m) => write!(f, "{}", m),
            FitDataMessage::SpeedZone(m) => write!(f, "{}", m),
            FitDataMessage::Sport(m) => write!(f, "{}", m),
            FitDataMessage::StressLevel(m) => write!(f, "{}", m),
            FitDataMessage::ThreeDSensorCalibration(m) => write!(f, "{}", m),
            FitDataMessage::TimestampCorrelation(m) => write!(f, "{}", m),
            FitDataMessage::Totals(m) => write!(f, "{}", m),
            FitDataMessage::TrainingFile(m) => write!(f, "{}", m),
            FitDataMessage::UserProfile(m) => write!(f, "{}", m),
            FitDataMessage::Video(m) => write!(f, "{}", m),
            FitDataMessage::VideoClip(m) => write!(f, "{}", m),
            FitDataMessage::VideoDescription(m) => write!(f, "{}", m),
            FitDataMessage::VideoFrame(m) => write!(f, "{}", m),
            FitDataMessage::VideoTitle(m) => write!(f, "{}", m),
            FitDataMessage::WatchfaceSettings(m) => write!(f, "{}", m),
            FitDataMessage::WeatherAlert(m) => write!(f, "{}", m),
            FitDataMessage::WeatherConditions(m) => write!(f, "{}", m),
            FitDataMessage::WeightScale(m) => write!(f, "{}", m),
            FitDataMessage::Workout(m) => write!(f, "{}", m),
            FitDataMessage::WorkoutSession(m) => write!(f, "{}", m),
            FitDataMessage::WorkoutStep(m) => write!(f, "{}", m),
            FitDataMessage::ZonesTarget(m) => write!(f, "{}", m),
            FitDataMessage::UnknownToSdk(_) => write!(f, "UnknownToSdk")
        }
    }
}

impl FitDataMessage {
    pub fn parse<'a>(input: &'a [u8], header: FitRecordHeader, parsing_state: &mut FitParsingState, timestamp: Option<FitFieldDateTime>) -> Result<(Option<FitDataMessage>, &'a [u8])> {
        let definition_message = parsing_state.get(header.local_mesg_num())?;
        match definition_message.global_mesg_num {
            
            FitGlobalMesgNum::Known(FitFieldMesgNum::AccelerometerData) => {
                let (val, o) =
                    FitMessageAccelerometerData::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::AccelerometerData(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Activity) => {
                let (val, o) =
                    FitMessageActivity::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Activity(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::AntChannelId) => {
                let (val, o) =
                    FitMessageAntChannelId::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::AntChannelId(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::AntRx) => {
                let (val, o) =
                    FitMessageAntRx::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::AntRx(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::AntTx) => {
                let (val, o) =
                    FitMessageAntTx::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::AntTx(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::AviationAttitude) => {
                let (val, o) =
                    FitMessageAviationAttitude::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::AviationAttitude(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::BarometerData) => {
                let (val, o) =
                    FitMessageBarometerData::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::BarometerData(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::BikeProfile) => {
                let (val, o) =
                    FitMessageBikeProfile::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::BikeProfile(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::BloodPressure) => {
                let (val, o) =
                    FitMessageBloodPressure::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::BloodPressure(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::CadenceZone) => {
                let (val, o) =
                    FitMessageCadenceZone::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::CadenceZone(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::CameraEvent) => {
                let (val, o) =
                    FitMessageCameraEvent::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::CameraEvent(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Capabilities) => {
                let (val, o) =
                    FitMessageCapabilities::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Capabilities(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Connectivity) => {
                let (val, o) =
                    FitMessageConnectivity::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Connectivity(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Course) => {
                let (val, o) =
                    FitMessageCourse::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Course(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::CoursePoint) => {
                let (val, o) =
                    FitMessageCoursePoint::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::CoursePoint(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DeveloperDataId) => {
                let (val, o) =
                    FitMessageDeveloperDataId::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DeveloperDataId(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DeviceInfo) => {
                let (val, o) =
                    FitMessageDeviceInfo::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DeviceInfo(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DeviceSettings) => {
                let (val, o) =
                    FitMessageDeviceSettings::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DeviceSettings(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveAlarm) => {
                let (val, o) =
                    FitMessageDiveAlarm::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DiveAlarm(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveGas) => {
                let (val, o) =
                    FitMessageDiveGas::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DiveGas(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveSettings) => {
                let (val, o) =
                    FitMessageDiveSettings::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DiveSettings(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::DiveSummary) => {
                let (val, o) =
                    FitMessageDiveSummary::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::DiveSummary(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Event) => {
                let (val, o) =
                    FitMessageEvent::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Event(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdDataConceptConfiguration) => {
                let (val, o) =
                    FitMessageExdDataConceptConfiguration::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ExdDataConceptConfiguration(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdDataFieldConfiguration) => {
                let (val, o) =
                    FitMessageExdDataFieldConfiguration::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ExdDataFieldConfiguration(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ExdScreenConfiguration) => {
                let (val, o) =
                    FitMessageExdScreenConfiguration::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ExdScreenConfiguration(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ExerciseTitle) => {
                let (val, o) =
                    FitMessageExerciseTitle::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ExerciseTitle(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::FieldCapabilities) => {
                let (val, o) =
                    FitMessageFieldCapabilities::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::FieldCapabilities(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::FieldDescription) => {
                let (val, o) =
                    FitMessageFieldDescription::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::FieldDescription(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::FileCapabilities) => {
                let (val, o) =
                    FitMessageFileCapabilities::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::FileCapabilities(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::FileCreator) => {
                let (val, o) =
                    FitMessageFileCreator::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::FileCreator(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::FileId) => {
                let (val, o) =
                    FitMessageFileId::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::FileId(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Goal) => {
                let (val, o) =
                    FitMessageGoal::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Goal(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::GpsMetadata) => {
                let (val, o) =
                    FitMessageGpsMetadata::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::GpsMetadata(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::GyroscopeData) => {
                let (val, o) =
                    FitMessageGyroscopeData::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::GyroscopeData(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Hr) => {
                let (val, o) =
                    FitMessageHr::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Hr(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::HrZone) => {
                let (val, o) =
                    FitMessageHrZone::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::HrZone(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::HrmProfile) => {
                let (val, o) =
                    FitMessageHrmProfile::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::HrmProfile(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Hrv) => {
                let (val, o) =
                    FitMessageHrv::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Hrv(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Lap) => {
                let (val, o) =
                    FitMessageLap::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Lap(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Length) => {
                let (val, o) =
                    FitMessageLength::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Length(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MagnetometerData) => {
                let (val, o) =
                    FitMessageMagnetometerData::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::MagnetometerData(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MemoGlob) => {
                let (val, o) =
                    FitMessageMemoGlob::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::MemoGlob(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MesgCapabilities) => {
                let (val, o) =
                    FitMessageMesgCapabilities::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::MesgCapabilities(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MetZone) => {
                let (val, o) =
                    FitMessageMetZone::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::MetZone(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Monitoring) => {
                let (val, o) =
                    FitMessageMonitoring::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Monitoring(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::MonitoringInfo) => {
                let (val, o) =
                    FitMessageMonitoringInfo::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::MonitoringInfo(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::NmeaSentence) => {
                let (val, o) =
                    FitMessageNmeaSentence::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::NmeaSentence(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ObdiiData) => {
                let (val, o) =
                    FitMessageObdiiData::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ObdiiData(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::OhrSettings) => {
                let (val, o) =
                    FitMessageOhrSettings::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::OhrSettings(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::OneDSensorCalibration) => {
                let (val, o) =
                    FitMessageOneDSensorCalibration::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::OneDSensorCalibration(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::PowerZone) => {
                let (val, o) =
                    FitMessagePowerZone::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::PowerZone(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Record) => {
                let (val, o) =
                    FitMessageRecord::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Record(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Schedule) => {
                let (val, o) =
                    FitMessageSchedule::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Schedule(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SdmProfile) => {
                let (val, o) =
                    FitMessageSdmProfile::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SdmProfile(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentFile) => {
                let (val, o) =
                    FitMessageSegmentFile::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SegmentFile(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentId) => {
                let (val, o) =
                    FitMessageSegmentId::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SegmentId(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentLap) => {
                let (val, o) =
                    FitMessageSegmentLap::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SegmentLap(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentLeaderboardEntry) => {
                let (val, o) =
                    FitMessageSegmentLeaderboardEntry::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SegmentLeaderboardEntry(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SegmentPoint) => {
                let (val, o) =
                    FitMessageSegmentPoint::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SegmentPoint(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Session) => {
                let (val, o) =
                    FitMessageSession::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Session(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Set) => {
                let (val, o) =
                    FitMessageSet::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Set(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SlaveDevice) => {
                let (val, o) =
                    FitMessageSlaveDevice::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SlaveDevice(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Software) => {
                let (val, o) =
                    FitMessageSoftware::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Software(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::SpeedZone) => {
                let (val, o) =
                    FitMessageSpeedZone::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::SpeedZone(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Sport) => {
                let (val, o) =
                    FitMessageSport::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Sport(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::StressLevel) => {
                let (val, o) =
                    FitMessageStressLevel::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::StressLevel(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ThreeDSensorCalibration) => {
                let (val, o) =
                    FitMessageThreeDSensorCalibration::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ThreeDSensorCalibration(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::TimestampCorrelation) => {
                let (val, o) =
                    FitMessageTimestampCorrelation::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::TimestampCorrelation(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Totals) => {
                let (val, o) =
                    FitMessageTotals::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Totals(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::TrainingFile) => {
                let (val, o) =
                    FitMessageTrainingFile::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::TrainingFile(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::UserProfile) => {
                let (val, o) =
                    FitMessageUserProfile::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::UserProfile(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Video) => {
                let (val, o) =
                    FitMessageVideo::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Video(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoClip) => {
                let (val, o) =
                    FitMessageVideoClip::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::VideoClip(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoDescription) => {
                let (val, o) =
                    FitMessageVideoDescription::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::VideoDescription(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoFrame) => {
                let (val, o) =
                    FitMessageVideoFrame::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::VideoFrame(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::VideoTitle) => {
                let (val, o) =
                    FitMessageVideoTitle::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::VideoTitle(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::WatchfaceSettings) => {
                let (val, o) =
                    FitMessageWatchfaceSettings::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::WatchfaceSettings(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::WeatherAlert) => {
                let (val, o) =
                    FitMessageWeatherAlert::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::WeatherAlert(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::WeatherConditions) => {
                let (val, o) =
                    FitMessageWeatherConditions::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::WeatherConditions(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::WeightScale) => {
                let (val, o) =
                    FitMessageWeightScale::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::WeightScale(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::Workout) => {
                let (val, o) =
                    FitMessageWorkout::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::Workout(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::WorkoutSession) => {
                let (val, o) =
                    FitMessageWorkoutSession::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::WorkoutSession(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::WorkoutStep) => {
                let (val, o) =
                    FitMessageWorkoutStep::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::WorkoutStep(val)), o))
            }
            FitGlobalMesgNum::Known(FitFieldMesgNum::ZonesTarget) => {
                let (val, o) =
                    FitMessageZonesTarget::parse(input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::ZonesTarget(val)), o))
            }
            FitGlobalMesgNum::Unknown(number) => {
                let (val, o) = FitMessageUnknownToSdk::parse(number, input, header, parsing_state, timestamp)?;
                Ok((Some(FitDataMessage::UnknownToSdk(val)), o))
            }
            _ => Ok((None, &input[definition_message.message_size..])),
        }
    }

    pub fn message_name(&self) -> &'static str {
        match self {FitDataMessage::AccelerometerData(_) => "AccelerometerData",
            FitDataMessage::Activity(_) => "Activity",
            FitDataMessage::AntChannelId(_) => "AntChannelId",
            FitDataMessage::AntRx(_) => "AntRx",
            FitDataMessage::AntTx(_) => "AntTx",
            FitDataMessage::AviationAttitude(_) => "AviationAttitude",
            FitDataMessage::BarometerData(_) => "BarometerData",
            FitDataMessage::BikeProfile(_) => "BikeProfile",
            FitDataMessage::BloodPressure(_) => "BloodPressure",
            FitDataMessage::CadenceZone(_) => "CadenceZone",
            FitDataMessage::CameraEvent(_) => "CameraEvent",
            FitDataMessage::Capabilities(_) => "Capabilities",
            FitDataMessage::Connectivity(_) => "Connectivity",
            FitDataMessage::Course(_) => "Course",
            FitDataMessage::CoursePoint(_) => "CoursePoint",
            FitDataMessage::DeveloperDataId(_) => "DeveloperDataId",
            FitDataMessage::DeviceInfo(_) => "DeviceInfo",
            FitDataMessage::DeviceSettings(_) => "DeviceSettings",
            FitDataMessage::DiveAlarm(_) => "DiveAlarm",
            FitDataMessage::DiveGas(_) => "DiveGas",
            FitDataMessage::DiveSettings(_) => "DiveSettings",
            FitDataMessage::DiveSummary(_) => "DiveSummary",
            FitDataMessage::Event(_) => "Event",
            FitDataMessage::ExdDataConceptConfiguration(_) => "ExdDataConceptConfiguration",
            FitDataMessage::ExdDataFieldConfiguration(_) => "ExdDataFieldConfiguration",
            FitDataMessage::ExdScreenConfiguration(_) => "ExdScreenConfiguration",
            FitDataMessage::ExerciseTitle(_) => "ExerciseTitle",
            FitDataMessage::FieldCapabilities(_) => "FieldCapabilities",
            FitDataMessage::FieldDescription(_) => "FieldDescription",
            FitDataMessage::FileCapabilities(_) => "FileCapabilities",
            FitDataMessage::FileCreator(_) => "FileCreator",
            FitDataMessage::FileId(_) => "FileId",
            FitDataMessage::Goal(_) => "Goal",
            FitDataMessage::GpsMetadata(_) => "GpsMetadata",
            FitDataMessage::GyroscopeData(_) => "GyroscopeData",
            FitDataMessage::Hr(_) => "Hr",
            FitDataMessage::HrZone(_) => "HrZone",
            FitDataMessage::HrmProfile(_) => "HrmProfile",
            FitDataMessage::Hrv(_) => "Hrv",
            FitDataMessage::Lap(_) => "Lap",
            FitDataMessage::Length(_) => "Length",
            FitDataMessage::MagnetometerData(_) => "MagnetometerData",
            FitDataMessage::MemoGlob(_) => "MemoGlob",
            FitDataMessage::MesgCapabilities(_) => "MesgCapabilities",
            FitDataMessage::MetZone(_) => "MetZone",
            FitDataMessage::Monitoring(_) => "Monitoring",
            FitDataMessage::MonitoringInfo(_) => "MonitoringInfo",
            FitDataMessage::NmeaSentence(_) => "NmeaSentence",
            FitDataMessage::ObdiiData(_) => "ObdiiData",
            FitDataMessage::OhrSettings(_) => "OhrSettings",
            FitDataMessage::OneDSensorCalibration(_) => "OneDSensorCalibration",
            FitDataMessage::PowerZone(_) => "PowerZone",
            FitDataMessage::Record(_) => "Record",
            FitDataMessage::Schedule(_) => "Schedule",
            FitDataMessage::SdmProfile(_) => "SdmProfile",
            FitDataMessage::SegmentFile(_) => "SegmentFile",
            FitDataMessage::SegmentId(_) => "SegmentId",
            FitDataMessage::SegmentLap(_) => "SegmentLap",
            FitDataMessage::SegmentLeaderboardEntry(_) => "SegmentLeaderboardEntry",
            FitDataMessage::SegmentPoint(_) => "SegmentPoint",
            FitDataMessage::Session(_) => "Session",
            FitDataMessage::Set(_) => "Set",
            FitDataMessage::SlaveDevice(_) => "SlaveDevice",
            FitDataMessage::Software(_) => "Software",
            FitDataMessage::SpeedZone(_) => "SpeedZone",
            FitDataMessage::Sport(_) => "Sport",
            FitDataMessage::StressLevel(_) => "StressLevel",
            FitDataMessage::ThreeDSensorCalibration(_) => "ThreeDSensorCalibration",
            FitDataMessage::TimestampCorrelation(_) => "TimestampCorrelation",
            FitDataMessage::Totals(_) => "Totals",
            FitDataMessage::TrainingFile(_) => "TrainingFile",
            FitDataMessage::UserProfile(_) => "UserProfile",
            FitDataMessage::Video(_) => "Video",
            FitDataMessage::VideoClip(_) => "VideoClip",
            FitDataMessage::VideoDescription(_) => "VideoDescription",
            FitDataMessage::VideoFrame(_) => "VideoFrame",
            FitDataMessage::VideoTitle(_) => "VideoTitle",
            FitDataMessage::WatchfaceSettings(_) => "WatchfaceSettings",
            FitDataMessage::WeatherAlert(_) => "WeatherAlert",
            FitDataMessage::WeatherConditions(_) => "WeatherConditions",
            FitDataMessage::WeightScale(_) => "WeightScale",
            FitDataMessage::Workout(_) => "Workout",
            FitDataMessage::WorkoutSession(_) => "WorkoutSession",
            FitDataMessage::WorkoutStep(_) => "WorkoutStep",
            FitDataMessage::ZonesTarget(_) => "ZonesTarget",
            FitDataMessage::UnknownToSdk(_) => "UnknownToSdk",
        }
    }

    
    pub fn is_accelerometer_data(&self) -> bool {
        match *self {
            FitDataMessage::AccelerometerData(_) => true,
            _ => false,
        }
    }
    
    pub fn is_activity(&self) -> bool {
        match *self {
            FitDataMessage::Activity(_) => true,
            _ => false,
        }
    }
    
    pub fn is_ant_channel_id(&self) -> bool {
        match *self {
            FitDataMessage::AntChannelId(_) => true,
            _ => false,
        }
    }
    
    pub fn is_ant_rx(&self) -> bool {
        match *self {
            FitDataMessage::AntRx(_) => true,
            _ => false,
        }
    }
    
    pub fn is_ant_tx(&self) -> bool {
        match *self {
            FitDataMessage::AntTx(_) => true,
            _ => false,
        }
    }
    
    pub fn is_aviation_attitude(&self) -> bool {
        match *self {
            FitDataMessage::AviationAttitude(_) => true,
            _ => false,
        }
    }
    
    pub fn is_barometer_data(&self) -> bool {
        match *self {
            FitDataMessage::BarometerData(_) => true,
            _ => false,
        }
    }
    
    pub fn is_bike_profile(&self) -> bool {
        match *self {
            FitDataMessage::BikeProfile(_) => true,
            _ => false,
        }
    }
    
    pub fn is_blood_pressure(&self) -> bool {
        match *self {
            FitDataMessage::BloodPressure(_) => true,
            _ => false,
        }
    }
    
    pub fn is_cadence_zone(&self) -> bool {
        match *self {
            FitDataMessage::CadenceZone(_) => true,
            _ => false,
        }
    }
    
    pub fn is_camera_event(&self) -> bool {
        match *self {
            FitDataMessage::CameraEvent(_) => true,
            _ => false,
        }
    }
    
    pub fn is_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::Capabilities(_) => true,
            _ => false,
        }
    }
    
    pub fn is_connectivity(&self) -> bool {
        match *self {
            FitDataMessage::Connectivity(_) => true,
            _ => false,
        }
    }
    
    pub fn is_course(&self) -> bool {
        match *self {
            FitDataMessage::Course(_) => true,
            _ => false,
        }
    }
    
    pub fn is_course_point(&self) -> bool {
        match *self {
            FitDataMessage::CoursePoint(_) => true,
            _ => false,
        }
    }
    
    pub fn is_developer_data_id(&self) -> bool {
        match *self {
            FitDataMessage::DeveloperDataId(_) => true,
            _ => false,
        }
    }
    
    pub fn is_device_info(&self) -> bool {
        match *self {
            FitDataMessage::DeviceInfo(_) => true,
            _ => false,
        }
    }
    
    pub fn is_device_settings(&self) -> bool {
        match *self {
            FitDataMessage::DeviceSettings(_) => true,
            _ => false,
        }
    }
    
    pub fn is_dive_alarm(&self) -> bool {
        match *self {
            FitDataMessage::DiveAlarm(_) => true,
            _ => false,
        }
    }
    
    pub fn is_dive_gas(&self) -> bool {
        match *self {
            FitDataMessage::DiveGas(_) => true,
            _ => false,
        }
    }
    
    pub fn is_dive_settings(&self) -> bool {
        match *self {
            FitDataMessage::DiveSettings(_) => true,
            _ => false,
        }
    }
    
    pub fn is_dive_summary(&self) -> bool {
        match *self {
            FitDataMessage::DiveSummary(_) => true,
            _ => false,
        }
    }
    
    pub fn is_event(&self) -> bool {
        match *self {
            FitDataMessage::Event(_) => true,
            _ => false,
        }
    }
    
    pub fn is_exd_data_concept_configuration(&self) -> bool {
        match *self {
            FitDataMessage::ExdDataConceptConfiguration(_) => true,
            _ => false,
        }
    }
    
    pub fn is_exd_data_field_configuration(&self) -> bool {
        match *self {
            FitDataMessage::ExdDataFieldConfiguration(_) => true,
            _ => false,
        }
    }
    
    pub fn is_exd_screen_configuration(&self) -> bool {
        match *self {
            FitDataMessage::ExdScreenConfiguration(_) => true,
            _ => false,
        }
    }
    
    pub fn is_exercise_title(&self) -> bool {
        match *self {
            FitDataMessage::ExerciseTitle(_) => true,
            _ => false,
        }
    }
    
    pub fn is_field_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::FieldCapabilities(_) => true,
            _ => false,
        }
    }
    
    pub fn is_field_description(&self) -> bool {
        match *self {
            FitDataMessage::FieldDescription(_) => true,
            _ => false,
        }
    }
    
    pub fn is_file_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::FileCapabilities(_) => true,
            _ => false,
        }
    }
    
    pub fn is_file_creator(&self) -> bool {
        match *self {
            FitDataMessage::FileCreator(_) => true,
            _ => false,
        }
    }
    
    pub fn is_file_id(&self) -> bool {
        match *self {
            FitDataMessage::FileId(_) => true,
            _ => false,
        }
    }
    
    pub fn is_goal(&self) -> bool {
        match *self {
            FitDataMessage::Goal(_) => true,
            _ => false,
        }
    }
    
    pub fn is_gps_metadata(&self) -> bool {
        match *self {
            FitDataMessage::GpsMetadata(_) => true,
            _ => false,
        }
    }
    
    pub fn is_gyroscope_data(&self) -> bool {
        match *self {
            FitDataMessage::GyroscopeData(_) => true,
            _ => false,
        }
    }
    
    pub fn is_hr(&self) -> bool {
        match *self {
            FitDataMessage::Hr(_) => true,
            _ => false,
        }
    }
    
    pub fn is_hr_zone(&self) -> bool {
        match *self {
            FitDataMessage::HrZone(_) => true,
            _ => false,
        }
    }
    
    pub fn is_hrm_profile(&self) -> bool {
        match *self {
            FitDataMessage::HrmProfile(_) => true,
            _ => false,
        }
    }
    
    pub fn is_hrv(&self) -> bool {
        match *self {
            FitDataMessage::Hrv(_) => true,
            _ => false,
        }
    }
    
    pub fn is_lap(&self) -> bool {
        match *self {
            FitDataMessage::Lap(_) => true,
            _ => false,
        }
    }
    
    pub fn is_length(&self) -> bool {
        match *self {
            FitDataMessage::Length(_) => true,
            _ => false,
        }
    }
    
    pub fn is_magnetometer_data(&self) -> bool {
        match *self {
            FitDataMessage::MagnetometerData(_) => true,
            _ => false,
        }
    }
    
    pub fn is_memo_glob(&self) -> bool {
        match *self {
            FitDataMessage::MemoGlob(_) => true,
            _ => false,
        }
    }
    
    pub fn is_mesg_capabilities(&self) -> bool {
        match *self {
            FitDataMessage::MesgCapabilities(_) => true,
            _ => false,
        }
    }
    
    pub fn is_met_zone(&self) -> bool {
        match *self {
            FitDataMessage::MetZone(_) => true,
            _ => false,
        }
    }
    
    pub fn is_monitoring(&self) -> bool {
        match *self {
            FitDataMessage::Monitoring(_) => true,
            _ => false,
        }
    }
    
    pub fn is_monitoring_info(&self) -> bool {
        match *self {
            FitDataMessage::MonitoringInfo(_) => true,
            _ => false,
        }
    }
    
    pub fn is_nmea_sentence(&self) -> bool {
        match *self {
            FitDataMessage::NmeaSentence(_) => true,
            _ => false,
        }
    }
    
    pub fn is_obdii_data(&self) -> bool {
        match *self {
            FitDataMessage::ObdiiData(_) => true,
            _ => false,
        }
    }
    
    pub fn is_ohr_settings(&self) -> bool {
        match *self {
            FitDataMessage::OhrSettings(_) => true,
            _ => false,
        }
    }
    
    pub fn is_one_d_sensor_calibration(&self) -> bool {
        match *self {
            FitDataMessage::OneDSensorCalibration(_) => true,
            _ => false,
        }
    }
    
    pub fn is_power_zone(&self) -> bool {
        match *self {
            FitDataMessage::PowerZone(_) => true,
            _ => false,
        }
    }
    
    pub fn is_record(&self) -> bool {
        match *self {
            FitDataMessage::Record(_) => true,
            _ => false,
        }
    }
    
    pub fn is_schedule(&self) -> bool {
        match *self {
            FitDataMessage::Schedule(_) => true,
            _ => false,
        }
    }
    
    pub fn is_sdm_profile(&self) -> bool {
        match *self {
            FitDataMessage::SdmProfile(_) => true,
            _ => false,
        }
    }
    
    pub fn is_segment_file(&self) -> bool {
        match *self {
            FitDataMessage::SegmentFile(_) => true,
            _ => false,
        }
    }
    
    pub fn is_segment_id(&self) -> bool {
        match *self {
            FitDataMessage::SegmentId(_) => true,
            _ => false,
        }
    }
    
    pub fn is_segment_lap(&self) -> bool {
        match *self {
            FitDataMessage::SegmentLap(_) => true,
            _ => false,
        }
    }
    
    pub fn is_segment_leaderboard_entry(&self) -> bool {
        match *self {
            FitDataMessage::SegmentLeaderboardEntry(_) => true,
            _ => false,
        }
    }
    
    pub fn is_segment_point(&self) -> bool {
        match *self {
            FitDataMessage::SegmentPoint(_) => true,
            _ => false,
        }
    }
    
    pub fn is_session(&self) -> bool {
        match *self {
            FitDataMessage::Session(_) => true,
            _ => false,
        }
    }
    
    pub fn is_set(&self) -> bool {
        match *self {
            FitDataMessage::Set(_) => true,
            _ => false,
        }
    }
    
    pub fn is_slave_device(&self) -> bool {
        match *self {
            FitDataMessage::SlaveDevice(_) => true,
            _ => false,
        }
    }
    
    pub fn is_software(&self) -> bool {
        match *self {
            FitDataMessage::Software(_) => true,
            _ => false,
        }
    }
    
    pub fn is_speed_zone(&self) -> bool {
        match *self {
            FitDataMessage::SpeedZone(_) => true,
            _ => false,
        }
    }
    
    pub fn is_sport(&self) -> bool {
        match *self {
            FitDataMessage::Sport(_) => true,
            _ => false,
        }
    }
    
    pub fn is_stress_level(&self) -> bool {
        match *self {
            FitDataMessage::StressLevel(_) => true,
            _ => false,
        }
    }
    
    pub fn is_three_d_sensor_calibration(&self) -> bool {
        match *self {
            FitDataMessage::ThreeDSensorCalibration(_) => true,
            _ => false,
        }
    }
    
    pub fn is_timestamp_correlation(&self) -> bool {
        match *self {
            FitDataMessage::TimestampCorrelation(_) => true,
            _ => false,
        }
    }
    
    pub fn is_totals(&self) -> bool {
        match *self {
            FitDataMessage::Totals(_) => true,
            _ => false,
        }
    }
    
    pub fn is_training_file(&self) -> bool {
        match *self {
            FitDataMessage::TrainingFile(_) => true,
            _ => false,
        }
    }
    
    pub fn is_user_profile(&self) -> bool {
        match *self {
            FitDataMessage::UserProfile(_) => true,
            _ => false,
        }
    }
    
    pub fn is_video(&self) -> bool {
        match *self {
            FitDataMessage::Video(_) => true,
            _ => false,
        }
    }
    
    pub fn is_video_clip(&self) -> bool {
        match *self {
            FitDataMessage::VideoClip(_) => true,
            _ => false,
        }
    }
    
    pub fn is_video_description(&self) -> bool {
        match *self {
            FitDataMessage::VideoDescription(_) => true,
            _ => false,
        }
    }
    
    pub fn is_video_frame(&self) -> bool {
        match *self {
            FitDataMessage::VideoFrame(_) => true,
            _ => false,
        }
    }
    
    pub fn is_video_title(&self) -> bool {
        match *self {
            FitDataMessage::VideoTitle(_) => true,
            _ => false,
        }
    }
    
    pub fn is_watchface_settings(&self) -> bool {
        match *self {
            FitDataMessage::WatchfaceSettings(_) => true,
            _ => false,
        }
    }
    
    pub fn is_weather_alert(&self) -> bool {
        match *self {
            FitDataMessage::WeatherAlert(_) => true,
            _ => false,
        }
    }
    
    pub fn is_weather_conditions(&self) -> bool {
        match *self {
            FitDataMessage::WeatherConditions(_) => true,
            _ => false,
        }
    }
    
    pub fn is_weight_scale(&self) -> bool {
        match *self {
            FitDataMessage::WeightScale(_) => true,
            _ => false,
        }
    }
    
    pub fn is_workout(&self) -> bool {
        match *self {
            FitDataMessage::Workout(_) => true,
            _ => false,
        }
    }
    
    pub fn is_workout_session(&self) -> bool {
        match *self {
            FitDataMessage::WorkoutSession(_) => true,
            _ => false,
        }
    }
    
    pub fn is_workout_step(&self) -> bool {
        match *self {
            FitDataMessage::WorkoutStep(_) => true,
            _ => false,
        }
    }
    
    pub fn is_zones_target(&self) -> bool {
        match *self {
            FitDataMessage::ZonesTarget(_) => true,
            _ => false,
        }
    }
    

    pub fn is_unknown(&self) -> bool {
        match *self {
            FitDataMessage::UnknownToSdk(_) => true,
            _ => false,
        }
    }
}

#[cfg(test)]
#[path = "./fittypes_test.rs"]
mod fittypes_test;